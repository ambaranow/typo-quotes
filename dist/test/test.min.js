/*! typoquotes v0.1.3 */
!function(n){function e(a){if(t[a])return t[a].exports;var s=t[a]={i:a,l:!1,exports:{}};return n[a].call(s.exports,s,s.exports,e),s.l=!0,s.exports}var t={};e.m=n,e.c=t,e.d=function(n,t,a){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:a})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=26)}([function(n,e,t){"use strict";function a(n,e){return e.forEach(function(e,t){n=n.replace(t,e)}),n}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&function(){return"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener}()?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},function(n,e,t){"use strict";function a(n,e){var t=new Map;return e.map(function(e){n=n.replace(e,function(n){var e=(Math.random()+"").substr(2);return t.set(e,n),"{"+e+"}"})}),{text:n,parts:t}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){return e.forEach(function(e,t){n=n.replace("{"+t+"}",e)}),n}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=t(5);e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),i=["quotes","dashes","angles","dblspace","specials","mathchars","punctuation","specialspaces","phones","numbers","nbsp","hellip","units"],o=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};a(this,n),e.actionlist=e.actionlist||i,e.lang=e.lang||"ru",this.preserveParts=t(2),this.restoreParts=t(3),this.processSpecials=t(6),this.processMath=t(7),this.processMinuses=t(8),this.processPunctuation=t(9),this.processSpecialSpaces=t(10),this.processAngles=t(11),this.processMultipleSpaces=t(12),this.processQuotes=t(13),this.processQuotesInner=t(14),this.processDashes=t(15),this.processPhones=t(16),this.processNumbers=t(17),this.processNbsps=t(18),this.processHellips=t(19),this.processUnits=t(20),this.actions(e.actionlist),this.lang(e.lang),this.m=[],this.tag="untypo",this.s="",this.normsym=["—","«","»","…","©","®","™","←","→","↑","↓","↔","°","́","×","≠","±","↕","‘","’","−","–","“","”","„","≥","≤","§","€","£","″","√","∫","½","¼","¾"," ","‚","¹","²","³","⅓","⅔","⅕","⅖","⅗","⅘","⅙","⅚","⅛","⅜","⅝","⅞","≈","'","⁰","⁴","⁵","⁶","⁷","⁸","⁹","⁺","⁻","⁼","⁽","⁾","ⁿ","ⁱ","₀","₁","₂","₃","₄","₅","₆","₇","₈","₉","₊","₋","₌","₍","₎"],this.htmlsym=["mdash","laquo","raquo","hellip","copy","reg","trade","larr","rarr","uarr","darr","harr","deg","#769","times","ne","plusmn","#8597","lsquo","rsquo","minus","ndash","ldquo","rdquo","bdquo","ge","le","sect","euro","pound","Prime","radic","int","frac12","frac14","frac34","nbsp","sbquo","sup1","sup2","sup3","#8531","#8532","#8533","#8534","#8535","#8536","#8537","#8538","#8539","#8540","#8541","#8542","#8776","quot","#8304","#8308","#8309","#8310","#8311","#8312","#8313","#8314","#8315","#8316","#8317","#8318","#8319","#8305","#8320","#8321","#8322","#8323","#8324","#8325","#8326","#8327","#8328","#8329","#8330","#8331","#8332","#8333","#8334"],this.RegLink=this.r("([  \n\t\v]|^)(((ht|f)tps?://)?([\\-\\w]+:[\\-\\w]+@)?([0-9a-z][\\-0-9a-z]*[0-9a-z]\\.)+[a-z]{2,6}(:\\d{1,5})?([?/\\\\#][?!^$.(){}:|=[\\]+\\-/\\\\*;&~#@,%\\wА-Яа-я]*)?)([  \n\t\v]|$)","gi"),this.RegMail=this.r("([  \n\t\v]|^)([\\-a-z0-9!#$%&'*+\\/=?^_`{|}~]+(\\.[\\-a-z0-9!#$%&'*+\\/=?^_`{|}~]+)*@([a-z0-9]([\\-a-z0-9]{0,61}[a-z0-9])?.)*([a-z]{2,6}))([  \n\t\v]|$)","gi")}return s(n,[{key:"r",value:function(n,e){return RegExp(n,e)}},{key:"actions",value:function(n){this._actions=n}},{key:"lang",value:function(n){var e=["ru","en"],t=e.indexOf(n.toLowerCase());t=t>-1?t:0,this._lang=e[t]}},{key:"requested",value:function(n){return this._actions.includes(n)}},{key:"process",value:function(n){var e=this.prepare(n),t=e.text,a=e.parts;return this.requested("specials")&&(t=this.processSpecials(t)),this.requested("mathchars")&&(t=this.processMath(t)),(this.requested("mathchars")||this.requested("dashes"))&&(t=this.processMinuses(t,this._lang)),this.requested("punctuation")&&(t=this.processPunctuation(t,this._actions)),this.requested("specialspaces")&&(t=this.processSpecialSpaces(t)),this.requested("angles")&&(t=this.processAngles(t)),this.requested("dblspace")&&(t=this.processMultipleSpaces(t)),this.requested("quotes")&&(t=this.processQuotes(t),t=this.processQuotesInner(t,this._lang)),this.requested("dashes")&&(t=this.processDashes(t,this._actions)),this.requested("phones")&&(t=this.processPhones(t,this._lang)),this.requested("numbers")&&(t=this.processNumbers(t,this._lang)),this.requested("nbsp")&&(t=this.processNbsps(t)),this.requested("hellip")&&(t=this.processHellips(t)),this.requested("units")&&(t=this.processUnits(t)),this.ready(t,a)}},{key:"prepare",value:function(n){function e(e){o.s=n.match(o.r("<"+o.tag+">[\\s\\S]+?</"+o.tag+">","g"));var t=0;if(o.s)for(;t<o.s.length;t++){var a=o.s[t].replace(o.r("<\\/?"+o.tag+">","g"),"");o.m.push(a),n=n.replace("<"+o.tag+">"+a+"</"+o.tag+">","UNTYPO"+(t+e)+"S")}return t+e}var t=document.createElement("div");t.innerHTML=n;for(var a=t.querySelectorAll("[data-typo]"),s=a.length;s--;){var i=a[s].innerHTML;a[s].outerHTML=i}n=t.innerHTML;var o=this;n=n.replace(/(\r\n|\r)/g,"\n").replace(/(\[code\]|\[quote[^\]$\n]*\]|<pre[^<>]*?>|\[img\])/g,"<"+this.tag+">$1").replace(/(\[\/code\]|\[\/quote\]|<\/pre>|\[\/img\])/g,"$1</"+this.tag+">").replace(/(<script[^<>]*?>|<style[^<>]*?>)/g,"<"+this.tag+">$1").replace(/(<\/script>|<\/style>)/g,"$1</"+this.tag+">").replace(/(<!--(.|\n)*?-->)/g,"<"+this.tag+">$1</"+this.tag+">").replace(/(\[url[^\[\]]+?\])/g,"<"+this.tag+">$1</"+this.tag+">").replace(/(="[^"\n\r]*")/g,"<"+this.tag+">$1</"+this.tag+">");for(var g=0;g<10;++g)n=n.replace(this.r("(<"+this.tag+">)([\\s\\S]*?)(<\\/?"+this.tag+">)","g"),function(n,e,t,a){return"/"!==a.charAt(1)?e+t:n}),n=n.replace(this.r("(<\\/"+this.tag+">)([\\s\\S]*?)(<\\/?"+this.tag+">)","g"),function(n,e,t,a){return"/"===a.charAt(1)?t+a:n});for(var r=e(0),l=0;l<2;++l)n=n.replace(this.RegLink,"$1<"+this.tag+">$2</"+this.tag+">$9").replace(this.RegMail,"$1<"+this.tag+">$2</"+this.tag+">$7");r=e(r);for(var A=0;A<this.htmlsym.length;++A)n=n.replace(this.r("&"+this.htmlsym[A]+";","g"),this.normsym[A]);var p=[];return this.preserveParts(n,p)}},{key:"ready",value:function(n,e){n=n.replace(/ (\))/g,"$1");for(var t=this.m.length-1;t>=0;--t)n=n.replace("UNTYPO"+t+"S",this.m[t]);return n=n.replace(this.r("(<\\/?"+this.tag+">)+","g"),"$1"),this.restoreParts(n,e)}}]),n}();window.Typoquotes=o,e.default=o,n.exports=e.default},function(n,e,t){"use strict";function a(n){var e=new Map([[/(\([cс]\))|(\{copy\})/gi,"©"],[/(\(r\))|(\{reg\})/gi,"®"],[/(\((тм|tm)\))|(\{(tm|trade)\})/gi,"™"],[/\{(ss|sect)}/g,"§"],[/\{deg}/g,"°"],[/\{rub}|\(rub\)/g,"₽"],[/\{euro}|\(euro\)/g,"€"],[/\{cent}|\(cent\)/g,"¢"],[/\{pound}|\(pound\)/g,"£"],[/\{(yen|yuan)}|\(yen|yuan\)/g,"¥"],[/\{alpha\}/gi,"α"],[/\{beta\}/gi,"β"],[/\{gamma\}/gi,"γ"],[/\{delta\}/gi,"δ"],[/\{epsilon\}/gi,"ε"],[/\{theta\}/gi,"θ"],[/\{lambda\}/gi,"λ"],[/\{mu\}/gi,"μ"],[/\{nu\}/gi,"ν"],[/\{pi\}/gi,"π"],[/\{rho\}/gi,"ρ"],[/\{sigma\}/gi,"σ"],[/\{tau\}/gi,"τ"],[/\{phi\}/gi,"φ"],[/\{psi\}/gi,"Ψ"],[/\{omega\}/gi,"ω"]]);return s(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a;var s=t(0);n.exports=e.default},function(n,e,t){"use strict";function a(n){n=n.replace(/(\d)(\s)?(\/)(\s)?(\d)/g,"$1$3$5");var e=new Map([[/\{!=}/g,"≠"],[/\{~}/g,"≈"],[/\{equal}/g,"≡"],[/\{<=}/g,"⩽"],[/\{=>}/g,"⩾"],[/\+-/g,"±"],[/\{-}/g,"–"],[/\{multiple}/g,"×"],[/\{divide}/g,"÷"],[/<->/g,"↔"],[/<=>/g,"⇔"],[/<-/g,"←"],[/<=/g,"⇐"],[/->/g,"→"],[/=>/g,"⇒"],[/\{\^1}/g,"¹"],[/\{\^2}/g,"²"],[/\{\^3}/g,"³"],[/\{1\/8}/g,"⅛"],[/\{1\/6}/g,"⅙"],[/\{1\/5}/g,"⅕"],[/\{1\/4}/g,"¼"],[/\{1\/3}/g,"⅓"],[/\{1\/2}/g,"½"],[/\{2\/5}/g,"⅖"],[/\{2\/3}/g,"⅔"],[/\{3\/8}/g,"⅜"],[/\{3\/5}/g,"⅗"],[/\{3\/4}/g,"¾"],[/\{4\/5}/g,"⅘"],[/\{5\/6}/g,"⅚"],[/\{5\/8}/g,"⅝"],[/\{7\/8}/g,"⅞"],[/\{part}/g,"∂"],[/\{any}/g,"∀"],[/\{exist}/g,"∃"],[/\{sum}/g,"Σ"],[/\{empty}/g,"∅"],[/\{infinity}/g,"∞"],[/\{belong}/g,"∈"],[/\{!belong}/g,"∉"],[/\{union}/g,"∪"],[/\{intersection}/g,"∩"],[/\{v}/g,"√"],[/\{v3}/g,"∛"],[/\{v4}/g,"∜"],[/\{ang}/g,"∠"]]);return s(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a;var s=t(0);n.exports=e.default},function(n,e,t){"use strict";function a(n,e){var t=function(n,e){return RegExp(n,e)};if(n=n.replace(/&nbsp;|\u00a0/gi," "),n=n.replace(/([^\s])(\u2014)([^\s])/gm,"$1 $2 $3"),n=n.replace(/\u2012|\u2013|\u002d|\u02d7|\u2212/gm,"-"),n=n.replace(/\s+(-)\s+/gm," $1 "),n=n.replace(/([\u00bb\u201c"],)(-)/gm,"$1 $2"),"ru"===e){n=n.replace(/(\s|^|<p>)([«"„‚]*)(-)([\s]|$)/g,"$1$2—$4"),n=n.replace(/([A-Za-zА-яёЁ0-9]) —/g,"$1 —"),n=n.replace(/([.,!?] |\n|^|<p>)— ([A-Za-zА-яёЁ0-9«"„‚])/g,"$1— $2");var a="(где|зачем|как|какая|какие|каким|каких|какое|какой|какого|каком|какому|кем|когда|кого|ком|кому|кто|куда|откуда|почему|чего|чем|чему|что|чём)";n=n.replace(t("([^А-яёЁ]|^)"+a+"[ ]{2}?(то|либо|нибудь)([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(t("([^А-яёЁ]|^)"+a+"[ ]{2}?(то|либо|нибудь)([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(t("([^А-яёЁ]|^)(кое|кой)[ ]{2}?"+a+"([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(t("([^А-яёЁ]|^)(кое|кой)[ ]{2}?"+a+"([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(/([\s]|^)(из)[ ]{2}?(за)([\s]|$)/gi,"$1$2-$3$4").replace(/([\s]|^)(из)[ ]{2}?(под)([\s]|$)/gi,"$1$2-$3$4").replace(/([А-яёЁ]{2,}) (ка|кась)([\s,.?!]|$)/g,"$1-$2$3").replace(/([^А-яёЁ]|^)(вс[ёе]|так)[ ]{2}?(таки)([^А-яёЁ]|$)/gi,"$1$2-$3$4").replace(/(ГОСТ(?:[ ]{2}Р))?[ ]{2}([\d.]+)-([\d]+)/gi,"$1 $2–$3"),n=n.replace(/([IVXLCDM]{1,3})-([IVXLCDM]{1,3})[ ]{2}?вв?\.?([\s.,?!;)])/g,"$1—$2 вв.$3").replace(/([\d]{1,4})-([\d]{1,4})[ ]{2}?гг?\.([\s.,?!;)])/g,"$1–$2 гг.$3").replace(/([^\d]|^)([0-2][0-9]:[0-5][0-9])-([0-2][0-9]:[0-5][0-9])([^\d]|$)/g,"$1$2–$3$4");var s="(?:[ьяюе]|[её]м)",i="(?:[ауе]|ом)",o="(январ"+s+"|феврал"+s+"|март"+i+"|апрел"+s+"|ма(?:[йяюе]|ем)|ию[нл]"+s+"август"+i+"|сентябр"+s+"|ноябр"+s+"|октябр"+s+"|декабр"+s+")";n=n.replace(t("([\\s]|^)([1-3]?[\\d])-([1-3]?[\\d])[ ]{2}?"+o+"([^А-яёЁ]|$)","gi"),"$1$2–$3 $4$5").replace(t("([^А-яёЁ]|^)"+o+"-"+o+"([^А-яёЁ]|&)","gi"),"$1$2—$3$4")}return n=n.replace(/(\d)--(\d)/g,"$1–$2").replace(/([^-]|\s|^)--([^-]|$|\n)/g,"$1—$2").replace(/([^-\d]|^)(\d+)-(\d+)([^-\d]|$)/g,"$1$2–$3$4").replace(/([^a-z][a-z]|[Α-Ωα-ω+=*\/])-(\d)/g,"$1−$2"),n=n.replace(/\s+(-)\s+/gm,"$1")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){n=n.replace(/( |\u00a0){2,}/g," "),n=n.replace(/(\t){2,}/g,"\t"),n=n.replace(/([^.])(\.{2})([^.])/g,"$1.$3"),n=n.replace(/(\.){4,}/g,"."),n=n.replace(/(,|:|;){2,}/g,"$1"),n=n.replace(/(\s*)\n{2,}(\s*)/g,"\n"),n=n.replace(/(\u2028|\u2029){2,}/g,"\u2028");var t=new Map;t.set(/([.,!?:)])(?=[^ \n"'.,;!?&:\])<»”{)])/g,"$1 "),t.set(/[\s]*(?=[.,;!?:])/g,""),t.set(/\s([-\u2013\u2014])/g," $1"),e.includes("nbsp")&&t.set(/\s([-\u2013\u2014])/g,"&nbsp;$1");var a=i(n,[/[\d]+([.,][\d]+)+/g,/^[a-z0-9_.+-]+@[a-z0-9-]+\.[a-z0-9-.]+$/gi,/((([a-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[a-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[a-z0-9.-]+)((?:\/[+~%\/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/gi,/[:;.]['_-]{0,2}[.,edpobnsu*#@|()&$308ехорвъэ]/gi]),g=a.text,r=a.parts;return g=s(g,t),o(g,r)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a;var s=t(0),i=t(2),o=t(3);n.exports=e.default},function(n,e,t){"use strict";function a(n){var e=new Map([[/([\u2116\u00a7])[\s]*(?=[\d])/g,"$1&nbsp;"],[/([\d])[\s]*(?=\u00b0[CСF])/g,"$1 "],[/([\d])[\s]*(?=%)/g,"$1"]]);return s(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a;var s=t(0);n.exports=e.default},function(n,e,t){"use strict";function a(n){var e=new Map([[/(\d)\*([\D])/g,"$1°$2"],[/(\d)'/g,"$1′"],[/(^[^"]*\d)"([^"]*$)/g,"$1″$2"],[/("[^"]*\d)"([^"]*?")/g,"$1″$2"]]);return s(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a;var s=t(0);n.exports=e.default},function(n,e,t){"use strict";function a(n){return n.replace(/[\s]{2,}/g," ")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n){return n=n.replace(/(^|\n|\s|—|-|\()"/g,"$1«").replace(/"($|\n|\s|—|-|\.|,|!|\?|:|;|\))/g,"»$1").replace(/«\)/g,"»)").replace(/«( ?)/g,"«").replace(/( ?)»/g,"»").replace(/>"/g,">«").replace(/"</g,"»<").replace(/«""/g,"«««").replace(/«"/g,"««").replace(/""»/g,"»»»").replace(/"»/g,"»»").replace(/("{2}|"»)/g,"»»").replace(/$"/g,"«").replace(/([A-Za-zа-яА-ЯёЁ])'/g,"$1’"),n=n.replace(/[a-zA-ZА-яёЁ]"-/g,"$1»-").replace(/-"[a-zA-ZА-яёЁ]/g,"-«$1"),n=n.replace(/(^[^«»]*)"/g,"$1«").replace(/"([^«»]*$)/g,"»$1").replace(/«([^«»]*)"/g,"«$1»").replace(/"([^«»]*)»/g,"«$1»")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){for(var t=0,a=0;a<n.length;++a)if("«"===n.charAt(a)){++t;for(var s=a+1;s<n.length;++s)if("«"===n.charAt(s)&&++t,"»"===n.charAt(s)&&--t<=0){n=function(e,t){var a="",s="",i="";0!==e&&(a=n.substring(0,e)),t!==n.length-1&&(i=n.substring(t+1,n.length)),s=n.substring(e,t+1);for(var o=0;o<32;++o)s=s.replace(/«([^«»]*)«([^»]*)»/g,"«$1„$2“"),s=s.replace(/„([^„“]*)„([^“]*)“/g,"„$1‚$2‘");return a+s+i}(a,s),a=s;break}t=0}return"en"===e&&(n=n.replace(/(»|’)(\.|,|!|\?)/g,"$2$1").replace(/«/g,"“").replace(/»/g,"”")),n=n.replace(/([A-z])”([A-z])/g,"$1’$2"),n=n.replace(/«(\d+( |\xA0)[A-z])/g,"“$1"),n=n.replace(/([A-z]( |\xA0)\d+)»/g,"$1”"),n=n.replace(/([^.{2}])(\.{1}»)/g,"$1»."),n=n.replace(/([^.{2}])(\.{1}”)/g,"$1”.")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){return n}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){return n=n.replace(/((тел\.|телефон?[а-я]{1,3})(:?)(\s+?))?(\+7|8)(\s+)?(\(?)(\d{3})(\)?)(\s+)?(\d{3})(\u2012|\u2013|\u2014|\u002d|\u02d7|\u2212)?(\d{2})(\u2012|\u2013|\u2014|\u002d|\u02d7|\u2212)?(\d{2})([^\w])/gi,'$2$3 <span data-typo="" class="nowrap">+7($8) $11–$13–$15</span>$16')}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){return n=n.replace(/( |\xA0|^|\n|\u2028|\u2029|>)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6&nbsp;$7&nbsp;$8&nbsp;$9"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029|>)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6&nbsp;$7&nbsp;$8"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029|>)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6&nbsp;$7"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029|>)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029|>)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029|>)(\d{1,3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029|>)(\d{2,3}) ?(\d{3})/g,"$1$2&nbsp;$3")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n){n=n.replace(/(\s)\/(\s)/g,"&nbsp;/&nbsp;"),n=n.replace(/((^|[\s])[a-zа-яёіїєґ'′]{1,2})[\s]/gi,"$1&nbsp;"),n=n.replace(/(\d)([a-zа-я])/g,"$1&nbsp;$2"),n=n.replace(/(\d)(\s)(\W)/g,"$1&nbsp;$3"),n=n.replace(/(тыс|млн|млрд|трлн|кв\.)(\s)(р\.|руб|кило|тон|кв(\.)?|м(\.)?)/gi,"$1&nbsp;$3");for(var e=["без","безо","в","во","вне","для","до","за","из","изо","из-за","из-под","к","ко","на","над","о","об","обо","около","от","ото","по","по-над","под","подо","при","про","с","со","сквозь","у","через","а","но","и","да","или","иль","либо","не","ни","a","the","at","to","or"],t=0;t<47;t++){var a=RegExp("( |^|\\(|«|„| )("+e[t]+") ","ig");n=n.replace(a,"$1$2&nbsp;")}return n=n.replace(/([А-Я]\.)(\s)?([А-Я]\.)(\s)?([А-Я][А-Яа-я]*)/g,"$1&nbsp;$3&nbsp;$5"),n=n.replace(/([А-Я][А-Яа-я]*)(\s)?([А-Я]\.)(\s)?([А-Я]\.)/g,"$1&nbsp;$3&nbsp;$5")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n){return n=n.replace(/\.{3}/g,"…")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e,t){"use strict";function a(n,e){return n=n.replace(/(\s)?(мкм|мм|см|дм|м|км|µm|mm|cm|m|km)\^?2/gi,"$2²"),n=n.replace(/(\s)?(мкм|мм|см|дм|м|км|µm|mm|cm|m|km)\^?3/gi,"$2³")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=a,n.exports=e.default},function(n,e){},function(n,e,t){"use strict";t(1)(t(47))},,,,function(n,e,t){"use strict";function a(n,e){return e.querySelector(n)}function s(n,e){return e.querySelectorAll(n)}function i(){for(var n=s(".test",document),e=n.length;e--;){var t=n[e].dataset,i=new o({lang:t&&t.lang?t.lang:"ru"}),g=a(".source",n[e]),r=g.innerHTML,l=a(".model",n[e]),A=l.innerHTML,p=a(".result",n[e]),C=i.process(r);C=i.process(C),C=i.process(C);var I=window.global.prettydiff.prettydiff({crlf:!1,html:!1,lang:"markup",langdefault:"markup",newline:!1,source:C,diff:A,diffview:"inline"});p.innerHTML=I}}t(21);var o=t(4);t(27),t(29),t(31),t(33),t(35),t(37),t(39),t(41),t(43),t(45),t(22),t(22),function(n){(document.attachEvent?"complete"===document.readyState:"loading"!==document.readyState)?n():document.addEventListener("DOMContentLoaded",n)}(i)},function(n,e,t){"use strict";t(1)(t(28))},function(n,e){n.exports="/* Always include this library before any other. This library exists only to\n * provide a common namespace in the browser to what node provides to simulate a\n * browser's global scope\n */\nvar global = {\n    prettydiff: {\n        pd: {}\n    }\n};\n"},function(n,e,t){"use strict";t(1)(t(30))},function(n,e){n.exports='/*global ace, define, global, module*/\n/*\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n*/\n(function language_init() {\n    "use strict";\n    var language = {};\n    global.prettydiff.language = language;\n    language.setlangmode = function language_setlangmode(input) {\n        var langmap = {\n            c_cpp     : "javascript",\n            coldfusion: "markup",\n            csharp    : "javascript",\n            css       : "css",\n            csv       : "csv",\n            dustjs    : "html",\n            ejs       : "html",\n            go        : "html",\n            handlebars: "html",\n            html      : "html",\n            html_ruby : "html",\n            java      : "javascript",\n            javascript: "javascript",\n            json      : "json",\n            jsp       : "markup",\n            jsx       : "javascript",\n            less      : "css",\n            markup    : "markup",\n            php       : "html",\n            qml       : "qml",\n            scss      : "css",\n            swig      : "html",\n            text      : "text",\n            titanium  : "tss",\n            tss       : "tss",\n            twig      : "html",\n            typescript: "typescript",\n            velocity  : "velocity",\n            xhtml     : "markup",\n            xml       : "markup"\n        };\n        if (typeof input !== "string") {\n            return "javascript";\n        }\n        if (input.indexOf("html") > -1) {\n            return "html";\n        }\n        if (langmap[input] === undefined) {\n            return "javascript";\n        }\n        return langmap[input];\n    };\n    language.nameproper  = function language_nameproper(input) {\n        var langmap = {\n            c_cpp     : "C++ (Not yet supported)",\n            coldfusion: "ColdFusion",\n            csharp    : "C#",\n            dustjs    : "Dust.js",\n            ejs       : "EJS Template",\n            elm       : "Elm Template",\n            go        : "Go Lang Template",\n            handlebars: "Handlebars Template",\n            html_ruby : "ERB (Ruby) Template",\n            java      : "Java",\n            javascript: "JavaScript",\n            jsp       : "JSTL (JSP)",\n            jsx       : "React JSX",\n            liquid    : "Liquid Template",\n            markup    : "markup",\n            scss      : "SCSS",\n            text      : "Plain Text",\n            titanium  : "Titanium Stylesheets",\n            tss       : "Titanium Stylesheets",\n            twig      : "HTML TWIG Template",\n            typescript: "TypeScript",\n            velocity  : "Apache Velocity",\n            volt      : "Volt Template"\n        };\n        if (typeof input !== "string" || langmap[input] === undefined) {\n            return input.toUpperCase();\n        }\n        return langmap[input];\n    };\n    // [0] = language value for ace mode [1] = prettydiff language category from [0]\n    // [2] = pretty formatting for text output to user\n    language.auto = function language_auto(sample, defaultLang) {\n        var b           = [],\n            c           = 0,\n            vartest     = (\n                /(((var)|(let)|(const)|(function)|(import))\\s+(\\w|\\$)+[a-zA-Z0-9]*)/\n            ).test(sample),\n            finalstatic = (/((((final)|(public)|(private))\\s+static)|(static\\s+void))/).test(\n                sample\n            ),\n            output      = function language_auto_output(langname) {\n                if (langname === "unknown") {\n                    return [defaultLang, language.setlangmode(defaultLang), "unknown"];\n                }\n                if (langname === "xhtml" || langname === "markup") {\n                    return ["xml", "html", "XHTML"];\n                }\n                if (langname === "tss") {\n                    return ["tss", "tss", "Titanium Stylesheets"];\n                }\n                return [langname, language.setlangmode(langname), language.nameproper(langname)];\n            },\n            cssA        = function language_auto_cssA() {\n                if ((/\\$[a-zA-Z]/).test(sample) === true || (/\\{\\s*(\\w|\\.|\\$|#)+\\s*\\{/).test(sample) === true) {\n                    return output("scss");\n                }\n                if ((/@[a-zA-Z]/).test(sample) === true || (/\\{\\s*(\\w|\\.|@|#)+\\s*\\{/).test(sample) === true) {\n                    return output("less");\n                }\n                return output("css");\n            },\n            notmarkup   = function language_auto_notmarkup() {\n                var d               = 0,\n                    join            = "",\n                    flaga           = false,\n                    flagb           = false,\n                    publicprivate   = (\n                        /((public)|(private))\\s+(static\\s+)?(((v|V)oid)|(class)|(final))/\n                    ).test(sample),\n                    javascriptA     = function language_auto_notmarkup_javascriptA() {\n                        if (sample.indexOf("(") > -1 || sample.indexOf("=") > -1 || (sample.indexOf(";") > -1 && sample.indexOf("{") > -1)) {\n                            if (vartest === false && ((/\\n\\s+#region\\s/).test(sample) === true || (/\\[\\w+:/).test(sample) === true)) {\n                                return output("csharp");\n                            }\n                            if (finalstatic === true || (/\\w<\\w+(,\\s+\\w+)*>/).test(sample) === true) {\n                                if ((/:\\s*((number)|(string))/).test(sample) === false && vartest === false && (finalstatic === true || publicprivate === true)) {\n                                    return output("java");\n                                }\n                                return output("typescript");\n                            }\n                            if ((/final\\s+static/).test(sample) === true) {\n                                return output("java");\n                            }\n                            return output("javascript");\n                        }\n                        return output("unknown");\n                    },\n                    cssOrJavaScript = function language_auto_notmarkup_cssOrJavaScript() {\n                        if ((/:\\s*((number)|(string))/).test(sample) === true && (/((public)|(private))\\s+/).test(sample) === true) {\n                            return output("typescript");\n                        }\n                        if ((/import\\s+java(\\.|(fx))/).test(sample) === true || (/((public)|(private))\\s+static\\s+/).test(sample) === true) {\n                            return output("java");\n                        }\n                        if ((/\\sclass\\s+\\w/).test(sample) === false && (/<[a-zA-Z]/).test(sample) === true && (/<\\/[a-zA-Z]/).test(sample) === true && ((/\\s?\\{%/).test(sample) === true || (/\\{(\\{|#)(?!(\\{|#|=))/).test(sample) === true)) {\n                            return output("twig");\n                        }\n                        if ((/^(\\s*(\\$|@))/).test(sample) === false && (/(\\};?\\s*)$/).test(sample) === true) {\n                            if ((/export\\s+default\\s+\\{/).test(sample) === true || (/(\\?|:)\\s*(\\{|\\[)/).test(sample) === true || (/(\\{|\\s|;)render\\s*\\(\\)\\s*\\{/).test(sample) === true || (/^(\\s*return;?\\s*\\{)/).test(sample) === true) {\n                                return output("javascript");\n                            }\n                        }\n                        if ((/\\{\\{#/).test(sample) === true && (/\\{\\{\\//).test(sample) === true && (/<\\w/).test(sample) === true) {\n                            return output("handlebars");\n                        }\n                        if ((/\\{\\s*(\\w|\\.|@|#)+\\s*\\{/).test(sample) === true) {\n                            return output("less");\n                        }\n                        if ((/\\$(\\w|-)/).test(sample) === true) {\n                            return output("scss");\n                        }\n                        if ((/(;|\\{|:)\\s*@\\w/).test(sample) === true) {\n                            return output("less");\n                        }\n                        if ((/class\\s+\\w+\\s+\\{/).test(sample) === true) {\n                            return output("java");\n                        }\n                        return output("css");\n                    };\n                for (d = 1; d < c; d = d + 1) {\n                    if (flaga === false) {\n                        if (b[d] === "*" && b[d - 1] === "/") {\n                            b[d - 1] = "";\n                            flaga    = true;\n                        } else if (flagb === false && b[d] === "f" && d < c - 6 && b[d + 1] === "i" && b[d + 2] === "l" && b[d + 3] === "t" && b[d + 4] === "e" && b[d + 5] === "r" && b[d + 6] === ":") {\n                            flagb = true;\n                        }\n                    } else if (flaga === true && b[d] === "*" && d !== c - 1 && b[d + 1] === "/") {\n                        flaga    = false;\n                        b[d]     = "";\n                        b[d + 1] = "";\n                    } else if (flagb === true && b[d] === ";") {\n                        flagb = false;\n                        b[d]  = "";\n                    }\n                    if (flaga === true || flagb === true) {\n                        b[d] = "";\n                    }\n                }\n                join = b.join("");\n                if ((/\\s\\/\\//).test(sample) === false && (/\\/\\/\\s/).test(sample) === false && (/^(\\s*(\\{|\\[)(?!%))/).test(sample) === true && (/((\\]|\\})\\s*)$/).test(sample) && sample.indexOf(",") !== -1) {\n                    return output("json");\n                }\n                if ((/((\\}?(\\(\\))?\\)*;?\\s*)|([a-z0-9]("|\')?\\)*);?(\\s*\\})*)$/i).test(sample) === true && (vartest === true || publicprivate === true || (/console\\.log\\(/).test(sample) === true || (/export\\s+default\\s+class\\s+/).test(sample) === true || (/document\\.get/).test(sample) === true || (/((\\=|(\\$\\())\\s*function)|(\\s*function\\s+(\\w*\\s+)?\\()/).test(sample) === true || sample.indexOf("{") === -1 || (/^(\\s*if\\s+\\()/).test(sample) === true)) {\n                    return javascriptA();\n                }\n                // * u007b === {\n                // * u0024 === $\n                // * u002e === .\n                if (sample.indexOf("{") > -1 && ((/^(\\s*[\\u007b\\u0024\\u002e#@a-z0-9])/i).test(sample) === true || (/^(\\s*\\/(\\*|\\/))/).test(sample) === true || (/^(\\s*\\*\\s*\\{)/).test(sample) === true) && (/^(\\s*if\\s*\\()/).test(sample) === false && (/\\=\\s*(\\{|\\[|\\()/).test(join) === false && (((/(\\+|-|\\=|\\?)\\=/).test(join) === false || (/\\/\\/\\s*\\=+/).test(join) === true) || ((/\\=+(\'|")?\\)/).test(sample) === true && (/;\\s*base64/).test(sample) === true)) && (/function(\\s+\\w+)*\\s*\\(/).test(join) === false) {\n                    if ((/\\s*#((include)|(define)|(endif))\\s+/).test(sample)) {\n                        return output("c_cpp");\n                    }\n                    return cssOrJavaScript();\n                }\n                if ((/"\\s*:\\s*\\{/).test(sample) === true) {\n                    return output("tss");\n                }\n                if (sample.indexOf("{%") > -1) {\n                    return output("twig");\n                }\n                return output("unknown");\n            },\n            markup      = function language_auto_markup() {\n                var html = function language_auto_markup_html() {\n                    if ((/<%\\s*\\}/).test(sample) === true) {\n                        return output("ejs");\n                    }\n                    if ((/<%\\s*end/).test(sample) === true) {\n                        return output("html_ruby");\n                    }\n                    if ((/\\{\\{(#|\\/|\\{)/).test(sample) === true) {\n                        return output("handlebars");\n                    }\n                    if ((/\\{\\{end\\}\\}/).test(sample) === true) {\n                        //place holder for Go lang templates\n\n                        return output("html");\n                    }\n                    if ((/\\s?\\{%/).test(sample) === true && (/\\{(\\{|#)(?!(\\{|#|\\=))/).test(sample) === true) {\n                        return output("twig");\n                    }\n                    if ((/<\\?/).test(sample) === true) {\n                        return output("php");\n                    }\n                    if ((/<jsp:include\\s/).test(sample) === true || (/<c:((set)|(if))\\s/).test(sample) === true) {\n                        return output("jsp");\n                    }\n                    if ((/\\{(#|\\?|\\^|@|<|\\+|~)/).test(sample) === true && (/\\{\\//).test(sample) === true) {\n                        return output("dustjs");\n                    }\n                    return output("html");\n                };\n                if ((/^(\\s*<!doctype\\u0020html>)/i).test(sample) === true || (/^(\\s*<html)/i).test(sample) === true || ((/^(\\s*<!DOCTYPE\\s+((html)|(HTML))\\s+PUBLIC\\s+)/).test(sample) === true && (/XHTML\\s+1\\.1/).test(sample) === false && (/XHTML\\s+1\\.0\\s+(S|s)((trict)|(TRICT))/).test(sample) === false)) {\n                    return html();\n                }\n                if ((/<jsp:include\\s/).test(sample) === true || (/<c:((set)|(if))\\s/).test(sample) === true) {\n                    return output("jsp");\n                }\n                if ((/<%\\s*\\}/).test(sample) === true) {\n                    return output("ejs");\n                }\n                if ((/<%\\s*end/).test(sample) === true) {\n                    return output("html_ruby");\n                }\n                if ((/\\{\\{(#|\\/|\\{)/).test(sample) === true) {\n                    return output("handlebars");\n                }\n                if ((/\\{\\{end\\}\\}/).test(sample) === true) {\n                    //place holder for Go lang templates\n\n                    return output("xml");\n                }\n                if ((/\\s?\\{%/).test(sample) === true && (/\\{\\{(?!(\\{|#|\\=))/).test(sample) === true) {\n                    return output("twig");\n                }\n                if ((/<\\?(?!(xml))/).test(sample) === true) {\n                    return output("php");\n                }\n                if ((/\\{(#|\\?|\\^|@|<|\\+|~)/).test(sample) === true && (/\\{\\//).test(sample) === true) {\n                    return output("dustjs");\n                }\n                if ((/<jsp:include\\s/).test(sample) === true || (/<c:((set)|(if))\\s/).test(sample) === true) {\n                    return output("jsp");\n                }\n                return output("xml");\n            };\n        if (sample === null) {\n            return;\n        }\n        if ((/^(\\s*<\\!DOCTYPE\\s+html>)/i).test(sample) === true) {\n            return output("html");\n        }\n        if ((/^(\\s*((if)|(for)|(function))\\s*\\()/).test(sample) === false && (/(\\s|;|\\})((if)|(for)|(function\\s*\\w*))\\s*\\(/).test(sample) === false && vartest === false && (/return\\s*\\w*\\s*(;|\\})/).test(sample) === false && (sample === undefined || (/^(\\s*#(?!(!\\/)))/).test(sample) === true || ((/\\n\\s*(\\.|@)\\w+(\\(?|(\\s*:))/).test(sample) === true && (/>\\s*<\\w/).test(sample) === false))) {\n            return cssA();\n        }\n        b = sample\n            .replace(/\\[[a-zA-Z][\\w\\-]*\\=("|\')?[a-zA-Z][\\w\\-]*("|\')?\\]/g, "")\n            .split("");\n        c = b.length;\n        if ((/^(\\s*\\{(%|#|\\{))/).test(sample) === true) {\n            return markup();\n        }\n        if (((/^([\\s\\w\\-]*<)/).test(sample) === false && (/(>[\\s\\w\\-]*)$/).test(sample) === false) || finalstatic === true) {\n            return notmarkup();\n        }\n        if ((((/(>[\\w\\s:]*)?<(\\/|!|#)?[\\w\\s:\\-\\[]+/).test(sample) === true || (/^(\\s*<\\?xml)/).test(sample) === true) && ((/^([\\s\\w]*<)/).test(sample) === true || (/(>[\\s\\w]*)$/).test(sample) === true)) || ((/^(\\s*<s((cript)|(tyle)))/i).test(sample) === true && (/(<\\/s((cript)|(tyle))>\\s*)$/i).test(sample) === true)) {\n            if ((/^([\\s\\w]*<)/).test(sample) === false || (/(>[\\s\\w]*)$/).test(sample) === false) {\n                return notmarkup();\n            }\n            return markup();\n        }\n        return output("unknown");\n    };\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function language_requirejs() {\n            return global.prettydiff.language;\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = global.prettydiff.language;\n    }\n}());\n'},function(n,e,t){"use strict";t(1)(t(32))},function(n,e){n.exports='/*global __dirname, ace, define, global, module, process, require, WScript*/\n/*jslint for: true, this: true*/\n/*\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n\n How to define a new option:\n\n 1. definitions - define the option\n 2. validate    - logic to assign values against accepted criteria\n 3. pdcomment   - only necessary if option is string type with a list of accepted values\n 4. domops      - associate ID names (from HTML) to values for populating the pretty diff comment in the web tool\n\n Functions map:\n\n * definitions   - a big object defining all the options\n * default       - pulls default values out of the definitions object. This is necessary to prevent collisions when processing multiple files simultanesouly\n * versionString - a function to build out human readable messaging about the current version from data in prettydiff.js\n * consolePrint  - a handy function to print documentation on all options and usage data to the console in the browser or command line.\n    ** to execute in the browser console: global.prettydiff.options.functions.consolePrint()\n    ** or use the alias document.consolePrint() from api/dom.js\n * pdcomment     - processes option overrides from the prettydiff.com code comment\n * validate      - process user input against supported options and their acceptable values.  I have plans to merge this into the definitions object\n * domops        - updates the comment string that appears in the options area of the web tool\n * node          - parses node arguments into options for submission to the validate function\n * binary        - a handy dandy tool to remove control characters from text output\n*/\n(function options_init() {\n    "use strict";\n    var options = {\n        functions: {}\n    };\n    global.prettydiff.options = options;\n    options.functions.definitions   = {\n        apacheVelocity : {\n            type      : "boolean",\n            definition: "Provides support for Apache Velocity template language.",\n            default   : false\n        },\n        api            : {\n            type      : "string",\n            definition: "An enternal option to help identify environment specific needs.",\n            default   : false\n        },\n        attributetoken : {\n            type      : "boolean",\n            definition: "Provides markups attributes as separate tokens in the parse table of mode pars" +\n                    "e, otherwise attributes are a data property of their respective element.",\n            default   : false\n        },\n        brace_style    : {\n            type      : "string",\n            definition: "Emulates JSBeautify\'s brace_style option using existing Pretty Diff options.",\n            values    : [\n                "collapse", "collapse-preserve-inline", "expand", "none"\n            ],\n            default   : "none"\n        },\n        braceline      : {\n            type      : "boolean",\n            definition: "If true a new line character will be inserted after opening curly braces and b" +\n                    "efore closing curly braces.",\n            default   : false\n        },\n        bracepadding   : {\n            type      : "boolean",\n            definition: "Inserts a space after the start of a contain and before the end of the contain" +\n                    "er in JavaScript if the contents of that container are not indented; such as: " +\n                    "conditions, function arguments, and escaped sequences of template strings.",\n            default   : false\n        },\n        braces         : {\n            type      : "string",\n            definition: "If lang is \'javascript\' and mode is \'beautify\' this determines if opening curl" +\n                    "y braces will exist on the same line as their condition or be forced onto a ne" +\n                    "w line.",\n            values    : [\n                "knr", "allman"\n            ],\n            default   : "knr"\n        },\n        color          : {\n            type      : "string",\n            definition: "The color scheme of the reports.",\n            default   : "white",\n            values    : ["canvas", "shadow", "white"]\n        },\n        comments       : {\n            type      : "string",\n            definition: "If mode is \'beautify\' this will determine whether comments should always start" +\n                    " at position 0 of each line or if comments should be indented according to the" +\n                    " code.",\n            default   : "indent",\n            values    : ["indent", "noindent"]\n        },\n        commline       : {\n            type      : "boolean",\n            definition: "If a blank new line should be forced above comments in markup.",\n            default   : false\n        },\n        compressedcss  : {\n            type      : "boolean",\n            definition: "If CSS should be beautified in a style where the properties and values are min" +\n                    "ifed for faster reading of selectors.",\n            default   : false\n        },\n        conditional    : {\n            type      : "boolean",\n            definition: "If true then conditional comments used by Internet Explorer are preserved at m" +\n                    "inification of markup.",\n            default   : false\n        },\n        content        : {\n            type      : "boolean",\n            definition: "If true and mode is \'diff\' this will normalize all string literals in JavaScri" +\n                    "pt to \'text\' and all content in markup to \'text\' so as to eliminate some diffe" +\n                    "rences from the HTML diff report.",\n            default   : false\n        },\n        context        : {\n            type      : "number",\n            definition: "This shortens the diff output by allowing a specified number of equivalent lin" +\n                    "es between each line of difference.",\n            default   : -1\n        },\n        correct        : {\n            type      : "boolean",\n            definition: "Automatically correct some sloppiness in JavaScript and markup.",\n            default   : false\n        },\n        crlf           : {\n            type      : "boolean",\n            definition: "If line termination should be Windows (CRLF) format.  Unix (LF) format is the " +\n                    "default.",\n            default   : false\n        },\n        cssinsertlines : {\n            type      : "boolean",\n            definition: "Inserts new line characters between every CSS code block.",\n            default   : false\n        },\n        csvchar        : {\n            type      : "string",\n            definition: "The character to be used as a separator if lang is \'csv\'.  Any string combinat" +\n                    "ion is accepted.",\n            default   : ","\n        },\n        diff           : {\n            type      : "string",\n            definition: "The code sample to be compared to \'source\' option. This is required if mode is" +\n                    " \'diff\'.",\n            default   : ""\n        },\n        diffcli        : {\n            type      : "boolean",\n            definition: "If true only text lines of the code differences are returned instead of an HTM" +\n                    "L diff report.",\n            default   : false\n        },\n        diffcomments   : {\n            type      : "boolean",\n            definition: "If true then comments will be preserved so that both code and comments are com" +\n                    "pared by the diff engine.",\n            default   : false\n        },\n        difflabel      : {\n            type      : "string",\n            definition: "This allows for a descriptive label for the diff file code of the diff HTML ou" +\n                    "tput.",\n            default   : "New Sample"\n        },\n        diffspaceignore: {\n            type      : "boolean",\n            definition: "If white space only differences should be ignored by the diff tool.",\n            default   : false\n        },\n        diffview       : {\n            type      : "string",\n            definition: "This determines whether the diff HTML output should display as a side-by-side " +\n                    "comparison or if the differences should display in a single table column.",\n            values    : [\n                "inline", "sidebyside"\n            ],\n            default   : "sidebyside"\n        },\n        dustjs         : {\n            type      : "boolean",\n            definition: "If the provided markup code is a Dust.js template.",\n            default   : false\n        },\n        elseline       : {\n            type      : "boolean",\n            definition: "If elseline is true then the keyword \'else\' is forced onto a new line in JavaS" +\n                    "cript beautification.",\n            default   : false\n        },\n        endcomma       : {\n            type      : "string",\n            definition: "If there should be a trailing comma in JavaScript arrays and objects. Value \\"" +\n                    "multiline\\" only applies to modes beautify and diff.",\n            values    : [\n                "always", "multiline", "never"\n            ],\n            default   : "never"\n        },\n        endquietly     : {\n            type      : "string",\n            definition: "A node only option to determine if terminal logging should be allowed or suppr" +\n                    "essed.",\n            values    : [\n                "", "log", "quiet"\n            ],\n            default   : ""\n        },\n        force_attribute: {\n            type      : "boolean",\n            definition: "If all markup attributes should be indented each onto their own line.",\n            default   : false\n        },\n        force_indent   : {\n            type      : "boolean",\n            definition: "If lang is \'markup\' this will force indentation upon all content and tags with" +\n                    "out regard for the creation of new text nodes.",\n            default   : false\n        },\n        formatArray    : {\n            type      : "string",\n            definition: "Determines if all JavaScript array indexes should be indented, never indented," +\n                    " or left to the default.",\n            values    : [\n                "default", "indent", "inline"\n            ],\n            default   : "default"\n        },\n        formatObject   : {\n            type      : "string",\n            definition: "Determines if all JavaScript array indexes should be indented, never indented," +\n                    " or left to the default.",\n            values    : [\n                "default", "indent", "inline"\n            ],\n            default   : "default"\n        },\n        functionname   : {\n            type      : "boolean",\n            definition: "If a space should follow a JavaScript function name.",\n            default   : false\n        },\n        help           : {\n            type      : "number",\n            definition: "A node only option to print documentation to the console. The value determines" +\n                    " where to wrap text.",\n            default   : 80\n        },\n        html           : {\n            type      : "boolean",\n            definition: "If lang is \'markup\' this will provide extra support for HTML specific sloppine" +\n                    "ss.",\n            default   : false\n        },\n        inchar         : {\n            type      : "string",\n            definition: "The string characters to comprise a single indentation. Any string combination" +\n                    " is accepted.",\n            default   : " "\n        },\n        inlevel        : {\n            type      : "number",\n            definition: "How much indentation padding should be applied to JavaScript beautification?",\n            default   : 0\n        },\n        insize         : {\n            type      : "number",\n            definition: "The number of characters to comprise a single indentation.",\n            default   : 4\n        },\n        jekyll         : {\n            type      : "boolean",\n            definition: "If YAML Jekyll HTML template comments are supported.",\n            default   : false\n        },\n        jsscope        : {\n            type      : "string",\n            definition: "An educational tool to generate HTML output of JavaScript code to identify sco" +\n                    "pe regions and declared references by color.",\n            values    : {\n                none  : "prevents use of this option",\n                report: "generates HTML output that renders in web browsers",\n                html  : "generates HTML output with escaped angle braces and ampersands for embedding a" +\n                        "s code, which is handy in code producing tools"\n            },\n            default   : "none"\n        },\n        jsx            : {\n            type      : "boolean",\n            definition: "An internal flag used to identify if a given code sample is React JSX code.",\n            default   : false\n        },\n        lang           : {\n            type      : "string",\n            definition: "The programming language of the source file.",\n            values    : [\n                "auto",\n                "markup",\n                "javascript",\n                "css",\n                "html",\n                "csv",\n                "text"\n            ],\n            default   : "auto"\n        },\n        langdefault    : {\n            type      : "string",\n            definition: "The fallback option if option \'lang\' is set to \'auto\' and a language cannot be" +\n                    " detected.",\n            values    : [\n                "markup",\n                "javascript",\n                "css",\n                "html",\n                "csv",\n                "text"\n            ],\n            default   : "text"\n        },\n        listoptions    : {\n            type      : "boolean",\n            definition: "A Node.js only option that writes current option settings to the console.",\n            default   : false\n        },\n        methodchain    : {\n            type      : "string",\n            definition: "Whether consecutive JavaScript methods should be chained onto a single line of" +\n                    " code instead of indented.",\n            values    : [\n                "chain", "indent", "none"\n            ],\n            default   : "indent"\n        },\n        miniwrap       : {\n            type      : "boolean",\n            definition: "Whether minified JavaScript should wrap after a specified character width.  Th" +\n                    "is option requires a value from option \'wrap\'.",\n            default   : false\n        },\n        mode           : {\n            type      : "string",\n            definition: "The operation to be performed.",\n            values    : {\n                analysis: "returns a code examination report",\n                beautify: "beautifies code and returns a string",\n                diff    : "returns either command line list of differences or an HTML report",\n                minify  : "minifies code and returns a string",\n                parse   : "using option \'parseFormat\' returns an object with shallow arrays, a multidimen" +\n                        "sional array, or an HTML report"\n            },\n            default   : "diff"\n        },\n        newline        : {\n            type      : "boolean",\n            definition: "Insert an empty line at the end of output.",\n            default   : false\n        },\n        neverflatten   : {\n            type      : "boolean",\n            definition: "If destructured lists in JavaScript should never be flattend.",\n            default   : false\n        },\n        nocaseindent   : {\n            type      : "boolean",\n            definition: "If a case statement should receive the same indentation as the containing swit" +\n                    "ch block.",\n            default   : false\n        },\n        nochainindent  : {\n            type      : "boolean",\n            definition: "If indentation should be prevent of JavaScript method chains broken onto multi" +\n                    "ple lines.",\n            default   : false\n        },\n        nodeasync      : {\n            type      : "boolean",\n            definition: "An internal option manage processing of multiple files simultanously",\n            default   : false\n        },\n        nodeerror      : {\n            type      : "boolean",\n            definition: "A Node.js only option if parse errors should be written to the console.",\n            default   : false\n        },\n        noleadzero     : {\n            type      : "boolean",\n            definition: "Whether leading 0s in CSS values immediately preceeding a decimal should be re" +\n                    "moved or prevented.",\n            default   : false\n        },\n        objsort        : {\n            type      : "string",\n            definition: "Sorts markup attributes and properties by key name in JavaScript and CSS.",\n            values    : [\n                "all", "css", "js", "markup", "none"\n            ],\n            default   : "none"\n        },\n        output         : {\n            type      : "string",\n            definition: "The path of the directory, if readmethod is value \'directory\', or path and nam" +\n                    "e of the file to write the output.  The path will be created or overwritten.",\n            default   : ""\n        },\n        parseFormat    : {\n            type      : "string",\n            definition: "Determines the output format for \'parse\' mode.",\n            values    : {\n                htmltable : "generates a human readable report in the format of an HTML table",\n                parallel  : "returns a series of parallel arrays",\n                sequential: "returns an array where each index is a child array containing the parsed token" +\n                        " and all descriptive data"\n            },\n            default   : "parallel"\n        },\n        parseSpace     : {\n            type      : "boolean",\n            definition: "Whether whitespace tokens should be included.",\n            default   : false\n        },\n        preserve       : {\n            type      : "number",\n            definition: "The maximum number of empty lines to retain.",\n            default   : 0\n        },\n        preserveComment: {\n            type      : "boolean",\n            definition: "Prevent comment reformatting due to option wrap.",\n            default   : false\n        },\n        qml            : {\n            type      : "boolean",\n            definition: "Enables QML syntax support in the jspretty library.",\n            default   : false\n        },\n        quote          : {\n            type      : "boolean",\n            definition: "If true and mode is \'diff\' then all single quote characters will be replaced b" +\n                    "y double quote characters in both the source and diff file input so as to elim" +\n                    "inate some differences from the diff report HTML output.",\n            default   : false\n        },\n        quoteConvert   : {\n            type      : "string",\n            definition: "If the quotes of JavaScript strings or markup attributes should be converted t" +\n                    "o single quotes or double quotes.",\n            values    : [\n                "double", "single", "none"\n            ],\n            default   : "none"\n        },\n        readmethod     : {\n            type      : "string",\n            definition: "The readmethod determines how Node.js should receive input and output.",\n            values    : {\n                auto        : "changes to value subdirectory, file, or screen depending on source resolution",\n                screen      : "reads from screen and outputs to screen",\n                file        : "reads a file and outputs to a file.  file requires option \'output\'",\n                filescreen  : "reads a file and writes to screen",\n                directory   : "process all files in the specified directory only",\n                subdirectory: "process all files in a directory and its subdirectories"\n            },\n            default   : "auto"\n        },\n        selectorlist   : {\n            type      : "boolean",\n            definition: "If comma separated CSS selectors should be retained on a single line of code.",\n            default   : false\n        },\n        semicolon      : {\n            type      : "boolean",\n            definition: "If true and mode is \'diff\' and lang is \'javascript\' all semicolon characters t" +\n                    "hat immediately preceed any white space containing a new line character will b" +\n                    "e removed so as to elimate some differences from the code comparison.",\n            default   : false\n        },\n        source         : {\n            type      : "string",\n            definition: "The source code or location for interpretation. This option is required for al" +\n                    "l modes.",\n            default   : ""\n        },\n        sourcelabel    : {\n            type      : "string",\n            definition: "This allows for a descriptive label of the source file code of the diff HTML o" +\n                    "utput.",\n            default   : "Source Sample"\n        },\n        space          : {\n            type      : "boolean",\n            definition: "Inserts a space following the function keyword for anonymous functions.",\n            default   : true\n        },\n        spaceclose     : {\n            type      : "boolean",\n            definition: "Markup self-closing tags end will end with \' />\' instead of \'/>\'.",\n            default   : false\n        },\n        style          : {\n            type      : "string",\n            definition: "If mode is \'beautify\' and lang is \'markup\' or \'html\' this will determine wheth" +\n                    "er the contents of script and style tags should always start at position 0 of " +\n                    "each line or if such content should be indented starting from the opening scri" +\n                    "pt or style tag.",\n            values    : [\n                "indent", "noindent"\n            ],\n            default   : "indent"\n        },\n        styleguide     : {\n            type      : "string",\n            definition: "Provides a collection of option presets to easily conform to popular JavaScrip" +\n                    "t style guides.",\n            values    : [\n                "airbnb",\n                "crockford",\n                "google",\n                "grunt",\n                "jquery",\n                "jslint",\n                "mediawiki",\n                "meteor",\n                "yandex",\n                "none"\n            ],\n            default   : "none"\n        },\n        summaryonly    : {\n            type      : "boolean",\n            definition: "Node only option to output only number of differences.",\n            default   : false\n        },\n        tagmerge       : {\n            type      : "boolean",\n            definition: "Allows immediately adjacement start and end markup tags of the same name to be" +\n                    " combined into a single self-closing tag.",\n            default   : false\n        },\n        tagsort        : {\n            type      : "boolean",\n            definition: "Sort child items of each respective markup parent element.",\n            default   : false\n        },\n        textpreserve   : {\n            type      : "boolean",\n            definition: "If text in the provided markup code should be preserved exactly as provided. T" +\n                    "his option eliminates beautification and wrapping of text content.",\n            default   : false\n        },\n        ternaryline    : {\n            type      : "boolean",\n            definition: "If ternary operators in JavaScript (? and :) should remain on the same line.",\n            default   : false\n        },\n        titanium       : {\n            type      : "boolean",\n            definition: "Forces the JavaScript parser to parse Titanium Style Sheets instead of JavaScr" +\n                    "ipt.",\n            default   : false\n        },\n        topcoms        : {\n            type      : "boolean",\n            definition: "If mode is \'minify\' this determines whether comments above the first line of c" +\n                    "ode should be kept.",\n            default   : false\n        },\n        twig           : {\n            type      : "boolean",\n            definition: "If markuppretty is passing twig tag data to jspretty.",\n            default   : false\n        },\n        typescript     : {\n            type      : "boolean",\n            definition: "Identifies certain edge cases where TypeScript is in conflict with React JSX r" +\n                    "egarding type generics",\n            default   : false\n        },\n        unformatted    : {\n            type      : "boolean",\n            definition: "If markup tags should have their insides preserved.",\n            default   : false\n        },\n        varword        : {\n            type      : "string",\n            definition: "If consecutive JavaScript variables should be merged into a comma separated li" +\n                    "st or if variables in a list should be separated.",\n            values    : [\n                "each", "list", "none"\n            ],\n            default   : "none"\n        },\n        version        : {\n            type      : "boolean",\n            definition: "A Node.js only option to write the version information to the console.",\n            default   : false\n        },\n        vertical       : {\n            type      : "string",\n            definition: "If lists of assignments and properties should be vertically aligned.",\n            values    : [\n                "all", "css", "js", "none"\n            ],\n            default   : "none"\n        },\n        wrap           : {\n            type      : "number",\n            definition: "How many characters long text content in markup or strings in JavaScript can b" +\n                    "e before wrapping. A value of 0 turns this feature off. A value of -1 will con" +\n                    "catenate strings in JavaScript if separated by a \'+\' operator.",\n            default   : 0\n        }\n    };\n    options.functions.default       = function options_default() {\n        var keys     = Object.keys(options.functions.definitions),\n            populate = function options_default_populate(name) {\n                if (name !== "api" && name !== "diff" && name !== "output" && name !== "source" && name !== "nodeasync" && (options.functions.nodeArgs === undefined || options.functions.nodeArgs[name] === undefined)) {\n                    options[name] = options\n                        .functions\n                        .definitions[name]\n                        .default;\n                }\n            };\n        keys.forEach(populate);\n    };\n    options.functions.versionString = function options__versionString() {\n        var dstring = "",\n            mstring = 0,\n            month   = [\n                "January",\n                "February",\n                "March",\n                "April",\n                "May",\n                "June",\n                "July",\n                "August",\n                "September",\n                "October",\n                "November",\n                "December"\n            ];\n        if (global.prettydiff.edition === undefined) {\n            return "";\n        }\n        dstring = global\n            .prettydiff\n            .edition\n            .latest\n            .toString();\n        mstring = Number(dstring.slice(2, 4)) - 1;\n        return "\\u001B[36mVersion\\u001B[39m: " + global.prettydiff.edition.version + " " +\n                "\\u001B[36mDated\\u001B[39m: " + dstring.slice(4, 6) + " " + month[mstring] + " " +\n                "20" + dstring.slice(0, 2);\n    };\n    options.functions.consolePrint  = function options_consolePrint() {\n        var list      = Object.keys(options.functions.definitions),\n            a         = 0,\n            b         = 0,\n            longest   = 0,\n            len       = list.length,\n            def       = "",\n            name      = "",\n            type      = "",\n            vlist     = [],\n            names     = [],\n            vals      = [],\n            lf        = (options.crlf === true)\n                ? "\\r\\n"\n                : "\\n",\n            limit     = (options.help === undefined)\n                ? 78\n                : options.help - 2,\n            namecolor = function options_colorPrint_namecolor(item) {\n                return "  * \\"\\u001B[32m" + item.replace("  * \\"", "") + "\\u001B[39m";\n            },\n            vertical  = function options_consolePrint_vertical(items) {\n                var mostest  = 0,\n                    x        = 0,\n                    y        = 0,\n                    leng     = items.length,\n                    newitems = [];\n                for (x = 0; x < leng; x = x + 1) {\n                    if (items[x].length > mostest) {\n                        mostest = items[x].length;\n                    }\n                }\n                for (x = 0; x < leng; x = x + 1) {\n                    y = items[x].length;\n                    newitems.push(items[x]);\n                    if (y < mostest) {\n                        do {\n                            y           = y + 1;\n                            newitems[x] = newitems[x] + " ";\n                        } while (y < mostest);\n                    }\n                }\n                return [newitems, mostest];\n            },\n            wrap      = function options_consolePrint_wrap(values) {\n                var start   = true,\n                    wrapper = [],\n                    wrappit = function options_consolePrint_wrap_wrappit() {\n                        var indent = (values === true && start === false)\n                                ? "     "\n                                : "  ",\n                            c      = limit - indent.length;\n                        name = name.replace(/^(\\s+)/, "");\n                        if (name.length < c) {\n                            wrapper.push(indent + name);\n                            name = "";\n                            return;\n                        }\n                        if (name.charAt(c) !== " " || name.charAt(c - 1) === " ") {\n                            do {\n                                c = c - 1;\n                            } while (c > 0 && (name.charAt(c) !== " " || name.charAt(c - 1) === " "));\n                        }\n                        if (c === 0) {\n                            wrapper.push(indent + name);\n                            name = "";\n                            return;\n                        }\n                        wrapper.push(indent + name.slice(0, c));\n                        name = name.slice(c);\n                    };\n                do {\n                    wrappit();\n                    start = false;\n                } while (name.length > 0);\n                if (options.crlf === true) {\n                    return wrapper.join("\\r\\n");\n                }\n                return wrapper.join("\\n");\n            },\n            output    = ["", "\\u001B[1mOptions\\u001B[22m"];\n        names   = vertical(list);\n        longest = names[1];\n        names   = names[0];\n        name    = "  Name";\n        b       = name.length;\n        if (b < longest) {\n            do {\n                b    = b + 1;\n                name = name + " ";\n            } while (b < longest);\n        }\n        name = name + "   - Type    - Default";\n        output.push("");\n        output.push(name);\n        b    = 0;\n        name = "";\n        do {\n            b    = b + 1;\n            name = name + "-";\n        } while (b < limit + 2);\n        output.push(name);\n        for (a = 0; a < len; a = a + 1) {\n            name = "* \\u001B[32m" + names[a] + "\\u001B[39m";\n            type = options\n                .functions\n                .definitions[list[a]]\n                .type;\n            if (type === "string") {\n                type = "\\u001B[33m" + type + "\\u001B[39m ";\n                def  = options\n                    .functions\n                    .definitions[list[a]]\n                    .default;\n                if (def === " ") {\n                    def = "(space)";\n                } else if (def === "") {\n                    def = "(empty string)";\n                } else {\n                    def = "\\"" + def + "\\"";\n                }\n            } else if (type === "number") {\n                type = "\\u001B[36m" + type + "\\u001B[39m ";\n                def  = options\n                    .functions\n                    .definitions[list[a]]\n                    .default\n                    .toString();\n            } else {\n                type = "\\u001B[35m" + type + "\\u001B[39m";\n                def  = options\n                    .functions\n                    .definitions[list[a]]\n                    .default\n                    .toString();\n            }\n            name = name + " - " + type + " - " + def;\n            output.push(name);\n            name = options\n                .functions\n                .definitions[list[a]]\n                .definition;\n            if (name.length < limit) {\n                output.push("  " + name);\n            } else {\n                output.push(wrap(false));\n            }\n            vlist = options\n                .functions\n                .definitions[list[a]]\n                .values;\n            if (vlist !== undefined) {\n                if (typeof vlist.length === "number") {\n                    name = "Accepted values: \\"" + vlist\n                        .toString()\n                        .replace(/,/g, "\\", \\"") + "\\"";\n                    name = "\\u001B[31m" + wrap(false);\n                    name = name.replace(\n                        "Accepted values: \\"",\n                        "Accepted values:\\u001B[39m \\"\\u001B[32m"\n                    );\n                    name = name.replace(/,\\u0020"/g, ", \\"\\u001B[32m");\n                    name = name.replace(/",/g, "\\u001B[39m\\",");\n                    output.push(name);\n                } else {\n                    output.push("  \\u001B[31mAccepted values:\\u001B[39m");\n                    vlist = Object.keys(options.functions.definitions[list[a]].values);\n                    vals  = vertical(vlist)[0];\n                    b     = 0;\n                    do {\n                        vals[b] = vals[b] + " ";\n                        name    = "  * \\"" + vals[b].replace(" ", "\\"") + " - " + options\n                            .functions\n                            .definitions[list[a]]\n                            .values[vlist[b]];\n                        name    = wrap(true);\n                        name    = name.replace(/\\u0020\\u0020\\*\\u0020"\\w+/, namecolor);\n                        output.push(name);\n                        b = b + 1;\n                    } while (b < vlist.length);\n                }\n            }\n            output.push("");\n        }\n        if (options.api === "node") {\n            output.push("\\u001B[1mUsage\\u001B[22m");\n            output.push(\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32moption1:\\u001B[39m\\u001B[" +\n                "33m\\"value\\"\\u001B[39m \\u001B[32moption2:\\u001B[39m\\u001B[33m\\"value\\"\\u001B[3" +\n                "9m ..."\n            );\n            output.push(\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32msource:\\u001B[39m\\u001B[3" +\n                "3m\\"myApplication.js\\"\\u001B[39m \\u001B[32mreadmethod:\\u001B[39m\\u001B[33m\\"fi" +\n                "lescreen\\"\\u001B[39m \\u001B[32mmode:\\u001B[39m\\u001B[33m\\"beautify\\"\\u001B[39m"\n            );\n            output.push(\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32msource:\\u001B[39m\\u001B[3" +\n                "3m\\"old_directory\\"\\u001B[39m \\u001B[32mdiff:\\u001B[39m\\u001B[33m\\"new_directo" +\n                "ry\\"\\u001B[39m \\u001B[32mreadmethod:\\u001B[39m\\u001B[33m\\"subdirectory\\"\\u001B" +\n                "[39m"\n            );\n            output.push(\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32mhelp\\u001B[39m:80     to " +\n                "see this help message, the number value sets word wrap"\n            );\n            output.push(\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32mversion\\u001B[39m     to " +\n                "see only the version line"\n            );\n            output.push(\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32mlist\\u001B[39m        to " +\n                "see the current settings"\n            );\n            output.push("");\n            output.push(options.functions.versionString());\n            output.push("");\n            return output.join(lf);\n        }\n        output.push("");\n        output.push(options.functions.versionString());\n        output.push("");\n        return output\n            .join(lf)\n            .replace(/\\u001b\\[\\d+m/g, "");\n    };\n    options.functions.pdcomment     = function options_pdcomment() {\n        var comment    = options.source,\n            type       = "source",\n            a          = 0,\n            b          = options.source.length,\n            strl       = 0,\n            strm       = "",\n            c          = -1,\n            build      = [],\n            comma      = -1,\n            g          = 0,\n            sourceChar = [],\n            quote      = "",\n            sind       = -1,\n            dind       = -1,\n            ss         = null,\n            sd         = null;\n        ss = options\n            .source\n            .match(/\\/\\*\\s*prettydiff.com/);\n        sd = options\n            .diff\n            .match(/\\/\\*\\s*prettydiff.com/);\n        if (ss === null) {\n            ss = options\n                .source\n                .match(/<\\!--+\\s*prettydiff.com/);\n            if (ss !== null) {\n                strm = ss[0];\n                strl = strm.length;\n                sind = options\n                    .source\n                    .indexOf(strm);\n                c    = sind + strl;\n            }\n        } else {\n            strm = ss[0];\n            strl = strm.length;\n            sind = options\n                .source\n                .indexOf(strm);\n            c    = sind + strl;\n        }\n        if (c < 0) {\n            if (sd === null) {\n                sd = options\n                    .diff\n                    .match(/<\\!--+\\s*prettydiff.com/);\n                if (sd !== null) {\n                    strm    = sd[0];\n                    strl    = strm.length;\n                    dind    = options\n                        .diff\n                        .indexOf(strm);\n                    c       = dind + strl;\n                    comment = options.diff;\n                    type    = "diff";\n                }\n            } else {\n                strm    = sd[0];\n                strl    = strm.length;\n                dind    = options\n                    .diff\n                    .indexOf(strm);\n                c       = dind + strl;\n                comment = options.diff;\n                type    = "diff";\n            }\n        }\n        if (c < 0) {\n            return;\n        }\n        if ((options.source.charAt(c - (strl + 1)) === "\\"" && options.source.charAt(c) === "\\"") || (sind < 0 && dind < 0)) {\n            return;\n        }\n        if (type === "source" && (/^(\\s*\\{\\s*"token"\\s*:\\s*\\[)/).test(options.source) === true && (/\\],\\s*"types"\\s*:\\s*\\[/).test(options.source) === true) {\n            return;\n        }\n        if (type === "diff" && (/^(\\s*\\{\\s*"token"\\s*:\\s*\\[)/).test(options.diff) === true && (/\\],\\s*"types"\\s*:\\s*\\[/).test(options.diff) === true) {\n            return;\n        }\n        for (c = c; c < b; c = c + 1) {\n            if (quote === "") {\n                if (comment.charAt(c) === "\\"" || comment.charAt(c) === "\'") {\n                    quote = comment.charAt(c);\n                    if (comment.charAt(c + 1) === " " && sourceChar[sourceChar.length - 1] === ":") {\n                        sourceChar.push("\\\\ ");\n                        c = c + 1;\n                    }\n                } else {\n                    if (comment.charAt(c) === "*" && comment.charAt(c + 1) === "/" && strm.slice(0, 2) === "/*") {\n                        break;\n                    }\n                    if (comment.charAt(c) === "-" && comment.charAt(c + 1) === "-" && comment.charAt(\n                        c + 2\n                    ) === ">" && strm.slice(0, 4) === "\x3c!--") {\n                        break;\n                    }\n                    if (sourceChar[sourceChar.length - 1] !== ":" || (sourceChar[sourceChar.length - 1] === ":" && comment.charAt(c) !== " ")) {\n                        sourceChar.push(comment.charAt(c));\n                    }\n                }\n            } else if (comment.charAt(c) === quote) {\n                quote = "";\n            }\n        }\n        comment = sourceChar.join("");\n        b       = comment.length;\n        for (c = 0; c < b; c = c + 1) {\n            if ((typeof comment.charAt(c - 1) !== "string" || comment.charAt(c - 1) !== "\\\\") && (comment.charAt(c) === "\\"" || comment.charAt(c) === "\'")) {\n                if (quote === "") {\n                    quote = comment.charAt(c);\n                } else {\n                    quote = "";\n                }\n            }\n            if (quote === "") {\n                if (comment.charAt(c) === ",") {\n                    g     = comma + 1;\n                    comma = c;\n                    if ((/(\\:\\\\\\s+)$/).test(comment.slice(g, comma)) === true) {\n                        build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/:\\\\/, ":"));\n                    } else {\n                        build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/(\\s*)$/, ""));\n                    }\n                }\n            }\n        }\n        g     = comma + 1;\n        comma = comment.length;\n        if ((/(\\:\\\\\\s+)$/).test(comment.slice(g, comma)) === true) {\n            build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/:\\\\/, ":"));\n        } else {\n            build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/(\\s*)$/, ""));\n        }\n        quote      = "";\n        b          = build.length;\n        sourceChar = [];\n        for (c = 0; c < b; c = c + 1) {\n            a = build[c].length;\n            for (g = 0; g < a; g = g + 1) {\n                if (build[c].indexOf(":") === -1) {\n                    build[c] = "";\n                    break;\n                }\n                sourceChar = [];\n                if ((typeof build[c].charAt(g - 1) !== "string" || build[c].charAt(g - 1) !== "\\\\") && (build[c].charAt(g) === "\\"" || build[c].charAt(g) === "\'")) {\n                    if (quote === "") {\n                        quote = build[c].charAt(g);\n                    } else {\n                        quote = "";\n                    }\n                }\n                if (quote === "") {\n                    if (build[c].charAt(g) === ":") {\n                        sourceChar.push(build[c].substring(0, g).replace(/(\\s*)$/, ""));\n                        sourceChar.push(build[c].substring(g + 1));\n                        if (sourceChar[1].charAt(0) === sourceChar[1].charAt(sourceChar[1].length - 1) && sourceChar[1].charAt(sourceChar[1].length - 2) !== "\\\\" && (sourceChar[1].charAt(0) === "\\"" || sourceChar[1].charAt(0) === "\'")) {\n                            sourceChar[1] = sourceChar[1].substring(1, sourceChar[1].length - 1);\n                        }\n                        build[c] = sourceChar;\n                        break;\n                    }\n                }\n            }\n        }\n        for (c = 0; c < b; c = c + 1) {\n            if (typeof build[c][1] === "string") {\n                build[c][0] = build[c][0].replace("api.", "");\n                if (build[c][0] === "brace_style") {\n                    if (build[c][1] === "collapse" || build[c][1] === "collapse-preserve-inline" || build[c][1] === "expand" || build[c][1] === "none") {\n                        options.brace_style = build[c][1];\n                    }\n                }\n                if (build[c][0] === "braces" || build[c][0] === "indent") {\n                    if (build[c][1] === "knr" || build[c][1] === "allman") {\n                        options.braces = build[c][1];\n                    }\n                } else if (build[c][0] === "color") {\n                    if (typeof b[c][1] === "string" && b[c][1] !== "") {\n                        options.color = b[c][1];\n                    }\n                } else if (build[c][0] === "comments") {\n                    if (build[c][1] === "indent" || build[c][1] === "noindent") {\n                        options.comments = "noindent";\n                    }\n                } else if (build[c][0] === "diffview") {\n                    if (build[c][1] === "sidebyside" || build[c][1] === "inline") {\n                        options.diffview = build[c][1];\n                    }\n                } else if (build[c][0] === "endcomma") {\n                    if (build[c][1] === "true" || build[c][1] === "always") {\n                        options.endcomma = "always";\n                    } else if (build[c][1] === "false" || build[c][1] === "never") {\n                        options.endcomma = "never";\n                    } else if (build[c][1] === "multiline") {\n                        options.endcomma = "multiline";\n                    }\n                } else if (build[c][0] === "formatArray" || build[c][0] === "formatObject") {\n                    if (build[c][1] === "default" || build[c][1] === "indent" || build[c][1] === "inline") {\n                        options[build[c][0]] = build[c][1];\n                    }\n                } else if (build[c][0] === "jsscope") {\n                    if (build[c][1] === "html" || build[c][1] === "none" || build[c][1] === "report") {\n                        options.jsscope = build[c][1];\n                    }\n                } else if (build[c][0] === "lang" || build[c][0] === "langdefault") {\n                    options[build[c][0]] = global\n                        .prettydiff\n                        .language\n                        .setlangmode(build[c][1]);\n                } else if (build[c][0] === "mode") {\n                    if (build[c][1] === "beautify" || build[c][1] === "minify" || build[c][1] === "diff" || build[c][1] === "parse" || build[c][1] === "analysis") {\n                        options.mode = build[c][1];\n                    }\n                } else if (build[c][0] === "objsort") {\n                    if (build[c][1] === "all" || build[c][1] === "js" || build[c][1] === "css" || build[c][1] === "markup" || build[c][1] === "none" || build[c][1] === "true" || build[c][1] === "false") {\n                        options.objsort = build[c][1];\n                    }\n                } else if (build[c][0] === "parseFormat") {\n                    if (build[c][1] === "htmltable" || build[c][1] === "parallel" || build[c][1] === "sequential") {\n                        options.parseFormat = build[c][1];\n                    }\n                } else if (build[c][0] === "quoteConvert") {\n                    if (build[c][1] === "single" || build[c][1] === "double" || build[c][1] === "none") {\n                        options.quoteConvert = build[c][1];\n                    }\n                } else if (build[c][0] === "style") {\n                    if (build[c][1] === "indent" || build[c][1] === "noindent") {\n                        options.style = build[c][1];\n                    }\n                } else if (build[c][0] === "typescript" && build[c][1] === "true") {\n                    options.typescript = true;\n                    options.lang       = "typescript";\n                } else if (build[c][0] === "varword") {\n                    if (build[c][1] === "each" || build[c][1] === "list" || build[c][1] === "none") {\n                        options.varword = build[c][1];\n                    }\n                } else if (build[c][0] === "vertical") {\n                    if (build[c][1] === "all" || build[c][1] === "css" || build[c][1] === "js" || build[c][1] === "none") {\n                        options.vertical = build[c][1];\n                    }\n                } else if (options[build[c][0]] !== undefined && options[build[c][1]] !== "") {\n                    if (build[c][1] === "true") {\n                        options[build[c][0]] = true;\n                    } else if (build[c][1] === "false") {\n                        options[build[c][0]] = false;\n                    } else if (isNaN(build[c][1]) === false && (/\\s+/).test(build[c][1]) === false) {\n                        options[build[c][0]] = Number(build[c][1]);\n                    } else {\n                        if (options.functions.definitions[build[c][0]].type === "string") {\n                            options[build[c][0]] = build[c][1];\n                        } else {\n                            options[build[c][0]] = options\n                                .functions\n                                .definitions[build[c][0]]\n                                .default;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    options.functions.validate      = function options_validate(api) {\n        var braceEscape = function diffview__options_braceEscape(input) {\n            return input\n                .replace(/&/g, "&amp;")\n                .replace(/</g, "&lt;")\n                .replace(/>/g, "&gt;");\n        };\n        if (options.api !== "dom") {\n            options\n                .functions\n                .default();\n        }\n        // apacheVelocity - provides support for Apache Velocity markup templates\n        options.apacheVelocity  = (\n            api.apacheVelocity === true || api.apacheVelocity === "true"\n        );\n        // determines api source as necessary to make a decision about whether to supply\n        // externally needed JS functions to reports\n        options.api             = (api.api === undefined || api.api.length === 0)\n            ? "node"\n            : api.api;\n        // attributetoken - whether attributes should be represented as token items in\n        // the parse table or whether they should be a data properties of their element\n        options.attributetoken  = (\n            api.attributetoken === true || api.attributetoken === "true"\n        );\n        // brace-style - provided to emulate JSBeautify\'s brace-style option\n        options.brace_style     = (\n            api.brace_style === "collapse" || api.brace_style === "collapse-preserve-inline" || api.brace_style === "expand"\n        )\n            ? api.brace_style\n            : "none";\n        // braceline - should a new line pad the interior of blocks (curly braces) in\n        // JavaScript\n        options.braceline       = (api.braceline === true || api.braceline === "true");\n        //bracepadding - should curly braces be padded with a space in JavaScript?\n        options.bracepadding    = (\n            api.bracepadding === true || api.bracepadding === "true"\n        );\n        // indent - should JSPretty format JavaScript in the normal KNR style or push\n        // curly braces onto a separate line like the "allman" style\n        options.braces          = (\n            api.braces === true || api.braces === "true" || api.braces === "allman"\n        )\n            ? "allman"\n            : "knr";\n        //color scheme of generated HTML artifacts\n        options.color           = (api.color === "canvas" || api.color === "shadow")\n            ? api.color\n            : "white";\n        //comments - if comments should receive indentation or not\n        options.comments        = (api.comments === "noindent")\n            ? "noindent"\n            : ((api.comments === "nocomment")\n                ? "nocomment"\n                : "indent");\n        //commline - If in markup a newline should be forced above comments\n        options.commline        = (api.commline === true || api.commline === "true");\n        // compressedcss - If the beautified CSS should contain minified properties\n        options.compressedcss   = (\n            api.compressedcss === true || api.compressedcss === "true"\n        );\n        // conditional - should IE conditional comments be preserved during markup\n        // minification\n        options.conditional     = (\n            api.conditional === true || api.conditional === "true" || api.html === true\n        );\n        //content - should content be normalized during a diff operation\n        options.content         = (api.content === true || api.content === "true");\n        // context - should the diff report only include the differences, if so then\n        // buffered by how many lines of code\n        options.context         = (\n            isNaN(api.context) === true || api.context === "" || Number(api.context) < 0\n        )\n            ? -1\n            : Number(api.context);\n        //correct - should JSPretty make some corrections for sloppy JS\n        options.correct         = (api.correct === true || api.correct === "true");\n        //crlf - if output should use \\r\\n (Windows compatible) for line termination\n        options.crlf            = (api.crlf === true || api.crlf === "true");\n        //cssinsertlines = if a new line should be forced between each css block\n        options.cssinsertlines = (\n            api.cssinsertlines === true || api.cssinsertlines === "true"\n        );\n        //csvchar - what character should be used as a separator\n        options.csvchar         = (typeof api.csvchar === "string" && api.csvchar.length > 0)\n            ? api.csvchar\n            : ",";\n        //diff - source code to compare with\n        options.diff            = (\n            typeof api.diff === "string" && api.diff.length > 0 && (/^(\\s+)$/).test(api.diff) === false\n        )\n            ? api.diff\n            : "";\n        // diffcli - if operating from Node.js and set to true diff output will be\n        // printed to stdout just like git diff\n        options.diffcli         = (api.diffcli === true || api.diffcli === "true");\n        //diffcomments - should comments be included in the diff operation\n        options.diffcomments    = (\n            api.diffcomments === true || api.diffcomments === "true"\n        );\n        //difflabel - a text label to describe the diff code\n        options.difflabel       = (\n            typeof api.difflabel === "string" && api.difflabel.length > 0\n        )\n            ? braceEscape(api.difflabel)\n            : "New Sample";\n        // diffspaceignore - If white space differences should be ignored by the diff\n        // tool\n        options.diffspaceignore = (\n            api.diffspaceignore === true || api.diffspaceignore === "true"\n        );\n        // diffview - should the diff report be a single column showing both sources\n        // simultaneously "inline" or showing the sources in separate columns\n        // "sidebyside"\n        options.diffview        = (api.diffview === "inline")\n            ? "inline"\n            : "sidebyside";\n        //dustjs - support for this specific templating scheme\n        options.dustjs          = (api.dustjs === true || api.dustjs === "true");\n        //elseline - for the \'else\' keyword onto a new line in JavaScript\n        options.elseline        = (api.elseline === true || api.elseline === "true");\n        // endcomma - if a trailing comma should be injected at the end of arrays and\n        // object literals in JavaScript\n        options.endcomma        = (\n            api.endcomma === true || api.endcomma === "true" || api.endcomma === "always"\n        )\n            ? "always"\n            : (api.endcomma === "multiline")\n                ? "multiline"\n                : "never";\n        // endquietly - a node only option to prevent writing anything to console as\n        // stdout\n        options.endquietly      = (api.endquietly === "log" || api.endquietly === "quiet")\n            ? api.endquietly\n            : "";\n        // force_attribute - forces indentation of all markup attriubtes\n        options.force_attribute = (\n            api.force_attribute === true || api.force_attribute === "true"\n        );\n        // force_indent - should markup beautification always force indentation even if\n        // disruptive\n        options.force_indent    = (\n            api.force_indent === true || api.force_indent === "true"\n        );\n        // formatArray - defines whether JavaScript array keys should be indented or\n        // kept on a single line\n        options.formatArray     = (\n            api.formatArray === "indent" || api.formatArray === "inline"\n        )\n            ? api.formatArray\n            : "default";\n        // formatObject - defines whether JavaScript object properties should be\n        // indented or kept on a single line\n        options.formatObject    = (\n            api.formatObject === "indent" || api.formatObject === "inline"\n        )\n            ? api.formatObject\n            : "default";\n        // functionname - if a space should occur between a function name and its\n        // arguments paren\n        options.functionname    = (\n            api.functionname === true || api.functionname === "true"\n        );\n        options.help            = (isNaN(api.help) === true || api.help === "")\n            ? 80\n            : Number(api.help);\n        // html - should markup be presumed to be HTML with all the aloppiness HTML\n        // allows\n        options.html            = (\n            api.html === true || api.html === "true" || api.html === "html-yes"\n        );\n        //inchar - what character(s) should be used to create a single identation\n        options.inchar          = (typeof api.inchar === "string" && api.inchar.length > 0)\n            ? api\n                .inchar\n                .replace(/\\\\t/g, "\\u0009")\n                .replace(/\\\\n/g, "\\u000a")\n                .replace(/\\\\r/g, "\\u000d")\n                .replace(/\\\\f/g, "\\u000c")\n                .replace(/\\\\b/g, "\\u0008")\n            : " ";\n        // inlevel - should indentation in JSPretty be buffered with additional\n        // indentation?  Useful when supplying code to sites accepting markdown\n        options.inlevel         = (\n            isNaN(api.inlevel) === true || api.inlevel === "" || Number(api.inlevel) < 1\n        )\n            ? 0\n            : Number(api.inlevel);\n        // insize - how many characters from api.inchar should constitute a single\n        // indentation\n        options.insize          = (isNaN(api.insize) === true || api.insize === "")\n            ? 4\n            : Number(api.insize);\n        // jekyll - If the delimiter "---" should be used to create comments in markup.\n        options.jekyll          = (api.jekyll === true || api.jekyll === "true");\n        // jsscope - do you want to enable the jsscope feature of JSPretty?  This\n        // feature will output formatted HTML instead of text code showing which\n        // variables are declared at which functional depth\n        options.jsscope         = (\n            api.jsscope === true || api.jsscope === "true" || api.jsscope === "report"\n        )\n            ? "report"\n            : (api.jsscope === "html")\n                ? "html"\n                : "none";\n        // jsx - an internal option that is tripped to true when JSX code is\n        // encountered.  This option allows the markuppretty and jspretty parsers know\n        // to recursively hand off to each other.\n        options.jsx             = false;\n        //lang - which programming language will we be analyzing\n        options.lang            = (typeof api.lang === "string" && api.lang !== "auto")\n            ? global\n                .prettydiff\n                .language\n                .setlangmode(api.lang.toLowerCase())\n            : "auto";\n        // langdefault - what language should lang value "auto" resort to when it cannot\n        // determine the language\n        options.langdefault     = (typeof api.langdefault === "string")\n            ? global\n                .prettydiff\n                .language\n                .setlangmode(api.langdefault.toLowerCase())\n            : "text";\n        // listoptions - a node only option to output the current options object to the\n        // console\n        options.listoptions     = (\n            api.listoptions === true || api.listoptions === "true" || api.listoptions === "l" || api.listoptions === "list"\n        );\n        // methodchain - if JavaScript method chains should be strung onto a single line\n        // instead of indented\n        options.methodchain     = (\n            api.methodchain === true || api.methodchain === "true" || api.methodchain === "chain"\n        )\n            ? "chain"\n            : (api.methodchain === "none")\n                ? "none"\n                : "indent";\n        // miniwrap - when language is JavaScript and mode is \'minify\' if option \'jwrap\'\n        // should be applied to all code\n        options.miniwrap        = (api.miniwrap === true || api.miniwrap === "true");\n        //mode - is this a minify, beautify, or diff operation\n        options.mode            = (\n            api.mode === "minify" || api.mode === "beautify" || api.mode === "parse" || api.mode === "analysis"\n        )\n            ? api.mode\n            : "diff";\n        //newline - Insert an empty line at the end of output.\n        options.newline         = (\n            api.newline === true || api.newline === "true"\n        );\n        //neverflatten - prevent flattening of destructured lists in JavaScript\n        options.neverflatten    = (\n            api.neverflatten === true || api.neverflatten === "true"\n        );\n        //nocaseindent - if a \'case\' should be indented to its parent \'switch\'\n        options.nocaseindent    = (\n            api.nocaseindent === true || api.nocaseindent === "true"\n        );\n        // nochainindent - prevent indentation when JavaScript chains of methods are\n        // broken onto multiple lines\n        options.nochainindent   = (\n            api.nochainindent === true || api.nochainindent === "true"\n        );\n        // nodeasync - meta data has to be passed in the output for bulk async\n        // operations otherwise there is cross-talk, which means prettydiff has to\n        // return an array of [data, meta] instead of a single string\n        options.nodeasync       = (api.nodeasync === true || api.nodeasync === "true");\n        // nodeerror - nodeonly rule about whether parse errors should be logged to the\n        // console\n        options.nodeerror       = (api.nodeerror === true || api.nodeerror === "true");\n        // noleadzero - in CSS removes and prevents a run of 0s from appearing\n        // immediately before a value\'s decimal.\n        options.noleadzero      = (api.noleadzero === true || api.noleadzero === "true");\n        //objsort will alphabetize object keys in JavaScript\n        options.objsort         = (\n            api.objsort === "all" || api.objsort === "js" || api.objsort === "css" || api.objsort === "markup" || api.objsort === true || api.objsort === "true"\n        )\n            ? api.objsort\n            : "none";\n        // output - a node only option of where to write the output into the file system\n        options.output          = (\n            typeof api.output === "string" && api.output.length > 0 && (/^(\\s+)$/).test(api.output) === false\n        )\n            ? api.output\n            : "";\n        //parseFormat - determine how the parse tree should be organized and formatted\n        options.parseFormat     = (\n            api.parseFormat === "sequential" || api.parseFormat === "htmltable"\n        )\n            ? api.parseFormat\n            : "parallel";\n        // parseSpace - whether whitespace tokens between tags should be included in the\n        // parse tree output\n        options.parseSpace      = (api.parseSpace === true || api.parseSpace === "true");\n        //preserve - should empty lines be preserved in beautify operations of JSPretty?\n        options.preserve        = (function core__optionPreserve() {\n            if (api.preserve === 1 || api.preserve === undefined || api.preserve === true || api.preserve === "all" || api.preserve === "js" || api.preserve === "css") {\n                return 1;\n            }\n            if (api.preserve === false || api.preserve === "" || isNaN(api.preserve) === true || Number(api.preserve) < 1 || api.preserve === "none") {\n                return 0;\n            }\n            return Number(api.preserve);\n        }());\n        // preserveComment - prevent comment reformatting due to option wrap\n        options.preserveComment = (api.preserveComment === true || api.preserveComment === "true");\n        // qml - if the language is qml (beautified as JavaScript that looks like CSS)\n        options.qml             = (api.qml === true || api.qml === "true");\n        // quoteConvert - convert " to \' (or \' to ") of string literals or markup\n        // attributes\n        options.quoteConvert    = (\n            api.quoteConvert === "single" || api.quoteConvert === "double"\n        )\n            ? api.quoteConvert\n            : "none";\n        // readmethod - a node only option to determine scope of operations (how to\n        // proceeed with source and diff options as text or file system properties)\n        options.readmethod      = (\n            api.readmethod === "subdirectory" || api.readmethod === "directory" || api.readmethod === "file" || api.readmethod === "filescreen" || api.readmethod === "screen"\n        )\n            ? api.readmethod\n            : "auto";\n        //selectorlist - should comma separated CSS selector lists be on one line\n        options.selectorlist    = (\n            api.selectorlist === true || api.selectorlist === "true"\n        );\n        // semicolon - should trailing semicolons be removed during a diff operation to\n        // reduce the number of false positive comparisons\n        options.semicolon       = (api.semicolon === true || api.semicolon === "true");\n        // source - the source code in minify and beautify operations or "base" code in\n        // operations\n        options.source          = (\n            typeof api.source === "string" && api.source.length > 0 && (/^(\\s+)$/).test(api.source) === false\n        )\n            ? api.source\n            : "";\n        //sourcelabel - a text label to describe the api.source code for the diff report\n        options.sourcelabel     = (\n            typeof api.sourcelabel === "string" && api.sourcelabel.length > 0\n        )\n            ? braceEscape(api.sourcelabel)\n            : "Base Sample";\n        // space - should JSPretty include a space between a function keyword and the\n        // next adjacent opening parenthesis character in beautification operations\n        options.space           = (api.space !== false && api.space !== "false");\n        //spaceclose - If markup self-closing tags should end with " />" instead of "/>"\n        options.spaceclose      = (api.spaceclose === true || api.spaceclose === "true");\n        // style - should JavaScript and CSS code receive indentation if embedded inline\n        // in markup\n        options.style           = (api.style === "noindent")\n            ? "noindent"\n            : "indent";\n        // styleguide - preset of beautification options to bring a JavaScript sample\n        // closer to conformance of a given style guide\n        options.styleguide      = (typeof api.styleguide === "string")\n            ? api\n                .styleguide\n                .toLowerCase()\n                .replace(/\\s+/g, "")\n            : "none";\n        // summaryonly - node only option to output only the diff summary\n        options.summaryonly     = (api.summaryonly === true || api.summaryonly === "true");\n        // tagmerge - Allows combining immediately adjacent start and end tags of the\n        // same name into a single self-closing tag:  <a href="home"></a> into\n        // <a//href="home"/>\n        options.tagmerge = (api.tagmerge === true || api.tagmerge === "true");\n        //sort markup child nodes alphabetically\n        options.tagsort         = (api.tagsort === true || api.tagsort === "true");\n        // textpreserve - Force the markup beautifier to retain text (white space and\n        // all) exactly as provided.\n        options.ternaryline     = (api.ternaryline === true || api.ternaryline === "true");\n        options.textpreserve    = (\n            api.textpreserve === true || api.textpreserve === "true"\n        );\n        // titanium - TSS document support via option, because this is a uniquely\n        // modified form of JSON\n        options.titanium        = (api.titanium === true || api.titanium === "true");\n        // topcoms - should comments at the top of a JavaScript or CSS source be\n        // preserved during minify operations\n        options.topcoms         = (api.topcoms === true || api.topcoms === "true");\n        // twig - if markuppretty is passing twig tag data to jspretty\n        options.twig            = (api.twig === true || api.twig === "true");\n        options.typescript      = (api.typescript === true || api.typescript === "true");\n        // unformatted - if the internals of markup tags should be preserved\n        options.unformatted     = (api.unformatted === true || api.unformatted === "true");\n        // varword - should consecutive variables be merged into a comma separated list\n        // or the opposite\n        options.varword         = (api.varword === "each" || api.varword === "list")\n            ? api.varword\n            : "none";\n        // version - a node only option to output the version number to command line\n        options.version         = (\n            api.version === true || api.version === "true" || api.version === "version" || api.version === "v"\n        );\n        // vertical - whether or not to vertically align lists of assigns in CSS and\n        // JavaScript\n        options.vertical        = (\n            api.vertical === "all" || api.vertical === "css" || api.vertical === "js"\n        )\n            ? api.vertical\n            : "none";\n        // wrap - in markup beautification should text content wrap after the first\n        // complete word up to a certain character length\n        options.wrap            = (\n            isNaN(api.wrap) === true || api.wrap === "" || options.textpreserve === true\n        )\n            ? 0\n            : Number(api.wrap);\n        options.autoval         = ["", "", ""];\n        if (options.lang === "auto") {\n            options.autoval = global\n                .prettydiff\n                .language\n                .auto(options.source, options.langdefault);\n            options.lang    = options.autoval[1];\n        } else if (options.lang === "qml") {\n            options.qml  = true;\n            options.lang = "javascript";\n        } else if (options.lang === "velocity") {\n            options.apacheVelocity = true;\n            options.lang           = "markup";\n        } else if (options.api === "dom") {\n            options.autoval = [options.lang, options.lang, options.lang];\n        } else {\n            options.lang = global\n                .prettydiff\n                .language\n                .setlangmode(options.lang);\n        }\n        if (options.lang === "typescript") {\n            options.lang       = "javascript";\n            options.typescript = true;\n        }\n        if (options.apacheVelocity === true) {\n            if (options.mode === "minify") {\n                options.apacheVelocity = false;\n            } else {\n                options.lang = "markup";\n            }\n        }\n        if (options.qml === true) {\n            if (options.mode === "minify") {\n                options.qml = false;\n            } else {\n                options.lang = "javascript";\n            }\n        }\n        if (api.alphasort === true || api.alphasort === "true" || api.objsort === true || api.objsort === "true") {\n            options.objsort = "all";\n        }\n        if (api.indent === "allman") {\n            options.braces = "allman";\n        }\n        if (api.methodchain === true || api.methodchain === "true") {\n            options.methodchain = "chain";\n        } else if (api.methodchain === false || api.methodchain === "false") {\n            options.methodchain = "indent";\n        }\n        if (api.vertical === true || api.vertical === "true") {\n            options.vertical = "all";\n        } else if (api.vertical === "cssonly") {\n            options.vertical = "css";\n        } else if (api.vertical === "jsonly") {\n            options.vertical = "js";\n        }\n        if (options.autoval[0] === "dustjs") {\n            options.dustjs = true;\n        }\n        if (options.lang === "html") {\n            options.html = true;\n            options.lang = "markup";\n        } else if (options.lang === "tss" || options.lang === "titanium") {\n            options.titanium = true;\n            options.lang     = "javscript";\n        }\n        if (options.qml === true) {\n            options.correct = false;\n            options.jsx     = false;\n        }\n        if (options.mode !== "beautify" && options.mode !== "diff" && options.endcomma === "multiline") {\n            options.endcomma = "never";\n        }\n        if (options.mode === "minify") {\n            if (options.wrap < 1) {\n                options.miniwrap = false;\n            } else if (options.miniwrap === false) {\n                options.wrap = -1;\n            }\n            options.correct = true;\n        } else if (options.jsscope !== "none") {\n            if (options.mode !== "beautify") {\n                options.jsscope = "none";\n            } else {\n                // wrap is disabled for jsscope because it can break HTML character entities in\n                // strings, which is fine in JS, but breaks things when rendered in the browser.\n                options.wrap = 0;\n            }\n        }\n\n        // old diff api\n        if (typeof options.baseTextLines === "string") {\n            options.source = options\n                .baseTextLines\n                .replace(options.functions.binaryCheck, "")\n                .replace(/\\r\\n?/g, "\\n");\n        }\n        if (typeof options.baseTextName === "string") {\n            options.sourcelabel = braceEscape(options.baseTextName);\n        }\n        if (typeof options.newTextLines === "string") {\n            options.diff = options\n                .newTextLines\n                .replace(options.functions.binaryCheck, "")\n                .replace(/\\r\\n?/g, "\\n");\n        }\n        if (typeof options.newTextName === "string") {\n            options.difflabel = braceEscape(options.newTextName);\n        }\n        if ((/^([0-9]+)$/).test(options.contextSize) === true) {\n            options.context = Number(options.contextSize);\n        }\n        if (typeof options.tchar === "string") {\n            options.inchar = options.tchar;\n        }\n        if ((/^([0-9]+)$/).test(options.tsize) === true) {\n            options.insize = Number(options.tsize);\n        }\n        //end old diff api\n\n        options\n            .functions\n            .pdcomment();\n        return options;\n    };\n    options.functions.domops        = function options_domops(id, value, commentString) {\n        var a    = 0,\n            data = [];\n        if (id === "adustno" || id === "bdustno" || id === "ddustno" || id === "mdustno" || id === "pdustno") {\n            data = ["dustjs", "false"];\n        } else if (id === "adustyes" || id === "bdustyes" || id === "ddustyes" || id === "mdustyes" || id === "pdustyes") {\n            data = ["dustjs", "true"];\n        } else if (id === "ahtml-no" || id === "htmld-no" || id === "html-no" || id === "htmlm-no" || id === "phtml-no") {\n            data = ["html", "false"];\n        } else if (id === "ahtml-no" || id === "htmld-yes" || id === "html-yes" || id === "htmlm-yes" || id === "phtml-yes") {\n            data = ["html", "true"];\n        } else if (id === "ajekyll-no" || id === "bjekyll-no" || id === "djekyll-no" || id === "mjekyll-no" || id === "pjekyll-no") {\n            data = ["jekyll", "false"];\n        } else if (id === "ajekyll-yes" || id === "bjekyll-yes" || id === "djekyll-yes" || id === "mjekyll-yes" || id === "pjekyll-yes") {\n            data = ["jekyll", "true"];\n        } else if (id === "attributetoken-no") {\n            data = ["attributetoken", "false"];\n        } else if (id === "attributetoken-yes") {\n            data = ["attributetoken", "true"];\n        } else if (id === "baselabel") {\n            data = ["sourcelabel", value];\n        } else if (id === "bbracestyle-collapse" || id === "dbracestyle-collapse") {\n            data = ["brace_style", "collapse"];\n        } else if (id === "bbracestyle-expand" || id === "dbracestyle-expand") {\n            data = ["brace_style", "expand"];\n        } else if (id === "bbracestyle-inline" || id === "dbracestyle-inline") {\n            data = ["brace_style", "collapse-preserve-inline"];\n        } else if (id === "bbracestyle-none" || id === "dbracestyle-none") {\n            data = ["brace_style", "none"];\n        } else if (id === "bbraceline-no" || id === "dbraceline-no") {\n            data = ["braceline", "false"];\n        } else if (id === "bbraceline-yes" || id === "dbraceline-yes") {\n            data = ["braceline", "true"];\n        } else if (id === "bbracepadding-no" || id === "dbracepadding-no") {\n            data = ["bracepadding", "false"];\n        } else if (id === "bbracepadding-yes" || id === "dbracepadding-yes") {\n            data = ["bracepadding", "true"];\n        } else if (id === "bcommline-no") {\n            data = ["commline", "false"];\n        } else if (id === "bcommline-yes") {\n            data = ["commline", "true"];\n        } else if (id === "bcompressedcss-no" || id === "dcompressedcss-no") {\n            data = ["compressedcss", "false"];\n        } else if (id === "bcompressedcss-yes" || id === "dcompressedcss-yes") {\n            data = ["compressedcss", "true"];\n        } else if (id === "beau-wrap" || id === "diff-wrap" || id === "mini-wrap") {\n            data = ["wrap", value];\n        } else if (id === "bendcomma-always" || id === "dendcomma-always") {\n            data = ["endcomma", "always"];\n        } else if (id === "bendcomma-multiline" || id === "dendcomma-multiline") {\n            data = ["endcomma", "multiline"];\n        } else if (id === "bendcomma-never" || id === "dendcomma-never") {\n            data = ["endcomma", "never"];\n        } else if (id === "bforce_attribute-no" || id === "dforce_attribute-no") {\n            data = ["force_attribute", "false"];\n        } else if (id === "bforce_attribute-yes" || id === "dforce_attribute-yes") {\n            data = ["force_attribute", "true"];\n        } else if (id === "bforce_indent-no" || id === "dforce_indent-no") {\n            data = ["force_indent", "false"];\n        } else if (id === "bforce_indent-yes" || id === "dforce_indent-yes") {\n            data = ["force_indent", "true"];\n        } else if (id === "bformatarray-default" || id === "dformatarray-default") {\n            data = ["formatArray", "default"];\n        } else if (id === "bformatarray-indent" || id === "dformatarray-indent") {\n            data = ["formatArray", "indent"];\n        } else if (id === "bformatarray-inline" || id === "dformatarray-inline") {\n            data = ["formatArray", "inline"];\n        } else if (id === "bformatobject-default" || id === "dformatobject-default") {\n            data = ["formatObject", "default"];\n        } else if (id === "bformatobject-indent" || id === "dformatobject-indent") {\n            data = ["formatObject", "indent"];\n        } else if (id === "bformatobject-inline" || id === "dformatobject-inline") {\n            data = ["formatObject", "inline"];\n        } else if (id === "bfunctionname-no" || id === "dfunctionname-no") {\n            data = ["functionname", "false"];\n        } else if (id === "bfunctionname-yes" || id === "dfunctionname-yes") {\n            data = ["functionname", "true"];\n        } else if (id === "bpreserve" || id === "dpreserve") {\n            data = ["preserve", value];\n        } else if (id === "bpreserveComment-false" || id === "dpreserveComment-false") {\n            data = ["preserveComment", "false"];\n        } else if (id === "bpreserveComment-true" || id === "dpreserveComment-true") {\n            data = ["preserveComment", "true"];\n        } else if (id === "bmethodchain-chain" || id === "dmethodchain-chain") {\n            data = ["methodchain", "chain"];\n        } else if (id === "bmethodchain-indent" || id === "dmethodchain-indent") {\n            data = ["methodchain", "indent"];\n        } else if (id === "bmethodchain-none" || id === "dmethodchain-none") {\n            data = ["methodchain", "none"];\n        } else if (id === "bnocaseindent-no" || id === "dnocaseindent-no") {\n            data = ["nocaseindent", "false"];\n        } else if (id === "bnocaseindent-yes" || id === "dnocaseindent-yes") {\n            data = ["nocaseindent", "true"];\n        } else if (id === "bnochainindent-no" || id === "dnochainindent-no") {\n            data = ["nochainindent", "false"];\n        } else if (id === "bnochainindent-yes" || id === "dnochainindent-yes") {\n            data = ["nochainindent", "true"];\n        } else if (id === "bnoleadzero-no") {\n            data = ["noleadzero", "false"];\n        } else if (id === "bnoleadzero-yes") {\n            data = ["noleadzero", "true"];\n        } else if (id === "bobjsort-all" || id === "dobjsort-all" || id === "mobjsort-all" || id === "pobjsort-all") {\n            data = ["objsort", "all"];\n        } else if (id === "bobjsort-cssonly" || id === "dobjsort-cssonly" || id === "mobjsort-cssonly" || id === "pobjsort-cssonly") {\n            data = ["objsort", "css"];\n        } else if (id === "bobjsort-jsonly" || id === "dobjsort-jsonly" || id === "mobjsort-jsonly" || id === "pobjsort-jsonly") {\n            data = ["objsort", "js"];\n        } else if (id === "bobjsort-markuponly" || id === "dobjsort-markuponly" || id === "mobjsort-markuponly" || id === "pobjsort-markuponly") {\n            data = ["objsort", "markup"];\n        } else if (id === "bobjsort-none" || id === "dobjsort-none" || id === "mobjsort-none" || id === "pobjsort-none") {\n            data = ["objsort", "none"];\n        } else if (id === "bquoteconvert-double" || id === "mquoteconvert-double") {\n            data = ["quoteConvert", "double"];\n        } else if (id === "bquoteconvert-none" || id === "mquoteconvert-none") {\n            data = ["quoteConvert", "none"];\n        } else if (id === "bquoteconvert-single" || id === "mquoteconvert-single") {\n            data = ["quoteConvert", "single"];\n        } else if (id === "bselectorlist-no" || id === "dselectorlist-no") {\n            data = ["selectorlist", "false"];\n        } else if (id === "bselectorlist-yes" || id === "dselectorlist-yes") {\n            data = ["selectorlist", "true"];\n        } else if (id === "bspaceclose-no") {\n            data = ["spaceclose", "false"];\n        } else if (id === "bspaceclose-yes") {\n            data = ["spaceclose", "true"];\n        } else if (id === "bstyleguide") {\n            if (value === "") {\n                data = ["styleguide", ""];\n            } else {\n                data = ["styleguide", value];\n            }\n        } else if (id === "btagmerge-no" || id === "dtagmerge-no" || id === "mtagmerge-no" || id === "ptagmerge-no") {\n            data = ["tagmerge", "false"];\n        } else if (id === "btagmerge-yes" || id === "dtagmerge-yes" || id === "mtagmerge-yes" || id === "ptagmerge-yes") {\n            data = ["tagmerge", "true"];\n        } else if (id === "btagsort-no" || id === "dtagsort-no" || id === "mtagsort-no" || id === "ptagsort-no") {\n            data = ["tagsort", "false"];\n        } else if (id === "btagsort-yes" || id === "dtagsort-yes" || id === "mtagsort-yes" || id === "ptagsort-yes") {\n            data = ["tagsort", "true"];\n        } else if (id === "bternaryline-no" || id === "dternaryline-no") {\n            data = ["ternaryline", "false"];\n        } else if (id === "bternaryline-yes" || id === "dternaryline-yes") {\n            data = ["ternaryline", "true"];\n        } else if (id === "btextpreserveno" || id === "dtextpreserveno" || id === "mtextpreserveno" || id === "ptextpreserveno") {\n            data = ["textpreserve", "false"];\n        } else if (id === "btextpreserveyes" || id === "dtextpreserveyes" || id === "mtextpreserveyes" || id === "ptextpreserveyes") {\n            data = ["textpreserve", "true"];\n        } else if (id === "bunformatted-no" || id === "dunformatted-no" || id === "munformatted-no" || id === "punformatted-no") {\n            data = ["unformatted", "false"];\n        } else if (id === "bunformatted-yes" || id === "dunformatted-yes" || id === "munformatted-yes" || id === "punformatted-yes") {\n            data = ["unformatted", "true"];\n        } else if (id === "bvarword-each" || id === "dvarword-each" || id === "mvarword-each" || id === "pvarword-each") {\n            data = ["varword", "each"];\n        } else if (id === "bvarword-list" || id === "dvarword-list" || id === "mvarword-list" || id === "pvarword-list") {\n            data = ["varword", "list"];\n        } else if (id === "bvarword-none" || id === "dvarword-none" || id === "mvarword-none" || id === "pvarword-none") {\n            data = ["varword", "none"];\n        } else if (id === "conditionald-no" || id === "conditionalm-no") {\n            data = ["conditional", "false"];\n        } else if (id === "conditionald-yes" || id === "conditionalm-yes") {\n            data = ["conditional", "true"];\n        } else if (id === "contextSize") {\n            data = ["context", value];\n        } else if (id === "csvchar") {\n            data = ["csvchar", value];\n        } else if (id === "cssinsertlines-no") {\n            data = ["cssinsertlines", "false"];\n        } else if (id === "cssinsertlines-yes") {\n            data = ["cssinsertlines", "true"];\n        } else if (id === "diff-char" || id === "beau-char") {\n            data = ["inchar", value];\n        } else if (id === "diff-line" || id === "beau-line") {\n            data = ["inchar", "\\n"];\n        } else if (id === "diff-quan" || id === "beau-quan" || id === "minn-quan") {\n            data = ["insize", value];\n        } else if (id === "diff-space" || id === "beau-space") {\n            data = ["inchar", " "];\n        } else if (id === "diff-tab" || id === "beau-tab") {\n            data = ["inchar", "\\t"];\n        } else if (id === "diffcontent") {\n            data = ["content", "true"];\n        } else if (id === "diffcontenty") {\n            data = ["content", "false"];\n        } else if (id === "diffcli-false") {\n            data = ["diffcli", "false"];\n        } else if (id === "diffcli-true") {\n            data = ["diffcli", "true"];\n        } else if (id === "diffcommentsn") {\n            data = ["diffcomments", "false"];\n        } else if (id === "diffcommentsy") {\n            data = ["diffcomments", "true"];\n        } else if (id === "difflabel") {\n            data = ["difflabel", value];\n        } else if (id === "diffscolon") {\n            data = ["semicolon", "true"];\n        } else if (id === "diffscolony") {\n            data = ["semicolon", "false"];\n        } else if (id === "diffspaceignoren") {\n            data = ["diffspaceignore", "false"];\n        } else if (id === "diffspaceignorey") {\n            data = ["diffspaceignore", "true"];\n        } else if (id === "incomment-no") {\n            data = ["comments", "noindent"];\n        } else if (id === "incomment-yes") {\n            data = ["comments", "indent"];\n        } else if (id === "inline") {\n            data = ["diffview", "inline"];\n        } else if (id === "inlevel") {\n            data = ["inlevel", value];\n        } else if (id === "inscriptd-no" || id === "inscript-no") {\n            data = ["style", "noindent"];\n        } else if (id === "inscriptd-yes" || id === "inscript-yes") {\n            data = ["style", "indent"];\n        } else if (id === "jscorrect-no" || id === "mjscorrect-no") {\n            data = ["correct", "false"];\n        } else if (id === "jscorrect-yes" || id === "mjscorrect-yes") {\n            data = ["correct", "true"];\n        } else if (id === "jselseline-no") {\n            data = ["elseline", "false"];\n        } else if (id === "jselseline-yes") {\n            data = ["elseline", "true"];\n        } else if (id === "jsindentd-all" || id === "jsindent-all") {\n            data = ["indent", "allman"];\n        } else if (id === "jsindentd-knr" || id === "jsindent-knr") {\n            data = ["indent", "knr"];\n        } else if (id === "jsscope-html") {\n            data = ["jsscope", "true"];\n        } else if (id === "jsscope-no") {\n            data = ["jsscope", "none"];\n        } else if (id === "jsscope-yes") {\n            data = ["jsscope", "html"];\n        } else if (id === "jsscope-html") {\n            data = ["jsscope", "report"];\n        } else if (id === "jsspaced-no" || id === "jsspace-no") {\n            data = ["jsspace", "false"];\n        } else if (id === "jsspaced-yes" || id === "jsspace-yes") {\n            data = ["jsspace", "true"];\n        } else if (id === "language") {\n            data = ["lang", value];\n        } else if (id === "lang-default") {\n            data = ["langdefault", value];\n        } else if (id === "langauge") {\n            data = ["lang", value];\n        } else if (id === "lterminator-crlf") {\n            data = ["crlf", "true"];\n        } else if (id === "lterminator-lf") {\n            data = ["crlf", "false"];\n        } else if (id === "miniwrapm-no") {\n            data = ["miniwrap", "false"];\n        } else if (id === "miniwrapm-yes") {\n            data = ["miniwrap", "true"];\n        } else if (id === "modeanalysis") {\n            data = ["mode", "analysis"];\n        } else if (id === "modebeautify") {\n            data = ["mode", "beautify"];\n        } else if (id === "modediff") {\n            data = ["mode", "diff"];\n        } else if (id === "modeminify") {\n            data = ["mode", "minify"];\n        } else if (id === "modeparse") {\n            data = ["mode", "parse"];\n        } else if (id === "newline-no") {\n            data = ["newline", "false"];\n        } else if (id === "newline-yes") {\n            data = ["newline", "true"];\n        } else if (id === "parseFormat-htmltable") {\n            data = ["parseFormat", "htmltable"];\n        } else if (id === "parseFormat-parallel") {\n            data = ["parseFormat", "parallel"];\n        } else if (id === "parseFormat-sequential") {\n            data = ["parseFormat", "sequential"];\n        } else if (id === "parsespace-no") {\n            data = ["parseSpace", "false"];\n        } else if (id === "parsespace-yes") {\n            data = ["parseSpace", "true"];\n        } else if (id === "sidebyside") {\n            data = ["diffview", "sidebyside"];\n        } else if (id === "topcoms-yes") {\n            data = ["topcoms", "true"];\n        } else if (id === "topcoms-no") {\n            data = ["topcoms", "false"];\n        } else if (id === "vertical-all") {\n            data = ["vertical", "all"];\n        } else if (id === "vertical-cssonly") {\n            data = ["vertical", "css"];\n        } else if (id === "vertical-jsonly") {\n            data = ["vertical", "js"];\n        } else if (id === "vertical-none") {\n            data = ["vertical", "none"];\n        }\n        if (data.length === 0) {\n            return commentString;\n        }\n        if (data[1] !== "true" && data[1] !== "false") {\n            data[1] = "\\"" + data[1] + "\\"";\n        }\n        for (a = commentString.length - 1; a > -1; a = a - 1) {\n            if (commentString[a].indexOf(data[0]) > -1) {\n                commentString[a] = data.join(": ");\n                break;\n            }\n        }\n        if (a < 0) {\n            commentString.push(data.join(": "));\n            commentString.sort();\n        }\n        return commentString;\n    };\n    options.functions.node          = function options_node(a) {\n        var b        = 0,\n            c        = a.length,\n            d        = [],\n            e        = [],\n            f        = 0,\n            opts     = {},\n            help     = false,\n            langauto = true;\n        for (b = 0; b < c; b = b + 1) {\n            e = [];\n            f = a[b].indexOf(":");\n            e.push(a[b].substring(0, f).replace(/(\\s+)$/, ""));\n            e.push(a[b].substring(f + 1).replace(/^(\\s+)/, ""));\n            d.push(e);\n        }\n        c = d.length;\n        for (b = 0; b < c; b = b + 1) {\n            if (d[b].length === 2) {\n                opts[d[b][0]] = d[b][1];\n                if (d[b][0] === "lang" && d[b][1] !== "auto") {\n                    langauto = false;\n                }\n            } else {\n                if (d[b] === "help" || d[b][0] === "help" || d[b][0] === "man" || d[b][0] === "manual") {\n                    help = true;\n                } else if (d[b] === "v" || d[b] === "version" || d[b][0] === "v" || d[b][0] === "version") {\n                    options.version = true;\n                } else if (d[b] === "l" || d[b] === "list" || d[b][0] === "l" || d[b][0] === "list") {\n                    options.listoptions = true;\n                }\n            }\n        }\n        if (Object.keys(opts).length < 2) {\n            help = true;\n        }\n        options.functions.nodeArgs = opts;\n        options\n            .functions\n            .validate(opts);\n        return [help, langauto];\n    };\n    options.functions.binaryCheck   = (\n        /\\u0000|\\u0001|\\u0002|\\u0003|\\u0004|\\u0005|\\u0006|\\u0007|\\u000b|\\u000e|\\u000f|\\u0010|\\u0011|\\u0012|\\u0013|\\u0014|\\u0015|\\u0016|\\u0017|\\u0018|\\u0019|\\u001a|\\u001c|\\u001d|\\u001e|\\u001f|\\u007f|\\u0080|\\u0081|\\u0082|\\u0083|\\u0084|\\u0085|\\u0086|\\u0087|\\u0088|\\u0089|\\u008a|\\u008b|\\u008c|\\u008d|\\u008e|\\u008f|\\u0090|\\u0091|\\u0092|\\u0093|\\u0094|\\u0095|\\u0096|\\u0097|\\u0098|\\u0099|\\u009a|\\u009b|\\u009c|\\u009d|\\u009e|\\u009f/g\n    );\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function options_requirejs() {\n            return global.prettydiff.options;\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = global.prettydiff.options;\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n            (function glib_options() {\n                var localPath = (\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\n                )\n                    ? __dirname\n                    : ".";\n                if (global.prettydiff.language === undefined) {\n                    global.prettydiff.language = require(\n                        localPath + "/lib/language.js"\n                    );\n                }\n            }());\n        }\n    } \n}());\n'},function(n,e,t){"use strict";t(1)(t(34))},function(n,e){n.exports='/*global ace, define, global, module*/\n(function finalFile_init() {\n    "use strict";\n    var finalFile = {\n        css   : {\n            color  : {\n                canvas: "#prettydiff.canvas{background:#986 url(\\"data:image/png;base64,iVBORw0KGgoAAAA" +\n                        "NSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob" +\n                        "3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcE" +\n                        "RRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRN" +\n                        "YAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQpl" +\n                        "cAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVA" +\n                        "aCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGD" +\n                        "IIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBN" +\n                        "A/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qI" +\n                        "l7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14" +\n                        "L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcU" +\n                        "l0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZ" +\n                        "kmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQii" +\n                        "GzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIB" +\n                        "BKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogv" +\n                        "QZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu" +\n                        "4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1h" +\n                        "ILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkn" +\n                        "eTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR" +\n                        "1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3G" +\n                        "K+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZ" +\n                        "VM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq" +\n                        "4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y" +\n                        "0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1r" +\n                        "i6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8f" +\n                        "b8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx" +\n                        "83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1ru" +\n                        "tu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdW" +\n                        "h1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lps" +\n                        "bxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ" +\n                        "0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r" +\n                        "/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pD" +\n                        "oVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo" +\n                        "3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZAT" +\n                        "IhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLx" +\n                        "MDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2Q" +\n                        "qboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxeds" +\n                        "K4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGn" +\n                        "Rs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO3" +\n                        "19kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +\n                        "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3" +\n                        "vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3" +\n                        "nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDv" +\n                        "OXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeO" +\n                        "T3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYP" +\n                        "P/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/b" +\n                        "Xyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GM" +\n                        "zLdsAAEFdaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9I" +\n                        "lc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1" +\n                        "ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvM" +\n                        "jAtMDk6NTM6MDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5" +\n                        "vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmO" +\n                        "mFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4" +\n                        "wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tb" +\n                        "S8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R" +\n                        "5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvY" +\n                        "mUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR" +\n                        "0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvc" +\n                        "D0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGl" +\n                        "mZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9I" +\n                        "mh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5" +\n                        "BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgI" +\n                        "CAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxMjoyNDozOC0wNjowMDwveG1wOkNyZWF0ZUR" +\n                        "hdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTYtMDEtMTNUMTM6MTg6MDctMDY6MDA8L" +\n                        "3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE2LTAxLTEzVDEzOjE" +\n                        "4OjA3LTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wL" +\n                        "mlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5OS1iYjM5NjA0MDVhOWQ8L3htcE1NOkluc3RhbmNlSUQ" +\n                        "+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDoxYzM3NjE4M" +\n                        "S1mOWU4LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx" +\n                        "4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZjA3LTQ5ZDEtOWIwZC02O" +\n                        "DEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3R" +\n                        "vcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZ" +\n                        "VR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9" +\n                        "zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6N" +\n                        "mIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZUlEPgogICA" +\n                        "gICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2d" +\n                        "Dp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3N" +\n                        "ob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgI" +\n                        "CAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2U" +\n                        "iPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +\n                        "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ" +\n                        "3LThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c" +\n                        "3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICA" +\n                        "gICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFja" +\n                        "W50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5" +\n                        "nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgI" +\n                        "CAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3R" +\n                        "FdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0O" +\n                        "nBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9" +\n                        "iZS5waG90b3Nob3A8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogI" +\n                        "CAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICA" +\n                        "gICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgI" +\n                        "CA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWR" +\n                        "mMzVhMTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxN" +\n                        "i0wMS0xM1QxMzoxMzoyMy0wNjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ" +\n                        "0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0O" +\n                        "nNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmN" +\n                        "oYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZ" +\n                        "jpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5kZXJ" +\n                        "pdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpwYXJhbWV0ZXJzPmNvb" +\n                        "nZlcnRlZCBmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nPC9" +\n                        "zdEV2dDpwYXJhbWV0ZXJzPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgP" +\n                        "HJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp" +\n                        "hY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3Rhb" +\n                        "mNlSUQ+eG1wLmlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5OS1iYjM5NjA0MDVhOWQ8L3N0RXZ0Oml" +\n                        "uc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMDEtMTNUMTM6MTg6M" +\n                        "DctMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW5" +\n                        "0PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zdEV2dDpzb2Z0d2FyZUFnZW50P" +\n                        "gogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICA" +\n                        "gICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NO" +\n                        "khpc3Rvcnk+CiAgICAgICAgIDx4bXBNTTpEZXJpdmVkRnJvbSByZGY6cGFyc2VUeXBlPSJSZXNvdXJ" +\n                        "jZSI+CiAgICAgICAgICAgIDxzdFJlZjppbnN0YW5jZUlEPnhtcC5paWQ6ODNhNzkwYWQtYzBlZC00Y" +\n                        "jNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjppbnN0YW5jZUlEPgogICAgICAgICAgICA8c3RSZWY" +\n                        "6ZG9jdW1lbnRJRD54bXAuZGlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWRmMzVhMTwvc" +\n                        "3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXA" +\n                        "uZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjBkLTY4MTMxMWQ3NDAzMTwvc3RSZWY6b3JpZ2luYWxEb" +\n                        "2N1bWVudElEPgogICAgICAgICA8L3htcE1NOkRlcml2ZWRGcm9tPgogICAgICAgICA8ZGM6Zm9ybWF" +\n                        "0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9wa" +\n                        "G90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOklDQ1Byb2ZpbGU+c1JHQiBJRUM" +\n                        "2MTk2Ni0yLjE8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvb" +\n                        "j4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj4zMDAwMDAwLzE" +\n                        "wMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj4zMDAwMDAwL" +\n                        "zEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC9" +\n                        "0aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb" +\n                        "3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjQ8L2V4aWY6UGl4ZWxYRGltZW5" +\n                        "zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFlEaW1lbnNpb" +\n                        "24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +\n                        "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWN" +\n                        "rZXQgZW5kPSJ3Ij8+bleIyQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX" +\n                        "8VGAAAANElEQVR42mJ89+4uAwMDAwPD6lkTGd69u/vu3d2ZHXnv3t1lgLPevbvLrCTIEJqWD1EJGAD" +\n                        "aTRll80WcLAAAAABJRU5ErkJggg==\\");color:#420}#prettydiff.canvas *:focus{outline" +\n                        ":0.1em dashed #f00}#prettydiff.canvas a{color:#039}#prettydiff.canvas .content" +\n                        "area,#prettydiff.canvas legend,#prettydiff.canvas fieldset select,#prettydiff." +\n                        "canvas .diff td,#prettydiff.canvas .report td,#prettydiff.canvas .data li,#pre" +\n                        "ttydiff.canvas .diff-right,#prettydiff.canvas fieldset input{background:#eeeee" +\n                        "8;border-color:#420}#prettydiff.canvas select,#prettydiff.canvas input,#pretty" +\n                        "diff.canvas .diff,#prettydiff.canvas .beautify,#prettydiff.canvas .report,#pre" +\n                        "ttydiff.canvas .beautify h3,#prettydiff.canvas .diff h3,#prettydiff.canvas .be" +\n                        "autify h4,#prettydiff.canvas .diff h4,#prettydiff.canvas #report,#prettydiff.c" +\n                        "anvas #report .author,#prettydiff.canvas fieldset{background:#ddddd8;border-co" +\n                        "lor:#420}#prettydiff.canvas fieldset fieldset{background:#eeeee8}#prettydiff.c" +\n                        "anvas fieldset fieldset input,#prettydiff.canvas fieldset fieldset select{back" +\n                        "ground:#ddddd8}#prettydiff.canvas h2,#prettydiff.canvas h2 button,#prettydiff." +\n                        "canvas h3,#prettydiff.canvas legend{color:#900}#prettydiff.canvas .contentarea" +\n                        "{box-shadow:0 1em 1em #b8a899}#prettydiff.canvas .segment{background:#fff}#pre" +\n                        "ttydiff.canvas h2 button,#prettydiff.canvas .segment,#prettydiff.canvas ol.seg" +\n                        "ment li{border-color:#420}#prettydiff.canvas th{background:#e8ddcc}#prettydiff" +\n                        ".canvas li h4{color:#06f}#prettydiff.canvas code{background:#eee;border-color:" +\n                        "#eee;color:#00f}#prettydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff" +\n                        ".canvas button{background-color:#ddddd8;border-color:#420;box-shadow:0 0.25em " +\n                        "0.5em #b8a899;color:#900}#prettydiff.canvas button:hover{background-color:#ccb" +\n                        ";border-color:#630;box-shadow:0 0.25em 0.5em #b8a899;color:#630}#prettydiff.ca" +\n                        "nvas th{background:#ccccc8}#prettydiff.canvas thead th,#prettydiff.canvas th.h" +\n                        "eading{background:#ccb}#prettydiff.canvas .diff h3{background:#ddd;border-colo" +\n                        "r:#999}#prettydiff.canvas td,#prettydiff.canvas th,#prettydiff.canvas .segment" +\n                        ",#prettydiff.canvas .count li,#prettydiff.canvas .data li,#prettydiff.canvas ." +\n                        "diff-right{border-color:#ccccc8}#prettydiff.canvas .count{background:#eed;bord" +\n                        "er-color:#999}#prettydiff.canvas .count li.fold{color:#900}#prettydiff.canvas " +\n                        "h2 button{background:#f8f8f8;box-shadow:0.1em 0.1em 0.25em #ddd}#prettydiff.ca" +\n                        "nvas li h4{color:#00f}#prettydiff.canvas code{background:#eee;border-color:#ee" +\n                        "e;color:#009}#prettydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff.ca" +\n                        "nvas .data .delete{background:#ffd8d8}#prettydiff.canvas .data .delete em{back" +\n                        "ground:#fff8f8;border-color:#c44;color:#900}#prettydiff.canvas .data .insert{b" +\n                        "ackground:#d8ffd8}#prettydiff.canvas .data .insert em{background:#f8fff8;borde" +\n                        "r-color:#090;color:#363}#prettydiff.canvas .data .replace{background:#fec}#pre" +\n                        "ttydiff.canvas .data .replace em{background:#ffe;border-color:#a86;color:#852}" +\n                        "#prettydiff.canvas .data .empty{background:#ddd}#prettydiff.canvas .data em.s0" +\n                        "{color:#000}#prettydiff.canvas .data em.s1{color:#f66}#prettydiff.canvas .data" +\n                        " em.s2{color:#12f}#prettydiff.canvas .data em.s3{color:#090}#prettydiff.canvas" +\n                        " .data em.s4{color:#d6d}#prettydiff.canvas .data em.s5{color:#7cc}#prettydiff." +\n                        "canvas .data em.s6{color:#c85}#prettydiff.canvas .data em.s7{color:#737}#prett" +\n                        "ydiff.canvas .data em.s8{color:#6d0}#prettydiff.canvas .data em.s9{color:#dd0}" +\n                        "#prettydiff.canvas .data em.s10{color:#893}#prettydiff.canvas .data em.s11{col" +\n                        "or:#b97}#prettydiff.canvas .data em.s12{color:#bbb}#prettydiff.canvas .data em" +\n                        ".s13{color:#cc3}#prettydiff.canvas .data em.s14{color:#333}#prettydiff.canvas " +\n                        ".data em.s15{color:#9d9}#prettydiff.canvas .data em.s16{color:#880}#prettydiff" +\n                        ".canvas .data .l0{background:#eeeee8}#prettydiff.canvas .data .l1{background:#" +\n                        "fed}#prettydiff.canvas .data .l2{background:#def}#prettydiff.canvas .data .l3{" +\n                        "background:#efe}#prettydiff.canvas .data .l4{background:#fef}#prettydiff.canva" +\n                        "s .data .l5{background:#eef}#prettydiff.canvas .data .l6{background:#fff8cc}#p" +\n                        "rettydiff.canvas .data .l7{background:#ede}#prettydiff.canvas .data .l8{backgr" +\n                        "ound:#efc}#prettydiff.canvas .data .l9{background:#ffd}#prettydiff.canvas .dat" +\n                        "a .l10{background:#edc}#prettydiff.canvas .data .l11{background:#fdb}#prettydi" +\n                        "ff.canvas .data .l12{background:#f8f8f8}#prettydiff.canvas .data .l13{backgrou" +\n                        "nd:#ffb}#prettydiff.canvas .data .l14{background:#eec}#prettydiff.canvas .data" +\n                        " .l15{background:#cfc}#prettydiff.canvas .data .l16{background:#eea}#prettydif" +\n                        "f.canvas .data .c0{background:inherit}#prettydiff.canvas #report p em{color:#0" +\n                        "60}#prettydiff.canvas #report p strong{color:#009}",\n                shadow: "#prettydiff.shadow{background:#333 url(\\"data:image/png;base64,iVBORw0KGgoAAAA" +\n                        "NSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob" +\n                        "3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcE" +\n                        "RRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRN" +\n                        "YAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQpl" +\n                        "cAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVA" +\n                        "aCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGD" +\n                        "IIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBN" +\n                        "A/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qI" +\n                        "l7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14" +\n                        "L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcU" +\n                        "l0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZ" +\n                        "kmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQii" +\n                        "GzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIB" +\n                        "BKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogv" +\n                        "QZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu" +\n                        "4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1h" +\n                        "ILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkn" +\n                        "eTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR" +\n                        "1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3G" +\n                        "K+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZ" +\n                        "VM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq" +\n                        "4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y" +\n                        "0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1r" +\n                        "i6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8f" +\n                        "b8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx" +\n                        "83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1ru" +\n                        "tu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdW" +\n                        "h1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lps" +\n                        "bxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ" +\n                        "0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r" +\n                        "/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pD" +\n                        "oVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo" +\n                        "3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZAT" +\n                        "IhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLx" +\n                        "MDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2Q" +\n                        "qboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxeds" +\n                        "K4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGn" +\n                        "Rs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO3" +\n                        "19kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +\n                        "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3" +\n                        "vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3" +\n                        "nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDv" +\n                        "OXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeO" +\n                        "T3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYP" +\n                        "P/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/b" +\n                        "Xyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GM" +\n                        "zLdsAAEQFaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9I" +\n                        "lc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1" +\n                        "ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvM" +\n                        "jAtMDk6NTM6MDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5" +\n                        "vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmO" +\n                        "mFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4" +\n                        "wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tb" +\n                        "S8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R" +\n                        "5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvY" +\n                        "mUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR" +\n                        "0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvc" +\n                        "D0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGl" +\n                        "mZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9I" +\n                        "mh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5" +\n                        "BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgI" +\n                        "CAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxMjoyNDozOC0wNjowMDwveG1wOkNyZWF0ZUR" +\n                        "hdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTYtMDEtMTNUMTU6MTE6MzMtMDY6MDA8L" +\n                        "3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE2LTAxLTEzVDE1OjE" +\n                        "xOjMzLTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wL" +\n                        "mlpZDo4MDAwYTE3Zi1jZTY1LTQ5NTUtYjFmMS05YjVkODIwNDIyNjU8L3htcE1NOkluc3RhbmNlSUQ" +\n                        "+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDoxZmZhNDk1Y" +\n                        "y1mYTU2LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx" +\n                        "4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZjA3LTQ5ZDEtOWIwZC02O" +\n                        "DEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3R" +\n                        "vcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZ" +\n                        "VR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9" +\n                        "zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6N" +\n                        "mIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZUlEPgogICA" +\n                        "gICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2d" +\n                        "Dp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3N" +\n                        "ob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgI" +\n                        "CAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2U" +\n                        "iPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +\n                        "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ" +\n                        "3LThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c" +\n                        "3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICA" +\n                        "gICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFja" +\n                        "W50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5" +\n                        "nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgI" +\n                        "CAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3R" +\n                        "FdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0O" +\n                        "nBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9" +\n                        "iZS5waG90b3Nob3A8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogI" +\n                        "CAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICA" +\n                        "gICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgI" +\n                        "CA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWR" +\n                        "mMzVhMTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxN" +\n                        "i0wMS0xM1QxMzoxMzoyMy0wNjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ" +\n                        "0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0O" +\n                        "nNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmN" +\n                        "oYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZ" +\n                        "jpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZ" +\n                        "lZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAua" +\n                        "WlkOjA0ZGYyNDk5LWE1NTktNDE4MC1iNjA1LWI2MTk3MWMxNWEwMzwvc3RFdnQ6aW5zdGFuY2VJRD4" +\n                        "KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc" +\n                        "3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGh" +\n                        "vdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgI" +\n                        "CAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDw" +\n                        "vcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KI" +\n                        "CAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICA" +\n                        "gICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvY" +\n                        "mUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICA" +\n                        "gPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiP" +\n                        "gogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICA" +\n                        "gICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb" +\n                        "24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICA" +\n                        "gICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9I" +\n                        "lJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN" +\n                        "0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgwMDBhMTdmL" +\n                        "WNlNjUtNDk1NS1iMWYxLTliNWQ4MjA0MjI2NTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICA" +\n                        "gICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc3RFdnQ6d2hlbj4KI" +\n                        "CAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDI" +\n                        "wMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzd" +\n                        "EV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICA" +\n                        "gICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHhtc" +\n                        "E1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmV" +\n                        "mOmluc3RhbmNlSUQ+eG1wLmlpZDowNGRmMjQ5OS1hNTU5LTQxODAtYjYwNS1iNjE5NzFjMTVhMDM8L" +\n                        "3N0UmVmOmluc3RhbmNlSUQ+CiAgICAgICAgICAgIDxzdFJlZjpkb2N1bWVudElEPnhtcC5kaWQ6ODN" +\n                        "hNzkwYWQtYzBlZC00YjNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjpkb2N1bWVudElEPgogICAgI" +\n                        "CAgICAgICA8c3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NmIyNGUyN2EtY2YwNy00OWQ" +\n                        "xLTliMGQtNjgxMzExZDc0MDMxPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwve" +\n                        "G1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ" +\n                        "+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgI" +\n                        "CAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOkl" +\n                        "DQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+C" +\n                        "iAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24" +\n                        "+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb" +\n                        "24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiA" +\n                        "gICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZ" +\n                        "jpQaXhlbFhEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlB" +\n                        "peGVsWURpbWVuc2lvbj40PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3Jpc" +\n                        "HRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +\n                        "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5hSvvCAAAAIGN" +\n                        "IUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAlSURBVHjaPMYxAQAwDAMgV" +\n                        "kv1VFFRuy9cvN0F7m66JNNhOvwBAPyqCtNeO5K2AAAAAElFTkSuQmCC\\");color:#fff}#prettyd" +\n                        "iff.shadow *:focus{outline:0.1em dashed #ff0}#prettydiff.shadow a:visited{colo" +\n                        "r:#f93}#prettydiff.shadow a{color:#cf3}#prettydiff.shadow .contentarea,#pretty" +\n                        "diff.shadow legend,#prettydiff.shadow fieldset select,#prettydiff.shadow .diff" +\n                        " td,#prettydiff.shadow .report td,#prettydiff.shadow .data li,#prettydiff.shad" +\n                        "ow .diff-right,#prettydiff.shadow fieldset input{background:#333;border-color:" +\n                        "#666}#prettydiff.shadow select,#prettydiff.shadow input,#prettydiff.shadow .di" +\n                        "ff,#prettydiff.shadow .beautify,#prettydiff.shadow .report,#prettydiff.shadow " +\n                        ".beautify h3,#prettydiff.shadow .diff h3,#prettydiff.shadow .beautify h4,#pret" +\n                        "tydiff.shadow .diff h4,#prettydiff.shadow #report,#prettydiff.shadow #report ." +\n                        "author,#prettydiff.shadow fieldset{background:#222;border-color:#666}#prettydi" +\n                        "ff.shadow fieldset fieldset{background:#333}#prettydiff.shadow fieldset fields" +\n                        "et input,#prettydiff.shadow fieldset fieldset select{background:#222}#prettydi" +\n                        "ff.shadow h2,#prettydiff.shadow h2 button,#prettydiff.shadow h3,#prettydiff.sh" +\n                        "adow input,#prettydiff.shadow option,#prettydiff.shadow select,#prettydiff.sha" +\n                        "dow legend{color:#ccc}#prettydiff.shadow .contentarea{box-shadow:0 1em 1em #00" +\n                        "0}#prettydiff.shadow .segment{background:#222}#prettydiff.shadow h2 button,#pr" +\n                        "ettydiff.shadow td,#prettydiff.shadow th,#prettydiff.shadow .segment,#prettydi" +\n                        "ff.shadow ol.segment li{border-color:#666}#prettydiff.shadow .count li.fold{co" +\n                        "lor:#cf3}#prettydiff.shadow th{background:#000}#prettydiff.shadow h2 button{ba" +\n                        "ckground:#585858;box-shadow:0.1em 0.1em 0.25em #000}#prettydiff.shadow li h4{c" +\n                        "olor:#ff0}#prettydiff.shadow code{background:#585858;border-color:#585858;colo" +\n                        "r:#ccf}#prettydiff.shadow ol.segment h4 strong{color:#f30}#prettydiff.shadow b" +\n                        "utton{background-color:#333;border-color:#666;box-shadow:0 0.25em 0.5em #000;c" +\n                        "olor:#ccc}#prettydiff.shadow button:hover{background-color:#777;border-color:#" +\n                        "aaa;box-shadow:0 0.25em 0.5em #222;color:#fff}#prettydiff.shadow th{background" +\n                        ":#444}#prettydiff.shadow thead th,#prettydiff.shadow th.heading{background:#44" +\n                        "4}#prettydiff.shadow .diff h3{background:#000;border-color:#666}#prettydiff.sh" +\n                        "adow .segment,#prettydiff.shadow .data li,#prettydiff.shadow .diff-right{borde" +\n                        "r-color:#444}#prettydiff.shadow .count li{border-color:#333}#prettydiff.shadow" +\n                        " .count{background:#555;border-color:#333}#prettydiff.shadow li h4{color:#ff0}" +\n                        "#prettydiff.shadow code{background:#000;border-color:#000;color:#ddd}#prettydi" +\n                        "ff.shadow ol.segment h4 strong{color:#c00}#prettydiff.shadow .data .delete{bac" +\n                        "kground:#300}#prettydiff.shadow .data .delete em{background:#200;border-color:" +\n                        "#c63;color:#c66}#prettydiff.shadow .data .insert{background:#030}#prettydiff.s" +\n                        "hadow .data .insert em{background:#010;border-color:#090;color:#6c0}#prettydif" +\n                        "f.shadow .data .replace{background:#345}#prettydiff.shadow .data .replace em{b" +\n                        "ackground:#023;border-color:#09c;color:#7cf}#prettydiff.shadow .data .empty{ba" +\n                        "ckground:#111}#prettydiff.shadow .diff .author{border-color:#666}#prettydiff.s" +\n                        "hadow .data em.s0{color:#fff}#prettydiff.shadow .data em.s1{color:#d60}#pretty" +\n                        "diff.shadow .data em.s2{color:#aaf}#prettydiff.shadow .data em.s3{color:#0c0}#" +\n                        "prettydiff.shadow .data em.s4{color:#f6f}#prettydiff.shadow .data em.s5{color:" +\n                        "#0cc}#prettydiff.shadow .data em.s6{color:#dc3}#prettydiff.shadow .data em.s7{" +\n                        "color:#a7a}#prettydiff.shadow .data em.s8{color:#7a7}#prettydiff.shadow .data " +\n                        "em.s9{color:#ff6}#prettydiff.shadow .data em.s10{color:#33f}#prettydiff.shadow" +\n                        " .data em.s11{color:#933}#prettydiff.shadow .data em.s12{color:#990}#prettydif" +\n                        "f.shadow .data em.s13{color:#987}#prettydiff.shadow .data em.s14{color:#fc3}#p" +\n                        "rettydiff.shadow .data em.s15{color:#897}#prettydiff.shadow .data em.s16{color" +\n                        ":#f30}#prettydiff.shadow .data .l0{background:#333}#prettydiff.shadow .data .l" +\n                        "1{background:#633}#prettydiff.shadow .data .l2{background:#335}#prettydiff.sha" +\n                        "dow .data .l3{background:#353}#prettydiff.shadow .data .l4{background:#636}#pr" +\n                        "ettydiff.shadow .data .l5{background:#366}#prettydiff.shadow .data .l6{backgro" +\n                        "und:#640}#prettydiff.shadow .data .l7{background:#303}#prettydiff.shadow .data" +\n                        " .l8{background:#030}#prettydiff.shadow .data .l9{background:#660}#prettydiff." +\n                        "shadow .data .l10{background:#003}#prettydiff.shadow .data .l11{background:#30" +\n                        "0}#prettydiff.shadow .data .l12{background:#553}#prettydiff.shadow .data .l13{" +\n                        "background:#432}#prettydiff.shadow .data .l14{background:#640}#prettydiff.shad" +\n                        "ow .data .l15{background:#562}#prettydiff.shadow .data .l16{background:#600}#p" +\n                        "rettydiff.shadow .data .c0{background:inherit}",\n                white : "#prettydiff.white{background:#f8f8f8 url(\\"data:image/png;base64,iVBORw0KGgoAA" +\n                        "AANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3N" +\n                        "ob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVU" +\n                        "cERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDN" +\n                        "RNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQ" +\n                        "plcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCE" +\n                        "VAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7A" +\n                        "GDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTK" +\n                        "BNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/" +\n                        "qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf" +\n                        "14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSK" +\n                        "cUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQC" +\n                        "AZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQ" +\n                        "iiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcF" +\n                        "IBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGo" +\n                        "gvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqw" +\n                        "Du4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh" +\n                        "1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIX" +\n                        "kneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoE" +\n                        "zR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl" +\n                        "3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9r" +\n                        "kZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWs" +\n                        "Nq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG" +\n                        "6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr" +\n                        "1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL" +\n                        "8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDt" +\n                        "Mx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1" +\n                        "rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqs" +\n                        "dWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+L" +\n                        "psbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5" +\n                        "PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/" +\n                        "3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5" +\n                        "pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qP" +\n                        "No3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZ" +\n                        "ATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepk" +\n                        "LxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq" +\n                        "2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxe" +\n                        "dsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1Yfq" +\n                        "GnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9Wt" +\n                        "O319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7" +\n                        "JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/" +\n                        "p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0db" +\n                        "q3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7v" +\n                        "DvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tW" +\n                        "eOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGh" +\n                        "YPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O" +\n                        "/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/" +\n                        "GMzLdsAADo2aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ" +\n                        "9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zO" +\n                        "m1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDg" +\n                        "vMjAtMDk6NTM6MDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53M" +\n                        "y5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmR" +\n                        "mOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvM" +\n                        "S4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9" +\n                        "tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc" +\n                        "1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmc" +\n                        "vZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuY" +\n                        "WRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnM" +\n                        "uYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb" +\n                        "2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2h" +\n                        "vcCBDQyAyMDE0IChNYWNpbnRvc2gpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlY" +\n                        "XRlRGF0ZT4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICA" +\n                        "gPHhtcDpNZXRhZGF0YURhdGU+MjAxNi0wMS0xMlQxMjoyNDozOC0wNjowMDwveG1wOk1ldGFkYXRhR" +\n                        "GF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3h" +\n                        "tcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmQ1M2M3ODQzL" +\n                        "WE1ZjItNDg0Ny04YzQzLTZlMmMwYTQ2OGJlYjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHh" +\n                        "tcE1NOkRvY3VtZW50SUQ+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjFjMzc2MTgxLWY5ZTgtMTE3OC05Y" +\n                        "TljLWQ4MjVkZmIwYTQ3MDwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmF" +\n                        "sRG9jdW1lbnRJRD54bXAuZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjBkLTY4MTMxMWQ3NDAzMTwve" +\n                        "G1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICA" +\n                        "gICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY" +\n                        "2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4" +\n                        "KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2YjI0ZTI3YS1jZjA3L" +\n                        "TQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICA" +\n                        "gIDxzdEV2dDp3aGVuPjIwMTYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgI" +\n                        "CAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0ICh" +\n                        "NYWNpbnRvc2gpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KI" +\n                        "CAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICA" +\n                        "gICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgI" +\n                        "CAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpkNTNjNzg0My1hNWYyLTQ4NDctOGM0My02ZTJjMGE" +\n                        "0NjhiZWI8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwM" +\n                        "TYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV" +\n                        "2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zdEV2d" +\n                        "Dpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDp" +\n                        "jaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogI" +\n                        "CAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzp" +\n                        "mb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZ" +\n                        "GU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9" +\n                        "zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50Y" +\n                        "XRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29" +\n                        "sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc" +\n                        "29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblV" +\n                        "uaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgI" +\n                        "CA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDx" +\n                        "leGlmOlBpeGVsWURpbWVuc2lvbj40PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6R" +\n                        "GVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +\n                        "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5cKga" +\n                        "XAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAkSURBVHjaPMahA" +\n                        "QAwDMCg7P+/KnsPcq4oHqpqdwNmBt3QDX8AeAUmcrZLnM4AAAAASUVORK5CYII=\\")}#prettydiff" +\n                        ".white *:focus{outline:0.1em dashed #06f}#prettydiff.white .contentarea,#prett" +\n                        "ydiff.white legend,#prettydiff.white fieldset select,#prettydiff.white .diff t" +\n                        "d,#prettydiff.white .report td,#prettydiff.white .data li,#prettydiff.white .d" +\n                        "iff-right,#prettydiff.white fieldset input{background:#fff;border-color:#999}#" +\n                        "prettydiff.white select,#prettydiff.white input,#prettydiff.white .diff,#prett" +\n                        "ydiff.white .beautify,#prettydiff.white .report,#prettydiff.white .beautify h3" +\n                        ",#prettydiff.white .diff h3,#prettydiff.white .beautify h4,#prettydiff.white ." +\n                        "diff h4,#prettydiff.white #pdsamples li div,#prettydiff.white #report,#prettyd" +\n                        "iff.white .author,#prettydiff.white #report .author,#prettydiff.white fieldset" +\n                        "{background:#eee;border-color:#999}#prettydiff.white .diff h3{background:#ddd;" +\n                        "border-color:#999}#prettydiff.white fieldset fieldset{background:#ddd}#prettyd" +\n                        "iff.white .contentarea{box-shadow:0 1em 1em #999}#prettydiff.white button{back" +\n                        "ground-color:#eee;border-color:#999;box-shadow:0 0.25em 0.5em #ccc;color:#666}" +\n                        "#prettydiff.white button:hover{background-color:#def;border-color:#03c;box-sha" +\n                        "dow:0 0.25em 0.5em #ccf;color:#03c}#prettydiff.white h2,#prettydiff.white h2 b" +\n                        "utton,#prettydiff.white h3{color:#b00}#prettydiff.white th{background:#eee;col" +\n                        "or:#333}#prettydiff.white thead th{background:#eef}#prettydiff.white .report s" +\n                        "trong{color:#009}#prettydiff.white .report em{color:#080}#prettydiff.white h2 " +\n                        "button,#prettydiff.white td,#prettydiff.white th,#prettydiff.white .segment,#p" +\n                        "rettydiff.white .count li,#prettydiff.white .diff-right #prettydiff.white ol.s" +\n                        "egment li{border-color:#ccc}#prettydiff.white .data li{border-color:#ccc}#pret" +\n                        "tydiff.white .count li.fold{color:#900}#prettydiff.white .count{background:#ee" +\n                        "d;border-color:#999}#prettydiff.white h2 button{background:#f8f8f8;box-shadow:" +\n                        "0.1em 0.1em 0.25em #ddd}#prettydiff.white li h4{color:#00f}#prettydiff.white c" +\n                        "ode{background:#eee;border-color:#eee;color:#009}#prettydiff.white ol.segment " +\n                        "h4 strong{color:#c00}#prettydiff.white .data .delete{background:#ffd8d8}#prett" +\n                        "ydiff.white .data .delete em{background:#fff8f8;border-color:#c44;color:#900}#" +\n                        "prettydiff.white .data .insert{background:#d8ffd8}#prettydiff.white .data .ins" +\n                        "ert em{background:#f8fff8;border-color:#090;color:#363}#prettydiff.white .data" +\n                        " .replace{background:#fec}#prettydiff.white .data .replace em{background:#ffe;" +\n                        "border-color:#a86;color:#852}#prettydiff.white .data .empty{background:#ddd}#p" +\n                        "rettydiff.white .data em.s0{color:#000}#prettydiff.white .data em.s1{color:#f6" +\n                        "6}#prettydiff.white .data em.s2{color:#12f}#prettydiff.white .data em.s3{color" +\n                        ":#090}#prettydiff.white .data em.s4{color:#d6d}#prettydiff.white .data em.s5{c" +\n                        "olor:#7cc}#prettydiff.white .data em.s6{color:#c85}#prettydiff.white .data em." +\n                        "s7{color:#737}#prettydiff.white .data em.s8{color:#6d0}#prettydiff.white .data" +\n                        " em.s9{color:#dd0}#prettydiff.white .data em.s10{color:#893}#prettydiff.white " +\n                        ".data em.s11{color:#b97}#prettydiff.white .data em.s12{color:#bbb}#prettydiff." +\n                        "white .data em.s13{color:#cc3}#prettydiff.white .data em.s14{color:#333}#prett" +\n                        "ydiff.white .data em.s15{color:#9d9}#prettydiff.white .data em.s16{color:#880}" +\n                        "#prettydiff.white .data .l0{background:#fff}#prettydiff.white .data .l1{backgr" +\n                        "ound:#fed}#prettydiff.white .data .l2{background:#def}#prettydiff.white .data " +\n                        ".l3{background:#efe}#prettydiff.white .data .l4{background:#fef}#prettydiff.wh" +\n                        "ite .data .l5{background:#eef}#prettydiff.white .data .l6{background:#fff8cc}#" +\n                        "prettydiff.white .data .l7{background:#ede}#prettydiff.white .data .l8{backgro" +\n                        "und:#efc}#prettydiff.white .data .l9{background:#ffd}#prettydiff.white .data ." +\n                        "l10{background:#edc}#prettydiff.white .data .l11{background:#fdb}#prettydiff.w" +\n                        "hite .data .l12{background:#f8f8f8}#prettydiff.white .data .l13{background:#ff" +\n                        "b}#prettydiff.white .data .l14{background:#eec}#prettydiff.white .data .l15{ba" +\n                        "ckground:#cfc}#prettydiff.white .data .l16{background:#eea}#prettydiff.white ." +\n                        "data .c0{background:inherit}#prettydiff.white #report p em{color:#080}#prettyd" +\n                        "iff.white #report p strong{color:#009}"\n            },\n            global : "#prettydiff{text-align:center;font-size:10px;overflow-y:scroll}#prettydiff .co" +\n                    "ntentarea{border-style:solid;border-width:0.1em;font-family:\\"Century Gothic\\"" +\n                    ",\\"Trebuchet MS\\";margin:0 auto;max-width:93em;padding:1em;text-align:left}#pr" +\n                    "ettydiff dd,#prettydiff dt,#prettydiff p,#prettydiff li,#prettydiff td,#pretty" +\n                    "diff blockquote,#prettydiff th{clear:both;font-family:\\"Palatino Linotype\\",\\"" +\n                    "Book Antiqua\\",Palatino,serif;font-size:1.6em;line-height:1.6em;text-align:lef" +\n                    "t}#prettydiff blockquote{font-style:italic}#prettydiff dt{font-size:1.4em;font" +\n                    "-weight:bold;line-height:inherit}#prettydiff li li,#prettydiff li p{font-size:" +\n                    "1em}#prettydiff th,#prettydiff td{border-style:solid;border-width:0.1em;paddin" +\n                    "g:0.1em 0.2em}#prettydiff td span{display:block}#prettydiff code,#prettydiff t" +\n                    "extarea{font-family:\\"Courier New\\",Courier,\\"Lucida Console\\",monospace}#pret" +\n                    "tydiff code,#prettydiff textarea{display:block;font-size:0.8em;width:100%}#pre" +\n                    "ttydiff code span{display:block;white-space:pre}#prettydiff code{border-style:" +\n                    "solid;border-width:0.2em;line-height:1em}#prettydiff textarea{line-height:1.4e" +\n                    "m}#prettydiff label{display:inline;font-size:1.4em}#prettydiff legend{border-r" +\n                    "adius:1em;border-style:solid;border-width:0.1em;font-size:1.4em;font-weight:bo" +\n                    "ld;margin-left:-0.25em;padding:0 0.5em}#prettydiff fieldset fieldset legend{fo" +\n                    "nt-size:1.2em}#prettydiff table{border-collapse:collapse}#prettydiff div.repor" +\n                    "t{border-style:none}#prettydiff h2,#prettydiff h3,#prettydiff h4{clear:both}#p" +\n                    "rettydiff table{margin:0 0 1em}#prettydiff .analysis .bad,#prettydiff .analysi" +\n                    "s .good{font-weight:bold}#prettydiff h1{font-size:3em;font-weight:normal;margi" +\n                    "n-top:0}#prettydiff h1 span{font-size:0.5em}#prettydiff h1 svg{border-style:so" +\n                    "lid;border-width:0.05em;float:left;height:1.5em;margin-right:0.5em;width:1.5em" +\n                    "}#prettydiff h2{border-style:none;background:transparent;font-size:1em;box-sha" +\n                    "dow:none;margin:0}#prettydiff h2 button{background:transparent;border-style:so" +\n                    "lid;cursor:pointer;display:block;font-size:2.5em;font-weight:normal;text-align" +\n                    ":left;width:100%;border-width:0.05em;font-weight:normal;margin:1em 0 0;padding" +\n                    ":0.1em}#prettydiff h2 span{display:block;float:right;font-size:0.5em}#prettydi" +\n                    "ff h3{font-size:2em;margin:0;background:transparent;box-shadow:none;border-sty" +\n                    "le:none}#prettydiff h4{font-size:1.6em;font-family:\\"Century Gothic\\",\\"Trebuc" +\n                    "het MS\\";margin:0}#prettydiff li h4{font-size:1em}#prettydiff button,#prettydi" +\n                    "ff fieldset,#prettydiff div input,#prettydiff textarea{border-style:solid;bord" +\n                    "er-width:0.1em}#prettydiff section{border-style:none}#prettydiff h2 button,#pr" +\n                    "ettydiff select,#prettydiff option{font-family:inherit}#prettydiff select{bord" +\n                    "er-style:inset;border-width:0.1em;width:13.5em}#prettydiff #dcolorScheme{float" +\n                    ":right;margin:-3em 0 0}#prettydiff #dcolorScheme label,#prettydiff #dcolorSche" +\n                    "me label{display:inline-block;font-size:1em}#prettydiff .clear{clear:both;disp" +\n                    "lay:block}#prettydiff caption,#prettydiff .content-hide{height:1em;left:-1000e" +\n                    "m;overflow:hidden;position:absolute;top:-1000em;width:1em}",\n            reports: "#prettydiff #report.contentarea{font-family:\\"Lucida Sans Unicode\\",\\"Helvetic" +\n                    "a\\",\\"Arial\\",sans-serif;max-width:none;overflow:scroll}#prettydiff .diff .rep" +\n                    "lace em,#prettydiff .diff .delete em,#prettydiff .diff .insert em{border-style" +\n                    ":solid;border-width:0.1em}#prettydiff #report dd,#prettydiff #report dt,#prett" +\n                    "ydiff #report p,#prettydiff #report li,#prettydiff #report td,#prettydiff #rep" +\n                    "ort blockquote,#prettydiff #report th{font-family:\\"Lucida Sans Unicode\\",\\"He" +\n                    "lvetica\\",\\"Arial\\",sans-serif;font-size:1.2em}#prettydiff div#webtool{backgro" +\n                    "und:transparent;font-size:inherit;margin:0;padding:0}#prettydiff #jserror span" +\n                    "{display:block}#prettydiff #a11y{background:transparent;padding:0}#prettydiff " +\n                    "#a11y div{margin:0.5em 0;border-style:solid;border-width:0.1em}#prettydiff #a1" +\n                    "1y h4{margin:0.25em 0}#prettydiff #a11y ol{border-style:solid;border-width:0.1" +\n                    "em}#prettydiff #cssreport.doc table{clear:none;float:left;margin-left:1em}#pre" +\n                    "ttydiff #css-size{left:24em}#prettydiff #css-uri{left:40em}#prettydiff #css-ur" +\n                    "i td{text-align:left}#prettydiff .report .analysis th{text-align:left}#prettyd" +\n                    "iff .report .analysis .parseData td{font-family:\\"Courier New\\",Courier,\\"Luci" +\n                    "da Console\\",monospace;text-align:left;white-space:pre}#prettydiff .report .an" +\n                    "alysis td{text-align:right}#prettydiff .analysis{float:left;margin:0 1em 1em 0" +\n                    "}#prettydiff .analysis td,#prettydiff .analysis th{padding:0.5em}#prettydiff #" +\n                    "statreport div{border-style:none}#prettydiff .diff,#prettydiff .beautify{borde" +\n                    "r-style:solid;border-width:0.1em;display:inline-block;margin:0 1em 1em 0;posit" +\n                    "ion:relative}#prettydiff .diff,#prettydiff .diff li #prettydiff .diff h3,#pret" +\n                    "tydiff .diff h4,#prettydiff .beautify,#prettydiff .beautify li,#prettydiff .be" +\n                    "autify h3,#prettydiff .beautify h4{font-family:\\"Courier New\\",Courier,\\"Lucid" +\n                    "a Console\\",monospace}#prettydiff .diff li,#prettydiff .beautify li,#prettydif" +\n                    "f .diff h3,#prettydiff .diff h4,#prettydiff .beautify h3,#prettydiff .beautify" +\n                    " h4{border-style:none none solid none;border-width:0 0 0.1em 0;box-shadow:none" +\n                    ";display:block;font-size:1.2em;margin:0 0 0 -.1em;padding:0.2em 2em;text-align" +\n                    ":left}#prettydiff .diff .skip{border-style:none none solid;border-width:0 0 0." +\n                    "1em}#prettydiff .diff .diff-left{border-style:none;display:table-cell}#prettyd" +\n                    "iff .diff .diff-right{border-style:none none none solid;border-width:0 0 0 0.1" +\n                    "em;display:table-cell;margin-left:-.1em;min-width:16.5em;right:0;top:0}#pretty" +\n                    "diff .diff .data li,#prettydiff .beautify .data li{min-width:16.5em;padding:0." +\n                    "5em}#prettydiff .diff li,#prettydiff .diff p,#prettydiff .diff h3,#prettydiff " +\n                    ".beautify li,#prettydiff .beautify p,#prettydiff .beautify h3{font-size:1.2em}" +\n                    "#prettydiff .diff li em,#prettydiff .beautify li em{font-style:normal;font-wei" +\n                    "ght:bold;margin:-0.5em -0.09em}#prettydiff .diff p.author{border-style:solid;b" +\n                    "order-width:0.2em 0.1em 0.1em;margin:0;overflow:hidden;padding:0.4em;text-alig" +\n                    "n:right}#prettydiff .difflabel{display:block;height:0}#prettydiff .count{borde" +\n                    "r-style:solid;border-width:0 0.1em 0 0;font-weight:normal;padding:0;text-align" +\n                    ":right}#prettydiff .count li{padding:0.5em 1em;text-align:right}#prettydiff .c" +\n                    "ount li.fold{cursor:pointer;font-weight:bold;padding-left:0.5em}#prettydiff .d" +\n                    "ata{text-align:left;white-space:pre}#prettydiff .beautify .data em{display:inl" +\n                    "ine-block;font-style:normal;font-weight:bold}#prettydiff .beautify li,#prettyd" +\n                    "iff .diff li{border-style:none none solid;border-width:0 0 0.1em;display:block" +\n                    ";height:1em;line-height:1.2;list-style-type:none;margin:0;white-space:pre}#pre" +\n                    "ttydiff .beautify ol,#prettydiff .diff ol{display:table-cell;margin:0;padding:" +\n                    "0}#prettydiff .beautify em.l0,#prettydiff .beautify em.l1,#prettydiff .beautif" +\n                    "y em.l2,#prettydiff .beautify em.l3,#prettydiff .beautify em.l4,#prettydiff .b" +\n                    "eautify em.l5,#prettydiff .beautify em.l6,#prettydiff .beautify em.l7,#prettyd" +\n                    "iff .beautify em.l8,#prettydiff .beautify em.l9,#prettydiff .beautify em.l10,#" +\n                    "prettydiff .beautify em.l11,#prettydiff .beautify em.l12,#prettydiff .beautify" +\n                    " em.l13,#prettydiff .beautify em.l14,#prettydiff .beautify em.l15,#prettydiff " +\n                    ".beautify em.l16{height:2.2em;margin:0 0 -1em;position:relative;top:-0.5em}#pr" +\n                    "ettydiff .beautify em.l0{margin-left:-0.5em;padding-left:0.5em}#prettydiff #re" +\n                    "port .beautify,#prettydiff #report .beautify li,#prettydiff #report .diff,#pre" +\n                    "ttydiff #report .diff li{font-family:\\"Courier New\\",Courier,\\"Lucida Console" +\n                    "\\",monospace}#prettydiff #report .beautify{border-style:solid}#prettydiff #rep" +\n                    "ort .diff h3,#prettydiff #report .beautify h3{margin:0}"\n        },\n        html  : {\n            body  : "/*]]>*\\/</style></head><body id=\\"prettydiff\\" class=\\"",\n            color : "white",\n            end   : "//]]>\\r\\n<\/script></body></html>",\n            head  : "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" ?><!DOCTYPE html PUBLIC \\"-//W3C//DTD" +\n                    " XHTML 1.1//EN\\" \\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\"><html xmlns=" +\n                    "\\"http://www.w3.org/1999/xhtml\\" xml:lang=\\"en\\"><head><title>Pretty Diff - Th" +\n                    "e difference tool</title><meta name=\\"robots\\" content=\\"index, follow\\"/> <me" +\n                    "ta name=\\"DC.title\\" content=\\"Pretty Diff - The difference tool\\"/> <link rel" +\n                    "=\\"canonical\\" href=\\"http://prettydiff.com/\\" type=\\"application/xhtml+xml\\"/" +\n                    "><meta http-equiv=\\"Content-Type\\" content=\\"application/xhtml+xml;charset=UTF" +\n                    "-8\\"/><meta http-equiv=\\"Content-Style-Type\\" content=\\"text/css\\"/><style typ" +\n                    "e=\\"text/css\\">/*<![CDATA[*\\/",\n            intro : "\\"><div class=\\"contentarea\\" id=\\"report\\"><section role=\\"heading\\"><h1><svg" +\n                    " height=\\"2000.000000pt\\" id=\\"pdlogo\\" preserveAspectRatio=\\"xMidYMid meet\\" " +\n                    "version=\\"1.0\\" viewBox=\\"0 0 2000.000000 2000.000000\\" width=\\"2000.000000pt" +\n                    "\\" xmlns=\\"http://www.w3.org/2000/svg\\"><g fill=\\"#999\\" stroke=\\"none\\" trans" +\n                    "form=\\"translate(0.000000,2000.000000) scale(0.100000,-0.100000)\\"> <path d=\\"" +\n                    "M14871 18523 c-16 -64 -611 -2317 -946 -3588 -175 -660 -319 -1202 -320 -1204 -2" +\n                    " -2 -50 39 -107 91 -961 876 -2202 1358 -3498 1358 -1255 0 -2456 -451 -3409 -12" +\n                    "79 -161 -140 -424 -408 -560 -571 -507 -607 -870 -1320 -1062 -2090 -58 -232 -38" +\n                    "6 -1479 -2309 -8759 -148 -563 -270 -1028 -270 -1033 0 -4 614 -8 1365 -8 l1364 " +\n                    "0 10 38 c16 63 611 2316 946 3587 175 660 319 1202 320 1204 2 2 50 -39 107 -91 " +\n                    "543 -495 1169 -862 1863 -1093 1707 -568 3581 -211 4965 946 252 210 554 524 767" +\n                    " 796 111 143 312 445 408 613 229 406 408 854 525 1320 57 225 380 1451 2310 875" +\n                    "9 148 563 270 1028 270 1033 0 4 -614 8 -1365 8 l-1364 0 -10 -37z m-4498 -5957 " +\n                    "c477 -77 889 -256 1245 -542 523 -419 850 -998 954 -1689 18 -121 18 -549 0 -670" +\n                    " -80 -529 -279 -972 -612 -1359 -412 -480 -967 -779 -1625 -878 -121 -18 -549 -1" +\n                    "8 -670 0 -494 74 -918 255 -1283 548 -523 419 -850 998 -954 1689 -18 121 -18 54" +\n                    "9 0 670 104 691 431 1270 954 1689 365 293 828 490 1283 545 50 6 104 13 120 15 " +\n                    "72 10 495 -3 588 -18z\\"/></g></svg><a href=\\"prettydiff.com.xhtml\\">Pretty Dif" +\n                    "f</a></h1><p id=\\"dcolorScheme\\"><label class=\\"label\\" for=\\"colorScheme\\">Co" +\n                    "lor Scheme</label><select id=\\"colorScheme\\"><option>Canvas</option><option>Sh" +\n                    "adow</option><option selected=\\"selected\\">White</option></select></p><p>Find " +\n                    "<a href=\\"https://github.com/prettydiff/prettydiff\\">Pretty Diff on GitHub</a>" +\n                    ".</p></section><section role=\\"main\\">",\n            script: "</section></div><script type=\\"application/javascript\\">//<![CDATA[\\r\\n"\n        },\n        script: {\n            beautify: "var pd={};pd.colorchange=function(){\\"use strict\\";var options=this.getElement" +\n                    "sByTagName(\\"option\\");document.getElementsByTagName(\\"body\\")[0].setAttribute" +\n                    "(\\"class\\",options[this.selectedIndex].innerHTML.toLowerCase());};pd.colorsche" +\n                    "me=document.getElementById(\\"colorScheme\\");pd.colorscheme.onchange=pd.colorch" +\n                    "ange;pd.beaufold=function dom__beaufold(){\\"use strict\\";var self=this,title=s" +\n                    "elf.getAttribute(\\"title\\").split(\\"line \\"),min=Number(title[1].substr(0,titl" +\n                    "e[1].indexOf(\\" \\"))),max=Number(title[2]),a=0,b=\\"\\",list=[self.parentNode.ge" +\n                    "tElementsByTagName(\\"li\\"),self.parentNode.nextSibling.getElementsByTagName(\\"" +\n                    "li\\")];if(self.innerHTML.charAt(0)===\\"-\\"){for(a=min;a<max;a=a+1){list[0][a]." +\n                    "style.display=\\"none\\";list[1][a].style.display=\\"none\\";}self.innerHTML=\\"+\\"" +\n                    "+self.innerHTML.substr(1);}else{for(a=min;a<max;a=a+1){list[0][a].style.displa" +\n                    "y=\\"block\\";list[1][a].style.display=\\"block\\";if(list[0][a].getAttribute(\\"cl" +\n                    "ass\\")===\\"fold\\"&&list[0][a].innerHTML.charAt(0)===\\"+\\"){b=list[0][a].getAtt" +\n                    "ribute(\\"title\\");b=b.substring(b.indexOf(\\"to line \\")+1);a=Number(b)-1;}}sel" +\n                    "f.innerHTML=\\"-\\"+self.innerHTML.substr(1);}};(function(){\\"use strict\\";var l" +\n                    "ists=document.getElementsByTagName(\\"ol\\"),listslen=lists.length,list=[],listl" +\n                    "en=0,a=0,b=0;for(a=0;a<listslen;a+=1){if(lists[a].getAttribute(\\"class\\")===\\"" +\n                    "count\\"&&lists[a].parentNode.getAttribute(\\"class\\")===\\"beautify\\"){list=list" +\n                    "s[a].getElementsByTagName(\\"li\\");listlen=list.length;for(b=0;b<listlen;b=b+1)" +\n                    "{if(list[b].getAttribute(\\"class\\")===\\"fold\\"){list[b].onmousedown=pd.beaufol" +\n                    "d;}}}}}());",\n            diff    : "var pd={};pd.colorchange=function(){\\"use strict\\";var options=this.getElement" +\n                    "sByTagName(\\"option\\");document.getElementsByTagName(\\"body\\")[0].setAttribute" +\n                    "(\\"class\\",options[this.selectedIndex].innerHTML.toLowerCase())};pd.difffold=f" +\n                    "unction dom__difffold(){\\"use strict\\";var a=0,b=0,self=this,title=self.getAtt" +\n                    "ribute(\\"title\\").split(\\"line \\"),min=Number(title[1].substr(0,title[1].index" +\n                    "Of(\\" \\"))),max=Number(title[2]),inner=self.innerHTML,lists=[],parent=self.par" +\n                    "entNode.parentNode,listnodes=(parent.getAttribute(\\"class\\")===\\"diff\\")?paren" +\n                    "t.getElementsByTagName(\\"ol\\"):parent.parentNode.getElementsByTagName(\\"ol\\")," +\n                    "listLen=listnodes.length;for(a=0;a<listLen;a=a+1){lists.push(listnodes[a].getE" +\n                    "lementsByTagName(\\"li\\"))}max=(max>=lists[0].length)?lists[0].length:max;if(in" +\n                    "ner.charAt(0)===\\"-\\"){self.innerHTML=\\"+\\"+inner.substr(1);for(a=min;a<max;a=" +\n                    "a+1){for(b=0;b<listLen;b=b+1){lists[b][a].style.display=\\"none\\"}}}else{self.i" +\n                    "nnerHTML=\\"-\\"+inner.substr(1);for(a=min;a<max;a=a+1){for(b=0;b<listLen;b=b+1)" +\n                    "{lists[b][a].style.display=\\"block\\"}}}};pd.colSliderGrab=function(e){\\"use st" +\n                    "rict\\";var event=e||window.event,touch=(e!==null&&e.type===\\"touchstart\\"),nod" +\n                    "e=this,diffRight=node.parentNode,diff=diffRight.parentNode,subOffset=0,lists=d" +\n                    "iff.getElementsByTagName(\\"ol\\"),counter=lists[0].clientWidth,data=lists[1].cl" +\n                    "ientWidth,width=lists[2].parentNode.clientWidth,total=lists[2].parentNode.pare" +\n                    "ntNode.clientWidth,offset=lists[2].parentNode.offsetLeft-lists[2].parentNode.p" +\n                    "arentNode.offsetLeft,min=((total-counter-data-2)-width),max=(total-width-count" +\n                    "er),status=\\"ew\\",minAdjust=min+15,maxAdjust=max-15,withinRange=false,diffLeft" +\n                    "=diffRight.previousSibling,drop=function dom__event_colSliderGrab_drop(f){f=f|" +\n                    "|window.event;f.preventDefault();node.style.cursor=status+\\"-resize\\";if(touch" +\n                    "===true){document.ontouchmove=null;document.ontouchend=null}else{document.onmo" +\n                    "usemove=null;document.onmouseup=null}},boxmove=function dom__event_colSliderGr" +\n                    "ab_boxmove(f){f=f||window.event;f.preventDefault();if(touch===true){subOffset=" +\n                    "offset-f.touches[0].clientX}else{subOffset=offset-f.clientX}if(subOffset>minAd" +\n                    "just&&subOffset<maxAdjust){withinRange=true}if(withinRange===true&&subOffset>m" +\n                    "axAdjust){diffRight.style.width=((total-counter-2)/10)+\\"em\\";status=\\"e\\"}els" +\n                    "e if(withinRange===true&&subOffset<minAdjust){diffRight.style.width=((total-co" +\n                    "unter-data-2)/10)+\\"em\\";status=\\"w\\"}else if(subOffset<max&&subOffset>min){di" +\n                    "ffRight.style.width=((width+subOffset)/10)+\\"em\\";status=\\"ew\\"}if(touch===tru" +\n                    "e){document.ontouchend=drop}else{document.onmouseup=drop}};event.preventDefaul" +\n                    "t();if(typeof pd.data===\\"object\\"&&pd.data.node.report.code.box!==null){offse" +\n                    "t=offset+pd.data.node.report.code.box.offsetLeft;offset=offset-pd.data.node.re" +\n                    "port.code.body.scrollLeft}else{subOffset=(document.body.parentNode.scrollLeft>" +\n                    "document.body.scrollLeft)?document.body.parentNode.scrollLeft:document.body.sc" +\n                    "rollLeft;offset=offset-subOffset}offset=offset+node.clientWidth;node.style.cur" +\n                    "sor=\\"ew-resize\\";diff.style.width=(total/10)+\\"em\\";diff.style.display=\\"inli" +\n                    "ne-block\\";if(diffLeft.nodeType!==1){do{diffLeft=diffLeft.previousSibling}whil" +\n                    "e(diffLeft.nodeType!==1)}diffLeft.style.display=\\"block\\";diffRight.style.widt" +\n                    "h=(diffRight.clientWidth/10)+\\"em\\";diffRight.style.position=\\"absolute\\";if(t" +\n                    "ouch===true){document.ontouchmove=boxmove;document.ontouchstart=false}else{doc" +\n                    "ument.onmousemove=boxmove;document.onmousedown=null}return false};(function(){" +\n                    "\\"use strict\\";var lists=document.getElementById(\\"prettydiff\\").getElementsBy" +\n                    "TagName(\\"ol\\"),cells=lists[0].getElementsByTagName(\\"li\\"),len=cells.length,a" +\n                    "=0;for(a=0;a<len;a=a+1){if(cells[a].getAttribute(\\"class\\")===\\"fold\\"){cells[" +\n                    "a].onclick=pd.difffold}}if(lists.length>3){lists[2].onmousedown=pd.colSliderGr" +\n                    "ab;lists[2].ontouchstart=pd.colSliderGrab}pd.colorscheme=document.getElementBy" +\n                    "Id(\\"colorScheme\\");pd.colorscheme.onchange=pd.colorchange}());",\n            minimal : "var pd={};pd.colorchange=function(){\\"use strict\\";var options=this.getElement" +\n                    "sByTagName(\\"option\\");document.getElementsByTagName(\\"body\\")[0].setAttribute" +\n                    "(\\"class\\",options[this.selectedIndex].innerHTML.toLowerCase())};document.getE" +\n                    "lementById(\\"colorScheme\\").onchange=pd.colorchange;"\n        }\n    };\n    finalFile.order = [\n        finalFile.html.head, //0\n        finalFile.css.color.canvas, //1\n        finalFile.css.color.shadow, //2\n        finalFile.css.color.white, //3\n        finalFile.css.reports, //4\n        finalFile.css.global, //5\n        finalFile.html.body, //6\n        finalFile.html.color, //7\n        finalFile.html.intro, //8\n        "", //9 - for meta analysis, like stats and accessibility\n        "", //10 - for generated report\n        finalFile.html.script, //11\n        finalFile.script.minimal, //12\n        finalFile.html.end //13\n    ];\n    global.prettydiff.finalFile = finalFile;\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function finalFile_requirejs() {\n            return global.prettydiff.finalFile;\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = global.prettydiff.finalFile;\n    }\n}());\n'},function(n,e,t){"use strict";t(1)(t(36))},function(n,e){n.exports='/*prettydiff.com api.topcoms:true,api.insize:4,api.inchar:" ",api.vertical:true */\n/*global ace, define, global, module*/\n/***********************************************************************\n safeSort is written by Austin Cheney on 23 Apr 2015.\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n **********************************************************************/\n(function safeSort_init() {\n    "use strict";\n    var safeSort = function safeSort_(array, operation, recursive) {\n        var arTest  = function safeSort_arTest(item) {\n                if (typeof item !== "object" || item.length === undefined || item.length < 2) {\n                    return false;\n                }\n                return true;\n            },\n            extref  = function safeSort__extref() {\n                //worthless function for backwards compatibility with older versions of V8 node.\n                return;\n            },\n            normal  = function safeSort__normal(item) {\n                var done    = [item[0]],\n                    storeb  = item,\n                    child   = function safeSort__normal_child() {\n                        var a   = 0,\n                            len = storeb.length;\n                        for (a = 0; a < len; a = a + 1) {\n                            if (arTest(storeb[a]) === true) {\n                                storeb[a] = safeSort__normal(storeb[a]);\n                            }\n                        }\n                    },\n                    recurse = function safeSort__normal_recurse(x) {\n                        var a      = 0,\n                            storea = [],\n                            len    = storeb.length;\n                        for (a = 0; a < len; a = a + 1) {\n                            if (storeb[a] !== x) {\n                                storea.push(storeb[a]);\n                            }\n                        }\n                        storeb = storea;\n                        if (storea.length > 0) {\n                            done.push(storea[0]);\n                            extref(storea[0]);\n                        } else {\n                            if (recursive === true) {\n                                child();\n                            }\n                            item = storeb;\n                        }\n                    };\n                extref = recurse;\n                recurse(array[0]);\n            },\n            descend = function safeSort__descend(item) {\n                var c       = 0,\n                    storeb  = item,\n                    len     = item.length,\n                    child   = function safeSort__descend_child() {\n                        var a    = 0,\n                            lenc = storeb.length;\n                        for (a = 0; a < lenc; a = a + 1) {\n                            if (arTest(storeb[a]) === true) {\n                                storeb[a] = safeSort__descend(storeb[a]);\n                            }\n                        }\n                    },\n                    recurse = function safeSort__descend_recurse() {\n                        var a      = 0,\n                            b      = 0,\n                            d      = 0,\n                            e      = 0,\n                            ind    = [],\n                            key    = storeb[c],\n                            tstore = "",\n                            tkey   = typeof key;\n                        for (a = c; a < len; a = a + 1) {\n                            tstore = typeof storeb[a];\n                            if (storeb[a] > key || (tstore > tkey)) {\n                                key = storeb[a];\n                                ind = [a];\n                            } else if (storeb[a] === key) {\n                                ind.push(a);\n                            }\n                        }\n                        d = ind.length;\n                        b = d + c;\n                        for (a = c; a < b; a = a + 1) {\n                            storeb[ind[e]] = storeb[a];\n                            storeb[a]      = key;\n                            e              = e + 1;\n                        }\n                        c = c + d;\n                        if (c < len) {\n                            extref();\n                        } else {\n                            if (recursive === true) {\n                                child();\n                            }\n                            item = storeb;\n                        }\n                    };\n                extref = recurse;\n                recurse();\n                return item;\n            },\n            ascend  = function safeSort__ascend(item) {\n                var c       = 0,\n                    storeb  = item,\n                    len     = item.length,\n                    child   = function safeSort__ascend_child() {\n                        var a    = 0,\n                            lenc = storeb.length;\n                        for (a = 0; a < lenc; a = a + 1) {\n                            if (arTest(storeb[a]) === true) {\n                                storeb[a] = safeSort__ascend(storeb[a]);\n                            }\n                        }\n                    },\n                    recurse = function safeSort__ascend_recurse() {\n                        var a      = 0,\n                            b      = 0,\n                            d      = 0,\n                            e      = 0,\n                            ind    = [],\n                            key    = storeb[c],\n                            tstore = "",\n                            tkey   = typeof key;\n                        for (a = c; a < len; a = a + 1) {\n                            tstore = typeof storeb[a];\n                            if (storeb[a] < key || tstore < tkey) {\n                                key = storeb[a];\n                                ind = [a];\n                            } else if (storeb[a] === key) {\n                                ind.push(a);\n                            }\n                        }\n                        d = ind.length;\n                        b = d + c;\n                        for (a = c; a < b; a = a + 1) {\n                            storeb[ind[e]] = storeb[a];\n                            storeb[a]      = key;\n                            e              = e + 1;\n                        }\n                        c = c + d;\n                        if (c < len) {\n                            extref();\n                        } else {\n                            if (recursive === true) {\n                                child();\n                            }\n                            item = storeb;\n                        }\n                    };\n                extref = recurse;\n                recurse();\n                return item;\n            };\n        if (arTest(array) === false) {\n            return array;\n        }\n        if (recursive === "true") {\n            recursive = true;\n        } else if (recursive !== true) {\n            recursive = false;\n        }\n        if (operation === "normal") {\n            return normal(array);\n        }\n        if (operation === "descend") {\n            return descend(array);\n        }\n        return ascend(array);\n    };\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function safeSort_requirejs() {\n            return function safeSort_requirejs_wrapper(x, y, z) {\n                return safeSort(x, y, z);\n            };\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = safeSort;\n    } else {\n        global.prettydiff.safeSort = safeSort;\n    }\n}());\n'},function(n,e,t){"use strict";t(1)(t(38))},function(n,e){n.exports='/*prettydiff.com topcoms:true,insize:4,inchar:" ",vertical:true */\n/*jshint laxbreak: true*/\n/*global ace, define, global, module*/\n/***********************************************************************\n csspretty is written by Austin Cheney on 7 Aug 2014.\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n\n **********************************************************************/\n/*\n This application beautifies CSS code as well as SCSS (Sass) and LESS\n variants. This application was written with extension in mind using the\n same array based architecture used for the markuppretty and jspretty\n libraries.  The architecture focuses on separation of roles.  The first\n area of the application reads the code and writes an array of tokens.\n The second area is the algorithm that determines what white space and\n indentation should be applied.  The final area is a report on the\n analysis of the code.\n -----------------------------------------------------------------------\n */\n(function () {\n    "use strict";\n    var csspretty = function csspretty_(options) {\n        var token      = [],\n            types      = [],\n            lines      = [],\n            depth      = [],\n            begin      = [],\n            uri        = [],\n            colors     = [],\n            output     = "",\n            endline    = false,\n            objsortop  = false,\n            verticalop = false,\n            colorNames = {\n                aliceblue           : 0.9288006825347457,\n                antiquewhite        : 0.8464695170775405,\n                aqua                : 0.7874,\n                aquamarine          : 0.8078549208338043,\n                azure               : 0.9726526495416643,\n                beige               : 0.8988459998705021,\n                bisque              : 0.8073232737297876,\n                black               : 0,\n                blanchedalmond      : 0.8508443960815607,\n                blue                : 0.0722,\n                blueviolet          : 0.12622014321946043,\n                brown               : 0.09822428787651079,\n                burlywood           : 0.5155984453389335,\n                cadetblue           : 0.29424681085422044,\n                chartreuse          : 0.7603202590262282,\n                chocolate           : 0.23898526114557292,\n                coral               : 0.3701793087292368,\n                cornflowerblue      : 0.30318641994179363,\n                cornsilk            : 0.9356211037296492,\n                crimson             : 0.16042199953025577,\n                cyan                : 0.7874,\n                darkblue            : 0.018640801980939217,\n                darkcyan            : 0.2032931783904645,\n                darkgoldenrod       : 0.27264703559992554,\n                darkgray            : 0.39675523072562674,\n                darkgreen           : 0.09114342904757505,\n                darkgrey            : 0.39675523072562674,\n                darkkhaki           : 0.45747326349994155,\n                darkmagenta         : 0.07353047651207048,\n                darkolivegreen      : 0.12651920884889156,\n                darkorange          : 0.40016167026523863,\n                darkorchid          : 0.1341314217485677,\n                darkred             : 0.05488967453113126,\n                darksalmon          : 0.4054147156338075,\n                darkseagreen        : 0.43789249325969054,\n                darkslateblue       : 0.06579284622798763,\n                darkslategray       : 0.06760815192804355,\n                darkslategrey       : 0.06760815192804355,\n                darkturquoise       : 0.4874606277449034,\n                darkviolet          : 0.10999048339343433,\n                deeppink            : 0.2386689582827583,\n                deepskyblue         : 0.444816033955754,\n                dimgray             : 0.14126329114027164,\n                dimgrey             : 0.14126329114027164,\n                dodgerblue          : 0.2744253699145608,\n                firebrick           : 0.10724525535015225,\n                floralwhite         : 0.9592248482500424,\n                forestgreen         : 0.18920812076002244,\n                fuchsia             : 0.2848,\n                gainsboro           : 0.7156935005064806,\n                ghostwhite          : 0.9431126188632283,\n                gold                : 0.6986087742815887,\n                goldenrod           : 0.41919977809568404,\n                gray                : 0.21586050011389915,\n                green               : 0.15438342968146068,\n                greenyellow         : 0.8060947261145331,\n                grey                : 0.21586050011389915,\n                honeydew            : 0.9633653555478173,\n                hotpink             : 0.3465843816971475,\n                indianred           : 0.21406134963884,\n                indigo              : 0.031075614863369846,\n                ivory               : 0.9907127060061531,\n                khaki               : 0.7701234339412052,\n                lavendar            : 0.8031875051452125,\n                lavendarblush       : 0.9017274863104644,\n                lawngreen           : 0.7390589312496334,\n                lemonchiffon        : 0.9403899224562171,\n                lightblue           : 0.6370914128080659,\n                lightcoral          : 0.35522120733134843,\n                lightcyan           : 0.9458729349482863,\n                lightgoldenrodyellow: 0.9334835101829635,\n                lightgray           : 0.651405637419824,\n                lightgreen          : 0.6909197995686475,\n                lightgrey           : 0.651405637419824,\n                lightpink           : 0.5856615273489745,\n                lightsalmon         : 0.47806752252059587,\n                lightseagreen       : 0.3505014511704197,\n                lightskyblue        : 0.5619563761833096,\n                lightslategray      : 0.23830165007286924,\n                lightslategrey      : 0.23830165007286924,\n                lightyellow         : 0.9816181839288161,\n                lime                : 0.7152,\n                limegreen           : 0.44571042246097864,\n                linen               : 0.8835734098437936,\n                magenta             : 0.2848,\n                maroon              : 0.04589194232421496,\n                mediumaquamarine    : 0.4938970331080111,\n                mediumblue          : 0.04407778021232784,\n                mediumorchid        : 0.21639251153773428,\n                mediumpurple        : 0.22905858091648004,\n                mediumseagreen      : 0.34393112338131226,\n                mediumslateblue     : 0.20284629471622434,\n                mediumspringgreen   : 0.7070430819418444,\n                mediumturquois      : 0.5133827926447991,\n                mediumvioletred     : 0.14371899849357186,\n                midnightblue        : 0.020717866350860484,\n                mintcream           : 0.9783460494758793,\n                mistyrose           : 0.8218304785918541,\n                moccasin            : 0.8008300099156694,\n                navajowhite         : 0.7651968234278562,\n                navy                : 0.015585128108223519,\n                oldlace             : 0.9190063340554899,\n                olive               : 0.20027537200567563,\n                olivedrab           : 0.2259315095192918,\n                orange              : 0.48170267036309605,\n                orangered           : 0.2551624375341641,\n                orchid              : 0.3134880676143873,\n                palegoldenrod       : 0.7879264788761452,\n                palegreen           : 0.7793675900635259,\n                paleturquoise       : 0.764360779217138,\n                palevioletred       : 0.2875499411788909,\n                papayawhip          : 0.8779710019983541,\n                peachpuff           : 0.7490558987825108,\n                peru                : 0.3011307487793569,\n                pink                : 0.6327107070246611,\n                plum                : 0.4573422158796909,\n                powderblue          : 0.6825458650060524,\n                purple              : 0.061477070432438476,\n                red                 : 0.2126,\n                rosyblue            : 0.3231945764940708,\n                royalblue           : 0.16663210743188323,\n                saddlebrown         : 0.09792228502052071,\n                salmon              : 0.3697724152759545,\n                sandybrown          : 0.46628543696283414,\n                seagreen            : 0.1973419970627483,\n                seashell            : 0.927378622069223,\n                sienna              : 0.13697631337097677,\n                silver              : 0.527115125705813,\n                skyblue             : 0.5529166851818412,\n                slateblue           : 0.14784278062136097,\n                slategray           : 0.20896704076536138,\n                slategrey           : 0.20896704076536138,\n                slightsteelblue     : 0.5398388828466575,\n                snow                : 0.9653334183484877,\n                springgreen         : 0.7305230606852947,\n                steelblue           : 0.20562642207624846,\n                tan                 : 0.48237604163921527,\n                teal                : 0.1699685577896842,\n                thistle             : 0.5681840109373312,\n                tomato              : 0.3063861271941505,\n                turquoise           : 0.5895536427577983,\n                violet              : 0.40315452986676303,\n                wheat               : 0.7490970282048214,\n                white               : 1,\n                whitesmoke          : 0.913098651793419,\n                yellow              : 0.9278,\n                yellowgreen         : 0.5076295720870697\n            },\n            stats      = {\n                braces    : 0,\n                colon     : 0,\n                comments  : {\n                    chars: 0,\n                    count: 0\n                },\n                properties: {\n                    chars: 0,\n                    count: 0\n                },\n                selectors : {\n                    chars: 0,\n                    count: 0\n                },\n                semi      : 0,\n                space     : 0,\n                values    : {\n                    chars: 0,\n                    count: 0\n                },\n                variables : {\n                    chars: 0,\n                    count: 0\n                }\n            },\n            lf         = (options.crlf === true || options.crlf === "true")\n                ? "\\r\\n"\n                : "\\n";\n        (function csspretty__options() {\n            objsortop      = (\n                options.objsort === true || options.objsort === "true" || options.objsort === "all" || options.objsort === "css"\n            );\n            verticalop     = (\n                options.compressedcss === false && (options.vertical === true || options.vertical === "true" || options.vertical === "all" || options.vertical === "css")\n            );\n            options.source = (\n                typeof options.source === "string" && options.source.length > 0\n            )\n                ? options\n                    .source\n                    .replace(/\\r\\n?/g, "\\n") + " "\n                : "Error: no source code supplied to csspretty!";\n        }());\n        if (typeof options.source !== "string" || options.source === "" || (/^(\\s+)$/).test(options.source) === true) {\n            if (options.nodeasync === true) {\n                return [options.source, "Error: no source supplied to csspretty."];\n            }\n            if (global.prettydiff.meta === undefined) {\n                global.prettydiff.meta = {};\n            }\n            global.prettydiff.meta.error = options.source;\n            return options.source;\n        }\n        (function csspretty__tokenize() {\n            var a          = 0,\n                b          = options\n                    .source\n                    .split(""),\n                len        = options.source.length,\n                ltype      = "",\n                itemsize   = 0,\n                space      = "",\n                endtest    = false,\n                struct     = [0],\n                mapper     = [],\n                structval  = "root",\n                nosort     = [],\n                esctest    = function csspretty__tokenize_esctest(xx) {\n                    var yy = xx;\n                    do {\n                        xx = xx - 1;\n                    } while (xx > 0 && b[xx] === "\\\\");\n                    if ((yy - xx) % 2 === 0) {\n                        return true;\n                    }\n                    return false;\n                },\n                // Since I am already identifying value types this is a good place to do some\n                // quick analysis and clean up on certain value conditions. These things are\n                // being corrected:\n                //  * fractional values missing a leading 0 are    provided a leading 0\n                // * 0 values with a dimension indicator    (px, em) have the dimension\n                // indicator    removed\n                //  * eliminate unnecessary leading 0s\n                //  * url values that are not quoted are wrapped    in double quote characters\n                // * color values are set to lowercase and    reduced from 6 to 3 digits if\n                // appropriate\n                value      = function csspretty__tokenize_item_value(val, font) {\n                    var x         = val.split(""),\n                        leng      = x.length,\n                        cc        = 0,\n                        dd        = 0,\n                        items     = [],\n                        block     = "",\n                        values    = [],\n                        qchar     = "",\n                        qreg      = {},\n                        transition = (token[token.length - 3] === "transition"),\n                        colorPush = function csspretty__tokenize_item_value_colorPush(value) {\n                            var vl = value.toLowerCase();\n                            if ((/^(#[0-9a-f]{3,6})$/).test(vl) === true) {\n                                colors.push(value);\n                            } else if ((/^(rgba?\\()/).test(vl) === true) {\n                                colors.push(value);\n                            } else if (colorNames[vl] !== undefined) {\n                                colors.push(value);\n                            }\n                            return value;\n                        };\n                    if (options.quoteConvert === "double") {\n                        qchar = "\\"";\n                    } else if (options.quoteConvert === "single") {\n                        qchar = "\'";\n                    }\n                    // this loop identifies containment so that tokens/sub-tokens are correctly\n                    // taken\n                    for (cc = 0; cc < leng; cc = cc + 1) {\n                        items.push(x[cc]);\n                        if (block === "") {\n                            if (x[cc] === "\\"") {\n                                block = "\\"";\n                                dd    = dd + 1;\n                            } else if (x[cc] === "\'") {\n                                block = "\'";\n                                dd    = dd + 1;\n                            } else if (x[cc] === "(") {\n                                block = ")";\n                                dd    = dd + 1;\n                            } else if (x[cc] === "[") {\n                                block = "]";\n                                dd    = dd + 1;\n                            }\n                        } else if ((x[cc] === "(" && block === ")") || (x[cc] === "[" && block === "]")) {\n                            dd = dd + 1;\n                        } else if (x[cc] === block) {\n                            dd = dd - 1;\n                            if (dd === 0) {\n                                block = "";\n                            }\n                        }\n                        if (block === "" && x[cc] === " ") {\n                            items.pop();\n                            values.push(colorPush(items.join("")));\n                            items = [];\n                        }\n                    }\n                    values.push(colorPush(items.join("")));\n                    leng = values.length;\n                    //This is where the rules mentioned above are applied\n                    for (cc = 0; cc < leng; cc = cc + 1) {\n                        if (options.noleadzero === false && (/^(\\.\\d)/).test(values[cc]) === true) {\n                            values[cc] = "0" + values[cc];\n                        } else if (options.noleadzero === true && (/^(0+\\.)/).test(values[cc])) {\n                            values[cc] = values[cc].replace(/^(0+\\.)/, ".");\n                        } else if ((/^(0+([a-z]{2,3}|%))$/).test(values[cc]) === true && transition === false) {\n                            values[cc] = "0";\n                        } else if ((/^(0+)/).test(values[cc]) === true) {\n                            values[cc] = values[cc].replace(/0+/, "0");\n                            if ((/\\d/).test(values[cc].charAt(1)) === true) {\n                                values[cc] = values[cc].substr(1);\n                            }\n                        } else if ((/^url\\((?!\\$)/).test(values[cc]) === true && values[cc].charAt(values[cc].length - 1) === ")") {\n                            block = values[cc].charAt(values[cc].indexOf("url(") + 4);\n                            if (block !== "@" && block !== "{" && block !== "<") {\n                                if (qchar === "") {\n                                    values[cc] = values[cc]\n                                        .replace(/url\\(\\s*(\'|")?/, "url(\\"")\n                                        .replace(/((\'|")?\\s*\\))$/, "\\")");\n                                } else {\n                                    values[cc] = values[cc]\n                                        .replace(/url\\(\\s*(\'|")?/, "url(" + qchar)\n                                        .replace(/((\'|")?\\s*\\))$/, qchar + ")");\n                                }\n                            }\n                        } else if (font === true) {\n                            if (qchar === "\'") {\n                                values[cc] = values[cc].replace(/"/g, "\'");\n                            } else {\n                                values[cc] = values[cc].replace(/\'/g, "\\"");\n                            }\n                        } else if (font === false && qchar !== "" && ((qchar === "\\"" && values[cc].charAt(0) === "\'" && values[cc].charAt(values[cc].length - 1) === "\'") || (qchar === "\'" && values[cc].charAt(0) === "\\"" && values[cc].charAt(values[cc].length - 1) === "\\""))) {\n                            qreg       = new RegExp(qchar, "g");\n                            values[cc] = qchar + values[cc]\n                                .slice(1, values[cc].length - 1)\n                                .replace(qreg, "\\\\" + qchar) + qchar;\n                        }\n                    }\n                    return values.join(" ");\n                },\n                //map location of empty lines for beautification\n                spacer     = function csspretty__tokenize_space(end) {\n                    var slen = space\n                            .split(lf)\n                            .length - 1,\n                        val  = 0;\n                    if (token.length === 0 && slen > 0) {\n                        slen = slen + 1;\n                    }\n                    if (slen > 0 && options.preserve > 0) {\n                        if (slen > options.preserve) {\n                            val = options.preserve + 1;\n                        } else {\n                            val = slen;\n                        }\n                    } else if (space.length > 1) {\n                        val = 1;\n                    } else if (slen === 0 && types[types.length - 1] === "comment" && types[types.length - 2] !== "comment") {\n                        types[types.length - 1] = "comment-inline";\n                    }\n                    if (slen > 1 && end === true && options.preserve > 0) {\n                        endline = true;\n                        space   = "";\n                        return val;\n                    }\n                    space = "";\n                    return val;\n                },\n                //sort parsed properties intelligently\n                objSort    = function csspretty__tokenize_objSort() {\n                    var cc        = 0,\n                        dd        = 0,\n                        ee        = 0,\n                        startlen  = token.length - 1,\n                        end       = startlen,\n                        keys      = [],\n                        keylen    = 0,\n                        keyend    = 0,\n                        start     = 0,\n                        sort      = function csspretty__tokenize_objSort_sort(x, y) {\n                            var xx = x[0],\n                                yy = y[0];\n                            if (types[xx] === "comment" || types[xx] === "comment-inline") {\n                                do {\n                                    xx = xx + 1;\n                                } while (\n                                    xx < startlen && (types[xx] === "comment" || types[xx] === "comment-inline")\n                                );\n                            }\n                            if (types[yy] === "comment" || types[yy] === "comment-inline") {\n                                do {\n                                    yy = yy + 1;\n                                } while (\n                                    yy < startlen && (types[yy] === "comment" || types[yy] === "comment-inline")\n                                );\n                            }\n                            if (types[xx] < types[yy]) {\n                                return -1;\n                            }\n                            if (types[xx] === types[yy] && token[xx].toLowerCase() < token[yy].toLowerCase()) {\n                                return -1;\n                            }\n                            return 1;\n                        },\n                        semiTest  = true,\n                        pairToken = [],\n                        pairTypes = [],\n                        pairLines = [],\n                        pairDepth = [],\n                        pairBegin = [];\n                    if (types[end] === "comment" || types[end] === "comment-inline") {\n                        do {\n                            end = end - 1;\n                        } while (\n                            end > 0 && (types[end] === "comment" || types[end] === "comment-inline")\n                        );\n                    }\n                    for (cc = startlen; cc > -1; cc = cc - 1) {\n                        if (types[cc] === "end") {\n                            dd = dd + 1;\n                        }\n                        if (types[cc] === "start") {\n                            dd = dd - 1;\n                        }\n                        if (dd === 0) {\n                            if ((types[cc] === "property" || types[cc] === "selector" || types[cc] === "propvar") && types[cc - 1] !== "property" && types[cc - 1] !== "selector") {\n                                start = cc;\n                                if (types[end + 1] === "comment-inline") {\n                                    end = end + 1;\n                                }\n                                if (types[start - 1] === "comment") {\n                                    do {\n                                        start = start - 1;\n                                    } while (start > -1 && types[start - 1] === "comment");\n                                }\n                                keys.push([\n                                    start, end + 1,\n                                    false\n                                ]);\n                                end = start - 1;\n                            }\n                        }\n                        if (dd < 0 && cc < startlen) {\n                            if (keys.length > 1 && (types[cc - 1] === "selector" || types[cc - 1] === "propvar" || (types[cc - 2] === "propvar" && types[cc - 1] === "value") || token[cc - 1] === "=" || token[cc - 1] === ":" || token[cc - 1] === "[" || token[cc - 1] === "{" || (token[cc - 1] === "," && structval !== "map") || cc === 0)) {\n                                if (structval === "map" && token[token.length - 1] !== ",") {\n                                    token.push(",");\n                                    types.push("semi");\n                                    lines.push(0);\n                                    depth.push(depth[depth.length - 1]);\n                                    begin.push(begin[begin.length - 1]);\n                                    keys[0][1] = keys[0][1] + 1;\n                                }\n                                keys.sort(sort);\n                                keylen   = keys.length;\n                                semiTest = false;\n                                for (dd = 0; dd < keylen; dd = dd + 1) {\n                                    keyend = keys[dd][1];\n                                    for (ee = keys[dd][0]; ee < keyend; ee = ee + 1) {\n                                        pairToken.push(token[ee]);\n                                        pairTypes.push(types[ee]);\n                                        pairLines.push(lines[ee]);\n                                        pairDepth.push(depth[ee]);\n                                        pairBegin.push(begin[ee]);\n                                        if ((token[ee] === ";" && structval === "block") || (token[ee] === "," && structval === "map") || token[ee] === "}") {\n                                            semiTest = true;\n                                        } else if ((structval === "block" && token[ee] !== ";") && (structval === "map" && token[ee] !== ",") && token[ee] !== "}" && types[ee] !== "comment" && types[ee] !== "comment-inline") {\n                                            semiTest = false;\n                                        }\n                                    }\n                                    if (semiTest === false) {\n                                        ee = pairTypes.length - 1;\n                                        if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {\n                                            do {\n                                                ee = ee - 1;\n                                            } while (\n                                                ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\n                                            );\n                                        }\n                                        ee = ee + 1;\n                                        if (structval === "map") {\n                                            pairToken.splice(ee, 0, ",");\n                                        } else {\n                                            pairToken.splice(ee, 0, ";");\n                                        }\n                                        pairTypes.splice(ee, 0, "semi");\n                                        pairDepth.splice(ee, 0, pairDepth[ee]);\n                                        pairBegin.splice(ee, 0, pairBegin[ee]);\n                                        if (pairLines[ee - 1] > 0) {\n                                            pairLines[ee - 1] = 0;\n                                            pairLines.splice(ee, 0, 1);\n                                        } else {\n                                            pairLines.splice(ee, 0, 0);\n                                        }\n                                    }\n                                }\n                                ee = pairTypes.length - 1;\n                                if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {\n                                    do {\n                                        ee = ee - 1;\n                                    } while (\n                                        ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\n                                    );\n                                }\n                                keylen = token.length - (cc + 1);\n                                token.splice(cc + 1, keylen);\n                                types.splice(cc + 1, keylen);\n                                lines.splice(cc + 1, keylen);\n                                depth.splice(cc + 1, keylen);\n                                begin.splice(cc + 1, keylen);\n                                token = token.concat(pairToken);\n                                types = types.concat(pairTypes);\n                                lines = lines.concat(pairLines);\n                                depth = depth.concat(pairDepth);\n                                begin = begin.concat(pairBegin);\n                                if (structval === "map") {\n                                    cc = token.length - 1;\n                                    if (types[cc].indexOf("comment") === 0) {\n                                        do {\n                                            cc = cc - 1;\n                                        } while (types[cc].indexOf("comment") === 0);\n                                    }\n                                    if (token[cc] === ",") {\n                                        token.splice(cc, 1);\n                                        types.splice(cc, 1);\n                                        lines.splice(cc, 1);\n                                        depth.splice(cc, 1);\n                                        begin.splice(cc, 1);\n                                    }\n                                }\n                            }\n                            return;\n                        }\n                    }\n                },\n                //the generic token builder\n                buildtoken = function csspretty__tokenize_build() {\n                    var aa         = 0,\n                        bb         = 0,\n                        out        = [],\n                        block      = [],\n                        outy       = "",\n                        mappy      = 0,\n                        comma      = (\n                            token.length > 0 && token[token.length - 1].charAt(token[token.length - 1].length - 1) === ","\n                        ),\n                        linev      = spacer(false),\n                        spacestart = function () {\n                            if ((/\\s/).test(b[aa + 1]) === true) {\n                                do {\n                                    aa = aa + 1;\n                                } while ((/\\s/).test(b[aa + 1]) === true);\n                            }\n                        };\n                    //this loop accounts for grouping mechanisms\n                    for (aa = a; aa < len; aa = aa + 1) {\n                        out.push(b[aa]);\n                        if (b[aa - 1] !== "\\\\" || esctest(aa) === false) {\n                            if (b[aa] === "\\"" && block[block.length - 1] !== "\'") {\n                                if (block[block.length - 1] === "\\"") {\n                                    block.pop();\n                                } else {\n                                    block.push("\\"");\n                                }\n                            } else if (b[aa] === "\'" && block[block.length - 1] !== "\\"") {\n                                if (block[block.length - 1] === "\'") {\n                                    block.pop();\n                                } else {\n                                    block.push("\'");\n                                }\n                            } else if (block[block.length - 1] !== "\\"" && block[block.length - 1] !== "\'") {\n                                if (b[aa] === "(") {\n                                    mappy = mappy + 1;\n                                    block.push(")");\n                                    spacestart();\n                                } else if (b[aa] === "[") {\n                                    block.push("]");\n                                    spacestart();\n                                } else if (b[aa] === "#" && b[aa + 1] === "{") {\n                                    out.push("{");\n                                    aa = aa + 1;\n                                    block.push("}");\n                                    spacestart();\n                                } else if (b[aa] === block[block.length - 1]) {\n                                    block.pop();\n                                    if ((/\\s/).test(out[out.length - 2]) === true) {\n                                        out.pop();\n                                        do {\n                                            out.pop();\n                                        } while ((/\\s/).test(out[out.length - 1]) === true);\n                                        out.push(b[aa]);\n                                    }\n                                }\n                            }\n                        }\n                        if (structval === "map" && block.length === 0 && (b[aa + 1] === "," || b[aa + 1] === ")")) {\n                            if (b[aa + 1] === ")" && token[token.length - 1] === "(") {\n                                token.pop();\n                                types.pop();\n                                lines.pop();\n                                depth.pop();\n                                begin.pop();\n                                struct.pop();\n                                structval = depth[depth.length - 1];\n                                out       = ["("];\n                                aa        = a - 1;\n                            } else {\n                                break;\n                            }\n                        }\n                        if (b[aa + 1] === ":") {\n                            bb = aa;\n                            if ((/\\s/).test(b[bb]) === true) {\n                                do {\n                                    bb = bb - 1;\n                                } while ((/\\s/).test(b[bb]) === true);\n                            }\n                            outy = b\n                                .slice(bb - 6, bb + 1)\n                                .join("");\n                            if (outy.indexOf("filter") === outy.length - 6 || outy.indexOf("progid") === outy.length - 6) {\n                                outy = "filter";\n                            }\n                        }\n                        if (block.length === 0 && ((b[aa + 1] === ";" && esctest(aa + 1) === false) || (b[aa + 1] === ":" && b[aa] !== ":" && b[aa + 2] !== ":" && outy !== "filter" && outy !== "progid") || b[aa + 1] === "}" || b[aa + 1] === "{" || (b[aa + 1] === "/" && (b[aa + 2] === "*" || b[aa + 2] === "/")))) {\n                            bb = out.length - 1;\n                            if ((/\\s/).test(out[bb]) === true) {\n                                do {\n                                    bb = bb - 1;\n                                    aa = aa - 1;\n                                    out.pop();\n                                } while ((/\\s/).test(out[bb]) === true);\n                            }\n                            break;\n                        }\n                        if (out[0] === "@" && block.length === 0 && (b[aa + 1] === "\\"" || b[aa + 1] === "\'")) {\n                            break;\n                        }\n                    }\n                    a        = aa;\n                    itemsize = out.length;\n                    if (structval === "map" && out[0] === "(") {\n                        mapper[mapper.length - 1] = mapper[mapper.length - 1] - 1;\n                    }\n                    if (comma === true && structval !== "map" && types[types.length - 1] !== "comment" && types[types.length - 1] !== "comment-inline") {\n                        token[token.length - 1] = token[token.length - 1] + out\n                            .join("")\n                            .replace(/\\s+/g, " ")\n                            .replace(/^\\s/, "")\n                            .replace(/\\s$/, "");\n                        return;\n                    }\n                    token.push(\n                        out.join("").replace(/\\s+/g, " ").replace(/^\\s/, "").replace(/\\s$/, "")\n                    );\n                    begin.push(struct[struct.length - 1]);\n                    depth.push(structval);\n                    lines.push(linev);\n                    if (token[token.length - 1].indexOf("extend(") === 0) {\n                        ltype = "pseudo";\n                        types.push("pseudo");\n                    } else if ("\\"\'".indexOf(token[token.length - 1].charAt(0)) > -1 && types[types.length - 1] === "propvar") {\n                        ltype = "item";\n                        types.push("value");\n                    } else if (out[0] === "@" || out[0] === "$") {\n                        if (types[types.length - 1] === "colon" && (types[types.length - 2] === "property" || types[types.length - 2] === "propvar")) {\n                            ltype = "value";\n                            types.push("value");\n                        } else {\n                            ltype = "propvar";\n                            types.push("propvar");\n                            outy = token[token.length - 1];\n                            aa   = outy.indexOf("(");\n                            if (outy.charAt(outy.length - 1) === ")" && aa > 0) {\n                                outy                    = outy.slice(aa + 1, outy.length - 1);\n                                token[token.length - 1] = token[token.length - 1].slice(0, aa + 1) + value(\n                                    outy,\n                                    false\n                                ) + ")";\n                            }\n                        }\n                    } else {\n                        ltype = "item";\n                        types.push("item");\n                    }\n                },\n                // Some tokens receive a generic type named \'item\' because their type is unknown\n                // until we know the following syntax.  This function replaces the type \'item\'\n                // with something more specific.\n                item       = function csspretty__tokenize_item(type) {\n                    var aa    = types.length,\n                        bb    = 0,\n                        coms  = [],\n                        tokel = (token.length > 1)\n                            ? token[token.length - 2]\n                            : "",\n                        toked = tokel.slice(tokel.length - 2);\n                    //backtrack through immediately prior comments to find the correct token\n                    if (ltype === "comment" || ltype === "comment-inline") {\n                        do {\n                            aa    = aa - 1;\n                            ltype = types[aa];\n                            coms.push(token[aa]);\n                        } while (aa > 0 && (ltype === "comment" || ltype === "comment-inline"));\n                    } else {\n                        aa = aa - 1;\n                    }\n                    //if the last non-comment type is \'item\' then id it\n                    if (ltype === "item" && types[aa].indexOf("external") < 0) {\n                        if (type === "start") {\n                            stats.selectors.count = stats.selectors.count + 1;\n                            stats.selectors.chars = stats.selectors.chars + itemsize;\n                            if (types[aa - 1] !== "comment" && types[aa - 1] !== "comment-inline" && types[aa - 1] !== "end" && types[aa - 1] !== "start" && types[aa - 1] !== "semi" && types[aa - 1] !== undefined && types[aa - 1].indexOf("external") < 0) {\n                                (function csspretty__tokenize_item_selparts() {\n                                    var parts = [],\n                                        cc    = aa,\n                                        dd    = 0;\n                                    do {\n                                        parts.push(token[cc]);\n                                        if (lines[cc] > 0 && token[cc] === ":" && token[cc - 1] !== ":") {\n                                            parts.push(" ");\n                                        } else if (token[cc] !== ":") {\n                                            parts.push(" ");\n                                        }\n                                        cc = cc - 1;\n                                    } while (\n                                        cc > -1 && types[cc] !== "comment" && types[cc] !== "comment-inline" && types[cc] !== "end" && types[cc] !== "start" && types[cc] !== "semi" && types[cc] !== undefined\n                                    );\n                                    parts.reverse();\n                                    cc = cc + 1;\n                                    dd = aa - cc;\n                                    lines[aa] = lines[cc];\n                                    token.splice(cc, dd);\n                                    types.splice(cc, dd);\n                                    lines.splice(cc, dd);\n                                    depth.splice(cc, dd);\n                                    begin.splice(cc, dd);\n                                    aa        = aa - dd;\n                                    token[aa] = parts\n                                        .join("")\n                                        .replace(/:\\u0020/g, ":")\n                                        .replace(/(\\s*,\\s*)/g, ",");\n                                }());\n                            } else {\n                                token[aa] = token[aa].replace(/(\\s*,\\s*)/g, ",");\n                            }\n                            if (options.compressedcss === true) {\n                                token[aa] = token[aa]\n                                    .replace(/\\s*&/, " &")\n                                    .replace(/\\s*>\\s*/g, ">")\n                                    .replace(/:\\s+/g, ":")\n                                    .replace(/^(\\s+)/, "")\n                                    .replace(/(\\s+)$/, "");\n                            } else {\n                                token[aa] = token[aa]\n                                    .replace(/\\s*&/, " &")\n                                    .replace(/\\s*>\\s*/g, " > ")\n                                    .replace(/:\\s+/g, ": ")\n                                    .replace(/^(\\s+)/, "")\n                                    .replace(/(\\s+)$/, "");\n                            }\n                            (function csspretty__tokenize_item_selectorsort() {\n                                var y    = 0,\n                                    slen = token[aa].length,\n                                    z    = "",\n                                    mark = 0,\n                                    list = [];\n                                for (y = 0; y < slen; y = y + 1) {\n                                    if (z === "" && token[aa].charAt(y) === ",") {\n                                        list.push(token[aa].slice(mark, y));\n                                        mark = y + 1;\n                                    } else if (token[aa].charAt(y) === "\\"" || token[aa].charAt(y) === "\'" || token[aa].charAt(y) === "(" || token[aa].charAt(y) === "{") {\n                                        z = token[aa].charAt(y);\n                                    } else if (token[aa].charAt(y) === z && (z === "\\"" || z === "\'\'")) {\n                                        z = "";\n                                    } else if (token[aa].charAt(y) === ")" && z === "(") {\n                                        z = "";\n                                    } else if (token[aa].charAt(y) === "}" && z === "{") {\n                                        z = "";\n                                    }\n                                }\n                                list.push(token[aa].slice(mark, y));\n                                list.sort();\n                                token[aa] = list.join(",").replace(/^(\\s+)/, "");\n                            }());\n                            types[aa] = "selector";\n                            ltype     = "selector";\n                        } else if (type === "end") {\n                            types[aa] = "value";\n                            ltype     = "value";\n                            if (options.mode !== "diff") {\n                                token[aa] = token[aa].replace(/\\s*!\\s+important/, " !important");\n                                if (options.quoteConvert !== "none" && (token[aa - 2] === "font" || token[aa - 2] === "font-family")) {\n                                    token[aa] = value(token[aa], true);\n                                } else {\n                                    token[aa] = value(token[aa], false);\n                                }\n                            }\n                            //take comments out until the \'item\' is found and then put the comments back\n                            if (options.mode === "beautify" || options.mode === "parse" || (options.mode === "diff" && options.diffcomments === true)) {\n                                if (token[token.length - 2] === "{") {\n                                    types[types.length - 1] = "propvar";\n                                    stats.values.count      = stats.values.count - 1;\n                                    stats.values.chars      = stats.values.chars - itemsize;\n                                    stats.variables.count   = stats.variables.count + 1;\n                                    stats.variables.chars   = stats.variables.chars + itemsize;\n                                } else if (structval === "block") {\n                                    if (coms.length > 0 && ltype !== "semi" && ltype !== "end" && ltype !== "start") {\n                                        aa = coms.length - 1;\n                                        do {\n                                            token.pop();\n                                            types.pop();\n                                            lines.pop();\n                                            depth.pop();\n                                            begin.pop();\n                                            aa = aa - 1;\n                                        } while (aa > 0);\n                                        if (options.mode === "diff") {\n                                            token.push("x;");\n                                        } else {\n                                            token.push(";");\n                                        }\n                                        depth.push(structval);\n                                        begin.push(struct[struct.length - 1]);\n                                        types.push("semi");\n                                        lines.push(spacer(false));\n                                        bb = coms.length - 1;\n                                        do {\n                                            token.push(coms[aa]);\n                                            if (coms[aa].indexOf("//") === 0 && lines[lines.length - 1] === 0) {\n                                                types.push("comment-inline");\n                                            } else {\n                                                types.push("comment");\n                                            }\n                                            depth.push(structval);\n                                            begin.push(struct[struct.length - 1]);\n                                            lines.push(0);\n                                            aa = aa + 1;\n                                        } while (aa < bb);\n                                    } else {\n                                        if (options.mode === "diff") {\n                                            token.push("x;");\n                                        } else {\n                                            token.push(";");\n                                        }\n                                        depth.push(structval);\n                                        begin.push(struct[struct.length - 1]);\n                                        types.push("semi");\n                                        lines.push(spacer(false));\n                                    }\n                                }\n                            }\n                            stats.values.count = stats.values.count + 1;\n                            stats.values.chars = stats.values.chars + itemsize;\n                        } else if (type === "semi") {\n                            if (types[aa - 1] === "colon") {\n                                stats.values.count = stats.values.count + 1;\n                                stats.values.chars = stats.values.chars + itemsize;\n                                types[aa]          = "value";\n                                ltype              = "value";\n                                if (options.mode !== "diff") {\n                                    token[aa] = token[aa].replace(/\\s*!\\s+important/, " !important");\n                                    if (options.quoteConvert !== "none" && (token[aa - 2] === "font" || token[aa - 2] === "font-family")) {\n                                        token[aa] = value(token[aa], true);\n                                    } else {\n                                        token[aa] = value(token[aa], false);\n                                    }\n                                }\n                            } else {\n                                //properties without values are considered variables\n                                if (types[aa] !== "value") {\n                                    if (types[aa] === "item" && types[aa - 1] === "value" && (toked === "}}" || toked === "?>" || toked === "->" || toked === "%}" || toked === "%>")) {\n                                        if (isNaN(token[token.length - 1]) === true) {\n                                            token[token.length - 2] = tokel + token.pop();\n                                        } else {\n                                            token[token.length - 2] = tokel + " " + token.pop();\n                                        }\n                                        types.pop();\n                                        return;\n                                    }\n                                    types[aa] = "propvar";\n                                    ltype     = "propvar";\n                                }\n                                if (token[aa].indexOf("\\"") > 0) {\n                                    bb        = token[aa].indexOf("\\"");\n                                    a         = a - (token[aa].length - bb);\n                                    token[aa] = token[aa].slice(0, bb);\n                                    buildtoken();\n                                } else if (token[aa].indexOf("\'") > 0) {\n                                    bb        = token[aa].indexOf("\'");\n                                    a         = a - (token[aa].length - bb);\n                                    token[aa] = token[aa].slice(0, bb);\n                                    buildtoken();\n                                } else if ((/\\s/).test(token[aa]) === true) {\n                                    bb = token[aa]\n                                        .replace(/\\s/, " ")\n                                        .indexOf(" ");\n                                    if (bb < token[aa].indexOf("(") && bb < token[aa].indexOf("[")) {\n                                        a         = a - (token[aa].length - bb);\n                                        token[aa] = token[aa].slice(0, bb);\n                                        buildtoken();\n                                    }\n                                }\n                                stats.variables.count = stats.variables.count + 1;\n                                stats.variables.chars = stats.variables.chars + itemsize;\n                            }\n                        } else if (type === "colon") {\n                            types[aa]              = "property";\n                            ltype                  = "property";\n                            stats.properties.count = stats.properties.count + 1;\n                            stats.properties.chars = stats.properties.chars + itemsize;\n                        } else if (token[aa].charAt(0) === "@" && ((types[aa - 2] !== "propvar" && types[aa - 2] !== "property") || types[aa - 1] === "semi")) {\n                            types[aa] = "propvar";\n                            ltype     = "propvar";\n                        }\n                    }\n                },\n                external   = function csspretty__tokenize_external(open, end) {\n                    var store  = [],\n                        quote  = "",\n                        name   = "",\n                        endlen = 0,\n                        start  = open.length,\n                        linev  = spacer(false),\n                        exit   = function csspretty__tokenize_external_exit(typename) {\n                            var endtype = types[types.length - 2];\n                            if (ltype === "item") {\n                                if (endtype === "colon") {\n                                    types[types.length - 1] = "value";\n                                } else {\n                                    item(endtype);\n                                }\n                            }\n                            types.push(typename);\n                        };\n                    nosort[nosort.length - 1] = true;\n                    for (a = a; a < len; a = a + 1) {\n                        store.push(b[a]);\n                        if (quote === "") {\n                            if (b[a] === "\\"") {\n                                quote = "\\"";\n                            } else if (b[a] === "\'") {\n                                quote = "\'";\n                            } else if (b[a] === "/") {\n                                if (b[a + 1] === "/") {\n                                    quote = "/";\n                                } else if (b[a + 1] === "*") {\n                                    quote = "*";\n                                }\n                            } else if (b[a + 1] === end.charAt(0)) {\n                                do {\n                                    endlen = endlen + 1;\n                                    a      = a + 1;\n                                    store.push(b[a]);\n                                } while (a < len && endlen < end.length && b[a + 1] === end.charAt(endlen));\n                                if (endlen === end.length) {\n                                    quote = store.join("");\n                                    if ((/\\s/).test(quote.charAt(start)) === true) {\n                                        do {\n                                            start = start + 1;\n                                        } while ((/\\s/).test(quote.charAt(start)) === true);\n                                    }\n                                    endlen = start;\n                                    do {\n                                        endlen = endlen + 1;\n                                    } while (endlen < end.length && (/\\s/).test(quote.charAt(endlen)) === false);\n                                    if (endlen === quote.length) {\n                                        endlen = endlen - end.length;\n                                    }\n                                    if (open === "{%") {\n                                        if (quote.indexOf("{%-") === 0) {\n                                            quote = quote\n                                                .replace(/^(\\{%-\\s*)/, "{%- ")\n                                                .replace(/(\\s*-%\\})$/, " -%}");\n                                            name  = quote.slice(4);\n                                        } else {\n                                            quote = quote\n                                                .replace(/^(\\{%\\s*)/, "{% ")\n                                                .replace(/(\\s*%\\})$/, " %}");\n                                            name  = quote.slice(3);\n                                        }\n                                    }\n                                    if (open === "{{") {\n                                        quote = quote\n                                            .replace(/^(\\{\\{\\s+)/, "{{")\n                                            .replace(/(\\s+\\}\\})$/, "}}");\n                                    }\n                                    if (ltype === "item" && types[types.length - 2] === "colon" && (types[types.length - 3] === "property" || types[types.length - 3] === "propvar")) {\n                                        ltype                   = "value";\n                                        types[types.length - 1] = "value";\n                                        if (isNaN(token[token.length - 1]) === true && token[token.length - 1].charAt(token[token.length - 1].length - 1) !== ")") {\n                                            token[token.length - 1] = token[token.length - 1] + quote;\n                                        } else {\n                                            token[token.length - 1] = token[token.length - 1] + " " + quote;\n                                        }\n                                        return;\n                                    }\n                                    lines.push(linev);\n                                    token.push(quote);\n                                    begin.push(struct[struct.length - 1]);\n                                    depth.push(structval);\n                                    if (open === "{%") {\n                                        name = name.slice(0, name.indexOf(" "));\n                                        if (name.indexOf("(") > 0) {\n                                            name = name.slice(0, name.indexOf("("));\n                                        }\n                                        store = [\n                                            "autoescape",\n                                            "block",\n                                            "capture",\n                                            "case",\n                                            "comment",\n                                            "embed",\n                                            "filter",\n                                            "for",\n                                            "form",\n                                            "if",\n                                            "macro",\n                                            "paginate",\n                                            "raw",\n                                            "sandbox",\n                                            "spaceless",\n                                            "tablerow",\n                                            "unless",\n                                            "verbatim"\n                                        ];\n                                        if (name === "else" || name === "elseif" || name === "when" || name === "elif") {\n                                            return exit("external_else");\n                                        }\n                                        for (endlen = store.length - 1; endlen > -1; endlen = endlen - 1) {\n                                            if (name === store[endlen]) {\n                                                return exit("external_start");\n                                            }\n                                            if (name === "end" + store[endlen]) {\n                                                return exit("external_end");\n                                            }\n                                        }\n                                    } else if (open === "{{") {\n                                        name   = quote.slice(2);\n                                        endlen = name.length;\n                                        start  = 0;\n                                        do {\n                                            start = start + 1;\n                                        } while (\n                                            start < endlen && (/\\s/).test(name.charAt(start)) === false && name.charAt(start) !== "("\n                                        );\n                                        name = name.slice(0, start);\n                                        if (name.charAt(name.length - 2) === "}") {\n                                            name = name.slice(0, name.length - 2);\n                                        }\n                                        if (name === "end") {\n                                            return exit("external_end");\n                                        }\n                                        if (name === "block" || name === "define" || name === "form" || name === "if" || name === "range" || name === "with") {\n                                            return exit("external_start");\n                                        }\n                                    }\n                                    return exit("external");\n                                }\n                                endlen = 0;\n                            }\n                        } else if (quote === b[a]) {\n                            if (quote === "\\"" || quote === "\'") {\n                                quote = "";\n                            } else if (quote === "/" && (b[a] === "\\r" || b[a] === "\\n")) {\n                                quote = "";\n                            } else if (quote === "*" && b[a + 1] === "/") {\n                                quote = "";\n                            }\n                        }\n                    }\n                },\n                //finds comments include those JS looking \'//\' comments\n                comment    = function csspretty__tokenize_comment(inline) {\n                    var aa        = 0,\n                        bb        = 0,\n                        out       = [b[a]],\n                        type      = "comment",\n                        extra     = "",\n                        spareType = [],\n                        spareToke = [],\n                        spareLine = [],\n                        spareBegn = [],\n                        spareDept = [],\n                        linev     = spacer(false);\n                    type = (inline === true && linev === 0)\n                        ? "comment-inline"\n                        : "comment";\n                    for (aa = a + 1; aa < len; aa = aa + 1) {\n                        out.push(b[aa]);\n                        if ((inline === false && b[aa - 1] === "*" && b[aa] === "/") || (inline === true && (b[aa + 1] === "\\n" || b[aa + 1] === "\\r"))) {\n                            break;\n                        }\n                    }\n                    if (ltype === "item") {\n                        bb = aa;\n                        do {\n                            bb = bb + 1;\n                            if (b[bb] === "/") {\n                                if (b[bb + 1] === "*" || b[bb + 1] === "/") {\n                                    extra = b[bb + 1];\n                                } else if (b[bb - 1] === "*" && extra === "*") {\n                                    extra = "";\n                                    bb    = bb + 1;\n                                }\n                            } else if ((b[bb] === "\\n" || b[bb] === "\\r") && extra === "/") {\n                                extra = "";\n                                bb    = bb + 1;\n                            }\n                        } while (\n                            bb < len && ((extra === "" && (/\\s/).test(b[bb]) === true) || extra !== "")\n                        );\n                        if (b[bb] === "{") {\n                            item("start");\n                        } else if (b[bb] === "}") {\n                            item("end");\n                        } else if (b[bb] === ";") {\n                            item("semi");\n                        } else if (b[bb] === ":") {\n                            item("colon");\n                        } else {\n                            item();\n                        }\n                    }\n                    a                    = aa;\n                    stats.comments.count = stats.comments.count + 1;\n                    stats.comments.chars = stats.comments.chars + out.length;\n                    if (options.mode === "minify") {\n                        out.push(lf);\n                    }\n                    if (options.mode === "beautify" || options.mode === "parse" || (options.mode === "diff" && options.diffcomments === true) || (options.mode === "minify" && options.topcoms === true)) {\n                        if (token.length > 0 && (ltype === "selector" || ltype === "propvar") && types[types.length - 1] !== "comment" && types[types.length - 1] !== "comment-inline") {\n                            spareToke.push(token[token.length - 1]);\n                            token.pop();\n                            types.pop();\n                            lines.pop();\n                            begin.pop();\n                            depth.pop();\n                            begin.push(struct[struct.length - 1]);\n                            depth.push(structval);\n                            token.push(out.join(""));\n                            types.push(type);\n                            lines.push(linev);\n                            begin.push(struct[struct.length - 1]);\n                            depth.push(structval);\n                            token.push(spareToke[0]);\n                            if (ltype === "propvar") {\n                                types.push("propvar");\n                            } else {\n                                types.push("selector");\n                            }\n                            lines.push(0);\n                        } else if (ltype === "colon" || ltype === "property" || ltype === "value" || ltype === "propvar") {\n                            do {\n                                spareToke.push(token[token.length - 1]);\n                                spareType.push(types[types.length - 1]);\n                                spareLine.push(lines[lines.length - 1]);\n                                spareDept.push(depth[depth.length - 1]);\n                                spareBegn.push(begin[begin.length - 1]);\n                                token.pop();\n                                types.pop();\n                                lines.pop();\n                                depth.pop();\n                                begin.pop();\n                            } while (\n                                types.length > 1 && types[types.length - 1] !== "semi" && types[types.length - 1] !== "start"\n                            );\n                            token.push(out.join(""));\n                            types.push(type);\n                            lines.push(linev);\n                            depth.push(structval);\n                            begin.push(struct[struct.length - 1]);\n                            do {\n                                token.push(spareToke[spareToke.length - 1]);\n                                types.push(spareType[spareType.length - 1]);\n                                lines.push(spareLine[spareLine.length - 1]);\n                                depth.push(spareDept[spareDept.length - 1]);\n                                begin.push(spareBegn[spareBegn.length - 1]);\n                                spareToke.pop();\n                                spareType.pop();\n                                spareLine.pop();\n                                spareDept.pop();\n                                spareBegn.pop();\n                            } while (spareToke.length > 0);\n                        } else {\n                            ltype = type;\n                            types.push(type);\n                            token.push(out.join(""));\n                            lines.push(linev);\n                            depth.push(structval);\n                            begin.push(struct[struct.length - 1]);\n                        }\n                    }\n                },\n                //do fancy things to property types like: sorting, consolidating, and padding\n                properties = function csspretty__tokenize_properties() {\n                    var aa    = 0,\n                        bb    = 1,\n                        cc    = 0,\n                        dd    = 0,\n                        p     = [],\n                        set   = [\n                            []\n                        ],\n                        next  = 0,\n                        stoke = [],\n                        stype = [],\n                        sline = [],\n                        sdept = [],\n                        sbegn = [];\n                    //identify properties and build out prop/val sets\n                    for (aa = token.length - 1; aa > -1; aa = aa - 1) {\n                        if (types[aa] === "start") {\n                            bb = bb - 1;\n                            if (bb === 0) {\n                                next = aa;\n                                set.pop();\n                                for (aa = set.length - 1; aa > -1; aa = aa - 1) {\n                                    set[aa].reverse();\n                                }\n                                break;\n                            }\n                        }\n                        if (types[aa] === "end") {\n                            bb = bb + 1;\n                        }\n                        if (bb === 1 && (types[aa] === "property" || (types[aa] === "propvar" && types[aa + 1] === "colon")) && options.mode === "beautify") {\n                            p.push(aa);\n                        }\n                        set[set.length - 1].push(aa);\n                        if (bb === 1 && (types[aa - 1] === "comment" || types[aa - 1] === "comment-inline" || types[aa - 1] === "semi" || types[aa - 1] === "end" || types[aa - 1] === "start") && types[aa] !== "start" && types[aa] !== "end") {\n                            set.push([]);\n                        }\n                    }\n                    //this reverse fixes the order of consecutive comments\n                    set.reverse();\n                    p.reverse();\n\n                    //consolidate margin and padding\n                    (function csspretty__tokenize_properties_propcheck() {\n                        var leng      = set.length,\n                            fourcount = function csspretty__tokenize_properties_propcheck_fourcount(name) {\n                                var test     = [\n                                        false, false, false, false\n                                    ],\n                                    val      = [\n                                        "0", "0", "0", "0"\n                                    ],\n                                    zero     = (/^(0+([a-z]+|%))/),\n                                    start    = aa,\n                                    yy       = -1,\n                                    zz       = 0,\n                                    valsplit = [],\n                                    store    = function csspretty__tokenize_properties_propcheck_fourcount_store(side) {\n                                        yy         = yy + 1;\n                                        val[side]  = token[set[aa][2]];\n                                        test[side] = true;\n                                        if (start < 0) {\n                                            start = aa;\n                                        }\n                                    };\n                                for (aa = aa; aa < leng; aa = aa + 1) {\n                                    if (token[set[aa][2]] !== undefined && token[set[aa][0]].indexOf(name) === 0) {\n                                        if (token[set[aa][0]] === name || token[set[aa][0]].indexOf(name + " ") === 0) {\n                                            yy       = yy + 1;\n                                            valsplit = token[set[aa][2]].split(" ");\n                                            if (valsplit.length === 1) {\n                                                val = [\n                                                    token[set[aa][2]],\n                                                    token[set[aa][2]],\n                                                    token[set[aa][2]],\n                                                    token[set[aa][2]]\n                                                ];\n                                            } else if (valsplit.length === 2) {\n                                                val = [\n                                                    valsplit[0], valsplit[1], valsplit[0], valsplit[1]\n                                                ];\n                                            } else if (valsplit.length === 3) {\n                                                val = [\n                                                    valsplit[0], valsplit[1], valsplit[2], valsplit[1]\n                                                ];\n                                            } else if (valsplit.length === 4) {\n                                                val = [\n                                                    valsplit[0], valsplit[1], valsplit[2], valsplit[3]\n                                                ];\n                                            } else {\n                                                return;\n                                            }\n                                            test = [true, true, true, true];\n                                        } else if (token[set[aa][0]].indexOf(name + "-bottom") === 0) {\n                                            store(2);\n                                        } else if (token[set[aa][0]].indexOf(name + "-left") === 0) {\n                                            store(3);\n                                        } else if (token[set[aa][0]].indexOf(name + "-right") === 0) {\n                                            store(1);\n                                        } else if (token[set[aa][0]].indexOf(name + "-top") === 0) {\n                                            store(0);\n                                        }\n                                    }\n                                    if (set[aa + 1] === undefined || token[set[aa + 1][0]].indexOf(name) < 0 || aa === leng - 1) {\n                                        if (test[0] === true && test[1] === true && test[2] === true && test[3] === true) {\n                                            set.splice(start + 1, yy);\n                                            leng = leng - yy;\n                                            aa   = aa - yy;\n                                            zz   = 0;\n                                            bb   = p.length;\n                                            do {\n                                                if (p[zz] === set[start][0]) {\n                                                    break;\n                                                }\n                                                zz = zz + 1;\n                                            } while (zz < bb);\n                                            if (zz < bb) {\n                                                p.splice(zz + 1, yy);\n                                            }\n                                            token[set[start][0]] = name;\n                                            if (zero.test(val[0]) === true) {\n                                                val[0] = "0";\n                                            }\n                                            if (zero.test(val[1]) === true) {\n                                                val[1] = "0";\n                                            }\n                                            if (zero.test(val[2]) === true) {\n                                                val[2] = "0";\n                                            }\n                                            if (zero.test(val[3]) === true) {\n                                                val[3] = "0";\n                                            }\n                                            if (val[1] === val[3]) {\n                                                val.pop();\n                                                if (val[0] === val[2]) {\n                                                    val.pop();\n                                                    if (val[0] === val[1]) {\n                                                        val.pop();\n                                                    }\n                                                }\n                                            }\n                                            token[set[start][2]] = val.join(" ");\n                                            if (token[set[start][2]].indexOf("!important") > 0) {\n                                                token[set[start][2]] = token[set[start][2]].replace(/\\s!important/g, "") + " !i" +\n                                                        "mportant";\n                                            }\n                                            if (options.mode === "beautify" && verticalop === true) {\n                                                if (token[set[start][0]].charAt(token[set[start][0]].length - 1) === " ") {\n                                                    yy = token[set[start][0]].length - name.length;\n                                                    do {\n                                                        name = name + " ";\n                                                        yy   = yy - 1;\n                                                    } while (yy > 0);\n                                                }\n                                            }\n                                        }\n                                        break;\n                                    }\n                                }\n                            };\n                        for (aa = 0; aa < leng; aa = aa + 1) {\n                            if (types[set[aa][0]] === "property") {\n                                if (token[set[aa][0]].indexOf("margin") === 0) {\n                                    fourcount("margin");\n                                }\n                                if (token[set[aa][0]].indexOf("padding") === 0) {\n                                    fourcount("padding");\n                                }\n                            }\n                        }\n                    }());\n\n                    //pad out those property names so that the colons are vertically aligned\n                    if (verticalop === true) {\n                        bb = 0;\n                        for (aa = p.length - 1; aa > -1; aa = aa - 1) {\n                            if (token[p[aa]].length > bb && token[p[aa]] !== "filter" && token[p[aa]] !== "progid") {\n                                bb = token[p[aa]].length;\n                            }\n                        }\n                        for (aa = p.length - 1; aa > -1; aa = aa - 1) {\n                            cc = bb - token[p[aa]].length;\n                            if (cc > 0 && token[p[aa]] !== "filter" && token[p[aa]] !== "progid") {\n                                do {\n                                    token[p[aa]] = token[p[aa]] + " ";\n                                    cc           = cc - 1;\n                                } while (cc > 0);\n                            }\n                        }\n                        if (endtest === false) {\n                            return;\n                        }\n                    }\n\n                    bb = set.length;\n                    for (aa = 0; aa < bb; aa = aa + 1) {\n                        dd = set[aa].length;\n                        for (cc = 0; cc < dd; cc = cc + 1) {\n                            stoke.push(token[set[aa][cc]]);\n                            stype.push(types[set[aa][cc]]);\n                            sline.push(lines[set[aa][cc]]);\n                            sdept.push(depth[set[aa][cc]]);\n                            sbegn.push(begin[set[aa][cc]]);\n                        }\n                    }\n                    //replace a block\'s data with sorted analyzed data\n                    token.splice(next + 1, token.length - next - 1);\n                    types.splice(next + 1, types.length - next - 1);\n                    lines.splice(next + 1, lines.length - next - 1);\n                    depth.splice(next + 1, depth.length - next - 1);\n                    begin.splice(next + 1, begin.length - next - 1);\n                    token = token.concat(stoke);\n                    types = types.concat(stype);\n                    lines = lines.concat(sline);\n                    depth = depth.concat(sdept);\n                    begin = begin.concat(sbegn);\n                };\n            //token building loop\n            for (a = 0; a < len; a = a + 1) {\n                if (ltype !== "comment" && ltype !== "comment-inline" && ltype !== "" && options.topcoms === true) {\n                    options.topcoms = false;\n                }\n                if ((/\\s/).test(b[a]) === true) {\n                    stats.space = stats.space + 1;\n                    space       = space + b[a];\n                } else if (b[a] === "/" && b[a + 1] === "*") {\n                    comment(false);\n                } else if (b[a] === "/" && b[a + 1] === "/") {\n                    comment(true);\n                } else if (b[a] === "<" && b[a + 1] === "?" && b[a + 2] === "p" && b[a + 3] === "h" && b[a + 4] === "p") {\n                    //php\n                    external("<?php", "?>");\n                } else if (b[a] === "<" && b[a + 1] === "%") {\n                    //asp\n                    external("<%", "%>");\n                } else if (b[a] === "{" && b[a + 1] === "%") {\n                    //asp\n                    external("{%", "%}");\n                } else if (b[a] === "{" && b[a + 1] === "{" && b[a + 2] === "{") {\n                    //mustache\n                    external("{{{", "}}}");\n                } else if (b[a] === "{" && b[a + 1] === "{") {\n                    //handlebars\n                    external("{{", "}}");\n                } else if (b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] === "#") {\n                    //ssi\n                    external("\x3c!--#", "--\x3e");\n                } else if (b[a] === "@" && b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (b[a + 5] === "{" || (/\\s/).test(b[a + 5]) === true)) {\n                    types.push("external_else");\n                    token.push("@else");\n                    lines.push(0);\n                    depth.push(depth[depth.length - 1]);\n                    begin.push(begin[begin.length - 1]);\n                    a = a + 4;\n                } else if (b[a] === "{" || (b[a] === "(" && token[token.length - 1] === ":" && types[types.length - 2] === "propvar")) {\n                    if (b[a] === "{" && token[token.length - 2] === ":") {\n                        types[types.length - 1] = "pseudo";\n                    }\n                    item("start");\n                    struct.push(token.length);\n                    ltype = "start";\n                    types.push("start");\n                    token.push(b[a]);\n                    begin.push(token.length);\n                    if (b[a] === "(") {\n                        structval = "map";\n                        depth.push("map");\n                        mapper.push(0);\n                    } else {\n                        structval = "block";\n                        depth.push("block");\n                    }\n                    nosort.push(false);\n                    lines.push(spacer(false));\n                    stats.braces = stats.braces + 1;\n                } else if (b[a] === "}" || (b[a] === ")" && structval === "map" && mapper[mapper.length - 1] === 0)) {\n                    endtest = true;\n                    if (b[a] === "}" && types[types.length - 1] === "item" && token[token.length - 2] === "{" && token[token.length - 3] !== undefined && token[token.length - 3].charAt(token[token.length - 3].length - 1) === "@") {\n                        token[token.length - 3] = token[token.length - 3] + "{" + token[token.length - 1] +\n                                "}";\n                        token.pop();\n                        token.pop();\n                        types.pop();\n                        types.pop();\n                        lines.pop();\n                        lines.pop();\n                        depth.pop();\n                        depth.pop();\n                        begin.pop();\n                        begin.pop();\n                    } else {\n                        if (b[a] === ")") {\n                            mapper.pop();\n                        } else if (b[a] === "}" && ltype === "value" && token[token.length - 1] !== ";") {\n                            token.push(";");\n                            types.push("semi");\n                            lines.push(0);\n                            depth.push("block");\n                            begin.push(begin[begin.length - 1]);\n                        }\n                        item("end");\n                        if (options.mode !== "diff") {\n                            properties();\n                        }\n                        ltype = "end";\n                        if (objsortop === true && nosort[nosort.length - 1] === false) {\n                            objSort();\n                        }\n                        nosort.pop();\n                        types.push("end");\n                        token.push(b[a]);\n                        lines.push(spacer(false));\n                        depth.push(structval);\n                        begin.push(struct[struct.length - 1]);\n                        stats.braces = stats.braces + 1;\n                    }\n                    struct.pop();\n                    if (token[struct[struct.length - 1]] === "{") {\n                        structval = "block";\n                    } else if (token[struct[struct.length - 1]] === "(") {\n                        structval = "map";\n                    } else {\n                        structval = "root";\n                    }\n                } else if (b[a] === ";" || (b[a] === "," && structval === "map")) {\n                    item("semi");\n                    if (types[types.length - 1] !== "semi" && types[types.length - 1] !== "start" && esctest(a) === false) {\n                        ltype = "semi";\n                        types.push("semi");\n                        token.push(b[a]);\n                        lines.push(spacer(false));\n                        depth.push(structval);\n                        begin.push(begin[begin.length - 1]);\n                    }\n                    stats.semi = stats.semi + 1;\n                    space      = "";\n                } else if (b[a] === ":" && types[types.length - 1] !== "end") {\n                    item("colon");\n                    types.push("colon");\n                    token.push(":");\n                    if ((/\\s/).test(b[a - 1]) === true) {\n                        lines.push(1);\n                    } else {\n                        lines.push(0);\n                    }\n                    ltype       = "colon";\n                    stats.colon = stats.colon + 1;\n                    space       = "";\n                } else {\n                    if (structval === "map" && b[a] === "(") {\n                        mapper[mapper.length - 1] = mapper[mapper.length - 1] + 1;\n                    }\n                    buildtoken();\n                }\n            }\n            if (endtest === false && verticalop === true) {\n                properties();\n            }\n        }());\n\n        if (options.mode === "parse") {\n            return (function csspretty__parse() {\n                var a      = 0,\n                    c      = token.length,\n                    record = [],\n                    def    = {\n                        token: "string - The parsed code tokens",\n                        types: "string - Data types of the tokens: colon, comment, comment-inline, end, extern" +\n                                "al, external_else, external_end, external_start, item, propvar, pseudo, select" +\n                                "or, semi, start, value",\n                        lines: "number - Whether the token is preceeded any space and/or line breaks in the or" +\n                                "iginal code source",\n                        depth: "string - Type of current structure",\n                        begin: "number - Index where current structure begins"\n                    };\n                if (options.parseFormat === "sequential") {\n                    for (a = 0; a < c; a = a + 1) {\n                        record.push([\n                            token[a], types[a], lines[a], depth[a], begin[a]\n                        ]);\n                    }\n                    if (options.nodeasync === true) {\n                        return [\n                            {\n                                data      : record,\n                                definition: def\n                            },\n                            ""\n                        ];\n                    }\n                    return {data: record, definition: def};\n                }\n                if (options.parseFormat === "htmltable") {\n                    return (function csspretty__parse_html() {\n                        var report = [],\n                            aa     = 0,\n                            len    = 0;\n                        report.push("<table summary=\'CSS parse table\'><thead><tr><th>index</th>");\n                        report.push("<th>token</th>");\n                        report.push("<th>types</th>");\n                        report.push("<th>lines</th>");\n                        report.push("<th>depth</th>");\n                        report.push("<th>begin</th>");\n                        report.push("</tr></thead><tbody>");\n                        len = token.length;\n                        for (aa = 0; aa < len; aa = aa + 1) {\n                            report.push("<tr><td>");\n                            report.push(aa);\n                            report.push("</td><td>");\n                            report.push(\n                                token[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\n                            );\n                            report.push("</td><td>");\n                            report.push(types[aa]);\n                            report.push("</td><td>");\n                            report.push(lines[aa]);\n                            report.push("</td><td>");\n                            report.push(depth[aa]);\n                            report.push("</td><td>");\n                            report.push(begin[aa]);\n                            report.push("</td></tr>");\n                        }\n                        report.push("</tbody></table>");\n                        if (options.nodeasync === true) {\n                            return [\n                                {\n                                    data      : report.join(""),\n                                    definition: def\n                                },\n                                ""\n                            ];\n                        }\n                        return {data: report.join(""), definition: def};\n                    }());\n                }\n                if (options.nodeasync === true) {\n                    return [\n                        {\n                            data      : {\n                                token: token,\n                                types: types,\n                                lines: lines,\n                                depth: depth,\n                                begin: begin\n                            },\n                            definition: def\n                        },\n                        ""\n                    ];\n                }\n                return {\n                    data      : {\n                        token: token,\n                        types: types,\n                        lines: lines,\n                        depth: depth,\n                        begin: begin\n                    },\n                    definition: def\n                };\n            }());\n        }\n\n        //analysis\n        if (options.mode === "analysis") {\n            return (function csspretty__summary() {\n                var summ  = [],\n                    inl   = options.source.length,\n                    out   = output.length,\n                    uris  = uri.length,\n                    uric  = 0,\n                    a     = 0,\n                    b     = 0,\n                    color = [];\n                (function csspretty_summary_colorNormalize() {\n                    var aa = 0,\n                        bb = 0,\n                        cc = colors.length;\n                    colors.sort();\n                    color.push(colors[0]);\n                    for (aa = 0; aa < cc; aa = aa + 1) {\n                        if (colors[aa] !== color[bb]) {\n                            color.push(colors[aa]);\n                            bb = bb + 1;\n                        }\n                    }\n                }());\n                summ.push(\n                    "<div class=\'report\' id=\'cssreport\'><p><strong>Number of HTTP requests:</strong" +\n                    "> <em>"\n                );\n                summ.push(uris);\n                summ.push(\n                    "</em></p><table class=\'analysis\' id=\'css-parts\' summary=\'Component counts and " +\n                    "sizes\'><caption>Component counts and sizes</caption><thead><tr><th>Type Name</" +\n                    "th><th>Quantity</th><th>Character Size</th></tr></thead><tbody><tr><th>curly b" +\n                    "races</th><td>"\n                );\n                summ.push(stats.braces);\n                summ.push("</td><td>");\n                summ.push(stats.braces);\n                summ.push("</td></tr><tr><th>colon</th><td>");\n                summ.push(stats.colon);\n                summ.push("</td><td>");\n                summ.push(stats.colon);\n                summ.push("</td></tr><tr><th>comments</th><td>");\n                summ.push(stats.comments.count);\n                summ.push("</td><td>");\n                summ.push(stats.comments.chars);\n                summ.push("</td></tr><tr><th>properties</th><td>");\n                summ.push(stats.properties.count);\n                summ.push("</td><td>");\n                summ.push(stats.properties.chars);\n                summ.push("</td></tr><tr><th>selectors</th><td>");\n                summ.push(stats.selectors.count);\n                summ.push("</td><td>");\n                summ.push(stats.selectors.chars);\n                summ.push("</td></tr><tr><th>semicolons</th><td>");\n                summ.push(stats.semi);\n                summ.push("</td><td>");\n                summ.push(stats.semi);\n                summ.push("</td></tr><tr><th>white space</th><td>");\n                summ.push(stats.space);\n                summ.push("</td><td>");\n                summ.push(stats.space);\n                summ.push("</td></tr><tr><th>values</th><td>");\n                summ.push(stats.values.count);\n                summ.push("</td><td>");\n                summ.push(stats.values.chars);\n                summ.push("</td></tr><tr><th>variables</th><td>");\n                summ.push(stats.variables.count);\n                summ.push("</td><td>");\n                summ.push(stats.variables.chars);\n                summ.push(\n                    "</td></tr></tbody></table><table class=\'analysis\' id=\'css-size\' summary=\'CSS c" +\n                    "haracter size change\'><caption>CSS character size change</caption><tbody><tr><" +\n                    "th>Input</th><td>"\n                );\n                summ.push(inl);\n                summ.push("</td></tr><tr><th>Output</th><td>");\n                summ.push(out);\n                summ.push("</td></tr><tr><th>");\n                if (out > inl) {\n                    summ.push("Increase</th><td>");\n                    summ.push(out - inl);\n                    summ.push("</td></tr><tr><th>Percent Change</th><td>");\n                    a = (((out - inl) / out) * 100);\n                    summ.push(a.toFixed(2));\n                } else {\n                    summ.push("Decrease</th><td>");\n                    summ.push(inl - out);\n                    summ.push("</td></tr><tr><th>Percent Change</th><td>");\n                    a = (((inl - out) / inl) * 100);\n                    summ.push(a.toFixed(2));\n                }\n                summ.push(\n                    "%</td></tr></tbody></table><table class=\'analysis\' id=\'css-uri\' summary=\'A lis" +\n                    "t of HTTP requests\'><caption>A List of HTTP Requests</caption><thead><tr><th>Q" +\n                    "uantity</th><th>URI</th></tr></thead><tbody>"\n                );\n                for (a = 0; a < uris; a = a + 1) {\n                    uric = 1;\n                    for (b = a + 1; b < uris; b = b + 1) {\n                        if (uri[a] === uri[b]) {\n                            uric = uric + 1;\n                            uri.splice(b, 1);\n                            uris = uris - 1;\n                        }\n                    }\n                    summ.push("<tr><td>");\n                    summ.push(uric);\n                    summ.push("</td><td>");\n                    summ.push(\n                        uri[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                    );\n                    summ.push("</td></tr>");\n                }\n                summ.push("</tbody></table>");\n                summ.push("</div><span class=\'clear\'></span>");\n                if (color.length === 0) {\n                    summ.push("<h4>0 colors were identified in the provided code.</h4>");\n                } else {\n                    summ.push("<h4>These ");\n                    summ.push(color.length);\n                    if (color.length > 1) {\n                        summ.push(" different");\n                    }\n                    summ.push(" color");\n                    if (color.length > 1) {\n                        summ.push("s");\n                    }\n                    summ.push(" were identified in the provided code:</h4><p>");\n                    summ.push(color.join(", "));\n                    summ.push("</p>");\n                    if (options.accessibility === true) {\n                        (function csspretty__summary_colorConvert() {\n                            var vl        = "",\n                                bb        = color.length,\n                                aa        = 0,\n                                luminance = function csspretty__summary_colorConvert_luminance(rgb) {\n                                    var convert = function csspretty__summary_colorConvert_luminance_convert(x) {\n                                        if (x === 0) {\n                                            return 0;\n                                        }\n                                        x = (x / 255);\n                                        if ((x * 100000) <= 3928) {\n                                            return ((x * 100) / 1292) * 10000;\n                                        }\n                                        x = x * 100000;\n                                        return Math.pow(((x + 5500) / 105500), 2.4) * 10000;\n                                    };\n                                    return (\n                                        (2126 * convert(rgb[0])) + (7152 * convert(rgb[1])) + (722 * convert(rgb[2]))\n                                    ) / 100000000;\n                                },\n                                hexToDec  = function csspretty__summary_colorConvert_hexToDec(val) {\n                                    var str = val\n                                            .slice(1)\n                                            .split(""),\n                                        rgb = [],\n                                        num = [],\n                                        aaa = 0,\n                                        bbb = str.length;\n                                    for (aaa = 0; aaa < bbb; aaa = aaa + 1) {\n                                        if (str[aaa] === "a") {\n                                            num.push(10);\n                                        } else if (str[aaa] === "b") {\n                                            num.push(11);\n                                        } else if (str[aaa] === "c") {\n                                            num.push(12);\n                                        } else if (str[aaa] === "d") {\n                                            num.push(13);\n                                        } else if (str[aaa] === "e") {\n                                            num.push(14);\n                                        } else if (str[aaa] === "f") {\n                                            num.push(15);\n                                        } else {\n                                            num.push(Number(str[aaa]));\n                                        }\n                                    }\n                                    if (bbb === 3) {\n                                        rgb.push((num[0] * 16) + num[0]);\n                                        rgb.push((num[1] * 16) + num[1]);\n                                        rgb.push((num[2] * 16) + num[2]);\n                                    } else {\n                                        rgb.push((num[0] * 16) + num[1]);\n                                        rgb.push((num[2] * 16) + num[3]);\n                                        rgb.push((num[4] * 16) + num[5]);\n                                    }\n                                    return luminance(rgb);\n                                },\n                                rgbToDec  = function csspretty__summary_colorConvert_rgbToDec(val) {\n                                    var rgb  = [],\n                                        rgbs = [],\n                                        rr   = 0;\n                                    if (vl.charAt(3) === "a") {\n                                        vl   = vl\n                                            .slice(5, vl.length - 1)\n                                            .replace(/\\s+/g, "");\n                                        rgbs = vl.split(",");\n                                        rgbs.pop();\n                                    } else {\n                                        vl   = vl\n                                            .slice(4, vl.length - 1)\n                                            .replace(/\\s+/g, "");\n                                        rgbs = vl.split(",");\n                                    }\n                                    do {\n                                        if ((/^([0-9a-f]{2})$/).test(rgbs[rr]) === false) {\n                                            if (rgbs[rr].charAt(rgbs[rr].length - 1) === "%") {\n                                                vl = rgbs[rr].slice(0, rgbs[rr].length - 1);\n                                                if (isNaN(vl) === true) {\n                                                    return val;\n                                                }\n                                                rgb.push(Number(vl));\n                                                if (rgb[rr] < 0) {\n                                                    rgb[rr] = 0;\n                                                } else if (rgb[rr] > 100) {\n                                                    rgb[rr] = 100;\n                                                }\n                                                rgb[rr] = Math.round(2.55 * rgb[rr]);\n                                            } else {\n                                                if (isNaN(rgbs[rr]) === true) {\n                                                    return val;\n                                                }\n                                                rgb.push(Number(rgbs[rr]));\n                                                if (rgb[rr] < 0) {\n                                                    rgb[rr] = 0;\n                                                } else if (rgb[rr] > 255) {\n                                                    rgb[rr] = 255;\n                                                }\n                                                rgb[rr] = Math.round(rgb[rr]);\n                                            }\n                                        }\n                                        rr = rr + 1;\n                                    } while (rr < 3);\n                                    return luminance(rgb);\n                                };\n                            colors = [];\n                            for (aa = 0; aa < bb; aa = aa + 1) {\n                                if (color[aa] === undefined) {\n                                    break;\n                                }\n                                vl = color[aa].toLowerCase();\n                                if ((/^(#[0-9a-f]{3,6})$/).test(vl) === true) {\n                                    colors.push(hexToDec(vl.slice(1)));\n                                } else if ((/^(rgba?\\()/).test(vl) === true) {\n                                    colors.push(rgbToDec(vl));\n                                } else if (colorNames[vl] !== undefined) {\n                                    colors.push(colorNames[vl]);\n                                }\n                            }\n                        }());\n                    }\n                }\n                if (options.nodeasync === true) {\n                    return [summ.join(""), ""];\n                }\n                return summ.join("");\n            }());\n        }\n\n        //beautification\n        if (options.mode !== "minify") {\n            output = (function csspretty__beautify() {\n                var a        = 0,\n                    len      = token.length,\n                    build    = [],\n                    indent   = options.inlevel,\n                    mixin    = false,\n                    //a single unit of indentation\n                    tab      = (function csspretty__beautify_tab() {\n                        var aa = 0,\n                            bb = [];\n                        for (aa = 0; aa < options.insize; aa = aa + 1) {\n                            bb.push(options.inchar);\n                        }\n                        return bb.join("");\n                    }()),\n                    //new lines plus indentation\n                    nl       = function csspretty__beautify_nl(tabs) {\n                        var aa = 0;\n                        if (build[build.length - 1] === tab) {\n                            do {\n                                build.pop();\n                            } while (build[build.length - 1] === tab);\n                        }\n                        build.push(lf);\n                        for (aa = 0; aa < tabs; aa = aa + 1) {\n                            build.push(tab);\n                        }\n                    },\n                    //breaks selector lists onto newlines\n                    selector = function csspretty__beautify_selector(item) {\n                        var aa    = 0,\n                            bb    = 0,\n                            cc    = 0,\n                            block = "",\n                            items = [],\n                            leng  = item.length;\n                        if (options.compressedcss === true && (/\\)\\s*when\\s*\\(/).test(item) === true) {\n                            item = item.replace(\n                                /\\)\\s*when\\s*\\(/,\n                                ")" + lf + (function csspretty__beautify_selector_whenTab() {\n                                    var wtab = "",\n                                        aaa  = indent + 1;\n                                    do {\n                                        wtab = wtab + tab;\n                                        aaa  = aaa - 1;\n                                    } while (aaa > 0);\n                                    return wtab;\n                                }()) + "when ("\n                            );\n                        }\n                        for (aa = 0; aa < leng; aa = aa + 1) {\n                            if (block === "") {\n                                if (item.charAt(aa) === "\\"") {\n                                    block = "\\"";\n                                    bb    = bb + 1;\n                                } else if (item.charAt(aa) === "\'") {\n                                    block = "\'";\n                                    bb    = bb + 1;\n                                } else if (item.charAt(aa) === "(") {\n                                    block = ")";\n                                    bb    = bb + 1;\n                                } else if (item.charAt(aa) === "[") {\n                                    block = "]";\n                                    bb    = bb + 1;\n                                }\n                            } else if ((item.charAt(aa) === "(" && block === ")") || (item.charAt(aa) === "[" && block === "]")) {\n                                bb = bb + 1;\n                            } else if (item.charAt(aa) === block) {\n                                bb = bb - 1;\n                                if (bb === 0) {\n                                    block = "";\n                                }\n                            }\n                            if (block === "" && item.charAt(aa) === ",") {\n                                items.push(item.substring(cc, aa + 1));\n                                cc = aa + 1;\n                            }\n                        }\n                        if (cc > 0) {\n                            items.push(item.substr(cc));\n                        }\n                        leng = items.length;\n                        if (leng === 0) {\n                            items.push(item);\n                        }\n                        if (options.selectorlist === true) {\n                            build.push(items.join(" "));\n                        } else {\n                            build.push(items[0].replace(/,(\\s*)/g, ", ").replace(/(,\\u0020)$/, ","));\n                            for (aa = 1; aa < leng; aa = aa + 1) {\n                                nl(indent);\n                                build.push(items[aa].replace(/,(\\s*)/g, ", ").replace(/(,\\u0020)$/, ","));\n                            }\n                        }\n                        if (options.compressedcss === false) {\n                            build.push(" ");\n                        }\n                    };\n                if (options.inlevel > 0) {\n                    a = options.inlevel;\n                    do {\n                        a = a - 1;\n                        build.push(tab);\n                    } while (a > 0);\n                }\n\n                //beautification loop\n                for (a = 0; a < len; a = a + 1) {\n                    if (lines[a] > 1 && options.compressedcss === false && (types[a] === "start" || types[a] === "end" || types[a] === "selector" || types[a] === "comment" || types[a] === "property" || types[a] === "propvar" || types[a].indexOf("external") > -1)) {\n                        if (options.cssinsertlines === true && types[a] === "selector" && types[a - 1] !== "comment") {\n                            lines[a] = lines[a] - 1;\n                        }\n                        if (build[build.length - 1] === tab) {\n                            do {\n                                build.pop();\n                            } while (build[build.length - 1] === tab);\n                        }\n                        if (lines[a] > 1) {\n                            if (lines[a] > 2) {\n                                do {\n                                    lines[a] = lines[a] - 1;\n                                    build.push(lf);\n                                } while (lines[a] > 2);\n                            }\n                            nl(indent);\n                        }\n                    }\n                    if (types[a] === "start") {\n                        if (types[a - 1] === "propvar" && options.compressedcss === false) {\n                            build.push(" ");\n                        }\n                        if (a > 0 && token[a - 1].charAt(token[a - 1].length - 1) === "#") {\n                            build.push(token[a]);\n                        } else {\n                            if (options.braces === true) {\n                                if (build[build.length - 1] === " ") {\n                                    build.pop();\n                                }\n                                nl(indent);\n                            } else if (types[a - 1] === "colon") {\n                                build.push(" ");\n                            }\n                            build.push(token[a]);\n                            indent = indent + 1;\n                            if (types[a + 1] !== "end" && (options.compressedcss === false || (options.compressedcss === true && types[a + 1] === "start")) && (types[a + 1] !== "selector" || options.cssinsertlines === false)) {\n                                nl(indent);\n                            }\n                        }\n                    } else if (types[a] === "end") {\n                        if (types[a + 1] === "external_else") {\n                            indent = indent - 1;\n                            nl(indent);\n                            build.push(token[a]);\n                            build.push(" ");\n                            build.push(token[a + 1]);\n                            build.push(" ");\n                            a = a + 1;\n                        } else if (mixin === true) {\n                            mixin = false;\n                            build.push(token[a]);\n                            build.push(" ");\n                        } else {\n                            indent = indent - 1;\n                            if (types[a - 1] !== "start" && options.compressedcss === false) {\n                                nl(indent);\n                            }\n                            build.push(token[a]);\n                            if (options.compressedcss === true && types[a + 1] === "end") {\n                                nl(indent - 1);\n                            } else if (options.cssinsertlines === true && types[a + 1] === "selector" && lines[a] < 2 && token[a - 1] !== "{") {\n                                build.push(lf);\n                            } else if (types[a + 1] !== "end" && types[a + 1] !== "semi" && types[a + 1] !== "comment") {\n                                nl(indent);\n                            }\n                        }\n                    } else if (types[a] === "semi") {\n                        if (token[a] !== "x;" && (options.compressedcss === false || (options.compressedcss === true && types[a + 1] !== "end"))) {\n                            build.push(token[a]);\n                        }\n                        if (types[a + 1] === "comment-inline") {\n                            build.push(" ");\n                        } else if (types[a + 1] !== "end" && types[a + 1] !== "comment" && options.compressedcss === false) {\n                            if (options.cssinsertlines === true && types[a + 1] === "selector") {\n                                build.push(lf);\n                            } else if (lines[a + 1] > 0 || (types[a + 1] !== undefined && types[a + 1].indexOf("external") < 0)) {\n                                nl(indent);\n                            }\n                        }\n                    } else if (types[a] === "selector") {\n                        if (a > 0 && types[a - 1] !== "comment" && (options.cssinsertlines === true || (options.compressedcss === true && (types[a - 1] === "start" || types[a - 1] === "semi")))) {\n                            nl(indent);\n                        }\n                        if (token[a].charAt(token[a].length - 1) === "#") {\n                            build.push(token[a]);\n                            mixin = true;\n                        } else if (token[a].indexOf(",") > -1) {\n                            selector(token[a]);\n                        } else {\n                            if (token[a].charAt(0) === ":" && token[a - 1] === "}" && build[build.length - 1] === " ") {\n                                build.pop();\n                            }\n                            build.push(token[a]);\n                            if (options.compressedcss === false) {\n                                build.push(" ");\n                            }\n                        }\n                    } else if ((types[a] === "comment" || types[a] === "comment-inline") && types[a - 1] !== "colon" && types[a - 1] !== "property") {\n                        if (types[a - 1] === "value" && types[a] === "comment-inline") {\n                            build.push(" ");\n                        }\n                        if (a > 0 && options.compressedcss === true && types[a] === "comment" && types[a - 1] !== "comment") {\n                            build.push(lf);\n                            nl(indent);\n                        } else if (a > 0 && types[a - 1] !== "start" && types[a] !== "comment-inline") {\n                            nl(indent);\n                        }\n                        build.push(token[a]);\n                        if (types[a + 1] !== "end" && types[a + 1] !== "comment") {\n                            nl(indent);\n                        }\n                    } else {\n                        if (types[a - 1] !== "semi" && options.compressedcss === false && (mixin === false || token[a - 1] === ":") && token[a - 2] !== "filter" && token[a - 2] !== "progid") {\n                            if (types[a] === "value" || (types[a].indexOf("external") > -1 && types[a - 1] === "colon")) {\n                                build.push(" ");\n                            }\n                        } else if (options.compressedcss === true && (types[a] === "value" || types[a] === "propvar")) {\n                            token[a] = token[a].replace(/(\\s*,\\s*)/g, ",");\n                        }\n                        if (types[a] === "external_start") {\n                            indent = indent + 1;\n                        } else if (types[a] === "external_end") {\n                            indent = indent - 1;\n                            if (build[build.length - 1] === tab) {\n                                build.pop();\n                            }\n                        } else if (types[a] === "external_else" && build[build.length - 1] === tab) {\n                            build.pop();\n                        }\n                        build.push(token[a]);\n                        if (types[a].indexOf("external") > -1 && types[a + 1] !== "semi") {\n                            if ((types[a + 1] !== undefined && types[a + 1].indexOf("external") > -1) || (lines[a + 1] === 1 && types[a + 1] !== "end") || lines[a + 1] > 1) {\n                                nl(indent);\n                            }\n                        }\n                    }\n                }\n                if (options.newline === true) {\n                    if (options.crlf === true) {\n                        build.push("\\r\\n");\n                    } else {\n                        build.push("\\n");\n                    }\n                }\n                if (options.preserve > 0 && (lines[lines.length - 1] > 0 || endline === true)) {\n                    return build\n                        .join("")\n                        .replace(/(\\s+)$/, lf);\n                }\n                return build\n                    .join("")\n                    .replace(/(\\s+)$/, "");\n            }());\n        } else {\n            if (options.newline === true) {\n                if (options.crlf === true) {\n                    output.push("\\r\\n");\n                } else {\n                    output.push("\\n");\n                }\n            }\n            output = token\n                .join("")\n                .replace(/;\\}/g, "}");\n        }\n        if (options.nodeasync === true) {\n            return [output, ""];\n        }\n        return output;\n    };\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function csspretty_requirejs() {\n            return function csspretty_requirejs_wrapper(x) {\n                return csspretty(x);\n            };\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = csspretty;\n    } else {\n        global.prettydiff.csspretty = csspretty;\n    }\n}());\n'},function(n,e,t){"use strict";t(1)(t(40))},function(n,e){n.exports='/*prettydiff.com api.topcoms:true,api.insize:4,api.inchar:" ",api.vertical:true */\n/*global ace, define, global, module*/\n/***********************************************************************\n csvpretty is written by Austin Cheney on 2 Oct 2015.\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n **********************************************************************/\n(function () {\n    "use strict";\n    var csvpretty = function csvpretty_(options) {\n        var token = [];\n        options.csvchar = (typeof options.csvchar === "string")\n            ? options.csvchar\n            : ",";\n        options.source  = (\n            typeof options.source !== "string" || options.source === "" || (/^(\\s+)$/).test(options.source) === true\n        )\n            ? "Error: no source supplied to csvpretty."\n            : options\n                .source\n                .replace(/\\r\\n/g, "\\n")\n                .replace(/\\r/g, "\\n");\n        (function csvpretty__tokenize() {\n            var input      = options\n                    .source\n                    .split(""),\n                d          = options.csvchar.length,\n                e          = 0,\n                cell       = [],\n                row        = [],\n                quote      = false,\n                cellCrunch = function csvpretty__tokenize_cellCrunch() {\n                    var str = cell.join("");\n                    cell = [];\n                    if (str !== "") {\n                        row.push(str);\n                    }\n                },\n                parse      = function csvpretty__tokenize_parse(item, index, arr) {\n                    if (quote === false) {\n                        if (cell.length === 0 && item === "\\"" && (arr[index + 1] !== "\\"" || arr[index + 2] === "\\"")) {\n                            quote = true;\n                        } else if (item === "\\"" && arr[index + 1] === "\\"") {\n                            cell.push("\\"");\n                            arr[index + 1] = "";\n                        } else if (item === "\\n") {\n                            cellCrunch();\n                            token.push(row);\n                            row = [];\n                        } else if (item === options.csvchar.charAt(0)) {\n                            if (d === 1) {\n                                cellCrunch();\n                            } else {\n                                e = 0;\n                                do {\n                                    e = e + 1;\n                                } while (e < d && arr[index + e] === options.csvchar.charAt(e));\n                                if (e === d) {\n                                    cellCrunch();\n                                    e = 1;\n                                    do {\n                                        arr[index + e] = "";\n                                        e              = e + 1;\n                                    } while (e < d);\n                                } else if (item !== "") {\n                                    cell.push(item);\n                                }\n                            }\n                        } else if (item !== "") {\n                            cell.push(item);\n                        }\n                    } else if (item !== "\\"" && item !== "") {\n                        cell.push(item);\n                    } else if (item === "\\"" && arr[index + 1] === "\\"") {\n                        cell.push("\\"");\n                        arr[index + 1] = "";\n                    } else if (item === "\\"") {\n                        cellCrunch();\n                        quote = false;\n                    }\n                };\n            input.forEach(parse);\n            if (cell.length > 0) {\n                cellCrunch();\n                token.push(row);\n            }\n        }());\n        return token;\n    };\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function csvpretty_requirejs() {\n            return function csvpretty_requirejs_wrapper(x) {\n                return csvpretty(x);\n            };\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = function commonjs_csvpretty(x) {\n            return csvpretty(x);\n        };\n    } else {\n        global.prettydiff.csvpretty = csvpretty;\n    }\n}());\n'},function(n,e,t){"use strict";t(1)(t(42))},function(n,e){n.exports='/*global ace, define, global, module*/\n/*jshint laxbreak: true*/\n/*\n\nWritten by Austin Cheney on 1 Mar 2017\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n\n * Output - an array of three indexes:\n * 1) Diff result as a HTML table\n * 2) Number of errors after the number of error lines used for total\n *    total error count when added to the next index\n * 3) Number of error lines in the HTML table\n */\n(function () {\n    "use strict";\n    var diffview = function diffview_(options) {\n        (function diffview__options() {\n            if (typeof options.diff === "string") {\n                if (options.functions !== undefined) {\n                    options.diff = options\n                        .diff\n                        .replace(options.functions.binaryCheck, "");\n                }\n                if (options.semicolon === true) {\n                    options.diff = options\n                        .diff\n                        .replace(/;\\n/g, "\\n")\n                        .replace(/;$/, "");\n                }\n            }\n            if (typeof options.source === "string") {\n                if (options.functions !== undefined) {\n                    options.source = options\n                        .source\n                        .replace(options.functions.binaryCheck, "");\n                }\n                if (options.semicolon === true) {\n                    options.source = options\n                        .source\n                        .replace(/;\\n/g, "\\n")\n                        .replace(/;$/, "");\n                }\n            }\n            options.diffview        = (options.diffview === "inline")\n                ? "inline"\n                : "sidebyside";\n            options.diffcomments    = (\n                options.diffcomments === true || options.diffcomments === "true"\n            );\n            options.diffspaceignore = (\n                options.diffspaceignore === true || options.diffspaceignore === "true"\n            );\n            options.quote           = (options.quote === true || options.quote === "true");\n            options.semicolon       = (\n                options.semicolon === true || options.semicolon === "true"\n            );\n            options.content         = (options.content === true || options.content === "true");\n            options.diffcli         = (options.diffcli === true || options.diffcli === "true");\n            options.context         = (isNaN(options.context) === false)\n                ? Number(options.context)\n                : -1;\n            if (options.diffcli === true && options.context < 0) {\n                options.context = 2;\n            }\n        }());\n        var errorout      = 0,\n            //diffline is a count of lines that are not equal\n            diffline      = 0,\n            //tab is a construct of a standard indentation for code\n            tab           = (function diffview__tab() {\n                var a      = 0,\n                    output = [];\n                if (options.inchar === "") {\n                    return "";\n                }\n                for (a = 0; a < options.insize; a = a + 1) {\n                    output.push(options.inchar);\n                }\n                return output.join("");\n            }()),\n            //translates source code from a string to an array by splitting on line breaks\n            stringAsLines = function diffview__stringAsLines(str) {\n                var lines = (options.diffcli === true)\n                    ? str\n                    : str\n                        .replace(/&/g, "&amp;")\n                        .replace(/&#lt;/g, "$#lt;")\n                        .replace(/&#gt;/g, "$#gt;")\n                        .replace(/</g, "$#lt;")\n                        .replace(/>/g, "$#gt;");\n                return lines.split("\\n");\n            },\n            //array representation of base source\n            baseTextArray = (typeof options.source === "string")\n                ? stringAsLines(options.source)\n                : options.source,\n            //array representation of new source\n            newTextArray  = (typeof options.diff === "string")\n                ? stringAsLines(options.diff)\n                : options.diff,\n            opcodes       = [],\n            codeBuild     = function diffview__opcodes() {\n                var table           = {},\n                    one             = (typeof options.source === "string")\n                        ? options.source.split("\\n")\n                        : options.source,\n                    two             = (typeof options.diff === "string")\n                        ? options.diff.split("\\n")\n                        : options.diff,\n                    lena            = one.length,\n                    lenb            = two.length,\n                    a               = 0,\n                    b               = 0,\n                    c               = 0,\n                    d               = 0,\n                    codes           = [],\n                    fix             = function diffview__opcodes_fix(code) {\n                        var prior = codes[codes.length - 1];\n                        if (prior !== undefined) {\n                            if (prior[0] === code[0]) {\n                                if (code[0] === "replace" || code[0] === "equal") {\n                                    prior[2] = code[2];\n                                    prior[4] = code[4];\n                                } else if (code[0] === "delete") {\n                                    prior[2] = code[2];\n                                } else if (code[0] === "insert") {\n                                    prior[4] = code[4];\n                                }\n                                return;\n                            }\n                            if (prior[0] === "insert" && prior[4] - prior[3] === 1) {\n                                if (code[2] - code[1] === 1) {\n                                    if (code[0] === "replace") {\n                                        prior[0] = "replace";\n                                        prior[1] = code[1];\n                                        prior[2] = code[2];\n                                        code[0]  = "insert";\n                                        code[1]  = -1;\n                                        code[2]  = -1;\n                                    } else if (code[0] === "delete") {\n                                        code[0] = "replace";\n                                        code[3] = prior[3];\n                                        code[4] = prior[4];\n                                        codes.pop();\n                                        prior = codes[codes.length - 1];\n                                        if (prior[0] === "replace") {\n                                            prior[2] = code[2];\n                                            prior[4] = code[4];\n                                            return;\n                                        }\n                                    }\n                                } else if (code[0] === "delete") {\n                                    prior[0] = "replace";\n                                    prior[1] = code[1];\n                                    prior[2] = code[1] + 1;\n                                    code[1]  = code[1] + 1;\n                                } else if (code[0] === "replace") {\n                                    prior[0] = "replace";\n                                    prior[1] = code[1];\n                                    prior[2] = code[1] + 1;\n                                    c = prior[2];\n                                    d = prior[4];\n                                    return;\n                                }\n                            } else if (prior[0] === "insert" && code[0] === "delete" && code[2] - code[1] === 1) {\n                                prior[4] = prior[4] - 1;\n                                code[0]  = "replace";\n                                code[3]  = prior[4];\n                                code[4]  = prior[4] + 1;\n                            } else if (prior[0] === "delete" && prior[2] - prior[1] === 1) {\n                                if (code[4] - code[3] === 1) {\n                                    if (code[0] === "replace") {\n                                        prior[0] = "replace";\n                                        prior[3] = code[3];\n                                        prior[4] = code[4];\n                                        code[0]  = "delete";\n                                        code[3]  = -1;\n                                        code[4]  = -1;\n                                    } else if (code[0] === "insert") {\n                                        code[0] = "replace";\n                                        code[1] = prior[1];\n                                        code[2] = prior[2];\n                                        codes.pop();\n                                        prior = codes[codes.length - 1];\n                                        if (prior[0] === "replace") {\n                                            prior[2] = code[2];\n                                            prior[4] = code[4];\n                                            return;\n                                        }\n                                    }\n                                } else if (code[0] === "insert") {\n                                    prior[0] = "replace";\n                                    prior[3] = code[3];\n                                    prior[4] = code[3] + 1;\n                                    code[3]  = code[3] + 1;\n                                } else if (code[0] === "replace") {\n                                    prior[0] = "replace";\n                                    prior[3] = code[3];\n                                    prior[4] = code[4] + 1;\n                                    c = prior[2];\n                                    d = prior[4];\n                                    return;\n                                }\n                            } else if (prior[0] === "delete" && code[0] === "insert" && code[4] - code[3] === 1) {\n                                prior[2] = prior[2] - 1;\n                                code[0]  = "replace";\n                                code[1]  = prior[2];\n                                code[2]  = prior[2] + 1;\n                            } else if (prior[0] === "replace") {\n                                if (code[0] === "delete") {\n                                    if (one[code[2] - 1] === two[prior[4] - 1]) {\n                                        if (prior[2] - prior[1] > 1) {\n                                            prior[4] = prior[4] - 1;\n                                        }\n                                        c = c - 1;\n                                        d = d - 1;\n                                        return;\n                                    }\n                                    if (one[code[2]] === two[prior[4] - 1]) {\n                                        if (prior[2] - prior[1] > 1) {\n                                            prior[2]             = prior[2] - 1;\n                                            prior[4]             = prior[4] - 11;\n                                            table[one[c - 1]][0] = table[one[c - 1]][0] - 1;\n                                        }\n                                    }\n                                } else if (code[0] === "insert") {\n                                    if (one[prior[2] - 1] === two[code[4] - 1]) {\n                                        if (prior[2] - prior[1] > 1) {\n                                            prior[2] = prior[2] - 1;\n                                        }\n                                        c = c - 1;\n                                        d = d - 1;\n                                        return;\n                                    }\n                                    if (one[code[2] - 1] === two[prior[4]]) {\n                                        if (prior[4] - prior[3] > 1) {\n                                            prior[2]             = prior[2] - 1;\n                                            prior[4]             = prior[4] - 1;\n                                            table[two[d - 1]][1] = table[two[d - 1]][1] - 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        codes.push(code);\n                    },\n                    equality        = function diffview__opcodes_equality() {\n                        do {\n                            table[one[c]][0] = table[one[c]][0] - 1;\n                            table[one[c]][1] = table[one[c]][1] - 1;\n                            c                = c + 1;\n                            d                = d + 1;\n                        } while (c < lena && d < lenb && one[c] === two[d]);\n                        fix(["equal", a, c, b, d]);\n                        b = d - 1;\n                        a = c - 1;\n                    },\n                    deletion        = function diffview__opcodes_deletion() {\n                        do {\n                            table[one[c]][0] = table[one[c]][0] - 1;\n                            c                = c + 1;\n                        } while (c < lena && table[one[c]][1] < 1);\n                        fix(["delete", a, c, -1, -1]);\n                        a = c - 1;\n                        b = d - 1;\n                    },\n                    deletionStatic  = function diffview__opcodes_deletionStatic() {\n                        table[one[a]][0] = table[one[a]][0] - 1;\n                        fix([\n                            "delete", a, a + 1,\n                            -1,\n                            -1\n                        ]);\n                        a = c;\n                        b = d - 1;\n                    },\n                    insertion       = function diffview__opcodes_insertion() {\n                        do {\n                            table[two[d]][1] = table[two[d]][1] - 1;\n                            d                = d + 1;\n                        } while (d < lenb && table[two[d]][0] < 1);\n                        fix(["insert", -1, -1, b, d]);\n                        a = c - 1;\n                        b = d - 1;\n                    },\n                    insertionStatic = function diffview__opcodes_insertionStatic() {\n                        table[two[b]][1] = table[two[b]][1] - 1;\n                        fix([\n                            "insert", -1, -1, b, b + 1\n                        ]);\n                        a = c - 1;\n                        b = d;\n                    },\n                    replacement     = function diffview__opcodes_replacement() {\n                        do {\n                            table[one[c]][0] = table[one[c]][0] - 1;\n                            table[two[d]][1] = table[two[d]][1] - 1;\n                            c                = c + 1;\n                            d                = d + 1;\n                        } while (c < lena && d < lenb && table[one[c]][1] > 0 && table[two[d]][0] > 0);\n                        fix(["replace", a, c, b, d]);\n                        a = c - 1;\n                        b = d - 1;\n                    },\n                    replaceUniques  = function diffview__opcodes_replaceUniques() {\n                        do {\n                            table[one[c]][0] = table[one[c]][0] - 1;\n                            c                = c + 1;\n                            d                = d + 1;\n                        } while (c < lena && d < lenb && table[one[c]][1] < 1 && table[two[d]][0] < 1);\n                        fix(["replace", a, c, b, d]);\n                        a = c - 1;\n                        b = d - 1;\n                    };\n\n                // * First Pass, account for lines from first file\n                // * build the table from the second file\n                do {\n                    if (options.diffspaceignore === true) {\n                        two[b] = two[b].replace(/\\s+/g, "");\n                    }\n                    if (table[two[b]] === undefined) {\n                        table[two[b]] = [0, 1];\n                    } else {\n                        table[two[b]][1] = table[two[b]][1] + 1;\n                    }\n                    b = b + 1;\n                } while (b < lenb);\n\n                // * Second Pass, account for lines from second file\n                // * build the table from the first file\n                lena = one.length;\n                a    = 0;\n                do {\n                    if (options.diffspaceignore === true) {\n                        one[a] = one[a].replace(/\\s+/g, "");\n                    }\n                    if (table[one[a]] === undefined) {\n                        table[one[a]] = [1, 0];\n                    } else {\n                        table[one[a]][0] = table[one[a]][0] + 1;\n                    }\n                    a = a + 1;\n                } while (a < lena);\n                a = 0;\n                b = 0;\n                // find all equality... differences are what\'s left over solve only for the\n                // second set test removing reverse test removing undefined checks for table\n                // refs\n\n                do {\n                    c = a;\n                    d = b;\n                    if (one[a] === two[b]) {\n                        equality();\n                    } else if (table[one[a]][1] < 1 && table[two[b]][0] < 1) {\n                        replaceUniques();\n                    } else if (table[one[a]][1] < 1 && one[a + 1] !== two[b + 2]) {\n                        deletion();\n                    } else if (table[two[b]][0] < 1 && one[a + 2] !== two[b + 1]) {\n                        insertion();\n                    } else if (table[one[a]][0] - table[one[a]][1] === 1 && one[a + 1] !== two[b + 2]) {\n                        deletionStatic();\n                    } else if (table[two[b]][1] - table[two[b]][0] === 1 && one[a + 2] !== two[b + 1]) {\n                        insertionStatic();\n                    } else if (one[a + 1] === two[b]) {\n                        deletion();\n                    } else if (one[a] === two[b + 1]) {\n                        insertion();\n                    } else {\n                        replacement();\n                    }\n                    a = a + 1;\n                    b = b + 1;\n                } while (a < lena && b < lenb);\n                if (lena - a === lenb - b) {\n                    if (one[a] === two[b]) {\n                        fix(["equal", a, lena, b, lenb]);\n                    } else {\n                        fix(["replace", a, lena, b, lenb]);\n                    }\n                } else if (a < lena) {\n                    fix(["delete", a, lena, -1, -1]);\n                } else if (b < lenb) {\n                    fix(["insert", -1, -1, b, lenb]);\n                }\n                return codes;\n            };\n\n        if (Array.isArray(options.source) === false && typeof options.source !== "string") {\n            return "Error: source value is not a string or array!";\n        }\n        if (Array.isArray(options.diff) === false && typeof options.diff !== "string") {\n            return "Error: diff value is not a string or array!";\n        }\n\n        opcodes = codeBuild();\n        //diffview application contains three primary parts\n        // 1.  opcodes - performs the \'largest common subsequence\'    calculation to\n        // determine which lines are different.  I    did not write this logic.  I have\n        // rewritten it for    performance, but original logic is still intact.\n        // 2.  charcomp - performs the \'largest common subsequence\' upon    characters\n        // of two compared lines.\n        // 3.  The construction of the output into the \'node\' array errorout is a count\n        // of differences after the opcodes generate the other two core pieces of logic\n        // are quaranteened into an anonymous function.\n        return (function diffview__report() {\n            var a              = 0,\n                i              = 0,\n                node           = ["<div class=\'diff\'>"],\n                data           = (options.diffcli === true)\n                    ? []\n                    : [\n                        [], [], [], []\n                    ],\n                baseStart      = 0,\n                baseEnd        = 0,\n                newStart       = 0,\n                newEnd         = 0,\n                rowcnt         = 0,\n                rowItem        = -1,\n                rcount         = 0,\n                foldcount      = 0,\n                foldstart      = -1,\n                jump           = 0,\n                finaldoc       = "",\n                tabFix         = (tab === "")\n                    ? ""\n                    : new RegExp("^((" + tab.replace(/\\\\/g, "\\\\") + ")+)"),\n                noTab          = function diffview__report_noTab(str) {\n                    var b      = 0,\n                        strLen = str.length,\n                        output = [];\n                    for (b = 0; b < strLen; b = b + 1) {\n                        output.push(str[b].replace(tabFix, ""));\n                    }\n                    return output;\n                },\n                htmlfix        = function diffview__report_htmlfix(item) {\n                    return item.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");\n                },\n                baseTab        = (tab === "")\n                    ? []\n                    : noTab(baseTextArray),\n                newTab         = (tab === "")\n                    ? []\n                    : noTab(newTextArray),\n                opcodesLength  = opcodes.length,\n                change         = "",\n                btest          = false,\n                ntest          = false,\n                repeat         = false,\n                ctest          = true,\n                code           = [],\n                charcompOutput = [],\n                // this is the character comparison logic that performs the \'largest common\n                // subsequence\' between two lines of code\n                charcomp       = function diffview__report_charcomp(lineA, lineB) {\n                    var b             = 0,\n                        dataA         = [],\n                        dataB         = [],\n                        cleanedA      = (options.diffcli === true)\n                            ? lineA\n                            : lineA\n                                .replace(/&#160;/g, " ")\n                                .replace(/&nbsp;/g, " ")\n                                .replace(/&lt;/g, "<")\n                                .replace(/&gt;/g, ">")\n                                .replace(/\\$#lt;/g, "<")\n                                .replace(/\\$#gt;/g, ">")\n                                .replace(/&amp;/g, "&"),\n                        cleanedB      = (options.diffcli === true)\n                            ? lineB\n                            : lineB\n                                .replace(/&#160;/g, " ")\n                                .replace(/&nbsp;/g, " ")\n                                .replace(/&lt;/g, "<")\n                                .replace(/&gt;/g, ">")\n                                .replace(/\\$#lt;/g, "<")\n                                .replace(/\\$#gt;/g, ">")\n                                .replace(/&amp;/g, "&"),\n                        dataMinLength = 0,\n                        currentdiff   = [],\n                        regStart      = (/_pdiffdiff\\u005f/g),\n                        regEnd        = (/_epdiffdiff\\u005f/g),\n                        strStart      = "_pdiffdiff\\u005f",\n                        strEnd        = "_epdiffdiff\\u005f",\n                        tabdiff       = (function diffview__report_charcomp_tabdiff() {\n                            var tabMatchA  = "",\n                                tabMatchB  = "",\n                                splitA     = "",\n                                splitB     = "",\n                                analysis   = [],\n                                matchListA = cleanedA.match(tabFix),\n                                matchListB = cleanedB.match(tabFix);\n                            if (matchListA === null || matchListB === null || (matchListA[0] === "" && matchListA.length === 1) || (matchListB[0] === "" && matchListB.length === 1)) {\n                                return ["", "", cleanedA, cleanedB];\n                            }\n                            tabMatchA = matchListA[0];\n                            tabMatchB = matchListB[0];\n                            splitA    = cleanedA.split(tabMatchA)[1];\n                            splitB    = cleanedB.split(tabMatchB)[1];\n                            if (tabMatchA.length > tabMatchB.length) {\n                                analysis  = tabMatchA.split(tabMatchB);\n                                tabMatchA = tabMatchB + strStart + analysis[1] + strEnd;\n                                tabMatchB = tabMatchB + strStart + strEnd;\n                            } else {\n                                analysis  = tabMatchB.split(tabMatchA);\n                                tabMatchB = tabMatchA + strStart + analysis[1] + strEnd;\n                                tabMatchA = tabMatchA + strStart + strEnd;\n                            }\n                            return [tabMatchA, tabMatchB, splitA, splitB];\n                        }()),\n                        whiteout      = function diffview__report_charcomp_whiteout(whitediff) {\n                            var spacetest = (/<((em)|(pd))>\\u0020+<\\/((em)|(pd))>/),\n                                crtest    = (/<((em)|(pd))>\\r+<\\/((em)|(pd))>/);\n                            if (spacetest.test(whitediff) === true) {\n                                return whitediff;\n                            }\n                            if (crtest.test(whitediff) === true) {\n                                return whitediff.replace(/\\s+/, "(carriage return)");\n                            }\n                            return whitediff.replace(/\\s+/, "(white space differences)");\n                        },\n                        //compare is the fuzzy string comparison algorithm\n                        compare       = function diffview__report_charcomp_compare(start) {\n                            var x          = 0,\n                                y          = 0,\n                                max        = Math.max(dataA.length, dataB.length),\n                                store      = [],\n                                sorta      = function diffview__report_charcomp_compare_sorta(a, b) {\n                                    if (a[1] - a[0] < b[1] - b[0]) {\n                                        return 1;\n                                    }\n                                    return -1;\n                                },\n                                sortb      = function diffview__report_charcomp_compare_sortb(a, b) {\n                                    if (a[0] + a[1] > b[0] + b[1]) {\n                                        return 1;\n                                    }\n                                    return -1;\n                                },\n                                whitetest  = (/^(\\s+)$/),\n                                whitespace = false,\n                                wordtest   = false;\n                            //first gather a list of all matching indexes into an array\n                            for (x = start; x < dataMinLength; x = x + 1) {\n                                for (y = start; y < max; y = y + 1) {\n                                    if (dataA[x] === dataB[y] || dataB[x] === dataA[y]) {\n                                        store.push([x, y]);\n                                        if (dataA[y] === dataB[x] && dataA[y + 1] === dataB[x + 1] && whitetest.test(dataB[x - 1]) === true) {\n                                            wordtest = true;\n                                            store    = [\n                                                [x, y]\n                                            ];\n                                        }\n                                        if (dataA[x] === dataB[y] && dataA[x + 1] === dataB[y + 1] && whitetest.test(dataB[y - 1]) === true) {\n                                            wordtest = true;\n                                            store    = [\n                                                [x, y]\n                                            ];\n                                        }\n                                        break;\n                                    }\n                                }\n                                if (wordtest === true) {\n                                    break;\n                                }\n                            }\n                            //if there are no character matches then quit out\n                            if (store.length === 0) {\n                                return [dataMinLength, max, 0, whitespace];\n                            }\n                            // take the list of matches and sort it first sort by size of change with\n                            // shortest up front second sort by sum of change start and end the second sort\n                            // results in the smallest change from the earliest point\n                            store.sort(sorta);\n                            if (dataMinLength - start < 5000) {\n                                store.sort(sortb);\n                            }\n                            //x should always be the shorter index (change start)\n                            if (store[0][0] < store[0][1]) {\n                                x = store[0][0];\n                                y = store[0][1];\n                            } else {\n                                y = store[0][0];\n                                x = store[0][1];\n                            }\n                            //package the output\n                            if (dataA[y] === dataB[x]) {\n                                if (dataA[y - 1] === dataB[x - 1] && x !== start) {\n                                    x = x - 1;\n                                    y = y - 1;\n                                }\n                                if (options.diffspaceignore === true && ((whitetest.test(dataA[y - 1]) === true && y - start > 0) || (whitetest.test(dataB[x - 1]) === true && x - start > 0))) {\n                                    whitespace = true;\n                                }\n                                return [x, y, 0, whitespace];\n                            }\n                            if (dataA[x] === dataB[y]) {\n                                if (dataA[x - 1] === dataB[y - 1] && x !== start) {\n                                    x = x - 1;\n                                    y = y - 1;\n                                }\n                                if (options.diffspaceignore === true && ((whitetest.test(dataA[x - 1]) === true && x - start > 0) || (whitetest.test(dataB[y - 1]) === true && y - start > 0))) {\n                                    whitespace = true;\n                                }\n                                return [x, y, 1, whitespace];\n                            }\n                        };\n                    //if same after accounting for character entities then exit\n                    if (cleanedA === cleanedB) {\n                        return [lineA, lineB];\n                    }\n                    //prevent extra error counting that occurred before entering this function\n                    errorout = errorout - 1;\n                    //diff for tabs\n                    if (tabFix !== "" && cleanedA.length !== cleanedB.length && cleanedA.replace(tabFix, "") === cleanedB.replace(tabFix, "") && options.diffspaceignore === false) {\n                        errorout = errorout + 1;\n                        if (options.diffcli === true) {\n                            tabdiff[0] = tabdiff[0] + tabdiff[2];\n                            tabdiff[0] = tabdiff[0]\n                                .replace(regStart, "<pd>")\n                                .replace(regEnd, "</pd>");\n                            tabdiff[1] = tabdiff[1] + tabdiff[3];\n                            tabdiff[1] = tabdiff[1]\n                                .replace(regStart, "<pd>")\n                                .replace(regEnd, "</pd>");\n                            return [\n                                tabdiff[0], tabdiff[1]\n                            ];\n                        }\n                        tabdiff[0] = tabdiff[0] + tabdiff[2];\n                        tabdiff[0] = tabdiff[0]\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;")\n                            .replace(regStart, "<em>")\n                            .replace(regEnd, "</em>");\n                        tabdiff[1] = tabdiff[1] + tabdiff[3];\n                        tabdiff[1] = tabdiff[1]\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;")\n                            .replace(regStart, "<em>")\n                            .replace(regEnd, "</em>");\n                        return [\n                            tabdiff[0], tabdiff[1]\n                        ];\n                    }\n                    //turn the pruned input into arrays\n                    dataA         = cleanedA.split("");\n                    dataB         = cleanedB.split("");\n                    //the length of the shortest array\n                    dataMinLength = Math.min(dataA.length, dataB.length);\n                    for (b = 0; b < dataMinLength; b = b + 1) {\n                        //if undefined break the loop\n                        if (dataA[b] === undefined || dataB[b] === undefined) {\n                            break;\n                        }\n                        //iterate until the arrays are not the same\n                        if (dataA[b] !== dataB[b]) {\n                            // fuzzy string comparison returns an array with these indexes 0 - shorter\n                            // ending index of difference 1 - longer ending index of difference 2 - 0 if\n                            // index 2 is for dataA or 1 for dataB 3 - whether the difference is only\n                            // whitespace\n                            currentdiff = compare(b);\n                            //supply the difference start indicator\n                            if (currentdiff[3] === false) {\n                                //count each difference\n                                errorout = errorout + 1;\n                                if (b > 0) {\n                                    dataA[b - 1] = dataA[b - 1] + strStart;\n                                    dataB[b - 1] = dataB[b - 1] + strStart;\n                                } else {\n                                    dataA[b] = strStart + dataA[b];\n                                    dataB[b] = strStart + dataB[b];\n                                }\n                                //complex decision tree on how to supply difference end indicator\n                                if (currentdiff[2] === 1) {\n                                    if (currentdiff[0] === 0) {\n                                        dataA[0] = dataA[0].replace(regStart, strStart + strEnd);\n                                    } else if (currentdiff[0] === dataMinLength) {\n                                        if (dataB.length === dataMinLength) {\n                                            dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;\n                                        } else {\n                                            dataA[currentdiff[0] - 1] = dataA[currentdiff[0] - 1] + strEnd;\n                                        }\n                                    } else {\n                                        if (dataA[currentdiff[0]].indexOf(strStart) > -1) {\n                                            dataA[currentdiff[0]] = dataA[currentdiff[0]] + strEnd;\n                                        } else if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {\n                                            dataA[b] = strEnd + dataA[b];\n                                        } else {\n                                            dataA[currentdiff[0]] = strEnd + dataA[currentdiff[0]];\n                                        }\n                                    }\n                                    if (currentdiff[1] > dataB.length - 1 || currentdiff[0] === dataMinLength) {\n                                        dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;\n                                    } else if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {\n                                        dataB[b + (currentdiff[1] - currentdiff[0])] = strEnd + dataB[b + (currentdiff[1] - currentdiff[0])];\n                                    } else {\n                                        dataB[currentdiff[1]] = strEnd + dataB[currentdiff[1]];\n                                    }\n                                } else {\n                                    if (currentdiff[0] === 0) {\n                                        dataB[0] = dataB[0].replace(regStart, strStart + strEnd);\n                                    } else if (currentdiff[0] === dataMinLength) {\n                                        if (dataA.length === dataMinLength) {\n                                            dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;\n                                        } else {\n                                            dataB[currentdiff[0] - 1] = dataB[currentdiff[0] - 1] + strEnd;\n                                        }\n                                    } else {\n                                        if (dataB[currentdiff[0]].indexOf(strStart) > -1) {\n                                            dataB[currentdiff[0]] = dataB[currentdiff[0]] + strEnd;\n                                        } else if (currentdiff[0] - currentdiff[1] === currentdiff[1]) {\n                                            dataB[b] = strEnd + dataB[b];\n                                        } else {\n                                            dataB[currentdiff[0]] = strEnd + dataB[currentdiff[0]];\n                                        }\n                                    }\n                                    if (currentdiff[1] > dataA.length - 1 || currentdiff[0] === dataMinLength) {\n                                        dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;\n                                    } else if (currentdiff[0] - currentdiff[1] === currentdiff[1]) {\n                                        dataA[b + (currentdiff[0] - currentdiff[1])] = strEnd + dataA[b + (currentdiff[0] - currentdiff[1])];\n                                    } else {\n                                        dataA[currentdiff[1]] = strEnd + dataA[currentdiff[1]];\n                                    }\n                                }\n                            }\n                            // we must rebase the array with the shorter difference so that the end of the\n                            // current difference is on the same index.  This provides a common baseline by\n                            // which to find the next unmatching index\n                            if (currentdiff[1] > currentdiff[0] && currentdiff[1] - currentdiff[0] < 1000) {\n                                if (currentdiff[2] === 1) {\n                                    do {\n                                        dataA.unshift("");\n                                        currentdiff[0] = currentdiff[0] + 1;\n                                    } while (currentdiff[1] > currentdiff[0]);\n                                } else {\n                                    do {\n                                        dataB.unshift("");\n                                        currentdiff[0] = currentdiff[0] + 1;\n                                    } while (currentdiff[1] > currentdiff[0]);\n                                }\n                            }\n                            // since the previous logic will grow the shorter array we have to redefine the\n                            // shortest length\n                            dataMinLength = Math.min(dataA.length, dataB.length);\n                            //assign the incrementer to the end of the longer difference\n                            b             = currentdiff[1];\n                        }\n                    }\n                    // if one array is longer than the other and not identified as different then\n                    // identify this difference in length\n                    if (dataA.length > dataB.length && dataB[dataB.length - 1] !== undefined && dataB[dataB.length - 1].indexOf(strEnd) < 1) {\n                        dataB.push(strStart + strEnd);\n                        dataA[dataB.length - 1] = strStart + dataA[dataB.length - 1];\n                        dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;\n                        errorout                = errorout + 1;\n                    }\n                    if (dataB.length > dataA.length && dataA[dataA.length - 1] !== undefined && dataA[dataA.length - 1].indexOf(strEnd) < 1) {\n                        dataA.push(strStart + strEnd);\n                        dataB[dataA.length - 1] = strStart + dataB[dataA.length - 1];\n                        dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;\n                        errorout                = errorout + 1;\n                    }\n                    // options.diffcli output doesn\'t need XML protected characters to be escaped\n                    // because its output is the command line\n                    if (options.diffcli === true) {\n                        return [\n                            dataA\n                                .join("")\n                                .replace(regStart, "<pd>")\n                                .replace(regEnd, "</pd>")\n                                .replace(/<pd>\\s+<\\/pd>/g, whiteout),\n                            dataB\n                                .join("")\n                                .replace(regStart, "<pd>")\n                                .replace(regEnd, "</pd>")\n                                .replace(/<pd>\\s+<\\/pd>/g, whiteout)\n                        ];\n                    }\n                    return [\n                        dataA\n                            .join("")\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;")\n                            .replace(regStart, "<em>")\n                            .replace(regEnd, "</em>")\n                            .replace(/<em>\\s+<\\/em>/g, whiteout),\n                        dataB\n                            .join("")\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;")\n                            .replace(regStart, "<em>")\n                            .replace(regEnd, "</em>")\n                            .replace(/<em>\\s+<\\/em>/g, whiteout)\n                    ];\n                };\n            if (options.diffcli === false) {\n                if (options.diffview === "inline") {\n                    node.push("<h3 class=\'texttitle\'>");\n                    node.push(options.sourcelabel);\n                    node.push(" vs. ");\n                    node.push(options.difflabel);\n                    node.push("</h3><ol class=\'count\'>");\n                } else {\n                    data[0].push("<div class=\'diff-left\'><h3 class=\'texttitle\'>");\n                    data[0].push(options.sourcelabel);\n                    data[0].push("</h3><ol class=\'count\'>");\n                    data[2].push("<div class=\'diff-right\'><h3 class=\'texttitle\'>");\n                    data[2].push(options.difflabel);\n                    data[2].push("</h3><ol class=\'count\' style=\'cursor:w-resize\'>");\n                }\n            } else {\n                foldstart = 0;\n            }\n            for (a = 0; a < opcodesLength; a = a + 1) {\n                code      = opcodes[a];\n                change    = code[0];\n                baseStart = code[1];\n                baseEnd   = code[2];\n                newStart  = code[3];\n                newEnd    = code[4];\n                rowcnt    = Math.max(baseEnd - baseStart, newEnd - newStart);\n                ctest     = true;\n\n                if (foldstart > -1 && options.diffcli === false) {\n                    data[0][foldstart] = data[0][foldstart].replace("xxx", foldcount);\n                }\n                if (options.diffcli === true) {\n                    if (foldstart > 49 && change === "equal") {\n                        break;\n                    }\n                    if (options.diffspaceignore === true && change === "replace" && baseTextArray[baseStart] !== undefined && newTextArray[newStart] !== undefined && baseTextArray[baseStart].replace(/\\s+/g, "") === newTextArray[newStart].replace(/\\s+/g, "")) {\n                        change = "equal";\n                    } else if (change !== "equal") {\n                        if (a > 0 && opcodes[a - 1][0] === "equal") {\n                            foldcount = options.context;\n                            if ((ntest === true || change === "insert") && (options.diffspaceignore === false || (/^(\\s+)$/g).test(newTextArray[newStart]) === false)) {\n                                foldstart = foldstart + 1;\n                                if (options.api === "dom") {\n                                    data.push("</li><li><h3>Line: ");\n                                    data.push(opcodes[a - 1][2] + 1);\n                                    data.push("</h3>");\n                                } else {\n                                    data.push("");\n                                    data.push("\\u001b[36mLine: " + (opcodes[a - 1][2] + 1) + "\\u001b[39m");\n                                }\n                                if (foldcount > 0) {\n                                    do {\n                                        if (newStart - foldcount > -1) {\n                                            if (options.api === "dom") {\n                                                data.push("<p>");\n                                                data.push(htmlfix(newTextArray[newStart - foldcount]));\n                                                data.push("</p>");\n                                            } else {\n                                                data.push(newTextArray[newStart - foldcount]);\n                                            }\n                                        }\n                                        foldcount = foldcount - 1;\n                                    } while (foldcount > 0);\n                                }\n                            } else {\n                                foldstart = foldstart + 1;\n                                if (options.api === "dom") {\n                                    data.push("</li><li><h3>Line: ");\n                                    data.push(baseStart + 1);\n                                    data.push("</h3>");\n                                } else {\n                                    data.push("");\n                                    data.push("\\u001b[36mLine: " + (baseStart + 1) + "\\u001b[39m");\n                                }\n                                if (foldcount > 0) {\n                                    do {\n                                        if (baseStart - foldcount > -1) {\n                                            if (options.api === "dom") {\n                                                data.push("<p>");\n                                                data.push(htmlfix(newTextArray[newStart - foldcount]));\n                                                data.push("</p>");\n                                            } else {\n                                                data.push(baseTextArray[baseStart - foldcount]);\n                                            }\n                                        }\n                                        foldcount = foldcount - 1;\n                                    } while (foldcount > 0);\n                                }\n                            }\n                        } else if (a < 1) {\n                            if (options.api === "dom") {\n                                data.push("</li><li><h3>Line: 1</h3>");\n                            } else {\n                                data.push("");\n                                data.push("\\u001b[36mLine: 1\\u001b[39m");\n                            }\n                            foldstart = foldstart + 1;\n                        }\n                        foldcount = 0;\n                        if ((ntest === true || change === "insert") && (options.diffspaceignore === false || (/^(\\s+)$/g).test(newTextArray[newStart]) === false)) {\n                            do {\n                                if (options.api === "dom") {\n                                    data.push("<ins>");\n                                    data.push(htmlfix(newTextArray[newStart + foldcount]));\n                                    data.push("</ins>");\n                                } else {\n                                    data.push("\\u001b[32m" + newTextArray[newStart + foldcount] + "\\u001b[39m");\n                                }\n                                foldcount = foldcount + 1;\n                            } while (foldcount < 7 && foldcount + newStart < newEnd);\n                        } else if (change === "delete" && (options.diffspaceignore === false || (/^(\\s+)$/g).test(baseTextArray[baseStart]) === false)) {\n                            do {\n                                if (options.api === "dom") {\n                                    data.push("<del>");\n                                    data.push(htmlfix(baseTextArray[baseStart + foldcount]))\n                                    data.push("</del>");\n                                } else {\n                                    data.push("\\u001b[31m" + baseTextArray[baseStart + foldcount] + "\\u001b[39m");\n                                }\n                                foldcount = foldcount + 1;\n                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);\n                        } else if (change === "replace" && (options.diffspaceignore === false || baseTextArray[baseStart].replace(/\\s+/g, "") !== newTextArray[newStart].replace(/\\s+/g, ""))) {\n                            do {\n                                charcompOutput = charcomp(\n                                    baseTextArray[baseStart + foldcount],\n                                    newTextArray[newStart + foldcount]\n                                );\n                                if (options.api === "dom") {\n                                    data.push("<del>");\n                                    data.push(htmlfix(charcompOutput[0]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\\/pd&gt;/g, "</em>"));\n                                    data.push("</del><ins>");\n                                    data.push(htmlfix(charcompOutput[1]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\\/pd&gt;/g, "</em>"));\n                                    data.push("</ins>");\n                                } else {\n                                    data.push("\\u001b[31m" + charcompOutput[0].replace(/<pd>/g, "\\u001b[1m").replace(/<\\/pd>/g, "\\u001b[22m") + "\\u001b[39m");\n                                    data.push("\\u001b[32m" + charcompOutput[1].replace(/<pd>/g, "\\u001b[1m").replace(/<\\/pd>/g, "\\u001b[22m") + "\\u001b[39m");\n                                }\n                                foldcount = foldcount + 1;\n                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);\n                        }\n                        if (((change === "insert" && foldcount + newStart === newEnd) || (change !== "insert" && foldcount + baseStart === baseEnd)) && baseTextArray[baseStart + foldcount] !== undefined && options.context > 0 && a < opcodesLength - 1 && opcodes[a + 1][0] === "equal") {\n                            foldcount = 0;\n                            baseStart = opcodes[a + 1][1];\n                            baseEnd   = opcodes[a + 1][2] - baseStart;\n                            do {\n                                if (options.api === "dom") {\n                                    data.push("<p>");\n                                    data.push(htmlfix(baseTextArray[baseStart + foldcount]));\n                                    data.push("</p>");\n                                } else {\n                                    data.push(baseTextArray[baseStart + foldcount]);\n                                }\n                                foldcount = foldcount + 1;\n                            } while (foldcount < options.context && foldcount < baseEnd);\n                        }\n                        if (btest === true) {\n                            baseStart = baseStart + 1;\n                            btest     = false;\n                        } else if (ntest === true) {\n                            newStart = newStart + 1;\n                            ntest    = false;\n                        } else {\n                            baseStart = baseStart + 1;\n                            newStart  = newStart + 1;\n                        }\n                    }\n                } else {\n                    for (i = 0; i < rowcnt; i = i + 1) {\n                        //apply options.context collapsing for the output, if needed\n                        if (options.context > -1 && opcodes.length > 1 && ((a > 0 && i === options.context) || (a === 0 && i === 0)) && change === "equal") {\n                            ctest = false;\n                            jump  = rowcnt - ((a === 0\n                                ? 1\n                                : 2) * options.context);\n                            if (jump > 1) {\n                                baseStart = baseStart + jump;\n                                newStart  = newStart + jump;\n                                i         = i + (jump - 1);\n                                if (options.diffcli === true) {\n                                    data[5].push([baseStart, newStart]);\n                                } else {\n                                    data[0].push("<li>...</li>");\n                                    if (options.diffview !== "inline") {\n                                        data[1].push("<li class=\\"skip\\">&#10;</li>");\n                                    }\n                                    data[2].push("<li>...</li>");\n                                    data[3].push("<li class=\\"skip\\">&#10;</li>");\n                                }\n                                if (a + 1 === opcodes.length) {\n                                    break;\n                                }\n                            }\n                        } else if (change !== "equal") {\n                            diffline = diffline + 1;\n                        }\n                        foldcount = foldcount + 1;\n                        // this is a check against false positives incurred by increasing or reducing of\n                        // nesting.  At this time it only checks one level deep.\n                        if (tab !== "") {\n                            if (btest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof baseTextArray[baseStart + 1] === "string" && typeof newTextArray[newStart] === "string" && baseTab[baseStart + 1] === newTab[newStart] && baseTab[baseStart] !== newTab[newStart] && (typeof newTextArray[newStart - 1] !== "string" || baseTab[baseStart] !== newTab[newStart - 1])) {\n                                btest = true;\n                            } else if (ntest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof newTextArray[newStart + 1] === "string" && typeof baseTextArray[baseStart] === "string" && newTab[newStart + 1] === baseTab[baseStart] && newTab[newStart] !== baseTab[baseStart] && (typeof baseTextArray[baseStart - 1] !== "string" || newTab[newStart] !== baseTab[baseStart - 1])) {\n                                ntest = true;\n                            }\n                        }\n                        if (options.diffview === "inline") {\n                            if (options.diffspaceignore === true && change === "replace" && baseTextArray[baseStart].replace(/\\s+/g, "") === newTextArray[newStart].replace(/\\s+/g, "")) {\n                                change   = "equal";\n                                errorout = errorout - 1;\n                            }\n                            if (options.context < 0 && rowItem < a) {\n                                rowItem = a;\n                                if (foldstart > -1) {\n                                    if (data[0][foldstart + 1] === foldcount - 1) {\n                                        data[0][foldstart] = "<li class=\\"" + data[0][foldstart].slice(\n                                            data[0][foldstart].indexOf(\n                                                "line xxx\\">- "\n                                            ) + 12\n                                        );\n                                    } else {\n                                        data[0][foldstart] = data[0][foldstart].replace(\n                                            "xxx",\n                                            (foldcount - 1 + rcount)\n                                        );\n                                    }\n                                }\n                                if (change !== "replace") {\n                                    if (baseEnd - baseStart > 1 || newEnd - newStart > 1) {\n                                        data[0].push("<li class=\\"fold\\" title=\\"folds from line " + (\n                                            foldcount + rcount\n                                        ) + " to line xxx\\">- ");\n                                        foldstart = data[0].length - 1;\n                                    } else {\n                                        data[0].push("<li>");\n                                    }\n                                    if (ntest === true || change === "insert") {\n                                        data[0].push("&#10;");\n                                    } else {\n                                        data[0].push(baseStart + 1);\n                                    }\n                                    data[0].push("</li>");\n                                } else {\n                                    rcount = rcount + 1;\n                                }\n                            } else if (change !== "replace") {\n                                data[0].push("<li>");\n                                if (ntest === true || change === "insert") {\n                                    data[0].push("&#10;");\n                                } else {\n                                    data[0].push(baseStart + 1);\n                                }\n                                data[0].push("</li>");\n                            } else if (change === "replace") {\n                                rcount = rcount + 1;\n                            }\n                            if (ntest === true || change === "insert") {\n                                data[2].push("<li>");\n                                data[2].push(newStart + 1);\n                                data[2].push("&#10;</li>");\n                                if (options.diffspaceignore === true && newTextArray[newStart].replace(/\\s+/g, "") === "") {\n                                    data[3].push("<li class=\\"equal\\">");\n                                    diffline = diffline - 1;\n                                } else {\n                                    data[3].push("<li class=\\"insert\\">");\n                                }\n                                data[3].push(newTextArray[newStart]);\n                                data[3].push("&#10;</li>");\n                            } else if (btest === true || change === "delete") {\n                                data[2].push("<li class=\\"empty\\">&#10;</li>");\n                                if (options.diffspaceignore === true && baseTextArray[baseStart].replace(/\\s+/g, "") === "") {\n                                    data[3].push("<li class=\\"equal\\">");\n                                    diffline = diffline - 1;\n                                } else {\n                                    data[3].push("<li class=\\"delete\\">");\n                                }\n                                data[3].push(baseTextArray[baseStart]);\n                                data[3].push("&#10;</li>");\n                            } else if (change === "replace") {\n                                if (baseTextArray[baseStart] !== newTextArray[newStart]) {\n                                    if (baseTextArray[baseStart] === "") {\n                                        charcompOutput = [\n                                            "", newTextArray[newStart]\n                                        ];\n                                    } else if (newTextArray[newStart] === "") {\n                                        charcompOutput = [baseTextArray[baseStart], ""];\n                                    } else if (baseStart < baseEnd && newStart < newEnd) {\n                                        charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);\n                                    }\n                                }\n                                if (baseStart < baseEnd) {\n                                    data[0].push("<li>" + (\n                                        baseStart + 1\n                                    ) + "</li>");\n                                    data[2].push("<li class=\\"empty\\">&#10;</li>");\n                                    if (options.diffspaceignore === true && baseTextArray[baseStart].replace(/\\s+/g, "") === "") {\n                                        data[3].push("<li class=\\"equal\\">");\n                                        diffline = diffline - 1;\n                                    } else {\n                                        data[3].push("<li class=\\"delete\\">");\n                                    }\n                                    if (newStart < newEnd) {\n                                        data[3].push(charcompOutput[0]);\n                                    } else {\n                                        data[3].push(baseTextArray[baseStart]);\n                                    }\n                                    data[3].push("&#10;</li>");\n                                }\n                                if (newStart < newEnd) {\n                                    data[0].push("<li class=\\"empty\\">&#10;</li>");\n                                    data[2].push("<li>");\n                                    data[2].push(newStart + 1);\n                                    data[2].push("</li>");\n                                    if (options.diffspaceignore === true && newTextArray[newStart].replace(/\\s+/g, "") === "") {\n                                        data[3].push("<li class=\\"equal\\">");\n                                        diffline = diffline - 1;\n                                    } else {\n                                        data[3].push("<li class=\\"insert\\">");\n                                    }\n                                    if (baseStart < baseEnd) {\n                                        data[3].push(charcompOutput[1]);\n                                    } else {\n                                        data[3].push(newTextArray[newStart]);\n                                    }\n                                    data[3].push("&#10;</li>");\n                                }\n                            } else if (baseStart < baseEnd || newStart < newEnd) {\n                                data[2].push("<li>");\n                                data[2].push(newStart + 1);\n                                data[2].push("</li>");\n                                data[3].push("<li class=\\"");\n                                data[3].push(change);\n                                data[3].push("\\">");\n                                data[3].push(baseTextArray[baseStart]);\n                                data[3].push("&#10;</li>");\n                            }\n                            if (btest === true) {\n                                baseStart = baseStart + 1;\n                                btest     = false;\n                            } else if (ntest === true) {\n                                newStart = newStart + 1;\n                                ntest    = false;\n                            } else {\n                                baseStart = baseStart + 1;\n                                newStart  = newStart + 1;\n                            }\n                        } else {\n                            if (btest === false && ntest === false && typeof baseTextArray[baseStart] === "string" && typeof newTextArray[newStart] === "string") {\n                                if (change === "replace" && baseStart < baseEnd && newStart < newEnd && baseTextArray[baseStart] !== newTextArray[newStart]) {\n                                    charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);\n                                } else {\n                                    charcompOutput = [\n                                        baseTextArray[baseStart], newTextArray[newStart]\n                                    ];\n                                }\n                                if (baseStart === Number(data[0][data[0].length - 1].substring(\n                                    data[0][data[0].length - 1].indexOf(">") + 1,\n                                    data[0][data[0].length - 1].lastIndexOf("<")\n                                )) - 1 || newStart === Number(data[2][data[2].length - 1].substring(\n                                    data[2][data[2].length - 1].indexOf(">") + 1,\n                                    data[2][data[2].length - 1].lastIndexOf("<")\n                                )) - 1) {\n                                    repeat = true;\n                                }\n                                if (repeat === false) {\n                                    if (baseStart < baseEnd) {\n                                        if (options.context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3] > 1)) {\n                                            rowItem = a;\n                                            data[0].push(\n                                                "<li class=\\"fold\\" title=\\"folds from line " + foldcount +\n                                                " to line xxx\\">- " + (\n                                                    baseStart + 1\n                                                ) + "</li>"\n                                            );\n                                            foldstart = data[0].length - 1;\n                                        } else {\n                                            data[0].push("<li>" + (\n                                                baseStart + 1\n                                            ) + "</li>");\n                                        }\n                                        data[1].push("<li class=\\"");\n                                        if (newStart >= newEnd) {\n                                            if (options.diffspaceignore === true && baseTextArray[baseStart].replace(/\\s+/g, "") === "") {\n                                                data[1].push("equal");\n                                                diffline = diffline - 1;\n                                            } else {\n                                                data[1].push("delete");\n                                            }\n                                        } else if (baseTextArray[baseStart] === "" && newTextArray[newStart] !== "" && (options.diffspaceignore === false || (baseTextArray[baseStart].replace(/\\s+/g, "") !== "" && newTextArray[newStart].replace(/\\s+/g, "") !== ""))) {\n                                            data[1].push("empty");\n                                        } else {\n                                            data[1].push(change);\n                                        }\n                                        data[1].push("\\">");\n                                        data[1].push(charcompOutput[0]);\n                                        data[1].push("&#10;</li>");\n                                    } else if (ctest === true) {\n                                        if (options.context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3])) {\n                                            rowItem = a;\n                                            if (foldstart > -1) {\n                                                data[0][foldstart] = data[0][foldstart].replace("xxx", (foldcount - 1));\n                                            }\n                                            data[0].push(\n                                                "<li class=\\"fold\\" title=\\"folds from line " + foldcount + " to line xxx\\">- &" +\n                                                "#10;</li>"\n                                            );\n                                            foldstart = data[0].length - 1;\n                                        } else {\n                                            data[0].push("<li class=\\"empty\\">&#10;</li>");\n                                        }\n                                        data[1].push("<li class=\\"empty\\"></li>");\n                                    }\n                                    if (newStart < newEnd) {\n                                        data[2].push("<li>" + (\n                                            newStart + 1\n                                        ) + "</li>");\n                                        data[3].push("<li class=\\"");\n                                        if (baseStart >= baseEnd) {\n                                            if (options.diffspaceignore === true && newTextArray[newStart].replace(/\\s+/g, "") === "") {\n                                                data[3].push("equal");\n                                                diffline = diffline - 1;\n                                            } else {\n                                                data[3].push("insert");\n                                            }\n                                        } else if (newTextArray[newStart] === "" && baseTextArray[baseStart] !== "" && (options.diffspaceignore === false || (baseTextArray[baseStart].replace(/\\s+/g, "") !== "" && newTextArray[newStart].replace(/\\s+/g, "") !== ""))) {\n                                            data[3].push("empty");\n                                        } else {\n                                            data[3].push(change);\n                                        }\n                                        data[3].push("\\">");\n                                        data[3].push(charcompOutput[1]);\n                                        data[3].push("&#10;</li>");\n                                    } else if (ctest === true) {\n                                        data[2].push("<li class=\\"empty\\">&#10;</li>");\n                                        data[3].push("<li class=\\"empty\\"></li>");\n                                    }\n                                } else {\n                                    repeat = false;\n                                }\n                                if (baseStart < baseEnd) {\n                                    baseStart = baseStart + 1;\n                                }\n                                if (newStart < newEnd) {\n                                    newStart = newStart + 1;\n                                }\n                            } else if (btest === true || (typeof baseTextArray[baseStart] === "string" && typeof newTextArray[newStart] !== "string")) {\n                                if (baseStart !== Number(data[0][data[0].length - 1].substring(\n                                    data[0][data[0].length - 1].indexOf(">") + 1,\n                                    data[0][data[0].length - 1].lastIndexOf("<")\n                                )) - 1) {\n                                    if (options.context < 0 && rowItem < a && opcodes[a][2] - opcodes[a][1] > 1) {\n                                        rowItem = a;\n                                        data[0].push(\n                                            "<li class=\\"fold\\" title=\\"folds from line " + foldcount +\n                                            " to line xxx\\">- " + (\n                                                baseStart + 1\n                                            ) + "</li>"\n                                        );\n                                        foldstart = data[0].length - 1;\n                                    } else {\n                                        data[0].push("<li>" + (\n                                            baseStart + 1\n                                        ) + "</li>");\n                                    }\n                                    data[1].push("<li class=\\"delete\\">");\n                                    data[1].push(baseTextArray[baseStart]);\n                                    data[1].push("&#10;</li>");\n                                    data[2].push("<li class=\\"empty\\">&#10;</li>");\n                                    data[3].push("<li class=\\"empty\\"></li>");\n                                }\n                                btest     = false;\n                                baseStart = baseStart + 1;\n                            } else if (ntest === true || (typeof baseTextArray[baseStart] !== "string" && typeof newTextArray[newStart] === "string")) {\n                                if (newStart !== Number(data[2][data[2].length - 1].substring(\n                                    data[2][data[2].length - 1].indexOf(">") + 1,\n                                    data[2][data[2].length - 1].lastIndexOf("<")\n                                )) - 1) {\n                                    if (options.context < 0 && rowItem < a && opcodes[a][4] - opcodes[a][3] > 1) {\n                                        rowItem = a;\n                                        data[0].push(\n                                            "<li class=\\"fold\\" title=\\"folds from line " + foldcount + " to line xxx\\">-</" +\n                                            "li>"\n                                        );\n                                        foldstart = data[0].length - 1;\n                                    } else {\n                                        data[0].push("<li class=\\"empty\\">&#10;</li>");\n                                    }\n                                    data[1].push("<li class=\\"empty\\"></li>");\n                                    data[2].push("<li>" + (\n                                        newStart + 1\n                                    ) + "</li>");\n                                    data[3].push("<li class=\\"insert\\">");\n                                    data[3].push(newTextArray[newStart]);\n                                    data[3].push("&#10;</li>");\n                                }\n                                ntest    = false;\n                                newStart = newStart + 1;\n                            }\n                        }\n                    }\n                }\n            }\n            if (options.diffcli === true) {\n                if (a < opcodesLength && foldstart > 49) {\n                    diffline = -1;\n                }\n                if (options.api === "dom") {\n                    data.push("</li></ol>");\n                    return [data.join("").replace("</li>", "<ol class=\\"diffcli\\">"), foldstart, diffline];\n                }\n                return [data, foldstart, diffline];\n            }\n            if (foldstart > -1) {\n                data[0][foldstart] = data[0][foldstart].replace("xxx", foldcount + rcount);\n            }\n            node.push(data[0].join(""));\n            node.push("</ol><ol class=");\n            if (options.diffview === "inline") {\n                node.push("\\"count\\">");\n            } else {\n                node.push("\\"data\\" data-prettydiff-ignore=\\"true\\">");\n                node.push(data[1].join(""));\n                node.push("</ol></div>");\n            }\n            node.push(data[2].join(""));\n            node.push("</ol><ol class=\\"data\\" data-prettydiff-ignore=\\"true\\">");\n            node.push(data[3].join(""));\n            if (options.diffview === "inline") {\n                node.push("</ol>");\n            } else {\n                node.push("</ol></div>");\n            }\n            node.push(\n                "<p class=\\"author\\">Diff view written by <a href=\\"http://prettydiff.com/\\">Pr" +\n                "etty Diff</a>.</p></div>"\n            );\n            baseTab  = (errorout === 1)\n                ? ""\n                : "s";\n            newTab   = (diffline === 1)\n                ? ""\n                : "s";\n            finaldoc = "<p><strong>Number of differences:</strong> <em>" + (\n                errorout + diffline\n            ) + "</em> difference" + baseTab + " from <em>" + diffline + "</em> line" +\n                    newTab + " of code.</p>" + node.join("");\n            return [\n                finaldoc\n                    .replace(\n                        /li\\u0020class="equal"><\\/li/g,\n                        "li class=\\"equal\\">&#10;</li"\n                    )\n                    .replace(/\\$#gt;/g, "&gt;")\n                    .replace(/\\$#lt;/g, "&lt;")\n                    .replace(/%#lt;/g, "$#lt;")\n                    .replace(/%#gt;/g, "$#gt;"),\n                errorout,\n                diffline\n            ];\n        }());\n    };\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function diffview_requirejs() {\n            return function diffview_requirejs_wrapper(x) {\n                return diffview(x);\n            };\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = diffview;\n    } else {\n        global.prettydiff.diffview = diffview;\n    }\n}());\n'},function(n,e,t){"use strict";t(1)(t(44))},function(n,e){n.exports='/*prettydiff.com topcoms:true,insize:4,inchar:" ",vertical:true */\n/*jshint laxbreak: true*/\n/*global __dirname, ace, define, global, module, process, require*/\n/*\n Special thanks to Harry Whitfield for assistance in providing test\n cases.\n\n jspretty is written by Austin Cheney on 2 Nov 2012\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n -----------------------------------------------------------------------\n */\n(function jspretty_init() {\n    "use strict";\n    var jspretty = function jspretty_(options) {\n        var sourcemap    = [\n                0, ""\n            ],\n            json         = (options.lang === "json"),\n            globalerror  = "",\n            // all data that is created from the tokization process is stored in the\n            // following four arrays: token, types, level, and lines.  All of this data\n            // passes from the tokenization process to be analyzed by the algorithm\n            token        = [], //stores parsed tokens\n            types        = [], //parallel array that describes the tokens\n            level        = [], //parallel array that list indentation per token\n            lines        = [], //used to preserve empty lines\n            depth        = [], //describes the token\'s current container\n            begin        = [], //index where current container starts\n            globals      = [], //which variables are declared globals\n            // meta used to find scope and variables for jsscope these values are assigned in parallel to the other arrays\n            //* irrelevant tokens are represented with an empty string\n            // * first \'(\' following \'function\' is token index number of function\'s closing\n            // curly brace\n            //* variables are represented with the value \'v\'\n            //* the closing brace of a function is an array of variables\n            meta         = [],\n            // lists a number at the opening paren of a function that points to the token\n            // index of the function\'s closing curly brace.  At the closing curly brace\n            // index this array stores an array indicating the names of variables declared\n            // in the current function for coloring by function depth in jsscope.  This\n            // array is ignored if jsscope is false\n            varlist      = [],\n            // groups variables from a variable list into a child array as well as\n            // properties of objects.  This array for adding extra space so that the "="\n            // following declared variables of a variable list is vertically aligned and\n            // likewise of the ":" with object properties\n            markupvar = [],\n            // notes a token index of a JSX markup tag assigned to JavaScript variable. This\n            // is necessary for indentation apart from syntactical factors.\n            error        = [],\n            news         = 0,\n            scolon       = 0,\n            // counts uncessary use of \'new\' keyword variables j, k, l, m, n, o, p, q, and w\n            // are used as various counters for the reporting only.  These variables do not\n            // store any tokens and are not used in the algorithm j counts line comments\n            stats        = {\n                comma       : 0,\n                commentBlock: {\n                    chars: 0,\n                    token: 0\n                },\n                commentLine : {\n                    chars: 0,\n                    token: 0\n                },\n                container   : 0,\n                number      : {\n                    chars: 0,\n                    token: 0\n                },\n                operator    : {\n                    chars: 0,\n                    token: 0\n                },\n                regex       : {\n                    chars: 0,\n                    token: 0\n                },\n                semicolon   : 0,\n                server      : {\n                    chars: 0,\n                    token: 0\n                },\n                space       : {\n                    newline: 0,\n                    other  : 0,\n                    space  : 0,\n                    tab    : 0\n                },\n                string      : {\n                    chars: 0,\n                    quote: 0,\n                    token: 0\n                },\n                word        : {\n                    chars: 0,\n                    token: 0\n                }\n            },\n            result       = "",\n            objsortop    = false,\n            verticalop   = false,\n            originalSize = options.source.length,\n            lf           = (options.crlf === true || options.crlf === "true")\n                ? "\\r\\n"\n                : "\\n",\n            extlib       = function jspretty__extlib(ops) {\n                var item = (ops === undefined)\n                    ? global\n                        .prettydiff\n                        .markuppretty(ops)\n                    : global\n                        .prettydiff\n                        .markuppretty(options);\n                if (options.nodeasync === true) {\n                    if (globalerror === "") {\n                        globalerror = item[1];\n                    }\n                    return item[0];\n                }\n                return item;\n            };\n        (function jspretty__options() {\n            var styleguide  = {},\n                brace_style = {};\n            if (options.mode === "beautify" || options.mode === "diff" || options.mode === "minify") {\n                objsortop  = (\n                    options.objsort === true || options.objsort === "true" || options.objsort === "all" || options.objsort === "js" || options.objsort === "jsonly"\n                );\n                verticalop = (\n                    options.vertical === true || options.vertical === "true" || options.vertical === "all" || options.vertical === "js"\n                );\n            }\n            options.source                          = (\n                typeof options.source === "string" && options.source.length > 0\n            )\n                ? options\n                    .source\n                    .replace(/\\r\\n?/g, "\\n")\n                : "Error: no source code supplied to jspretty!";\n            if (options.mode !== "analysis" && options.source.indexOf("Error: no") < 0) {\n                options.source = options.source + " ";\n            }\n            options.titanium                        = (options.titanium === true || options.titanium === "true")\n                ? (function jspretty__options_titanium() {\n                    options.correct  = false;\n                    options.titanium = true;\n                    token.push("x{");\n                    types.push("start");\n                    lines.push(0);\n                    depth.push("global");\n                    begin.push(0);\n                    return true;\n                }())\n                : false;\n            styleguide.airbnb                       = function jspretty__options_styleairbnb() {\n                options.bracepadding = true;\n                options.correct      = true;\n                options.endcomma     = "always";\n                options.inchar       = " ";\n                options.insize       = 2;\n                options.preserve     = 1;\n                options.quoteConvert = "single";\n                options.varword      = "each";\n                options.wrap         = 80;\n            };\n            styleguide.crockford                    = function jspretty__options_stylecrockford() {\n                options.bracepadding  = false;\n                options.correct       = true;\n                options.elseline      = false;\n                options.endcomma      = "never";\n                options.inchar        = " ";\n                options.insize        = 4;\n                options.nocaseindent  = true;\n                options.nochainindent = false;\n                options.space         = true;\n                options.varword       = "each";\n                verticalop            = false;\n            };\n            styleguide.google                       = function jspretty__options_stylegoogle() {\n                options.correct      = true;\n                options.inchar       = " ";\n                options.insize       = 4;\n                options.preserve     = 1;\n                options.quoteConvert = "single";\n                verticalop           = false;\n                options.wrap         = -1;\n            };\n            styleguide.grunt                        = function jspretty__options_stylegrunt() {\n                options.inchar       = " ";\n                options.insize       = 2;\n                options.quoteConvert = "single";\n                options.varword      = "each";\n            };\n            styleguide.jquery                       = function jspretty__options_stylejquery() {\n                options.bracepadding = true;\n                options.correct      = true;\n                options.inchar       = "\\u0009";\n                options.insize       = 1;\n                options.quoteConvert = "double";\n                options.varword      = "each";\n                options.wrap         = 80;\n            };\n            styleguide.jslint                       = styleguide.crockford;\n            styleguide.mrdoobs                      = function jspretty__options_stylemrdoobs() {\n                options.braceline    = true;\n                options.bracepadding = true;\n                options.correct      = true;\n                options.inchar       = "\\u0009";\n                options.insize       = 1;\n                verticalop           = false;\n            };\n            styleguide.mediawiki                    = function jspretty__options_stylemediawiki() {\n                options.bracepadding = true;\n                options.correct      = true;\n                options.inchar       = "\\u0009";\n                options.insize       = 1;\n                options.preserve     = 1;\n                options.quoteConvert = "single";\n                options.space        = false;\n                options.wrap         = 80;\n            };\n            styleguide.meteor                       = function jspretty__options_stylemeteor() {\n                options.correct = true;\n                options.inchar  = " ";\n                options.insize  = 2;\n                options.wrap    = 80;\n            };\n            styleguide.yandex                       = function jspretty__options_styleyandex() {\n                options.bracepadding = false;\n                options.correct      = true;\n                options.quoteConvert = "single";\n                options.varword      = "each";\n                verticalop           = false;\n            };\n            brace_style.collapse                    = function jspretty__options_collapse() {\n                options.braceline    = false;\n                options.bracepadding = false;\n                options.braces       = false;\n                options.formatObject = "indent";\n                options.neverflatten = true;\n            };\n            brace_style["collapse-preserve-inline"] = function jspretty__options_collapseInline() {\n                options.braceline    = false;\n                options.bracepadding = true;\n                options.braces       = false;\n                options.formatObject = "inline";\n                options.neverflatten = false;\n            };\n            brace_style.expand                      = function jspretty__options_expand() {\n                options.braceline    = false;\n                options.bracepadding = false;\n                options.braces       = true;\n                options.formatObject = "indent";\n                options.neverflatten = true;\n            };\n            if (styleguide[options.styleguide] !== undefined) {\n                styleguide[options.styleguide]();\n            }\n            if (brace_style[options.brace_style] !== undefined) {\n                brace_style[options.brace_style]();\n            }\n            if (json === true) {\n                options.wrap = 0;\n            }\n        }());\n        if (options.source === "Error: no source code supplied to jspretty!") {\n            return options.source;\n        }\n\n        (function jspretty__tokenize() {\n            var a              = 0,\n                b              = options.source.length,\n                c              = options\n                    .source\n                    .split(""),\n                ltoke          = "",\n                ltype          = "",\n                lword          = [],\n                brace          = [],\n                pword          = [],\n                lengtha        = 0,\n                lengthb        = 0,\n                wordTest       = -1,\n                paren          = -1,\n                classy         = [],\n                depthlist      = [\n                    ["global", 0]\n                ],\n                tempstore      = [],\n                pdepth         = [],\n                //depth and status of templateStrings\n                templateString = [],\n                //identify variable declarations\n                vart           = {\n                    count: [],\n                    index: [],\n                    word : [],\n                    len  : -1\n                },\n                //operations for start types: (, [, {\n                start          = function jspretty__tokenize_startInit() {\n                    return;\n                },\n                //peek at whats up next\n                nextchar       = function jspretty__tokenize_nextchar(len, current) {\n                    var cc    = 0,\n                        dd    = "",\n                        front = (current === true)\n                            ? a\n                            : a + 1;\n                    if (typeof len !== "number" || len < 1) {\n                        len = 1;\n                    }\n                    if (c[a] === "/") {\n                        if (c[a + 1] === "/") {\n                            dd = "\\n";\n                        } else if (c[a + 1] === "*") {\n                            dd = "/";\n                        }\n                    }\n                    for (cc = front; cc < b; cc = cc + 1) {\n                        if ((/\\s/).test(c[cc]) === false) {\n                            if (c[cc] === "/") {\n                                if (dd === "") {\n                                    if (c[cc + 1] === "/") {\n                                        dd = "\\n";\n                                    } else if (c[cc + 1] === "*") {\n                                        dd = "/";\n                                    }\n                                } else if (dd === "/" && c[cc - 1] === "*") {\n                                    dd = "";\n                                }\n                            }\n                            if (dd === "" && c[cc - 1] + c[cc] !== "*/") {\n                                return c\n                                    .slice(cc, cc + len)\n                                    .join("");\n                            }\n                        } else if (dd === "\\n" && c[cc] === "\\n") {\n                            dd = "";\n                        }\n                    }\n                    return "";\n                },\n                //cleans up improperly applied ASI\n                asifix         = function jspretty__tokenize_asifix() {\n                    var len = types.length;\n                    do {\n                        len = len - 1;\n                    } while (\n                        len > 0 && (types[len] === "comment" || types[len] === "comment-inline")\n                    );\n                    if (token[len] === "from") {\n                        len = len - 2;\n                    }\n                    if (token[len] === "x;") {\n                        token.splice(len, 1);\n                        types.splice(len, 1);\n                        lines.splice(len, 1);\n                        depth.splice(len, 1);\n                        begin.splice(len, 1);\n                    }\n                },\n                //determine the definition of containment by depth\n                depthPush      = function jspretty__tokenize_depthPush() {\n                    // * block      : if, for, while, catch, function, class, map\n                    // * immediates : else, do, try, finally, switch\n                    // * paren based: method, expression, paren\n                    // * data       : array, object\n                    var last  = 0,\n                        aa    = 0,\n                        wordx = "",\n                        wordy = "",\n                        bpush = false;\n                    lengtha = token.length;\n                    last    = lengtha - 1;\n                    aa      = last - 1;\n                    wordx   = token[aa];\n                    wordy   = (depth[aa] === undefined)\n                        ? ""\n                        : token[begin[aa] - 1];\n                    if (types[aa] === "comment" || types[aa] === "comment-inline") {\n                        do {\n                            aa = aa - 1;\n                        } while (aa > 0 && (types[aa] === "comment" || types[aa] === "comment-inline"));\n                        wordx = token[aa];\n                    }\n                    if ((token[last] === "{" || token[last] === "x{") && ((wordx === "else" && token[last] !== "if") || wordx === "do" || wordx === "try" || wordx === "finally" || wordx === "switch")) {\n                        depth.push(wordx);\n                    } else if (token[last] === "{" || token[last] === "x{") {\n                        if (lengtha === 1 && options.jsx === true) {\n                            depth.push("global");\n                        } else if (classy[classy.length - 1] === 0 && wordx !== "return") {\n                            classy.pop();\n                            depth.push("class");\n                        } else if (token[aa - 1] === "class") {\n                            depth.push("class");\n                        } else if (token[aa] === "]" && token[aa - 1] === "[") {\n                            depth.push("array");\n                        } else if (types[aa] === "word" && (types[aa - 1] === "word" || (token[aa - 1] === "?" && types[aa - 2] === "word")) && token[aa] !== "in" && token[aa - 1] !== "export" && token[aa - 1] !== "import") {\n                            depth.push("map");\n                        } else if (depth[aa] === "method" && types[aa] === "end" && types[begin[aa] - 1] === "word" && token[begin[aa] - 2] === "new") {\n                            depth.push("initializer");\n                        } else if (token[last] === "{" && (wordx === ")" || wordx === "x)") && (types[begin[aa] - 1] === "word" || token[begin[aa] - 1] === "]")) {\n                            if (wordy === "if") {\n                                depth.push("if");\n                            } else if (wordy === "for") {\n                                depth.push("for");\n                            } else if (wordy === "while") {\n                                depth.push("while");\n                            } else if (wordy === "class") {\n                                depth.push("class");\n                            } else if (wordy === "switch" || token[begin[aa] - 1] === "switch") {\n                                depth.push("switch");\n                            } else if (wordy === "catch") {\n                                depth.push("catch");\n                            } else {\n                                depth.push("function");\n                            }\n                        } else if (token[last] === "{" && (wordx === ";" || wordx === "x;")) {\n                            //ES6 block\n                            depth.push("block");\n                        } else if (token[last] === "{" && token[aa] === ":" && depth[aa] === "switch") {\n                            //ES6 block\n                            depth.push("block");\n                        } else if (token[aa - 1] === "import" || token[aa - 2] === "import" || token[aa - 1] === "export" || token[aa - 2] === "export") {\n                            depth.push("object");\n                        } else if (wordx === ")" && (pword[0] === "function" || pword[0] === "if" || pword[0] === "for" || pword[0] === "class" || pword[0] === "while" || pword[0] === "switch" || pword[0] === "catch")) {\n                            // if preceeded by a paren the prior containment is preceeded by a keyword if\n                            // (...) {\n                            depth.push(pword[0]);\n                        } else if (depth[aa] === "notation") {\n                            //if following a TSX array type declaration\n                            depth.push("function");\n                        } else if ((types[aa] === "literal" || types[aa] === "word") && types[aa - 1] === "word" && token[begin[aa] - 1] !== "for") {\n                            //if preceed by a word and either string or word public class {\n                            depth.push("function");\n                        } else if (depthlist.length > 0 && token[aa] !== ":" && depthlist[depthlist.length - 1][0] === "object" && (\n                            token[begin[aa] - 2] === "{" || token[begin[aa] - 2] === ","\n                        )) {\n                            // if an object wrapped in some containment which is itself preceeded by a curly\n                            // brace or comma var a={({b:{cat:"meow"}})};\n                            depth.push("function");\n                        } else if (types[pword[1] - 1] === "markup" && token[pword[1] - 3] === "function") {\n                            //checking for TSX function using an angle brace name\n                            depth.push("function");\n                        } else if (wordx === "=>") {\n                            //checking for fat arrow assignment\n                            depth.push("function");\n                        } else if (wordx === ")" && depth[aa] === "method" && types[begin[aa] - 1] === "word") {\n                            depth.push("function");\n                        } else if (types[last - 1] === "word" && token[last] === "{" && token[last - 1] !== "return" && token[last - 1] !== "in" && token[last - 1] !== "import" && token[last - 1] !== "const" && token[last - 1] !== "let" && token[last - 1] !== "") {\n                            //ES6 block\n                            depth.push("block");\n                        } else {\n                            depth.push("object");\n                        }\n                    } else if (token[last] === "[") {\n                        if ((/\\s/).test(c[a - 1]) === true && types[aa] === "word" && wordx !== "return" && options.twig === false) {\n                            depth.push("notation");\n                        } else {\n                            depth.push("array");\n                        }\n                    } else if (token[last] === "(" || token[last] === "x(") {\n                        if (types[aa] === "generic") {\n                            depth.push("method");\n                        } else if (token[aa] === "}" && depth[aa] === "function") {\n                            depth.push("method");\n                        } else if (wordx === "if" || wordx === "for" || wordx === "function" || wordx === "class" || wordx === "while" || wordx === "catch" || wordx === "switch" || wordx === "with") {\n                            depth.push("expression");\n                        } else if ((types[aa] === "word" && wordx !== "return") || (wordx === "}" && (depth[aa] === "function" || depth[aa] === "class"))) {\n                            depth.push("method");\n                        } else {\n                            depth.push("paren");\n                        }\n                    } else if (ltoke === ":" && types[aa] === "word" && token[aa - 1] === "[") {\n                        depth[aa]     = "attribute";\n                        depth[aa - 1] = "attribute";\n                        depth.push("attribute");\n                        depthlist[depthlist.length - 1][0] = "attribute";\n                    } else if (depthlist.length === 0) {\n                        depth.push("global");\n                        begin.push(0);\n                        bpush = true;\n                    } else {\n                        depth.push(depthlist[depthlist.length - 1][0]);\n                        begin.push(depthlist[depthlist.length - 1][1]);\n                        bpush = true;\n                    }\n                    if (bpush === false) {\n                        begin.push(last);\n                    }\n                },\n                tokenpop       = function jspretty__tokenize_tokenpop() {\n                    lengtha   = lengtha - 1;\n                    lengthb   = lengthb - 1;\n                    tempstore = [token.pop(), types.pop(), lines.pop(), depth.pop(), begin.pop()];\n                },\n                //reinsert the prior popped token\n                temppush       = function jspretty__tokenize_temppush() {\n                    token.push(tempstore[0]);\n                    types.push(tempstore[1]);\n                    lines.push(tempstore[2]);\n                    depth.push(tempstore[3]);\n                    begin.push(tempstore[4]);\n                    lengtha = lengtha + 1;\n                },\n                //populate various parallel arrays\n                tokenpush      = function jspretty__tokenize_tokenpush(comma, lin) {\n                    if (comma === true) {\n                        token.push(",");\n                        types.push("separator");\n                    } else {\n                        token.push(ltoke);\n                        types.push(ltype);\n                    }\n                    lengtha = token.length;\n                    lines.push(lin);\n                    depthPush();\n                },\n                //inserts ending curly brace\n                blockinsert    = function jspretty__tokenize_blockinsert() {\n                    var next = nextchar(5, false),\n                        g    = lengtha - 1;\n                    if (json === true) {\n                        return;\n                    }\n                    if (depth[lengtha - 1] === "do" && next === "while" && token[lengtha - 1] === "}") {\n                        return;\n                    }\n                    next = next.slice(0, 4);\n                    if (ltoke === ";" && token[g - 1] === "x{") {\n                        //to prevent the semicolon from inserting between the braces --\x3e while (x) {};\n                        tokenpop();\n                        ltoke = "x}";\n                        ltype = "end";\n                        tokenpush(false, 0);\n                        brace.pop();\n                        pdepth = depthlist.pop();\n                        ltoke  = ";";\n                        ltype  = "end";\n                        temppush();\n                        return;\n                    }\n                    ltoke = "x}";\n                    ltype = "end";\n                    if (token[lengtha - 1] === "x}") {\n                        return;\n                    }\n                    if (depth[lengtha - 1] === "if" && (token[lengtha - 1] === ";" || token[lengtha - 1] === "x;") && next === "else") {\n                        tokenpush(false, 0);\n                        brace.pop();\n                        pdepth = depthlist.pop();\n                        return;\n                    }\n                    do {\n                        tokenpush(false, 0);\n                        brace.pop();\n                        pdepth = depthlist.pop();\n                    } while (brace[brace.length - 1] === "x{");\n                },\n                //remove "vart" object data\n                vartpop        = function jspretty__tokenize_vartpop() {\n                    vart\n                        .count\n                        .pop();\n                    vart\n                        .index\n                        .pop();\n                    vart\n                        .word\n                        .pop();\n                    vart.len = vart.len - 1;\n                },\n                logError       = function jspretty__tokenize_logError(message, start) {\n                    var f = a,\n                        g = types.length;\n                    if (error.length > 0) {\n                        return;\n                    }\n                    error.push(message);\n                    do {\n                        f = f - 1;\n                    } while (c[f] !== "\\n" && f > 0);\n                    error.push(c.slice(f, start).join(""));\n                    if (g > 1) {\n                        do {\n                            g = g - 1;\n                        } while (g > 0 && types[g] !== "comment");\n                    }\n                    if (g > -1 && g < token.length && token[g].indexOf("//") === 0 && error[1].replace(/^\\s+/, "").indexOf(token[g + 1]) === 0 && (token[g].split("\\"").length % 2 === 1 || token[g].split("\'").length % 2 === 1)) {\n                        error = [\n                            message, token[g] + error[1]\n                        ];\n                    } else {\n                        error = [\n                            message, error[1]\n                        ];\n                    }\n                    if (globalerror === "") {\n                        globalerror = message + ":" + error[1];\n                    }\n                },\n                //A tokenizer for keywords, reserved words, and variables\n                word           = function jspretty__tokenize_word() {\n                    var f        = wordTest,\n                        g        = 1,\n                        build    = [],\n                        output   = "",\n                        nextitem = "",\n                        elsefix  = function jspretty__tokenize_word_elsefix() {\n                            brace.push("x{");\n                            depthlist.push(["else", lengtha]);\n                            token.splice(lengtha - 3, 1);\n                            types.splice(lengtha - 3, 1);\n                            lines.splice(lengtha - 3, 1);\n                            depth.splice(lengtha - 3, 1);\n                            begin.splice(lengtha - 3, 1);\n                        };\n                    do {\n                        build.push(c[f]);\n                        if (c[f] === "\\\\") {\n                            logError("Illegal escape in JavaScript", a);\n                        }\n                        f = f + 1;\n                    } while (f < a);\n                    output   = build.join("");\n                    wordTest = -1;\n                    if (types.length > 1 && output === "function" && token[lengtha - 1] === "(" && (token[token.length - 2] === "{" || token[token.length - 2] === "x{")) {\n                        types[types.length - 1] = "start";\n                    }\n                    if (types.length > 2 && output === "function" && ltoke === "(" && (token[token.length - 2] === "}" || token[token.length - 2] === "x}")) {\n                        if (token[token.length - 2] === "}") {\n                            for (f = token.length - 3; f > -1; f = f - 1) {\n                                if (types[f] === "end") {\n                                    g = g + 1;\n                                } else if (types[f] === "start" || types[f] === "end") {\n                                    g = g - 1;\n                                }\n                                if (g === 0) {\n                                    break;\n                                }\n                            }\n                            if (token[f] === "{" && token[f - 1] === ")") {\n                                g = 1;\n                                for (f = f - 2; f > -1; f = f - 1) {\n                                    if (types[f] === "end") {\n                                        g = g + 1;\n                                    } else if (types[f] === "start" || types[f] === "end") {\n                                        g = g - 1;\n                                    }\n                                    if (g === 0) {\n                                        break;\n                                    }\n                                }\n                                if (token[f - 1] !== "function" && token[f - 2] !== "function") {\n                                    types[types.length - 1] = "start";\n                                }\n                            }\n                        } else {\n                            types[types.length - 1] = "start";\n                        }\n                    }\n                    if (options.correct === true && (output === "Object" || output === "Array") && c[a + 1] === "(" && c[a + 2] === ")" && token[lengtha - 2] === "=" && token[lengtha - 1] === "new") {\n                        if (output === "Object") {\n                            token[lengtha - 1]                 = "{";\n                            ltoke                              = "}";\n                            depth[a - 1]                       = "object";\n                            depthlist[depthlist.length - 1][0] = "object";\n                        } else {\n                            token[lengtha - 1]                 = "[";\n                            ltoke                              = "]";\n                            depth[a - 1]                       = "array";\n                            depthlist[depthlist.length - 1][0] = "array";\n                        }\n                        types[lengtha - 1] = "start";\n                        ltype              = "end";\n                        c[a + 1]           = "";\n                        c[a + 2]           = "";\n                        stats.container    = stats.container + 2;\n                        a                  = a + 2;\n                    } else {\n                        g = types.length - 1;\n                        f = g;\n                        if (options.varword !== "none" && (output === "var" || output === "let" || output === "const")) {\n                            if (types[g] === "comment" || types[g] === "comment-inline") {\n                                do {\n                                    g = g - 1;\n                                } while (g > 0 && (types[g] === "comment" || types[g] === "comment-inline"));\n                            }\n                            if (options.varword === "list" && vart.len > -1 && vart.index[vart.len] === g && output === vart.word[vart.len]) {\n                                stats.word.token     = stats.word.token + 1;\n                                stats.word.chars     = stats.word.chars + output.length;\n                                ltoke                = ",";\n                                ltype                = "separator";\n                                token[g]             = ltoke;\n                                types[g]             = ltype;\n                                vart.count[vart.len] = 0;\n                                vart.index[vart.len] = g;\n                                vart.word[vart.len]  = output;\n                                return;\n                            }\n                            vart.len = vart.len + 1;\n                            vart\n                                .count\n                                .push(0);\n                            vart\n                                .index\n                                .push(g);\n                            vart\n                                .word\n                                .push(output);\n                            g = f;\n                        } else if (vart.len > -1 && output !== vart.word[vart.len] && token.length === vart.index[vart.len] + 1 && token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && options.varword === "list") {\n                            vartpop();\n                        }\n                        if (output === "else" && (types[g] === "comment" || types[g] === "comment-inline")) {\n                            do {\n                                f = f - 1;\n                            } while (f > -1 && (types[f] === "comment" || types[f] === "comment-inline"));\n                            if (token[f] === "x;" && (token[f - 1] === "}" || token[f - 1] === "x}")) {\n                                token.splice(f, 1);\n                                types.splice(f, 1);\n                                lines.splice(f, 1);\n                                depth.splice(f, 1);\n                                begin.splice(f, 1);\n                                g = g - 1;\n                                f = f - 1;\n                            }\n                            do {\n                                build = [\n                                    token[g], types[g], lines[g], depth[g], begin[g]\n                                ];\n                                tokenpop();\n                                token.splice(g - 3, 0, build[0]);\n                                types.splice(g - 3, 0, build[1]);\n                                lines.splice(g - 3, 0, build[2]);\n                                depth.splice(g - 3, 0, build[3]);\n                                begin.splice(g - 3, 0, build[4]);\n                                f = f + 1;\n                            } while (f < g);\n                        }\n                        if (output === "from" && token[lengtha - 1] === "x;" && token[lengtha - 2] === "}") {\n                            asifix();\n                        }\n                        if (output === "while" && token[lengtha - 1] === "x;" && token[lengtha - 2] === "}") {\n                            (function jspretty__tokenize_word_whilefix() {\n                                var d = 0,\n                                    e = 0;\n                                for (e = lengtha - 3; e > -1; e = e - 1) {\n                                    if (types[e] === "end") {\n                                        d = d + 1;\n                                    } else if (types[e] === "start") {\n                                        d = d - 1;\n                                    }\n                                    if (d < 0) {\n                                        if (token[e] === "{" && token[e - 1] === "do") {\n                                            asifix();\n                                        }\n                                        return;\n                                    }\n                                }\n                            }());\n                        }\n                        ltoke            = output;\n                        ltype            = "word";\n                        stats.word.token = stats.word.token + 1;\n                        stats.word.chars = stats.word.chars + output.length;\n                        if (output === "from" && token[lengtha - 1] === "}") {\n                            asifix();\n                        }\n                    }\n                    tokenpush(false, 0);\n                    if (output === "class") {\n                        classy.push(0);\n                    }\n                    if (output === "do") {\n                        nextitem = nextchar(1, true);\n                        if (nextitem !== "{") {\n                            ltoke = "x{";\n                            ltype = "start";\n                            brace.push("x{");\n                            tokenpush(false, 0);\n                            depthlist.push([\n                                "do", lengtha - 1\n                            ]);\n                        }\n                    }\n                    if (output === "else") {\n                        nextitem = nextchar(2, true);\n                        if (nextitem !== "if" && nextitem.charAt(0) !== "{") {\n                            ltoke = "x{";\n                            ltype = "start";\n                            brace.push("x{");\n                            tokenpush(false, 0);\n                            depthlist.push([\n                                "else", lengtha - 1\n                            ]);\n                        }\n                        if (token[lengtha - 3] === "x}") {\n                            if (token[lengtha - 2] === "else") {\n                                if (token[lengtha - 4] === "x}" && pdepth[0] !== "if" && depth[depth.length - 2] === "else") {\n                                    elsefix();\n                                } else if (token[lengtha - 4] === "}" && depth[lengtha - 4] === "if" && pdepth[0] === "if" && token[pdepth[1] - 1] !== "if" && token[begin[lengtha - 3]] === "x{") {\n                                    //fixes when "else" is following a block that isn\'t "if"\n                                    elsefix();\n                                }\n                            } else if (token[lengtha - 2] === "x}" && depth[depth.length - 2] === "if") {\n                                elsefix();\n                            }\n                        }\n                    }\n                    if ((output === "for" || output === "if" || output === "switch" || output === "catch") && options.twig === false && token[lengtha - 2] !== ".") {\n                        nextitem = nextchar(1, true);\n                        if (nextitem !== "(") {\n                            paren = lengtha - 1;\n                            start("x(");\n                        }\n                    }\n                },\n                //sort object properties\n                objSort        = function jspretty__tokenize_objSort() {\n                    var cc        = 0,\n                        dd        = 0,\n                        ee        = 0,\n                        startlen  = token.length - 1,\n                        behind    = startlen,\n                        keys      = [],\n                        keylen    = 0,\n                        keyend    = 0,\n                        front     = 0,\n                        sort      = function jspretty__tokenize_objSort_sort(x, y) {\n                            var xx = x[0],\n                                yy = y[0];\n                            if (types[xx] === "comment" || types[xx] === "comment-inline") {\n                                do {\n                                    xx = xx + 1;\n                                } while (\n                                    xx < startlen && (types[xx] === "comment" || types[xx] === "comment-inline")\n                                );\n                            }\n                            if (types[yy] === "comment" || types[yy] === "comment-inline") {\n                                do {\n                                    yy = yy + 1;\n                                } while (\n                                    yy < startlen && (types[yy] === "comment" || types[yy] === "comment-inline")\n                                );\n                            }\n                            if (token[xx].toLowerCase() > token[yy].toLowerCase()) {\n                                return 1;\n                            }\n                            return -1;\n                        },\n                        commaTest = true,\n                        pairToken = [],\n                        pairTypes = [],\n                        pairLines = [],\n                        pairDepth = [],\n                        pairBegin = [];\n                    if (token[behind] === "," || types[behind] === "comment") {\n                        do {\n                            behind = behind - 1;\n                        } while (behind > 0 && (token[behind] === "," || types[behind] === "comment"));\n                    }\n                    for (cc = behind; cc > -1; cc = cc - 1) {\n                        if (types[cc] === "end") {\n                            dd = dd + 1;\n                        }\n                        if (types[cc] === "start") {\n                            dd = dd - 1;\n                        }\n                        if (dd === 0) {\n                            if (types[cc].indexOf("template") > -1) {\n                                return;\n                            }\n                            if (token[cc] === ",") {\n                                commaTest = true;\n                                front     = cc + 1;\n                            }\n                            if (commaTest === true && token[cc] === "," && front < behind) {\n                                if (token[behind] !== ",") {\n                                    behind = behind + 1;\n                                }\n                                if (types[front] === "comment-inline") {\n                                    front = front + 1;\n                                }\n                                keys.push([front, behind]);\n                                behind = front - 1;\n                            }\n                        }\n                        if (dd < 0 && cc < startlen) {\n                            if (keys.length > 0 && keys[keys.length - 1][0] > cc + 1) {\n                                ee = keys[keys.length - 1][0];\n                                if (types[ee - 1] !== "comment-inline") {\n                                    ee = ee - 1;\n                                }\n                                keys.push([\n                                    cc + 1,\n                                    ee\n                                ]);\n                            }\n                            if (token[cc - 1] === "=" || token[cc - 1] === ":" || token[cc - 1] === "(" || token[cc - 1] === "[" || token[cc - 1] === "," || types[cc - 1] === "word" || cc === 0) {\n                                if (keys.length > 1) {\n                                    keys.sort(sort);\n                                    keylen    = keys.length;\n                                    commaTest = false;\n                                    for (dd = 0; dd < keylen; dd = dd + 1) {\n                                        keyend = keys[dd][1];\n                                        if (lines[keys[dd][0] - 1] > 1 && pairLines.length > 0) {\n                                            pairLines[pairLines.length - 1] = lines[keys[dd][0] - 1];\n                                        }\n                                        for (ee = keys[dd][0]; ee < keyend; ee = ee + 1) {\n                                            pairToken.push(token[ee]);\n                                            pairTypes.push(types[ee]);\n                                            pairLines.push(lines[ee]);\n                                            pairDepth.push(depth[ee]);\n                                            pairBegin.push(begin[ee]);\n\n                                            //remove extra commas\n                                            if (token[ee] === ",") {\n                                                commaTest = true;\n                                            } else if (token[ee] !== "," && types[ee] !== "comment" && types[ee] !== "comment-inline") {\n                                                commaTest = false;\n                                            }\n                                        }\n                                        if (commaTest === false) {\n                                            ee = pairTypes.length - 1;\n                                            if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {\n                                                do {\n                                                    ee = ee - 1;\n                                                } while (\n                                                    ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\n                                                );\n                                            }\n                                            ee = ee + 1;\n                                            pairToken.splice(ee, 0, ",");\n                                            pairTypes.splice(ee, 0, "separator");\n                                            pairLines.splice(ee, 0, pairLines[ee - 1]);\n                                            pairDepth.splice(ee, 0, "object");\n                                            pairBegin.splice(ee, 0, cc);\n                                            pairLines[ee - 1] = 0;\n                                        }\n                                    }\n                                    ee = pairTypes.length;\n                                    do {\n                                        ee = ee - 1;\n                                    } while (\n                                        ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\n                                    );\n                                    if (options.endcomma === "never" || options.endcomma === "multiline") {\n                                        pairToken.splice(ee, 1);\n                                        pairTypes.splice(ee, 1);\n                                        pairLines.splice(ee, 1);\n                                        pairDepth.splice(ee, 1);\n                                        pairBegin.splice(ee, 1);\n                                    }\n                                    keylen = token.length - (cc + 1);\n                                    token.splice(cc + 1, keylen);\n                                    types.splice(cc + 1, keylen);\n                                    lines.splice(cc + 1, keylen);\n                                    depth.splice(cc + 1, keylen);\n                                    begin.splice(cc + 1, keylen);\n                                    token     = token.concat(pairToken);\n                                    types     = types.concat(pairTypes);\n                                    lines     = lines.concat(pairLines);\n                                    depth     = depth.concat(pairDepth);\n                                    begin     = begin.concat(pairBegin);\n                                    lengtha   = token.length;\n                                    pairToken = [cc];\n                                    for (cc = cc + 1; cc < lengtha; cc = cc + 1) {\n                                        if (types[cc] === "start") {\n                                            pairToken.push(cc);\n                                        }\n                                        begin[cc] = pairToken[pairToken.length - 1];\n                                        if (types[cc] === "end") {\n                                            pairToken.pop();\n                                        }\n                                    }\n                                } else if (options.endcomma === "always" && types[lengtha - 1] !== "start") {\n                                    tokenpush(true, 0);\n                                }\n                            }\n                            return;\n                        }\n                    }\n                },\n                slashes        = function jspretty__tokenize_slashes(index) {\n                    var slashy = index;\n                    do {\n                        slashy = slashy - 1;\n                    } while (c[slashy] === "\\\\" && slashy > 0);\n                    if ((index - slashy) % 2 === 1) {\n                        return true;\n                    }\n                    return false;\n                },\n                // commaComment ensures that commas immediately precede comments instead of\n                // immediately follow\n                commaComment   = function jspretty__tokenize_commacomment() {\n                    var x = types.length;\n                    if (depth[lengtha - 1] === "object" && objsortop === true) {\n                        ltoke = ",";\n                        ltype = "separator";\n                        asifix();\n                        tokenpush(false, 0);\n                    } else {\n                        do {\n                            x = x - 1;\n                        } while (\n                            x > 0 && (types[x - 1] === "comment" || types[x - 1] === "comment-inline")\n                        );\n                        token.splice(x, 0, ",");\n                        types.splice(x, 0, "separator");\n                        lines.splice(x, 0, 0);\n                        depthPush();\n                    }\n                },\n                //injects a comma into the end of arrays for use with endcomma option\n                endCommaArray  = function jspretty__tokenize_endCommaArray() {\n                    var d = 0,\n                        e = 0;\n                    for (d = lengtha; d > 0; d = d - 1) {\n                        if (types[d] === "end") {\n                            e = e + 1;\n                        } else if (types[d] === "start") {\n                            e = e - 1;\n                        }\n                        if (e < 0) {\n                            return;\n                        }\n                        if (e === 0 && token[d] === ",") {\n                            return tokenpush(true, 0);\n                        }\n                    }\n                },\n                //automatic semicolon insertion\n                asi            = function jspretty__tokenize_asi(isEnd) {\n                    var len   = token.length - 1,\n                        aa    = 0,\n                        next  = nextchar(1, false),\n                        tokel = token[len],\n                        typel = types[len],\n                        deepl = depth[len],\n                        begnl = begin[len],\n                        clist = (depthlist.length === 0)\n                            ? ""\n                            : depthlist[depthlist.length - 1][0];\n                    if (json === true || tokel === ";" || tokel === "," || next === "{" || deepl === "class" || deepl === "map" || deepl === "attribute" || clist === "initializer" || types[begnl - 1] === "generic") {\n                        return;\n                    }\n                    if (((deepl === "global" && typel !== "end") || (typel === "end" && depth[begnl - 1] === "global")) && (next === "" || next === "}") && deepl === depth[lengtha - 2] && options.jsx === true) {\n                        return;\n                    }\n                    if (deepl === "array" && tokel !== "]") {\n                        return;\n                    }\n                    if (typel !== undefined && typel.indexOf("template") > -1) {\n                        return;\n                    }\n                    if (next === ";" && isEnd === false) {\n                        return;\n                    }\n                    if (options.qml === true) {\n                        if (typel === "start") {\n                            return;\n                        }\n                        ltoke = "x;";\n                        ltype = "separator";\n                        tokenpush(false, 0);\n                        if (brace[brace.length - 1] === "x{" && nextchar !== "}") {\n                            blockinsert();\n                        }\n                        return;\n                    }\n                    if (tokel === "}" && (deepl === "function" || deepl === "if" || deepl === "else" || deepl === "for" || deepl === "do" || deepl === "while" || deepl === "switch" || deepl === "class" || deepl === "try" || deepl === "catch" || deepl === "finally" || deepl === "block")) {\n                        if (token[begnl - 1] === ")") {\n                            aa = begin[begnl - 1] - 1;\n                            if (token[aa - 1] === "function") {\n                                aa = aa - 1;\n                            }\n                            if (depth[aa - 1] === "object" || depth[aa - 1] === "switch") {\n                                return;\n                            }\n                            if (token[aa - 1] !== "=" && token[aa - 1] !== "return" && token[aa - 1] !== ":") {\n                                return;\n                            }\n                        } else {\n                            return;\n                        }\n                    }\n                    if (typel === "comment" || typel === "comment-inline" || clist === "method" || clist === "paren" || clist === "expression" || clist === "array" || clist === "object" || (clist === "switch" && deepl !== "method" && token[begin[lengtha - 1]] === "(")) {\n                        return;\n                    }\n                    if (depth[lengtha - 1] === "expression" && (token[begin[lengtha - 1] - 1] !== "while" || (token[begin[lengtha - 1] - 1] === "while" && depth[begin[lengtha - 1] - 2] !== "do"))) {\n                        return;\n                    }\n                    if (next !== "" && "=<>+*?|^:&%~,.()]".indexOf(next) > -1 && isEnd === false) {\n                        return;\n                    }\n                    if (typel === "comment" || typel === "comment-inline") {\n                        do {\n                            len = len - 1;\n                        } while (\n                            len > 0 && (types[len] === "comment" || types[len] === "comment-inline")\n                        );\n                        if (len < 1) {\n                            return;\n                        }\n                        tokel = token[len];\n                        typel = types[len];\n                        deepl = depth[len];\n                    }\n                    if (tokel === undefined || typel === "start" || typel === "separator" || (typel === "operator" && tokel !== "++" && tokel !== "--") || tokel === "x}" || tokel === "var" || tokel === "let" || tokel === "const" || tokel === "else" || tokel.indexOf("#!/") === 0 || tokel === "instanceof") {\n                        return;\n                    }\n                    if (deepl === "method" && (token[begnl - 1] === "function" || token[begnl - 2] === "function")) {\n                        return;\n                    }\n                    if (options.varword === "list") {\n                        vart.index[vart.len] = token.length;\n                    }\n                    ltoke = ";";\n                    ltype = "separator";\n                    token.splice(len + 1, 0, "x;");\n                    types.splice(len + 1, 0, "separator");\n                    lines.splice(len, 0, 0);\n                    depthPush();\n                    if (brace[brace.length - 1] === "x{" && nextchar !== "}") {\n                        blockinsert();\n                    }\n                },\n                //convert ++ and -- into "= x +"  and "= x -" in most cases\n                plusplus = function jspretty__tokenize_plusplus() {\n                    var store      = [],\n                        pre        = true,\n                        toke       = "+",\n                        tokea      = "",\n                        tokeb      = "",\n                        tokec      = "",\n                        inc        = 0,\n                        ind        = 0,\n                        walk       = 0,\n                        end        = function jspretty__tokenize_plusplus_endInit() {\n                            return;\n                        },\n                        period     = function jspretty__tokenize_plusplus_periodInit() {\n                            return;\n                        },\n                        applyStore = function jspretty__tokenize_plusplus_applyStore() {\n                            var x = 0,\n                                y = store[0].length;\n                            do {\n                                token.push(store[0][x]);\n                                types.push(store[1][x]);\n                                lines.push(store[2][x]);\n                                depth.push(store[3][x]);\n                                begin.push(store[4][x]);\n                                x = x + 1;\n                            } while (x < y);\n                        },\n                        next       = "";\n                    lengtha = token.length;\n                    tokea   = token[lengtha - 1];\n                    tokeb   = token[lengtha - 2];\n                    tokec   = token[lengtha - 3];\n                    end     = function jspretty__tokenize_plusplus_end() {\n                        walk = begin[walk] - 1;\n                        if (types[walk] === "end") {\n                            jspretty__tokenize_plusplus_end();\n                        } else if (token[walk - 1] === ".") {\n                            period();\n                        }\n                    };\n                    period  = function jspretty__tokenize_plusplus_period() {\n                        walk = walk - 2;\n                        if (types[walk] === "end") {\n                            end();\n                        } else if (token[walk - 1] === ".") {\n                            jspretty__tokenize_plusplus_period();\n                        }\n                    };\n                    if (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--") {\n                        walk = lengtha - 1;\n                        if (types[walk] === "end") {\n                            end();\n                        } else if (token[walk - 1] === ".") {\n                            period();\n                        }\n                    }\n                    if (token[walk - 1] === "++" || token[walk - 1] === "--") {\n                        if ("startendoperator".indexOf(types[walk - 2]) > -1) {\n                            return;\n                        }\n                        store.push(token.slice(walk));\n                        store.push(types.slice(walk));\n                        store.push(lines.slice(walk));\n                        store.push(depth.slice(walk));\n                        store.push(begin.slice(walk));\n                        token.splice(walk, lengtha - walk);\n                        types.splice(walk, lengtha - walk);\n                        lines.splice(walk, lengtha - walk);\n                        depth.splice(walk, lengtha - walk);\n                        begin.splice(walk, lengtha - walk);\n                    } else {\n                        if (options.correct === false || (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--")) {\n                            return;\n                        }\n                        next = nextchar(1, false);\n                        if ((tokea === "++" || tokea === "--") && (c[a] === ";" || next === ";" || c[a] === "}" || next === "}" || c[a] === ")" || next === ")")) {\n                            toke = depth[lengtha - 1];\n                            if (toke === "array" || toke === "method" || toke === "object" || toke === "paren" || toke === "notation" || (token[begin[lengtha - 1] - 1] === "while" && toke !== "while")) {\n                                return;\n                            }\n                            inc = lengtha - 1;\n                            do {\n                                inc = inc - 1;\n                                if (token[inc] === "return") {\n                                    return;\n                                }\n                                if (types[inc] === "end") {\n                                    do {\n                                        inc = begin[inc] - 1;\n                                    } while (types[inc] === "end" && inc > 0);\n                                }\n                            } while (\n                                inc > 0 && (token[inc] === "." || types[inc] === "word" || types[inc] === "end")\n                            );\n                            if (token[inc] === "," && c[a] !== ";" && next !== ";" && c[a] !== "}" && next !== "}" && c[a] !== ")" && next !== ")") {\n                                return;\n                            }\n                            if (types[inc] === "operator") {\n                                if (depth[inc] === "switch" && token[inc] === ":") {\n                                    do {\n                                        inc = inc - 1;\n                                        if (types[inc] === "start") {\n                                            ind = ind - 1;\n                                            if (ind < 0) {\n                                                break;\n                                            }\n                                        } else if (types[inc] === "end") {\n                                            ind = ind + 1;\n                                        }\n                                        if (token[inc] === "?" && ind === 0) {\n                                            return;\n                                        }\n                                    } while (inc > 0);\n                                } else {\n                                    return;\n                                }\n                            }\n                            pre = false;\n                            if (tokea === "--") {\n                                toke = "-";\n                            } else {\n                                toke = "+";\n                            }\n                        } else if (tokec === "[" || tokec === ";" || tokec === "x;" || tokec === "}" || tokec === "{" || tokec === "(" || tokec === ")" || tokec === "," || tokec === "return") {\n                            if (tokea === "++" || tokea === "--") {\n                                if (tokec === "[" || tokec === "(" || tokec === "," || tokec === "return") {\n                                    return;\n                                }\n                                if (tokea === "--") {\n                                    toke = "-";\n                                }\n                                pre = false;\n                            } else if (tokeb === "--" || tokea === "--") {\n                                toke = "-";\n                            }\n                        } else {\n                            return;\n                        }\n                        if (pre === false) {\n                            tokenpop();\n                        }\n                        walk = lengtha - 1;\n                        if (types[walk] === "end") {\n                            end();\n                        } else if (token[walk - 1] === ".") {\n                            period();\n                        }\n                        store.push(token.slice(walk));\n                        store.push(types.slice(walk));\n                        store.push(lines.slice(walk));\n                        store.push(depth.slice(walk));\n                        store.push(begin.slice(walk));\n                    }\n                    if (pre === true) {\n                        token.splice(walk - 1, 1);\n                        types.splice(walk - 1, 1);\n                        lines.splice(walk - 1, 1);\n                        depth.splice(walk - 1, 1);\n                        begin.splice(walk - 1, 1);\n                        ltoke = "=";\n                        ltype = "operator";\n                        tokenpush(false, 0);\n                        applyStore();\n                        ltoke = toke;\n                        ltype = "operator";\n                        tokenpush(false, 0);\n                        ltoke = "1";\n                        ltype = "literal";\n                        tokenpush(false, 0);\n                    } else {\n                        ltoke = "=";\n                        ltype = "operator";\n                        tokenpush(false, 0);\n                        applyStore();\n                        ltoke = toke;\n                        ltype = "operator";\n                        tokenpush(false, 0);\n                        ltoke = "1";\n                        ltype = "literal";\n                        tokenpush(false, 0);\n                    }\n                    ltoke = token[lengtha - 1];\n                    ltype = types[lengtha - 1];\n                    if (next === "}" && c[a] !== ";") {\n                        asi(false);\n                    }\n                },\n                //converts "+=" and "-=" to "x = x + 1"\n                plusequal = function jspretty__tokenize_plusequal(op) {\n                    var toke       = op.charAt(0),\n                        walk       = lengtha - 1,\n                        store      = [],\n                        end        = function jspretty__tokenize_plusequal_endInit() {\n                            return;\n                        },\n                        period     = function jspretty__tokenize_plusequal_periodInit() {\n                            return;\n                        },\n                        applyStore = function jspretty__tokenize_plusplus_applyStore() {\n                            var x = 0,\n                                y = store[0].length;\n                            do {\n                                token.push(store[0][x]);\n                                types.push(store[1][x]);\n                                lines.push(store[2][x]);\n                                depth.push(store[3][x]);\n                                begin.push(store[4][x]);\n                                x = x + 1;\n                            } while (x < y);\n                        };\n                    end    = function jspretty__tokenize_plusequal_end() {\n                        walk = begin[walk] - 1;\n                        if (types[walk] === "end") {\n                            jspretty__tokenize_plusequal_end();\n                        } else if (token[walk - 1] === ".") {\n                            period();\n                        }\n                    };\n                    period = function jspretty__tokenize_plusequal_period() {\n                        walk = walk - 2;\n                        if (types[walk] === "end") {\n                            end();\n                        } else if (token[walk - 1] === ".") {\n                            jspretty__tokenize_plusequal_period();\n                        }\n                    };\n                    if (types[walk] === "end") {\n                        end();\n                    } else if (token[walk - 1] === ".") {\n                        period();\n                    }\n                    store.push(token.slice(walk));\n                    store.push(types.slice(walk));\n                    store.push(lines.slice(walk));\n                    store.push(depth.slice(walk));\n                    store.push(begin.slice(walk));\n                    ltoke = "=";\n                    ltype = "operator";\n                    tokenpush(false, 0);\n                    applyStore();\n                    return toke;\n                },\n                //fixes asi location if inserted after an inserted brace\n                asibrace       = function jspretty__tokenize_asibrace() {\n                    var aa = token.length;\n                    do {\n                        aa = aa - 1;\n                    } while (aa > -1 && token[aa] === "x}");\n                    if (depth[aa] === "else") {\n                        return tokenpush(false, 0);\n                    }\n                    aa = aa + 1;\n                    token.splice(aa, 0, ltoke);\n                    types.splice(aa, 0, ltype);\n                    lines.push(0);\n                    depthPush();\n                },\n                //convert double quotes to single or the opposite\n                quoteConvert   = function jspretty__tokenize_quoteConvert(item) {\n                    var dub   = (options.quoteConvert === "double"),\n                        qchar = (dub === true)\n                            ? "\\""\n                            : "\'";\n                    item = item.slice(1, item.length - 1);\n                    if (dub === true) {\n                        item = item.replace(/"/g, "\'");\n                    } else {\n                        item = item.replace(/\'/g, "\\"");\n                    }\n                    return qchar + item + qchar;\n                },\n                //manage comment wrapping\n                commentwrap    = function jspretty__tokenize_commentwrap(comment, line) {\n                    var prior        = "",\n                        ptype        = "",\n                        xblock       = (function jspretty__tokenize_commentLine_xblock() {\n                            if (token[lengtha - 1] !== "x}" || (lines[lengtha - 1] > 0 && nextchar(4, false) !== "else") || (token[lengtha - 1] === "x}" && (token[lengtha - 2] === "}" || token[lengtha - 2] === "x}"))) {\n                                return false;\n                            }\n                            tokenpop();\n                            return true;\n                        }()),\n                        ind          = 0,\n                        vartest      = "",\n                        cstart       = (line === true)\n                            ? "// "\n                            : " * ",\n                        empty        = (/^(\\/\\/\\s*)$/),\n                        list         = (\n                            /^(\\/\\/\\s*(\\*|-|@|\\=|(\\d+(\\.|(\\s*-))))(?!(\\*|-|@|\\=|(\\d+(\\.|(\\s*-))))))/\n                        ),\n                        hrule        = (/^(\\/\\/\\s*---+\\s*)$/),\n                        remind       = (/^(\\/\\/\\s*((todo)|(note:)))/i),\n                        commentSplit = function jspretty__tokenize_commentLine_commentSplit() {\n                            var endi    = options.wrap - 3,\n                                starti  = 0,\n                                spacely = (comment.indexOf(" ") > 0),\n                                len     = 0,\n                                block   = [];\n                            if (line === true) {\n                                comment = comment.slice(2);\n                                if (spacely === true) {\n                                    do {\n                                        //split comments by word if possible\n                                        len    = comment.length;\n                                        starti = 0;\n                                        if ((/\\s/).test(comment.charAt(0)) === true) {\n                                            do {\n                                                starti = starti + 1;\n                                            } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\n                                        }\n                                        comment = comment.slice(starti);\n                                        len     = comment.length;\n                                        endi    = (options.wrap - 3);\n                                        if ((/\\s/).test(comment.slice(0, endi + 1)) === true && endi < len) {\n                                            endi = endi + 1;\n                                            do {\n                                                endi = endi - 1;\n                                            } while (endi > 0 && (/\\s/).test(comment.charAt(endi)) === false);\n                                        } else if ((/\\s/).test(comment) === true && endi < len) {\n                                            do {\n                                                endi = endi + 1;\n                                            } while (endi < len && (/\\s/).test(comment.charAt(endi)) === false);\n                                        } else {\n                                            endi = len;\n                                        }\n                                        ltoke = cstart + comment\n                                            .slice(0, endi)\n                                            .replace(/(\\s+)$/, "");\n                                        tokenpush(false, 0);\n                                        comment = comment.slice(endi);\n                                    } while (comment.length > endi);\n                                    if (comment !== "") {\n                                        len    = comment.length;\n                                        starti = 0;\n                                        if ((/\\s/).test(comment.charAt(0)) === true) {\n                                            do {\n                                                starti = starti + 1;\n                                            } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\n                                        }\n                                        ltoke = cstart + comment.slice(starti);\n                                        ltoke = ltoke.replace(/(\\s+)$/, "");\n                                        tokenpush(false, 0);\n                                    }\n                                } else {\n                                    if (prior.indexOf("//") === 0 && prior.length < endi && prior.indexOf(" ") === -1 && comment.indexOf(" ") === -1) {\n                                        endi               = endi - prior.length;\n                                        token[lengtha - 1] = prior + comment.slice(0, endi);\n                                        comment            = comment.slice(endi);\n                                        endi               = options.wrap;\n                                    }\n                                    endi = endi - 2;\n                                    do {\n                                        ltoke = cstart + comment.slice(0, endi);\n                                        ltoke = ltoke.replace(/(\\s+)$/, "");\n                                        tokenpush(false, 0);\n                                        comment = comment.slice(endi);\n                                    } while (comment.length > endi);\n                                    if (comment !== "") {\n                                        ltoke = cstart + comment.slice(0, endi);\n                                        ltoke = ltoke.replace(/(\\s+)$/, "");\n                                        tokenpush(false, 0);\n                                    }\n                                }\n                            } else {\n                                // the functionality for wrapping block comments is written here, but currently\n                                // disabled.  It demands a bit more finesse to prevent violation of JSLint and\n                                // some mutilation of white space styles\n                                if (spacely === true) {\n                                    len    = comment.length;\n                                    starti = 0;\n                                    if ((/\\s/).test(comment.charAt(0)) === true) {\n                                        do {\n                                            starti = starti + 1;\n                                        } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\n                                    }\n                                    endi = (options.wrap - 3) + starti;\n                                    if ((/\\s/).test(comment.charAt(endi)) === false && endi < len) {\n                                        do {\n                                            endi = endi - 1;\n                                        } while (endi > starti && (/\\s/).test(comment.charAt(endi)) === false);\n                                    }\n                                    if (endi > 0) {\n                                        block.push("/* " + comment.slice(starti, endi));\n                                        do {\n                                            starti = endi;\n                                            if ((/\\s/).test(comment.charAt(starti)) === true) {\n                                                do {\n                                                    starti = starti + 1;\n                                                } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\n                                            }\n                                            endi = (options.wrap - 3) + starti;\n                                            if ((/\\s/).test(comment.charAt(endi)) === false && endi < len) {\n                                                do {\n                                                    endi = endi - 1;\n                                                } while (\n                                                    endi > 0 && endi > starti && (/\\s/).test(comment.charAt(endi)) === false\n                                                );\n                                            }\n                                            block.push(cstart + comment.slice(starti, endi).replace(/(\\s+)$/, ""));\n                                        } while (endi > 0 && endi < len);\n                                        block.push(" */");\n                                        ltoke = block.join(lf);\n                                    } else {\n                                        ltoke = "/* " + comment.replace(/(\\s+)$/, "") + " */";\n                                    }\n                                    tokenpush(false, 0);\n                                } else {\n                                    len  = comment.length;\n                                    endi = options.wrap - 3;\n                                    block.push("/* " + comment.slice(0, endi));\n                                    do {\n                                        starti = endi;\n                                        endi   = starti + (options.wrap - 3);\n                                        block.push(cstart + comment.slice(starti, endi));\n                                    } while (endi < len);\n                                    block.push(" */");\n                                    ltoke = block.join(lf);\n                                    tokenpush(false, 0);\n                                }\n                            }\n                        };\n\n                    if (lines[lines.length - 1] === 0 && ltype !== "comment" && ltype !== "comment-inline" && options.styleguide !== "mrdoobs") {\n                        ltype = "comment-inline";\n                    } else {\n                        ltype = "comment";\n                    }\n                    if (options.preserveComment === true) {\n                        return tokenpush(false, 0);\n                    }\n                    if (hrule.test(comment) === true) {\n                        if (comment.charAt(2) !== " ") {\n                            comment = "// " + comment.slice(2);\n                        }\n                        ltoke = comment;\n                        return tokenpush(false, 0);\n                    }\n                    lengtha = token.length;\n                    if (comment.indexOf("/*global") === 0) {\n                        return tokenpush(false, 0);\n                    }\n                    if (line === true) {\n                        comment = comment\n                            .replace(/\\s\\/\\//g, " ")\n                            .replace(/(\\s+)$/, "");\n                    } else {\n                        if (comment.indexOf("/**") === 0) {\n                            return tokenpush(false, 0);\n                        }\n                        if (comment.indexOf("\\n") < 0 && comment.indexOf(":") > 0 && comment.indexOf(",") > 0) {\n                            return tokenpush(false, 0);\n                        }\n                        if ((/\\n(\\u0020|\\t)/).test(comment) === true && ((/\\n\\u0020\\*(\\u0020|\\/)/).test(comment) === false || (/\\n(?!(\\u0020\\*(\\u0020|\\/)))/).test(comment) === true)) {\n                            return tokenpush(false, 0);\n                        }\n                        if (comment.length < options.wrap - 3) {\n                            return tokenpush(false, 0);\n                        }\n                        if ((/^(\\/\\*\\u0020)/).test(comment) === true && (/\\n\\u0020\\*\\u0020/).test(comment) === true) {\n                            comment = comment.replace("/* ", "/*");\n                        }\n                        comment = comment\n                            .replace(/\\n\\u0020\\*\\u0020/g, " ")\n                            .replace(/\\n(\\u0020|\\t)+/g, "\\n");\n                        comment = comment.slice(2, comment.length - 2);\n                    }\n                    if (lengtha > 0) {\n                        prior = token[lengtha - 1];\n                        ptype = types[lengtha - 1];\n                    }\n                    if (ltype === "comment" && ptype !== "comment-inline" && options.wrap > 0 && empty.test(comment) === false && (comment.length > options.wrap || prior.indexOf("//") === 0)) {\n                        if (lengtha > 0 && token[lengtha - 1].indexOf("//") === 0 && empty.test(token[lengtha - 1]) === false && hrule.test(token[lengtha - 1]) === false && list.test(comment) === false && remind.test(comment) === false) {\n                            if (comment.charAt(2) !== " ") {\n                                comment = prior + " " + comment.slice(2);\n                            } else {\n                                comment = prior + comment.slice(2);\n                            }\n                            tokenpop();\n                        }\n                        if (token[lengtha - 1] === "var" || token[lengtha - 1] === "let" || token[lengtha - 1] === "const") {\n                            tokenpop();\n                            vartest = token[lengtha - 1];\n                        }\n                        if (comment.length > options.wrap - 2) {\n                            commentSplit();\n                        } else {\n                            if (line === true) {\n                                ltoke = comment;\n                            } else {\n                                ltoke = "/* " + comment\n                                    .replace(/^(\\s+)/, "")\n                                    .replace(/(\\s+)$/, "") + " */";\n                            }\n                            tokenpush(false, 0);\n                        }\n                        if (vartest !== "") {\n                            temppush();\n                            ind = lengtha - 1;\n                            do {\n                                ind = ind - 1;\n                            } while (types[ind] === "comment");\n                            lines[ind]         = lines[lengtha - 1];\n                            lines[lengtha - 1] = 0;\n                        }\n                    } else if (options.wrap < 0 && prior.indexOf("//") === 0) {\n                        if (comment.charAt(2) !== " ") {\n                            token[lengtha - 1] = prior + " " + comment.slice(2);\n                        } else {\n                            token[lengtha - 1] = prior + comment.slice(2);\n                        }\n                    } else {\n                        if (token[lengtha - 1] === "var" || token[lengtha - 1] === "let" || token[lengtha - 1] === "const") {\n                            tokenpop();\n                            vartest = token[lengtha - 1];\n                        }\n                        if (line === true) {\n                            ltoke = comment;\n                        } else {\n                            ltoke = "/* " + comment\n                                .replace(/^(\\s+)/, "")\n                                .replace(/(\\s+)$/, "") + " */";\n                        }\n                        tokenpush(false, 0);\n                        if (vartest !== "") {\n                            temppush();\n                            ind = lengtha - 1;\n                            do {\n                                ind = ind - 1;\n                            } while (types[ind] === "comment");\n                            lines[ind]         = lines[lengtha - 1];\n                            lines[lengtha - 1] = 0;\n                        }\n                    }\n                    if (xblock === true) {\n                        token.push("x}");\n                        types.push("end");\n                        lines.push(0);\n                        depth[lengtha - 1] = pdepth[0];\n                        begin[lengtha - 1] = pdepth[1];\n                        depth.push(pdepth[0]);\n                        begin.push(pdepth[1]);\n                    }\n                },\n                //merges strings separated by "+" if options.wrap is less than 0\n                strmerge       = function jspretty__tokenize_strmerge() {\n                    var aa   = 0,\n                        bb   = "",\n                        item = ltoke.slice(1, ltoke.length - 1);\n                    tokenpop();\n                    aa        = token.length - 1;\n                    bb        = token[aa];\n                    token[aa] = bb.slice(0, bb.length - 1) + item + bb.charAt(0);\n                },\n                // the generic function is a generic tokenizer start argument contains the\n                // token\'s starting syntax offset argument is length of start minus control\n                // chars end is how is to identify where the token ends\n                generic        = function jspretty__tokenize_genericBuilder(starting, ending) {\n                    var ee     = 0,\n                        ender  = ending.split(""),\n                        endlen = ender.length,\n                        jj     = b,\n                        build  = [starting],\n                        base   = a + starting.length,\n                        output = "",\n                        escape = false;\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    // this insanity is for JSON where all the required quote characters are\n                    // escaped.\n                    if (c[a - 1] === "\\\\" && slashes(a - 1) === true && (c[a] === "\\"" || c[a] === "\'")) {\n                        tokenpop();\n                        if (token[0] === "{") {\n                            if (c[a] === "\\"") {\n                                starting = "\\"";\n                                ending   = "\\\\\\"";\n                                build    = ["\\""];\n                            } else {\n                                starting = "\'";\n                                ending   = "\\\\\'";\n                                build    = ["\'"];\n                            }\n                            escape = true;\n                        } else {\n                            if (c[a] === "\\"") {\n                                return "\\\\\\"";\n                            }\n                            return "\\\\\'";\n                        }\n                    }\n                    for (ee = base; ee < jj; ee = ee + 1) {\n                        if (ee > a + 1) {\n                            if (c[ee] === "<" && c[ee + 1] === "?" && c[ee + 2] === "p" && c[ee + 3] === "h" && c[ee + 4] === "p" && c[ee + 5] !== starting && starting !== "//" && starting !== "/*") {\n                                a = ee;\n                                build.push(jspretty__tokenize_genericBuilder("<?php", "?>"));\n                                ee = ee + build[build.length - 1].length - 1;\n                            } else if (c[ee] === "<" && c[ee + 1] === "%" && c[ee + 2] !== starting && starting !== "//" && starting !== "/*") {\n                                a = ee;\n                                build.push(jspretty__tokenize_genericBuilder("<%", "%>"));\n                                ee = ee + build[build.length - 1].length - 1;\n                            } else if (c[ee] === "{" && c[ee + 1] === "%" && c[ee + 2] !== starting && starting !== "//" && starting !== "/*") {\n                                a = ee;\n                                build.push(jspretty__tokenize_genericBuilder("{%", "%}"));\n                                ee = ee + build[build.length - 1].length - 1;\n                            } else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] === "{" && c[ee + 3] !== starting && starting !== "//" && starting !== "/*") {\n                                a = ee;\n                                build.push(jspretty__tokenize_genericBuilder("{{{", "}}}"));\n                                ee = ee + build[build.length - 1].length - 1;\n                            } else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] !== starting && starting !== "//" && starting !== "/*") {\n                                a = ee;\n                                build.push(jspretty__tokenize_genericBuilder("{{", "}}"));\n                                ee = ee + build[build.length - 1].length - 1;\n                            } else if (c[ee] === "<" && c[ee + 1] === "!" && c[ee + 2] === "-" && c[ee + 3] === "-" && c[ee + 4] === "#" && c[ee + 5] !== starting && starting !== "//" && starting !== "/*") {\n                                a = ee;\n                                build.push(jspretty__tokenize_genericBuilder("\x3c!--#", "--\x3e"));\n                                ee = ee + build[build.length - 1].length - 1;\n                            } else {\n                                build.push(c[ee]);\n                            }\n                        } else {\n                            build.push(c[ee]);\n                        }\n                        if ((starting === "\\"" || starting === "\'") && json === false && c[ee - 1] !== "\\\\" && (c[ee] === "\\n" || ee === jj - 1)) {\n                            logError("Unterminated string in JavaScript", ee);\n                            break;\n                        }\n                        if (c[ee] === ender[endlen - 1] && (c[ee - 1] !== "\\\\" || slashes(ee - 1) === false)) {\n                            if (endlen === 1) {\n                                break;\n                            }\n                            // `ee - base` is a cheap means of computing length of build array the `ee -\n                            // base` and `endlen` are both length based values, so adding two (1 for each)\n                            // provides an index based number\n                            if (build[ee - base] === ender[0] && build.slice(ee - base - endlen + 2).join("") === ending) {\n                                break;\n                            }\n                        }\n                    }\n                    if (escape === true) {\n                        output = build[build.length - 1];\n                        build.pop();\n                        build.pop();\n                        build.push(output);\n                    }\n                    a = ee;\n                    if (starting === "//") {\n                        stats.space.newline = stats.space.newline + 1;\n                        build.pop();\n                    }\n                    output = build.join("");\n                    if (starting === "//") {\n                        output = output.replace(/(\\s+)$/, "");\n                    } else if (starting === "/*") {\n                        build = output.split(lf);\n                        for (ee = build.length - 1; ee > -1; ee = ee - 1) {\n                            build[ee] = build[ee].replace(/(\\s+)$/, "");\n                        }\n                        output = build.join(lf);\n                    }\n                    if (options.jsscope !== "none") {\n                        output = output\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;");\n                    }\n                    if (starting === "{%") {\n                        if (output.indexOf("{%-") < 0) {\n                            output = output\n                                .replace(/^(\\{%\\s*)/, "{% ")\n                                .replace(/(\\s*%\\})$/, " %}");\n                        } else {\n                            output = output\n                                .replace(/^(\\{%-\\s*)/, "{%- ")\n                                .replace(/(\\s*-%\\})$/, " -%}");\n                        }\n                    }\n                    if (output.indexOf("#region") === 0 || output.indexOf("#endregion") === 0) {\n                        output = output.replace(/(\\s+)$/, "");\n                    }\n                    return output;\n                },\n                //a tokenizer for regular expressions\n                regex          = function jspretty__tokenize_regex() {\n                    var ee     = 0,\n                        f      = b,\n                        h      = 0,\n                        i      = 0,\n                        build  = ["/"],\n                        output = "",\n                        square = false;\n                    for (ee = a + 1; ee < f; ee = ee + 1) {\n                        build.push(c[ee]);\n                        if (c[ee - 1] !== "\\\\" || c[ee - 2] === "\\\\") {\n                            if (c[ee] === "[") {\n                                square = true;\n                            }\n                            if (c[ee] === "]") {\n                                square = false;\n                            }\n                        }\n                        if (c[ee] === "/" && square === false) {\n                            if (c[ee - 1] === "\\\\") {\n                                i = 0;\n                                for (h = ee - 1; h > 0; h = h - 1) {\n                                    if (c[h] === "\\\\") {\n                                        i = i + 1;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                                if (i % 2 === 0) {\n                                    break;\n                                }\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                    if (c[ee + 1] === "g" || c[ee + 1] === "i" || c[ee + 1] === "m" || c[ee + 1] === "y" || c[ee + 1] === "u") {\n                        build.push(c[ee + 1]);\n                        if (c[ee + 2] !== c[ee + 1] && (c[ee + 2] === "g" || c[ee + 2] === "i" || c[ee + 2] === "m" || c[ee + 2] === "y" || c[ee + 2] === "u")) {\n                            build.push(c[ee + 2]);\n                            if (c[ee + 3] !== c[ee + 1] && c[ee + 3] !== c[ee + 2] && (c[ee + 3] === "g" || c[ee + 3] === "i" || c[ee + 3] === "m" || c[ee + 3] === "y" || c[ee + 3] === "u")) {\n                                build.push(c[ee + 3]);\n                                if (c[ee + 4] !== c[ee + 1] && c[ee + 4] !== c[ee + 2] && c[ee + 4] !== c[ee + 3] && (c[ee + 4] === "g" || c[ee + 4] === "i" || c[ee + 4] === "m" || c[ee + 4] === "y" || c[ee + 4] === "u")) {\n                                    build.push(c[ee + 4]);\n                                    if (c[ee + 5] !== c[ee + 1] && c[ee + 5] !== c[ee + 2] && c[ee + 5] !== c[ee + 3] && c[ee + 5] !== c[ee + 4] && (c[ee + 5] === "g" || c[ee + 5] === "i" || c[ee + 5] === "m" || c[ee + 5] === "y" || c[ee + 5] === "u")) {\n                                        build.push(c[ee + 4]);\n                                        a = ee + 5;\n                                    } else {\n                                        a = ee + 4;\n                                    }\n                                } else {\n                                    a = ee + 3;\n                                }\n                            } else {\n                                a = ee + 2;\n                            }\n                        } else {\n                            a = ee + 1;\n                        }\n                    } else {\n                        a = ee;\n                    }\n                    output = build.join("");\n                    if (options.jsscope !== "none") {\n                        output = output\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;");\n                    }\n                    return output;\n                },\n                //a unique tokenizer for operator characters\n                operator       = function jspretty__tokenize_operator() {\n                    var syntax = [\n                            "=",\n                            "<",\n                            ">",\n                            "+",\n                            "*",\n                            "?",\n                            "|",\n                            "^",\n                            ":",\n                            "&",\n                            "%",\n                            "~"\n                        ],\n                        g      = 0,\n                        h      = 0,\n                        jj     = b,\n                        build  = [c[a]],\n                        synlen = syntax.length,\n                        output = "";\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    if (c[a] === "/" && (lengtha > 0 && (ltype !== "word" || ltoke === "typeof" || ltoke === "return" || ltoke === "else") && ltype !== "literal" && ltype !== "end")) {\n                        if (ltoke === "return" || ltoke === "typeof" || ltoke === "else" || ltype !== "word") {\n                            ltoke             = regex();\n                            ltype             = "regex";\n                            stats.regex.token = stats.regex.token + 1;\n                            stats.regex.chars = stats.regex.chars + ltoke.length;\n                        } else {\n                            stats.operator.token = stats.operator.token + 1;\n                            stats.operator.chars = stats.operator.token + 1;\n                            ltoke                = "/";\n                            ltype                = "operator";\n                        }\n                        tokenpush(false, 0);\n                        return "regex";\n                    }\n                    if (c[a] === "?" && ("+-*/".indexOf(c[a + 1]) > -1 || (c[a + 1] === ":" && syntax.join("").indexOf(c[a + 2]) < 0))) {\n                        return "?";\n                    }\n                    if (c[a] === ":" && "+-*/".indexOf(c[a + 1]) > -1) {\n                        return ":";\n                    }\n                    if (a < b - 1) {\n                        if (c[a] !== "<" && c[a + 1] === "<") {\n                            return c[a];\n                        }\n                        if (c[a] === "!" && c[a + 1] === "/") {\n                            return "!";\n                        }\n                        if (c[a] === "-") {\n                            if (c[a + 1] === "-") {\n                                output = "--";\n                            } else if (c[a + 1] === "=") {\n                                output = "-=";\n                            } else if (c[a + 1] === ">") {\n                                output = "->";\n                            }\n                            if (output === "") {\n                                return "-";\n                            }\n                        }\n                        if (c[a] === "+") {\n                            if (c[a + 1] === "+") {\n                                output = "++";\n                            } else if (c[a + 1] === "=") {\n                                output = "+=";\n                            }\n                            if (output === "") {\n                                return "+";\n                            }\n                        }\n                        if (c[a] === "=" && c[a + 1] !== "=" && c[a + 1] !== "!" && c[a + 1] !== ">") {\n                            return "=";\n                        }\n                    }\n                    if (output === "") {\n                        if ((c[a + 1] === "+" && c[a + 2] === "+") || (c[a + 1] === "-" && c[a + 2] === "-")) {\n                            output = c[a];\n                        } else {\n                            for (g = a + 1; g < jj; g = g + 1) {\n                                if ((c[g] === "+" && c[g + 1] === "+") || (c[g] === "-" && c[g + 1] === "-")) {\n                                    break;\n                                }\n                                for (h = 0; h < synlen; h = h + 1) {\n                                    if (c[g] === syntax[h]) {\n                                        build.push(syntax[h]);\n                                        break;\n                                    }\n                                }\n                                if (h === synlen) {\n                                    break;\n                                }\n                            }\n                            output = build.join("");\n                        }\n                    }\n                    a = a + (output.length - 1);\n                    if (options.jsscope !== "none") {\n                        output = output\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;");\n                    }\n                    if (output === "=>" && ltoke === ")") {\n                        g  = token.length - 1;\n                        jj = begin[g];\n                        do {\n                            if (begin[g] === jj) {\n                                depth[g] = "method";\n                            }\n                            g = g - 1;\n                        } while (g > jj - 1);\n                    }\n                    if (output.length === 2 && output.charAt(1) === "=" && "!=<>|&?".indexOf(output.charAt(0)) < 0 && options.correct === true) {\n                        return plusequal(output);\n                    }\n                    return output;\n                },\n                //ES6 template string support\n                tempstring     = function jspretty__tokenize_tempstring() {\n                    var output = [c[a]];\n                    for (a = a + 1; a < b; a = a + 1) {\n                        output.push(c[a]);\n                        if (c[a] === "`" && (c[a - 1] !== "\\\\" || slashes(a - 1) === false)) {\n                            templateString.pop();\n                            break;\n                        }\n                        if (c[a - 1] === "$" && c[a] === "{" && (c[a - 2] !== "\\\\" || slashes(a - 2) === false)) {\n                            templateString[templateString.length - 1] = true;\n                            break;\n                        }\n                    }\n                    return output.join("");\n                },\n                //a tokenizer for numbers\n                numb           = function jspretty__tokenize_number() {\n                    var ee    = 0,\n                        f     = b,\n                        build = [c[a]],\n                        test  = /zz/,\n                        dot   = (build[0] === ".");\n                    if (a < b - 2 && c[a] === "0") {\n                        if (c[a + 1] === "x") {\n                            test = /[0-9a-fA-F]/;\n                        } else if (c[a + 1] === "o") {\n                            test = /[0-9]/;\n                        } else if (c[a + 1] === "b") {\n                            test = /0|1/;\n                        }\n                        if (test.test(c[a + 2]) === true) {\n                            build.push(c[a + 1]);\n                            ee = a + 1;\n                            do {\n                                ee = ee + 1;\n                                build.push(c[ee]);\n                            } while (test.test(c[ee + 1]) === true);\n                            a = ee;\n                            return build.join("");\n                        }\n                    }\n                    for (ee = a + 1; ee < f; ee = ee + 1) {\n                        if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {\n                            build.push(c[ee]);\n                            if (c[ee] === ".") {\n                                dot = true;\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                    if (ee < f - 1 && ((/\\d/).test(c[ee - 1]) === true || ((/\\d/).test(c[ee - 2]) === true && (c[ee - 1] === "-" || c[ee - 1] === "+"))) && (c[ee] === "e" || c[ee] === "E")) {\n                        build.push(c[ee]);\n                        if (c[ee + 1] === "-" || c[ee + 1] === "+") {\n                            build.push(c[ee + 1]);\n                            ee = ee + 1;\n                        }\n                        dot = false;\n                        for (ee = ee + 1; ee < f; ee = ee + 1) {\n                            if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {\n                                build.push(c[ee]);\n                                if (c[ee] === ".") {\n                                    dot = true;\n                                }\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                    a = ee - 1;\n                    return build.join("");\n                },\n                // Not a tokenizer.  This counts white space characters and determines if there\n                // are empty lines to be preserved\n                space          = function jspretty__tokenize_space() {\n                    var schars    = [],\n                        f         = 0,\n                        locallen  = b,\n                        emptyline = 1,\n                        output    = "",\n                        stest     = (/\\s/),\n                        asitest   = false;\n                    for (f = a; f < locallen; f = f + 1) {\n                        if (c[f] === "\\n") {\n                            stats.space.newline = stats.space.newline + 1;\n                            asitest             = true;\n                        } else if (c[f] === " ") {\n                            stats.space.space = stats.space.space + 1;\n                        } else if (c[f] === "\\t") {\n                            stats.space.tab = stats.space.tab + 1;\n                        } else if (stest.test(c[f]) === true) {\n                            stats.space.other = stats.space.other + 1;\n                        } else {\n                            break;\n                        }\n                        schars.push(c[f]);\n                    }\n                    a = f - 1;\n                    if (token.length === 0) {\n                        return;\n                    }\n                    output = schars.join("");\n                    if (output.indexOf("\\n") > -1 && token[token.length - 1].indexOf("#!/") !== 0) {\n                        schars = output.split("\\n");\n                        if (schars.length > 2) {\n                            emptyline = schars.length - 1;\n                            if (token[lengtha - 1].indexOf("//") === 0) {\n                                emptyline = emptyline + 1;\n                            }\n                            if (emptyline > options.preserve + 1) {\n                                emptyline = options.preserve + 1;\n                            }\n                        } else if (token[lengtha - 1] !== undefined && token[lengtha - 1].indexOf("//") === 0) {\n                            emptyline = 2;\n                        }\n                        if (ltype === "comment" && ltoke.charAt(1) !== "*" && emptyline < 2) {\n                            lines[lines.length - 1] = emptyline + 1;\n                        } else {\n                            lines[lines.length - 1] = emptyline;\n                        }\n                    }\n                    if (asitest === true && ltoke !== ";" && lengthb < token.length && c[a + 1] !== "}") {\n                        asi(false);\n                        lengthb = token.length;\n                    }\n                },\n                // Identifies blocks of markup embedded within JavaScript for language supersets\n                // like React JSX.\n                markup         = function jspretty__tokenize_markup() {\n                    var output     = [],\n                        curlytest  = false,\n                        endtag     = false,\n                        anglecount = 0,\n                        curlycount = 0,\n                        tagcount   = 0,\n                        d          = 0,\n                        next       = "",\n                        syntaxnum  = "0123456789=<>+-*?|^:&.,;%(){}[]~",\n                        syntax     = "=<>+-*?|^:&.,;%(){}[]~";\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    d = token.length - 1;\n                    if (types[d] === "comment" || types[d] === "comment-inline") {\n                        do {\n                            d = d - 1;\n                        } while (d > 0 && (types[d] === "comment" || types[d] === "comment-inline"));\n                    }\n                    if (c[a] === "<" && c[a + 1] === ">") {\n                        a     = a + 1;\n                        ltype = "generic";\n                        return "<>";\n                    }\n                    if ((c[a] !== "<" && syntaxnum.indexOf(c[a + 1]) > -1) || token[d] === "++" || token[d] === "--" || (/\\s/).test(c[a + 1]) === true || ((/\\d/).test(c[a + 1]) === true && (ltype === "operator" || ltype === "literal" || (ltype === "word" && ltoke !== "return")))) {\n                        ltype = "operator";\n                        return operator();\n                    }\n                    if (options.typescript === false && (token[d] === "return" || types[d] === "operator" || types[d] === "start" || types[d] === "separator" || (token[d] === "}" && depthlist[depthlist.length - 1][0] === "global"))) {\n                        ltype       = "markup";\n                        options.jsx = true;\n                    } else if (options.typescript === true || token[lengtha - 1] === "#include" || (((/\\s/).test(c[a - 1]) === false || ltoke === "public" || ltoke === "private" || ltoke === "static" || ltoke === "final" || ltoke === "implements" || ltoke === "class" || ltoke === "void" || ltoke === "Promise") && syntaxnum.indexOf(c[a + 1]) < 0)) {\n                        //Java type generics\n                        return (function jspretty__tokenize_markup_generic() {\n                            var generics = [\n                                    "<",\n                                    c[a + 1]\n                                ],\n                                comma    = false,\n                                e        = 1,\n                                f        = 0;\n                            if (c[a + 1] === "<") {\n                                e = 2;\n                            }\n                            for (d = a + 2; d < b; d = d + 1) {\n                                generics.push(c[d]);\n                                if (c[d] === "?" && c[d + 1] === ">") {\n                                    generics.push(">");\n                                    d = d + 1;\n                                }\n                                if (c[d] === ",") {\n                                    comma = true;\n                                    if ((/\\s/).test(c[d + 1]) === false) {\n                                        generics.push(" ");\n                                    }\n                                } else if (c[d] === "[") {\n                                    f = f + 1;\n                                } else if (c[d] === "]") {\n                                    f = f - 1;\n                                } else if (c[d] === "<") {\n                                    e = e + 1;\n                                } else if (c[d] === ">") {\n                                    e = e - 1;\n                                    if (e === 0 && f === 0) {\n                                        if ((/\\s/).test(c[d - 1]) === true) {\n                                            ltype = "operator";\n                                            return operator();\n                                        }\n                                        ltype = "generic";\n                                        a     = d;\n                                        return generics\n                                            .join("")\n                                            .replace(/\\s+/g, " ");\n                                    }\n                                }\n                                if ((syntax.indexOf(c[d]) > -1 && c[d] !== "," && c[d] !== "<" && c[d] !== ">" && c[d] !== "[" && c[d] !== "]") || (comma === false && (/\\s/).test(c[d]) === true)) {\n                                    ltype = "operator";\n                                    return operator();\n                                }\n                            }\n                        }());\n                    } else {\n                        ltype = "operator";\n                        return operator();\n                    }\n                    for (a = a; a < b; a = a + 1) {\n                        output.push(c[a]);\n                        if (c[a] === "{") {\n                            curlycount = curlycount + 1;\n                            curlytest  = true;\n                        } else if (c[a] === "}") {\n                            curlycount = curlycount - 1;\n                            if (curlycount === 0) {\n                                curlytest = false;\n                            }\n                        } else if (c[a] === "<" && curlytest === false) {\n                            if (c[a + 1] === "<") {\n                                do {\n                                    output.push(c[a]);\n                                    a = a + 1;\n                                } while (c[a + 1] === "<");\n                            }\n                            anglecount = anglecount + 1;\n                            if (c[a + 1] === "/") {\n                                endtag = true;\n                            }\n                        } else if (c[a] === ">" && curlytest === false) {\n                            if (c[a + 1] === ">") {\n                                do {\n                                    output.push(c[a]);\n                                    a = a + 1;\n                                } while (c[a + 1] === ">");\n                            }\n                            anglecount = anglecount - 1;\n                            if (endtag === true) {\n                                tagcount = tagcount - 1;\n                            } else if (c[a - 1] !== "/") {\n                                tagcount = tagcount + 1;\n                            }\n                            if (anglecount === 0 && curlycount === 0 && tagcount < 1) {\n                                ltype = "markup";\n                                next  = nextchar(2, false);\n                                if (next.charAt(0) !== "<") {\n                                    return output.join("");\n                                }\n                                // catch additional trailing tag sets\n                                if (next.charAt(0) === "<" && syntaxnum.indexOf(next.charAt(1)) < 0 && (/\\s/).test(next.charAt(1)) === false) {\n                                    // perform a minor safety test to verify if "<" is a tag start or a less than\n                                    // operator\n                                    d = a + 1;\n                                    do {\n                                        d = d + 1;\n                                        if (c[d] === ">" || ((/\\s/).test(c[d - 1]) === true && syntaxnum.indexOf(c[d]) < 0)) {\n                                            break;\n                                        }\n                                        if (syntaxnum.indexOf(c[d]) > -1) {\n                                            return output.join("");\n                                        }\n                                    } while (d < b);\n                                } else {\n                                    return output.join("");\n                                }\n                            }\n                            endtag = false;\n                        }\n                    }\n                    ltype = "markup";\n                    return output.join("");\n                },\n                //operations for end types: ), ], }\n                end            = function jspretty__tokenize_end(x) {\n                    var insert   = false,\n                        next     = nextchar(1, false),\n                        newarray = function jspretty__tokenize_end_newarray() {\n                            var aa       = begin[lengtha - 1],\n                                bb       = 0,\n                                cc       = 0,\n                                ar       = (token[begin[lengtha - 1] - 1] === "Array"),\n                                startar  = (ar === true)\n                                    ? "["\n                                    : "{",\n                                endar    = (ar === true)\n                                    ? "]"\n                                    : "}",\n                                namear   = (ar === true)\n                                    ? "array"\n                                    : "object",\n                                arraylen = 0;\n                            tokenpop();\n                            cc = lengtha - 1;\n                            if (ar === true && token[cc - 1] === "(" && types[cc] === "literal" && token[cc].charAt(0) !== "\\"" && token[cc].charAt(0) !== "\'") {\n                                arraylen = token[cc] - 1;\n                                tokenpop();\n                                tokenpop();\n                                tokenpop();\n                                token[token.length - 1]         = "[";\n                                lengtha                         = token.length;\n                                types[types.length - 1]         = "start";\n                                lines[lines.length - 1]         = 0;\n                                depth[depth.length - 1]         = "array";\n                                begin[begin.length - 1]         = lengtha - 1;\n                                depthlist[depthlist.length - 1] = [\n                                    "array", lengtha - 1\n                                ];\n                                do {\n                                    tokenpush(true, 0);\n                                    arraylen = arraylen - 1;\n                                } while (arraylen > 0);\n                            } else {\n                                token[aa] = startar;\n                                types[aa] = "start";\n                                cc        = begin[aa];\n                                token.splice(aa - 2, 2);\n                                types.splice(aa - 2, 2);\n                                lines.splice(aa - 2, 2);\n                                depth.splice(aa - 2, 2);\n                                begin.splice(aa - 2, 2);\n                                lengtha                         = lengtha - 2;\n                                depthlist[depthlist.length - 1] = [\n                                    namear, aa - 2\n                                ];\n                                pdepth                          = [namear, aa];\n                                bb                              = lengtha - 1;\n                                do {\n                                    if (begin[bb] === cc) {\n                                        depth[bb] = namear;\n                                        begin[bb] = begin[bb] - 2;\n                                    }\n                                    bb = bb - 1;\n                                } while (bb > aa - 3);\n                            }\n                            ltoke = endar;\n                            ltype = "end";\n                            tokenpush(false, 0);\n                        };\n                    stats.container = stats.container + 1;\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    if (classy.length > 0) {\n                        if (classy[classy.length - 1] === 0) {\n                            classy.pop();\n                        } else {\n                            classy[classy.length - 1] = classy[classy.length - 1] - 1;\n                        }\n                    }\n                    if (x === ")" || x === "x)" || x === "]") {\n                        plusplus();\n                        asifix();\n                    }\n                    if (x === ")" || x === "x)") {\n                        asi(false);\n                    }\n                    if (vart.len > -1) {\n                        if (x === "}" && ((options.varword === "list" && vart.count[vart.len] === 0) || (token[token.length - 1] === "x;" && options.varword === "each"))) {\n                            vartpop();\n                        }\n                        vart.count[vart.len] = vart.count[vart.len] - 1;\n                        if (vart.count[vart.len] < 0) {\n                            vartpop();\n                        }\n                    }\n                    if (ltoke === "," && depth[lengtha - 1] !== "initializer" && ((x === "]" && (options.endcomma === "never" || options.endcomma === "multiline" || token[lengtha - 2] === "[")) || x === "}")) {\n                        tokenpop();\n                    } else if ((x === "]" || x === "}") && options.endcomma === "always" && ltoke !== ",") {\n                        endCommaArray();\n                    }\n                    if (x === ")" || x === "x)") {\n                        ltoke = x;\n                        ltype = "end";\n                        if (lword.length > 0) {\n                            pword = lword[lword.length - 1];\n                            if (pword.length > 1 && next !== "{" && (pword[0] === "if" || pword[0] === "for" || (pword[0] === "while" && depth[pword[1] - 2] !== undefined && depth[pword[1] - 2] !== "do") || pword[0] === "with")) {\n                                insert = true;\n                            }\n                        }\n                    } else if (x === "]") {\n                        ltoke = "]";\n                        ltype = "end";\n                        pword = [];\n                    } else if (x === "}") {\n                        if (ltoke !== "," || options.endcomma === "always") {\n                            if (ltoke === ";" && options.mode === "minify") {\n                                token[token.length - 1] = "x;";\n                            }\n                            plusplus();\n                        }\n                        if (depthlist.length > 0 && depthlist[depthlist.length - 1][0] !== "object") {\n                            asi(true);\n                        } else if (objsortop === true) {\n                            objSort();\n                        }\n                        if (ltype === "comment" || ltype === "comment-inline") {\n                            lengtha = token.length;\n                            ltoke   = token[lengtha - 1];\n                            ltype   = types[lengtha - 1];\n                        }\n                        if (options.braceline === true) {\n                            lines[lines.length - 1] = 2;\n                        }\n                        ltoke = "}";\n                        ltype = "end";\n                        pword = [];\n                    }\n                    lword.pop();\n                    tokenpush(false, 0);\n                    if (x === ")" && options.correct === true && (token[begin[lengtha - 1] - 1] === "Array" || token[begin[lengtha - 1] - 1] === "Object") && token[begin[lengtha - 1] - 2] === "new") {\n                        newarray();\n                    }\n                    pdepth = depthlist.pop();\n                    if (brace[brace.length - 1] === "x{" && x === "}") {\n                        blockinsert();\n                    }\n                    brace.pop();\n                    if (brace[brace.length - 1] === "x{" && x === "}" && depth[lengtha - 1] !== "try") {\n                        if (next !== ":" && token[begin[a] - 1] !== "?") {\n                            blockinsert();\n                        }\n                    }\n                    if (insert === true) {\n                        ltoke = "x{";\n                        ltype = "start";\n                        tokenpush(false, 0);\n                        brace.push("x{");\n                        pword[1] = lengtha - 1;\n                        depthlist.push(pword);\n                    }\n                },\n                //determines tag names for {% %} based template tags and returns a type\n                tname          = function jspretty__tokenize_tname(x) {\n                    var sn       = 2,\n                        en       = 0,\n                        st       = x.slice(0, 2),\n                        len      = x.length,\n                        name     = "",\n                        namelist = [\n                            "autoescape",\n                            "block",\n                            "capture",\n                            "case",\n                            "comment",\n                            "embed",\n                            "filter",\n                            "for",\n                            "form",\n                            "if",\n                            "macro",\n                            "paginate",\n                            "raw",\n                            "sandbox",\n                            "spaceless",\n                            "tablerow",\n                            "unless",\n                            "verbatim"\n                        ];\n                    if (x.charAt(2) === "-") {\n                        sn = sn + 1;\n                    }\n                    if ((/\\s/).test(x.charAt(sn)) === true) {\n                        do {\n                            sn = sn + 1;\n                        } while ((/\\s/).test(x.charAt(sn)) === true && sn < len);\n                    }\n                    en = sn;\n                    do {\n                        en = en + 1;\n                    } while (\n                        (/\\s/).test(x.charAt(en)) === false && x.charAt(en) !== "(" && en < len\n                    );\n                    if (en === len) {\n                        en = x.length - 2;\n                    }\n                    name = x.slice(sn, en);\n                    if (name === "else" || (st === "{%" && (name === "elseif" || name === "when" || name === "elif"))) {\n                        return "template_else";\n                    }\n                    if (st === "{{") {\n                        if (name === "end") {\n                            return "template_end";\n                        }\n                        if (name === "block" || name === "define" || name === "form" || name === "if" || name === "range" || name === "with") {\n                            return "template_start";\n                        }\n                        return "template";\n                    }\n                    for (en = namelist.length - 1; en > -1; en = en - 1) {\n                        if (name === namelist[en]) {\n                            return "template_start";\n                        }\n                        if (name === "end" + namelist[en]) {\n                            return "template_end";\n                        }\n                    }\n                    return "template";\n                };\n            start = function jspretty__tokenize_start(x) {\n                brace.push(x);\n                stats.container = stats.container + 1;\n                if (wordTest > -1) {\n                    word();\n                }\n                if (vart.len > -1) {\n                    vart.count[vart.len] = vart.count[vart.len] + 1;\n                }\n                if (token[lengtha - 2] === "function") {\n                    lword.push(["function", lengtha]);\n                } else {\n                    lword.push([ltoke, lengtha]);\n                }\n                ltoke = x;\n                ltype = "start";\n                if (x === "(" || x === "x(") {\n                    asifix();\n                } else if (x === "{") {\n                    if (paren > -1) {\n                        if (begin[paren - 1] === begin[begin[lengtha - 1] - 1] || token[begin[lengtha - 1]] === "x(") {\n                            paren = -1;\n                            end("x)");\n                            asifix();\n                            ltoke = "{";\n                            ltype = "start";\n                        }\n                    } else if (ltoke === ")") {\n                        asifix();\n                    }\n                    if ((ltype === "comment" || ltype === "comment-inline") && token[lengtha - 2] === ")") {\n                        ltoke              = token[lengtha - 1];\n                        token[lengtha - 1] = "{";\n                        ltype              = types[lengtha - 1];\n                        types[lengtha - 1] = "start";\n                    }\n                }\n                if (options.braceline === true && x === "{") {\n                    tokenpush(false, 2);\n                } else {\n                    tokenpush(false, 0);\n                }\n                if (classy.length > 0) {\n                    classy[classy.length - 1] = classy[classy.length - 1] + 1;\n                }\n                depthlist.push([\n                    depth[depth.length - 1],\n                    begin[begin.length - 1]\n                ]);\n            };\n            for (a = 0; a < b; a = a + 1) {\n                if ((/\\s/).test(c[a])) {\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    space();\n                } else if (c[a] === "<" && c[a + 1] === "?" && c[a + 2] === "p" && c[a + 3] === "h" && c[a + 4] === "p") {\n                    //php\n                    ltoke              = generic("<?php", "?>");\n                    ltype              = "template";\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "<" && c[a + 1] === "%") {\n                    //asp\n                    ltoke              = generic("<%", "%>");\n                    ltype              = "template";\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "{" && c[a + 1] === "%") {\n                    //twig\n                    ltoke              = generic("{%", "%}");\n                    ltype              = tname(ltoke);\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "{" && c[a + 1] === "{" && c[a + 2] === "{") {\n                    //mustache\n                    ltoke              = generic("{{{", "}}}");\n                    ltype              = "template";\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "{" && c[a + 1] === "{") {\n                    //handlebars\n                    ltoke              = generic("{{", "}}");\n                    ltype              = tname(ltoke);\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-" && c[a + 4] === "#") {\n                    //ssi\n                    ltoke              = generic("\x3c!--#", "--\x3e");\n                    ltype              = "template";\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-") {\n                    //markup comment\n                    ltoke                    = generic("\x3c!--", "--\x3e");\n                    ltype                    = "comment";\n                    stats.commentBlock.token = stats.commentBlock.token + 1;\n                    stats.commentBlock.chars = stats.commentBlock.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "<") {\n                    //markup\n                    ltoke              = markup();\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "*")) {\n                    //comment block\n                    ltoke                    = generic("/*", "*\\/");\n                    stats.commentBlock.token = stats.commentBlock.token + 1;\n                    stats.commentBlock.chars = stats.commentBlock.chars + ltoke.length;\n                    if (ltoke.indexOf("# sourceMappingURL=") === 2) {\n                        sourcemap[0] = token.length;\n                        sourcemap[1] = ltoke;\n                    }\n                    if (options.comments !== "nocomment") {\n                        ltype = "comment";\n                        if (token[lengtha - 1] === "var" || token[lengtha - 1] === "let" || token[lengtha - 1] === "const") {\n                            tokenpop();\n                            commentwrap(ltoke, false);\n                            temppush();\n                            if (lines[lengtha - 3] === 0) {\n                                lines[lengtha - 3] = lines[lengtha - 1];\n                            }\n                            lines[lengtha - 1] = 0;\n                        } else {\n                            commentwrap(ltoke, false);\n                        }\n                    }\n                } else if ((lines.length === 0 || lines[lines.length - 1] > 0) && c[a] === "#" && c[a + 1] === "!" && (c[a + 2] === "/" || c[a + 2] === "[")) {\n                    //shebang\n                    ltoke              = generic("#!" + c[a + 2], "\\n");\n                    ltoke              = ltoke.slice(0, ltoke.length - 1);\n                    ltype              = "literal";\n                    stats.server.token = stats.server.token + 1;\n                    stats.server.chars = stats.server.chars + ltoke.length;\n                    tokenpush(false, 2);\n                } else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "/")) {\n                    //comment line\n                    asi(false);\n                    ltoke                   = generic("//", "\\n");\n                    stats.commentLine.token = stats.commentLine.token + 1;\n                    stats.commentLine.chars = stats.commentLine.chars + ltoke.length;\n                    if (ltoke.indexOf("# sourceMappingURL=") === 2) {\n                        sourcemap[0] = token.length;\n                        sourcemap[1] = ltoke;\n                    }\n                    if (options.comments !== "nocomment") {\n                        commentwrap(ltoke, true);\n                    }\n                } else if (c[a] === "#" && c[a + 1] === "r" && c[a + 2] === "e" && c[a + 3] === "g" && c[a + 4] === "i" && c[a + 5] === "o" && c[a + 6] === "n" && (/\\s/).test(c[a + 7]) === true) {\n                    //comment line\n                    asi(false);\n                    ltoke                   = generic("#region", "\\n");\n                    ltype                   = "comment";\n                    stats.commentLine.token = stats.commentLine.token + 1;\n                    stats.commentLine.chars = stats.commentLine.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "#" && c[a + 1] === "e" && c[a + 2] === "n" && c[a + 3] === "d" && c[a + 4] === "r" && c[a + 5] === "e" && c[a + 6] === "g" && c[a + 7] === "i" && c[a + 8] === "o" && c[a + 9] === "n") {\n                    //comment line\n                    asi(false);\n                    ltoke                   = generic("#endregion", "\\n");\n                    ltype                   = "comment";\n                    stats.commentLine.token = stats.commentLine.token + 1;\n                    stats.commentLine.chars = stats.commentLine.chars + ltoke.length;\n                    tokenpush(false, 0);\n                } else if (c[a] === "`" || (c[a] === "}" && templateString[templateString.length - 1] === true)) {\n                    //template string\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    if (c[a] === "`") {\n                        templateString.push(false);\n                    } else {\n                        templateString[templateString.length - 1] = false;\n                    }\n                    ltoke              = tempstring();\n                    ltype              = "literal";\n                    stats.string.token = stats.string.token + 1;\n                    if (ltoke.charAt(ltoke.length - 1) === "{") {\n                        stats.string.quote = stats.string.quote + 3;\n                        stats.string.chars = stats.string.chars + ltoke.length - 3;\n                    } else {\n                        stats.string.quote = stats.string.quote + 2;\n                        stats.string.chars = ltoke.length - 2;\n                    }\n                    tokenpush(false, 0);\n                } else if (c[a] === "\\"" || c[a] === "\'") {\n                    //string\n                    ltoke = generic(c[a], c[a]);\n                    ltype = "literal";\n                    if ((ltoke.charAt(0) === "\\"" && options.quoteConvert === "single") || (ltoke.charAt(0) === "\'" && options.quoteConvert === "double")) {\n                        ltoke = quoteConvert(ltoke);\n                    }\n                    stats.string.token = stats.string.token + 1;\n                    if (ltoke.length > 1) {\n                        stats.string.chars = stats.string.chars + ltoke.length - 2;\n                    }\n                    stats.string.quote = stats.string.quote + 2;\n                    if (options.wrap !== 0 && token[lengtha - 1] === "+" && (token[lengtha - 2].charAt(0) === "\\"" || token[lengtha - 2].charAt(0) === "\'")) {\n                        strmerge();\n                    } else if (options.wrap > 0 && (types[lengtha] !== "operator" || token[lengtha] === "=" || token[lengtha] === ":" || (token[lengtha] === "+" && types[lengtha - 1] === "literal"))) {\n                        if ((token[0] === "[" && (/(\\]\\s*)$/).test(options.source) === true) || (token[0] === "{" && (/(\\}\\s*)$/).test(options.source) === true)) {\n                            tokenpush(false, 0);\n                        } else if (types[lengtha - 2] === "literal" && token[lengtha - 1] === "+" && (token[lengtha - 2].charAt(0) === "\\"" || token[lengtha - 2].charAt(0) === "\'") && token[lengtha - 2].length < options.wrap + 2) {\n                            strmerge();\n                        } else {\n                            tokenpush(false, 0);\n                        }\n                    } else {\n                        tokenpush(false, 0);\n                    }\n                } else if (c[a] === "-" && (a < b - 1 && c[a + 1] !== "=" && c[a + 1] !== "-") && (ltype === "literal" || ltype === "word") && ltoke !== "return" && (ltoke === ")" || ltoke === "]" || ltype === "word" || ltype === "literal")) {\n                    //subtraction\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    stats.operator.token = stats.operator.token + 1;\n                    stats.operator.chars = stats.operator.chars + 1;\n                    ltoke                = "-";\n                    ltype                = "operator";\n                    tokenpush(false, 0);\n                } else if (wordTest === -1 && (c[a] !== "0" || (c[a] === "0" && c[a + 1] !== "b")) && ((/\\d/).test(c[a]) || (a !== b - 2 && c[a] === "-" && c[a + 1] === "." && (/\\d/).test(c[a + 2])) || (a !== b - 1 && (c[a] === "-" || c[a] === ".") && (/\\d/).test(c[a + 1])))) {\n                    //number\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    if (ltype === "end" && c[a] === "-") {\n                        ltoke                = "-";\n                        ltype                = "operator";\n                        stats.operator.token = stats.operator.token + 1;\n                        stats.operator.chars = stats.operator.chars + 1;\n                    } else {\n                        ltoke              = numb();\n                        ltype              = "literal";\n                        stats.number.token = stats.number.token + 1;\n                        stats.number.chars = stats.number.chars + ltoke.length;\n                    }\n                    tokenpush(false, 0);\n                } else if (c[a] === ":" && c[a + 1] === ":") {\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    plusplus();\n                    asifix();\n                    a                    = a + 1;\n                    stats.operator.token = stats.operator.token + 1;\n                    stats.operator.chars = stats.operator.chars + 2;\n                    ltoke                = "::";\n                    ltype                = "separator";\n                    tokenpush(false, 0);\n                } else if (c[a] === ",") {\n                    //comma\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    plusplus();\n                    stats.comma = stats.comma + 1;\n                    if (ltype === "comment" || ltype === "comment-inline") {\n                        commaComment();\n                    } else if (vart.len > -1 && vart.count[vart.len] === 0 && options.varword === "each") {\n                        asifix();\n                        ltoke = ";";\n                        ltype = "separator";\n                        tokenpush(false, 0);\n                        ltoke = vart.word[vart.len];\n                        ltype = "word";\n                        tokenpush(false, 0);\n                        vart.index[vart.len] = token.length - 1;\n                    } else {\n                        ltoke = ",";\n                        ltype = "separator";\n                        asifix();\n                        tokenpush(false, 0);\n                    }\n                } else if (c[a] === ".") {\n                    //period\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    stats.operator.token = stats.operator.token + 1;\n                    if (c[a + 1] === "." && c[a + 2] === ".") {\n                        ltoke                = "...";\n                        ltype                = "operator";\n                        stats.operator.chars = stats.operator.chars + 3;\n                        a                    = a + 2;\n                    } else {\n                        asifix();\n                        ltoke                = ".";\n                        ltype                = "separator";\n                        stats.operator.chars = stats.operator.chars + 1;\n                    }\n                    if ((/\\s/).test(c[a - 1]) === true) {\n                        tokenpush(false, 1);\n                    } else {\n                        tokenpush(false, 0);\n                    }\n                } else if (c[a] === ";") {\n                    //semicolon\n                    if (wordTest > -1) {\n                        word();\n                    }\n                    if (options.qml === true) {\n                        ltoke = "x;";\n                        ltype = "separator";\n                        tokenpush(false, 0);\n                    } else {\n                        if (classy[classy.length - 1] === 0) {\n                            classy.pop();\n                        }\n                        if (vart.len > -1 && vart.count[vart.len] === 0) {\n                            if (options.varword === "each") {\n                                vartpop();\n                            } else {\n                                vart.index[vart.len] = token.length;\n                            }\n                        }\n                        stats.semicolon = stats.semicolon + 1;\n                        plusplus();\n                        ltoke = ";";\n                        ltype = "separator";\n                        if (token[token.length - 1] === "x}") {\n                            asibrace();\n                        } else {\n                            tokenpush(false, 0);\n                        }\n                    }\n                    if (brace[brace.length - 1] === "x{" && nextchar(1, false) !== "}") {\n                        blockinsert();\n                    }\n                } else if (c[a] === "(" || c[a] === "[" || c[a] === "{") {\n                    start(c[a]);\n                } else if (c[a] === ")" || c[a] === "]" || c[a] === "}") {\n                    end(c[a]);\n                } else if (c[a] === "*" && depth[lengtha - 1] === "object" && wordTest < 0 && (/\\s/).test(c[a + 1]) === false && c[a + 1] !== "=" && (/\\d/).test(c[a + 1]) === false) {\n                    wordTest = a;\n                } else if (c[a] === "=" || c[a] === "&" || c[a] === "<" || c[a] === ">" || c[a] === "+" || c[a] === "-" || c[a] === "*" || c[a] === "/" || c[a] === "!" || c[a] === "?" || c[a] === "|" || c[a] === "^" || c[a] === ":" || c[a] === "%" || c[a] === "~") {\n                    //operator\n                    ltoke = operator();\n                    if (ltoke === "regex") {\n                        ltoke = token[lengtha - 1];\n                    } else {\n                        ltype                = "operator";\n                        stats.operator.token = stats.operator.token + 1;\n                        stats.operator.chars = stats.operator.chars + ltoke.length;\n                        if (ltoke !== "!" && ltoke !== "++" && ltoke !== "--") {\n                            asifix();\n                        }\n                        tokenpush(false, 0);\n                    }\n                } else if (wordTest < 0 && c[a] !== "") {\n                    wordTest = a;\n                }\n                if (vart.len > -1 && token.length === vart.index[vart.len] + 2 && token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && ltype !== "comment" && ltype !== "comment-inline" && options.varword === "list") {\n                    vartpop();\n                }\n            }\n            if (options.jsx === false && ((token[token.length - 1] !== "}" && token[0] === "{") || token[0] !== "{") && ((token[token.length - 1] !== "]" && token[0] === "[") || token[0] !== "[")) {\n                asi(false);\n            }\n            if (sourcemap[0] === token.length - 1) {\n                ltoke = "\\n" + sourcemap[1];\n                ltype = "literal";\n                tokenpush(false, 0);\n            }\n            if (token[token.length - 1] === "x;" && (token[token.length - 2] === "}" || token[token.length - 2] === "]") && begin[begin.length - 2] === 0) {\n                tokenpop();\n            }\n        }());\n\n        if (options.correct === true) {\n            (function jspretty__correct() {\n                var a = 0,\n                    b = token.length;\n                for (a = 0; a < b; a = a + 1) {\n                    if (token[a] === "x;") {\n                        token[a] = ";";\n                        scolon   = scolon + 1;\n                    } else if (token[a] === "x{") {\n                        token[a] = "{";\n                    } else if (token[a] === "x}") {\n                        token[a] = "}";\n                    } else if (token[a] === "x(") {\n                        token[a] = "(";\n                    } else if (token[a] === "x)") {\n                        token[a] = ")";\n                    }\n                }\n            }());\n        }\n        if (options.nodeasync === false) {\n            if (global.prettydiff.meta === undefined) {\n                global.prettydiff.meta       = {};\n                global.prettydiff.meta.error = "";\n            }\n            if (global.prettydiff.meta.error === "") {\n                global.prettydiff.meta.error = globalerror;\n            }\n        }\n        if (options.mode === "parse") {\n            return (function jspretty__parse() {\n                var a      = 0,\n                    c      = token.length,\n                    record = [],\n                    def    = {\n                        begin: "number - The index where the current container starts",\n                        depth: "string - The name of the current container",\n                        lines: "number - Whether the token is preceeded any space and/or line breaks in the or" +\n                                "iginal code source",\n                        token: "string - The parsed code tokens",\n                        types: "string - Data types of the tokens: comment, comment-inline, end, literal, mark" +\n                                "up, operator, regex, separator, start, template, template_else, template_end, " +\n                                "template_start, word"\n                    };\n                for (a = 0; a < c; a = a + 1) {\n                    if (options.correct === false && (token[a] === "x;" || token[a] === "x{" || token[a] === "x}" || token[a] === "x(" || token[a] === "x)")) {\n                        c = c - 1;\n                        begin.splice(a, 1);\n                        depth.splice(a, 1);\n                        lines.splice(a, 1);\n                        token.splice(a, 1);\n                        types.splice(a, 1);\n                    }\n                    if (options.parseFormat !== "htmltable" && types[a] === "markup" && global.prettydiff.markuppretty !== undefined) {\n                        options.source = token[a];\n                        options.jsx    = true;\n                        token[a]       = global\n                            .prettydiff\n                            .markuppretty(options)\n                            .data;\n                    }\n                }\n                if (options.parseFormat === "sequential") {\n                    for (a = 0; a < c; a = a + 1) {\n                        record.push([\n                            token[a], types[a], depth[a], begin[a], lines[a]\n                        ]);\n                    }\n                    if (options.nodeasync === true) {\n                        return [\n                            {\n                                data      : record,\n                                definition: def\n                            },\n                            globalerror\n                        ];\n                    }\n                    return {data: record, definition: def};\n                }\n                if (options.parseFormat === "htmltable") {\n                    return (function jspretty__parse_html() {\n                        var output = [],\n                            header = "<tr class=\\"header\\"><th>index</th><th>token</th><th>types</th><th>depth</th><" +\n                                    "th>begin</th><th>lines</th></tr>",\n                            aa     = 0,\n                            len    = 0;\n                        output.push("<table summary=\'CSS parse table\'><thead>");\n                        output.push(header);\n                        output.push("</thead><tbody>");\n                        len = token.length;\n                        for (aa = 0; aa < len; aa = aa + 1) {\n                            if (types[aa] === "markup" && global.prettydiff.markuppretty !== undefined) {\n                                options.source = token[aa];\n                                options.jsx    = true;\n                                output.push("<tr><td colspan=\\"6\\" class=\\"nested\\">");\n                                output.push(global.prettydiff.markuppretty(options).data.replace(\n                                    "<thead>",\n                                    "<thead><tr><th colspan=\\"10\\" class=\\"nested\\">markup tokens</th></tr>"\n                                ));\n                                output.push("</td></tr>");\n                                output.push(\n                                    "<tr><th colspan=\\"6\\" class=\\"nested\\">JavaScript tokens</th></tr>"\n                                );\n                                output.push(header);\n                            } else {\n                                output.push("<tr><td>");\n                                output.push(aa);\n                                output.push("</td><td>");\n                                output.push(\n                                    token[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\n                                );\n                                output.push("</td><td>");\n                                output.push(types[aa]);\n                                output.push("</td><td>");\n                                output.push(depth[aa]);\n                                output.push("</td><td>");\n                                output.push(begin[aa]);\n                                output.push("</td><td>");\n                                output.push(lines[aa]);\n                                output.push("</td></tr>");\n                            }\n                        }\n                        output.push("</tbody></table>");\n                        if (options.nodeasync === true) {\n                            return [\n                                {\n                                    data      : output.join(""),\n                                    definition: def\n                                },\n                                globalerror\n                            ];\n                        }\n                        return {data: output.join(""), definition: def};\n                    }());\n                }\n                if (options.nodeasync === true) {\n                    return [\n                        {\n                            data      : {\n                                begin: begin,\n                                depth: depth,\n                                lines: lines,\n                                token: token,\n                                types: types\n                            },\n                            definition: def\n                        },\n                        globalerror\n                    ];\n                }\n                return {\n                    data      : {\n                        begin: begin,\n                        depth: depth,\n                        lines: lines,\n                        token: token,\n                        types: types\n                    },\n                    definition: def\n                };\n            }());\n        }\n\n        if (options.jsx === true && options.jsscope !== "none" && token[0] === "{") {\n            options.jsscope = "none";\n            (function jspretty__jsxScope() {\n                var a   = 0,\n                    len = token.length;\n                for (a = 0; a < len; a = a + 1) {\n                    if (types[a] === "word" && token[a - 1] !== ".") {\n                        token[a] = "[pdjsxscope]" + token[a] + "[/pdjsxscope]";\n                    }\n                }\n            }());\n        }\n        if (options.mode === "beautify" || options.mode === "diff") {\n            //this function is the pretty-print algorithm\n            (function jspretty__beautify() {\n                var a             = 0,\n                    b             = token.length,\n                    indent        = options.inlevel, //will store the current level of indentation\n                    list          = [], //stores comma status of current block\n                    wordlist      = [], //if the current list is word types preceeded by a word (Java type invocations)\n                    lastlist      = false, //remembers the list status of the most recently closed block\n                    ternary       = [], //used to identify ternary statments\n                    varline       = [], //determines if a current list of the given block is a list of variables following the "var" keyword\n                    ctype         = "", //ctype stands for "current type"\n                    ctoke         = "", //ctoke standa for "current token"\n                    ltype         = types[0], //ltype stands for "last type"\n                    ltoke         = token[0], //ltype stands for "last token"\n                    lettest       = -1,\n                    varlen        = [\n                        []\n                    ], //stores lists of variables, assignments, and object properties for white space padding\n                    extraindent   = [\n                        []\n                    ], //stores token indexes where extra indentation occurs from ternaries and broken method chains\n                    arrbreak      = [], //array where a method break has occurred\n                    destruct      = [], //attempt to identify object destructuring\n                    itemcount     = [], //counts items in destructured lists\n                    assignlist    = [false], //are you in a list right now?\n                    destructfix   = function jspretty__beautify_destructFix(listFix, override) {\n                        // listfix  - at the end of a list correct the containing list override - to\n                        // break arrays with more than 4 items into a vertical list\n                        var c          = 0,\n                            d          = (listFix === true)\n                                ? 0\n                                : 1,\n                            ei         = (extraindent[extraindent.length - 1] === undefined)\n                                ? []\n                                : extraindent[extraindent.length - 1],\n                            arrayCheck = (\n                                override === false && depth[a] === "array" && listFix === true && ctoke !== "["\n                            );\n                        if (destruct[destruct.length - 1] === false || (depth[a] === "array" && options.formatArray === "inline") || (depth[a] === "object" && options.formatObject === "inline")) {\n                            return;\n                        }\n                        destruct[destruct.length - 1] = false;\n                        for (c = a - 1; c > -1; c = c - 1) {\n                            if (types[c] === "end") {\n                                d = d + 1;\n                            } else if (types[c] === "start") {\n                                d = d - 1;\n                            }\n                            if (depth[c] === "global") {\n                                return;\n                            }\n                            if (d === 0) {\n                                if (depth[a] === "class" || depth[a] === "map" || (arrayCheck === false && ((listFix === false && token[c] !== "(" && token[c] !== "x(") || (listFix === true && token[c] === ",")))) {\n                                    if (types[c + 1] === "template_start") {\n                                        if (lines[c] < 1) {\n                                            level[c] = -20;\n                                        } else {\n                                            level[c] = indent - 1;\n                                        }\n                                    } else if (ei.length > 0 && ei[ei.length - 1] > -1) {\n                                        level[c] = indent - 1;\n                                    } else {\n                                        level[c] = indent;\n                                    }\n                                }\n                                if (listFix === false) {\n                                    return;\n                                }\n                            }\n                            if (d < 0) {\n                                if (types[c + 1] === "template_start") {\n                                    if (lines[c] < 1) {\n                                        level[c] = -20;\n                                    } else {\n                                        level[c] = indent - 1;\n                                    }\n                                } else if (ei.length > 0 && ei[ei.length - 1] > -1) {\n                                    level[c] = indent - 1;\n                                } else {\n                                    level[c] = indent;\n                                }\n                                return;\n                            }\n                        }\n                    },\n                    strwrap       = function jspretty__beautify_strwrap(offset) {\n                        var aa        = 0,\n                            bb        = 0,\n                            cc        = 0,\n                            dd        = 0,\n                            ee        = 0,\n                            ff        = 0,\n                            x         = 0,\n                            str       = "",\n                            off       = false,\n                            ei        = (extraindent[extraindent.length - 1] === undefined)\n                                ? []\n                                : extraindent[extraindent.length - 1],\n                            ind       = (token[begin[a]] === "(" && (list[list.length - 1] === true || ei.length > 0))\n                                ? indent + 3\n                                : indent + 2,\n                            bgn       = begin[a],\n                            dep       = depth[a],\n                            lin       = lines[a],\n                            wrap      = options.wrap - 2,\n                            paren     = token[a + 1] === ".",\n                            uchar     = (/u[0-9a-fA-F]{4}/),\n                            xchar     = (/x[0-9a-fA-F]{2}/),\n                            item      = token[a],\n                            qchar     = item.charAt(0),\n                            slash     = function jspretty__beautify_strwrap_slash(trim, entity) {\n                                var dist = 0;\n                                if (entity === true) {\n                                    ff = trim;\n                                }\n                                do {\n                                    dist = dist + 1;\n                                } while (item.charAt(cc - (trim + dist)) === "\\\\" && dist < cc);\n                                if (entity === false) {\n                                    cc = cc - dist;\n                                    ff = ff + dist;\n                                } else if (dist % 2 === 1) {\n                                    cc = cc - ff;\n                                } else {\n                                    ff = 0;\n                                }\n                            },\n                            parenpush = function jspretty_beautify_strwrap_parenpush() {\n                                token.splice(a, 0, "(");\n                                types.splice(a, 0, "start");\n                                lines.splice(a, 0, lin);\n                                depth.splice(a, 0, "paren");\n                                begin.splice(a, 0, a);\n                                level.push(indent + 1);\n                                bgn = a;\n                                dep = "paren";\n                                a   = a + 1;\n                                b   = b + 1;\n                                x   = x + 1;\n                            },\n                            tokenpush = function jspretty_beautify_strwrap_tokenpush(toke, type) {\n                                token.splice(a, 0, toke);\n                                types.splice(a, 0, type);\n                                lines.splice(a, 0, lin);\n                                depth.splice(a, 0, dep);\n                                begin.splice(a, 0, bgn);\n                                if (toke === "+") {\n                                    level.push(ind);\n                                } else if (toke === ")") {\n                                    level.push(indent);\n                                    level[a - 1] = indent;\n                                } else {\n                                    level.push(-10);\n                                }\n                                a = a + 1;\n                                b = b + 1;\n                                x = x + 1;\n                            };\n                        aa = a;\n                        do {\n                            aa = aa - 1;\n                            if (aa === begin[a] && token[aa] === "(") {\n                                break;\n                            }\n                        } while (aa > 0 && level[aa - 1] < -9);\n                        if (ltoke === "(") {\n                            level[a - 1] = indent + 1;\n                        }\n                        if (token[aa] === "." && token[begin[a]] !== "(") {\n                            ind = ind + 1;\n                        }\n                        if (token[begin[a]] === "(" && list[list.length - 1] === false && token[aa] !== "?" && token[aa] !== ":") {\n                            ind = indent + 1;\n                        }\n                        if (paren === true && token[aa] !== "?" && token[aa] !== ":") {\n                            ind = indent + 1;\n                        }\n                        if (offset > 1 && item.length > offset) {\n                            off = true;\n                            if (paren === true) {\n                                tokenpush("(");\n                            }\n                            if (item.charAt(offset - 5) === "\\\\" && uchar.test(item.slice(offset - 4, offset + 1)) === true) {\n                                str  = item.slice(0, offset - 5) + item.charAt(0);\n                                item = item.charAt(0) + item.slice(offset - 5);\n                            } else if (item.charAt(offset - 4) === "\\\\" && uchar.test(item.slice(offset - 3, offset + 2)) === true) {\n                                str  = item.slice(0, offset - 4) + item.charAt(0);\n                                item = item.charAt(0) + item.slice(offset - 4);\n                            } else if (item.charAt(offset - 3) === "\\\\" && (uchar.test(item.slice(offset - 2, offset + 3)) === true || xchar.test(item.slice(offset - 2, offset + 1)) === true)) {\n                                str  = item.slice(0, offset - 3) + item.charAt(0);\n                                item = item.charAt(0) + item.slice(offset - 3);\n                            } else if (item.charAt(offset - 2) === "\\\\" && (uchar.test(item.slice(offset - 1, offset + 4)) === true || xchar.test(item.slice(offset - 1, offset + 2)) === true)) {\n                                str  = item.slice(0, offset - 2) + item.charAt(0);\n                                item = item.charAt(0) + item.slice(offset - 2);\n                            } else if (item.charAt(offset - 1) === "\\\\") {\n                                str  = item.slice(0, offset - 1) + item.charAt(0);\n                                item = item.charAt(0) + item.slice(offset - 1);\n                            } else {\n                                str  = item.slice(0, offset) + item.charAt(0);\n                                item = item.charAt(0) + item.slice(offset);\n                            }\n                            if (str.charAt(str.length - 2) === "\\\\") {\n                                str = str + str.charAt(0);\n                            }\n                            tokenpush(str, "literal");\n                            tokenpush("+", "operator");\n                        }\n                        if (item.length > wrap) {\n                            if (depth[a] === "object" || depth[a] === "array") {\n                                destructfix(true, false);\n                            }\n                            if (off === false && paren === true) {\n                                parenpush();\n                            }\n                            token.splice(a, 1);\n                            types.splice(a, 1);\n                            lines.splice(a, 1);\n                            depth.splice(a, 1);\n                            begin.splice(a, 1);\n                            b    = b - 1;\n                            item = item.slice(1, item.length - 1);\n                            bb   = Math.floor(item.length / wrap) * wrap;\n                            for (aa = 0; aa < bb; aa = aa + wrap) {\n                                cc = aa + wrap + dd;\n                                if (item.charAt(cc - 5) === "\\\\" && uchar.test(item.slice(cc - 4, cc + 1)) === true) {\n                                    slash(5, true);\n                                } else if (item.charAt(cc - 4) === "\\\\" && uchar.test(item.slice(cc - 3, cc + 2)) === true) {\n                                    slash(4, true);\n                                } else if (item.charAt(cc - 3) === "\\\\" && (uchar.test(item.slice(cc - 2, cc + 3)) === true || xchar.test(item.slice(cc - 2, cc + 1)) === true)) {\n                                    slash(3, true);\n                                } else if (item.charAt(cc - 2) === "\\\\" && (uchar.test(item.slice(cc - 1, cc + 4)) === true || xchar.test(item.slice(cc - 1, cc + 2)) === true)) {\n                                    slash(2, true);\n                                } else if (item.charAt(cc - 1) === "\\\\") {\n                                    slash(1, true);\n                                } else {\n                                    ff = 0;\n                                }\n                                if (item.charAt(cc - 1) === "\\\\") {\n                                    slash(1, false);\n                                }\n                                if (aa > 0 && dd < 0) {\n                                    aa = aa - 1;\n                                    dd = 0;\n                                }\n                                if (item.charAt(cc - 1) === "\\\\") {\n                                    str = qchar + item.slice(ee, cc - 1) + qchar;\n                                    ee  = cc - 1;\n                                    aa  = aa - 1;\n                                } else {\n                                    str = qchar + item.slice(ee, cc) + qchar;\n                                    ee  = cc;\n                                }\n                                if (item.charAt(cc) === "\\\\") {\n                                    aa = aa - ff;\n                                }\n                                tokenpush(str, "literal");\n                                if (aa < item.length - wrap) {\n                                    tokenpush("+", "operator");\n                                }\n                            }\n                            if (aa < item.length) {\n                                tokenpush(qchar + item.slice(aa, aa + wrap) + qchar, "literal");\n                            }\n                            if (paren === true) {\n                                tokenpush(")", "end");\n                            }\n                            a  = a - 1;\n                            x  = x - 1;\n                            aa = a + 1;\n                            do {\n                                aa = aa + 1;\n                                if (types[aa - 1] === "start") {\n                                    begin[aa - 1] = (aa - 1);\n                                } else if (begin[aa - 1] > bgn) {\n                                    begin[aa - 1] = begin[aa - 1] + x;\n                                }\n                            } while (aa < b);\n                            ctoke = token[a];\n                            ctype = types[a];\n                            ltoke = token[a - 1];\n                            ltype = types[a - 1];\n                        } else {\n                            if (off === true) {\n                                aa = a;\n                                do {\n                                    aa = aa + 1;\n                                    if (types[aa - 1] === "start") {\n                                        begin[aa - 1] = (aa - 1);\n                                    } else if (begin[aa - 1] > bgn) {\n                                        begin[aa - 1] = begin[aa - 1] + x;\n                                    }\n                                } while (aa < b);\n                            }\n                            token[a] = item;\n                            level.push(-10);\n                        }\n                        ctoke = token[a];\n                        ctype = "string";\n                    },\n                    literal       = function jspretty__beautify_literal() {\n                        if (ctoke.indexOf("#!/") === 0) {\n                            level.push(indent);\n                        } else {\n                            if (ctoke.charAt(0) === "}") {\n                                level[a - 1] = -20;\n                            }\n                            if (options.bracepadding === true && ctoke.charAt(0) === "}" && ctoke.charAt(ctoke.length - 1) === "`") {\n                                level[a - 1] = -10;\n                            }\n                            if (options.wrap > 0 && ctoke.length > options.wrap && (ctoke.charAt(0) === "\\"" || ctoke.charAt(0) === "\'")) {\n                                strwrap(0);\n                            } else {\n                                level.push(-10);\n                            }\n                        }\n                        if ((ltoke === "," || ltype === "start") && (depth[a] === "object" || depth[a] === "array") && destruct[destruct.length - 1] === false && a > 0) {\n                            level[a - 1] = indent;\n                        }\n                    },\n                    endExtraInd   = function jspretty__beautify_endExtraInd() {\n                        var ei = extraindent[extraindent.length - 1],\n                            c  = 0;\n                        if (ei === undefined) {\n                            return;\n                        }\n                        c = ei.length - 1;\n                        if (c < 1 && ei[c] < 0 && (ctoke === ";" || ctoke === "x;" || ctoke === ")" || ctoke === "x)" || ctoke === "}" || ctoke === "x}")) {\n                            return ei.pop();\n                        }\n                        if (c < 0 || ei[c] < 0) {\n                            return;\n                        }\n                        if (ctoke === ":") {\n                            if (token[ei[c]] !== "?") {\n                                do {\n                                    ei.pop();\n                                    c      = c - 1;\n                                    indent = indent - 1;\n                                } while (c > -1 && ei[c] > -1 && token[ei[c]] !== "?");\n                            }\n                            ei[c]        = a;\n                            level[a - 1] = indent;\n                        } else {\n                            do {\n                                ei.pop();\n                                c      = c - 1;\n                                indent = indent - 1;\n                            } while (c > -1 && ei[c] > -1);\n                        }\n                        if ((depth[a] === "array" || ctoke === ",") && ei.length < 1) {\n                            ei.push(-1);\n                        }\n                    },\n                    comment       = function jspretty__beautify_comment() {\n                        destructfix(false, false);\n                        if (token[a - 1] === ",") {\n                            level[a - 1] = indent;\n                        } else if (lines[a - 1] === 0 && types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\n                            level[a - 1] = -20;\n                        } else if (ltoke === "=" && (/^(\\/\\*\\*\\s*@[a-z_]+\\s)/).test(ctoke) === true) {\n                            level[a - 1] = -10;\n                        } else {\n                            level[a - 1] = indent;\n                        }\n                        level.push(indent);\n                    },\n                    commentInline = function jspretty__beautify_commentInline() {\n                        destructfix(false, false);\n                        if (a < b - 1 && depth[a + 1] !== "block" && (token[a + 1] === "{" || token[a + 1] === "x{")) {\n                            token[a]     = token[a + 1];\n                            types[a]     = "start";\n                            depth[a]     = depth[a + 1];\n                            begin[a]     = begin[a + 1];\n                            lines[a]     = lines[a + 1];\n                            token[a + 1] = ctoke;\n                            types[a + 1] = ctype;\n                            a            = a - 1;\n                        } else {\n                            level[a - 1] = -10;\n                            if (depth[a] === "paren" || depth[a] === "method") {\n                                level.push(indent + 2);\n                            } else {\n                                level.push(indent);\n                            }\n                        }\n                    },\n                    template      = function jspretty__beautify_template() {\n                        if (ctype === "template_else") {\n                            level[a - 1] = indent - 1;\n                            level.push(indent);\n                        } else if (ctype === "template_start") {\n                            indent = indent + 1;\n                            if (lines[a - 1] < 1) {\n                                level[a - 1] = -20;\n                            }\n                            if (lines[a] > 0) {\n                                level.push(indent);\n                            } else {\n                                level.push(-20);\n                            }\n                        } else if (ctype === "template_end") {\n                            indent = indent - 1;\n                            if (ltype === "template_start" || lines[a - 1] < 1) {\n                                level[a - 1] = -20;\n                            } else {\n                                level[a - 1] = indent;\n                            }\n                            if (lines[a] > 0) {\n                                level.push(indent);\n                            } else {\n                                level.push(-20);\n                            }\n                        } else if (ctype === "template") {\n                            if (lines[a] > 0) {\n                                level.push(indent);\n                            } else {\n                                level.push(-20);\n                            }\n                        }\n                    },\n                    markup        = function jspretty__beautify_markup() {\n                        if ((token[a + 1] !== "," && ctoke.indexOf("/>") !== ctoke.length - 2) || (token[a + 1] === "," && token[begin[a] - 3] !== "React")) {\n                            destructfix(false, false);\n                        }\n                        if (ltoke === "return" || ltoke === "?" || ltoke === ":") {\n                            level[a - 1] = -10;\n                            level.push(-20);\n                        } else if (ltype === "start" || (token[a - 2] === "return" && depth[a - 1] === "method")) {\n                            level.push(indent);\n                        } else {\n                            level.push(-20);\n                        }\n                        if (varline[varline.length - 1] === true) {\n                            markupvar.push(a);\n                        }\n                    },\n                    separator     = function jspretty__beautify_separator() {\n                        var methtest      = false,\n                            ei            = (extraindent[extraindent.length - 1] === undefined)\n                                ? []\n                                : extraindent[extraindent.length - 1],\n                            propertybreak = function jspretty__beautify_separator_propertybreak() {\n                                var c = 0,\n                                    d = begin[a],\n                                    e = 1;\n                                if (ctoke === "." && ltype !== "end" && types[a + 2] !== "start") {\n                                    level[a - 1] = -20;\n                                    return;\n                                }\n                                for (c = a - 2; c > d; c = c - 1) {\n                                    if (begin[c] === d) {\n                                        if (token[c] === ".") {\n                                            e = e + 1;\n                                        }\n                                        if (token[c] === ";" || token[c] === "," || types[c] === "operator" || token[c] === "return" || token[c] === "break" || token[c] === "continue" || types[c] === "comment" || types[c] === "comment-inline") {\n                                            break;\n                                        }\n                                        if (types[c - 1] === "end") {\n                                            if (types[c] !== "start" && types[c] !== "operator" && token[c] !== ".") {\n                                                break;\n                                            }\n                                            c = begin[c - 1];\n                                        }\n                                    }\n                                }\n                                if (e < 2) {\n                                    level[a - 1] = -20;\n                                    return;\n                                }\n                                indent = indent + 1;\n                                if (token[c] !== ".") {\n                                    do {\n                                        c = c + 1;\n                                    } while (c < a && (token[c] !== "." || begin[c] !== d));\n                                }\n                                for (e = c; e < a; e = e + 1) {\n                                    if (token[e] === "." && begin[e] === d) {\n                                        level[e - 1] = indent;\n                                    } else if (level[e] > -9) {\n                                        level[e] = level[e] + 1;\n                                    }\n                                }\n                                level[a - 1] = indent;\n                                ei.push(a);\n                            };\n                        if (ctoke === "::") {\n                            level[a - 1] = -20;\n                            return level.push(-20);\n                        }\n                        if ((options.methodchain === "chain" || (options.methodchain === "none" && lines[a] < 1)) && types[a - 1] === "comment-inline" && a > 1) {\n                            return (function jspretty__beautify_separator_commentfix() {\n                                var c    = 0,\n                                    d    = b,\n                                    last = token[a - 1];\n                                level[a - 2] = -20;\n                                level[a - 1] = -20;\n                                for (c = a; c < d; c = c + 1) {\n                                    token[c - 1] = token[c];\n                                    types[c - 1] = types[c];\n                                    if (token[c] === ";" || token[c] === "x;" || token[c] === "{" || token[c] === "x{" || lines[c] > 0) {\n                                        token[c] = last;\n                                        types[c] = "comment-inline";\n                                        a        = a - 1;\n                                        return;\n                                    }\n                                }\n                                token[c - 1] = last;\n                                types[c - 1] = "comment-inline";\n                                a            = a - 1;\n                            }());\n                        }\n                        if (ctoke === ".") {\n                            if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && ei.length > 0) {\n                                if (depth[a] === "object" || depth[a] === "array") {\n                                    destructfix(true, false);\n                                } else {\n                                    destructfix(false, false);\n                                }\n                            }\n                            if ((options.methodchain === "chain" || (options.methodchain === "none" && lines[a] < 1)) && ltype !== "comment" && ltype !== "comment-inline") {\n                                level[a - 1] = -20;\n                            } else {\n                                if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && (types[a + 2] === "start" || ltoke === ")" || (token[ei[ei.length - 1]] !== "."))) {\n                                    if (token[ei[ei.length - 1]] !== "." && options.nochainindent === false) {\n                                        propertybreak();\n                                    } else {\n                                        level[a - 1] = indent;\n                                    }\n                                } else if (token[ei[ei.length - 1]] === ".") {\n                                    level[a - 1] = indent;\n                                } else {\n                                    level[a - 1] = -20;\n                                }\n                            }\n                            if (types[a - 1] === "comment" || types[a - 1] === "comment-inline") {\n                                if (ei > 0) {\n                                    level[a - 1] = indent;\n                                } else {\n                                    level[a - 1] = indent + 1;\n                                }\n                            }\n                            return level.push(-20);\n                        }\n                        if (ctoke === ",") {\n                            if (list[list.length - 1] === false && (depth[a] === "object" || depth[a] === "array" || depth[a] === "paren" || depth[a] === "expression" || depth[a] === "method")) {\n                                list[list.length - 1] = true;\n                                if (token[begin[a]] === "(") {\n                                    (function jspretty__beautify_separator_plusfix() {\n                                        var aa = a;\n                                        do {\n                                            aa = aa - 1;\n                                            if (begin[aa] === begin[a] && token[aa] === "+" && level[aa] > -9) {\n                                                level[aa] = level[aa] + 2;\n                                            }\n                                        } while (aa > begin[a]);\n                                    }());\n                                }\n                            }\n                            if (ei.length > 0) {\n                                if (ei[ei.length - 1] > -1) {\n                                    endExtraInd();\n                                }\n                                level[a - 1] = -20;\n                                return level.push(indent);\n                            }\n                            if (token[a - 2] === ":" && token[a - 4] === "where") {\n                                level[a - 1] = -20;\n                                return level.push(-10);\n                            }\n                            level[a - 1]                    = -20;\n                            itemcount[itemcount.length - 1] = itemcount[itemcount.length - 1] + 1;\n                            if ((token[begin[a]] === "(" || token[begin[a]] === "x(") && options.jsx === false && depth[a] !== "global" && (types[a - 1] !== "literal" || token[a - 2] !== "+" || (types[a - 1] === "literal" && token[a - 2] === "+" && types[a - 3] !== "literal"))) {\n                                return level.push(-10);\n                            }\n                            if (ltype === "word" && types[a - 2] === "word" && "var-let-const-from".indexOf(token[a - 2]) < 0 && (types[a - 3] === "end" || token[a - 3] === ";")) {\n                                wordlist[wordlist.length - 1] = true;\n                                return level.push(-10);\n                            }\n                            if (wordlist[wordlist.length - 1] === true || depth[a] === "notation") {\n                                return level.push(-10);\n                            }\n                            if (destruct[destruct.length - 1] === true && itemcount[itemcount.length - 1] > 4 && (depth[a] === "array" || depth[a] === "object")) {\n                                destructfix(true, true);\n                            }\n                            if (depth[a] === "object") {\n                                if (destruct[destruct.length - 1] === true && types[begin[a] - 1] !== "word" && token[begin[a] - 1] !== "(" && token[begin[a] - 1] !== "x(") {\n                                    (function jspretty__beautify_separator_objDestruct() {\n                                        var aa = 0,\n                                            bb = 0;\n                                        for (aa = a - 1; aa > -1; aa = aa - 1) {\n                                            if (types[aa] === "end") {\n                                                bb = bb + 1;\n                                            } else if (types[aa] === "start") {\n                                                bb = bb - 1;\n                                            }\n                                            if (bb < 0 || (bb === 0 && token[aa] === ",")) {\n                                                return;\n                                            }\n                                            if (bb === 0 && token[aa] === ":") {\n                                                return destructfix(true, false);\n                                            }\n                                        }\n                                    }());\n                                }\n                            }\n                            if (types[a - 1] === "word" && token[a - 2] === "for") {\n                                //This is for Volt templates\n                                return level.push(-10);\n                            }\n                            if (destruct[destruct.length - 1] === false || (token[a - 2] === "+" && ltype === "literal" && level[a - 2] > 0 && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'"))) {\n                                if (depth[a] === "method") {\n                                    if (token[a - 2] === "+" && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'") && (token[a - 3].charAt(0) === "\\"" || token[a - 3].charAt(0) === "\'")) {\n                                        return level.push(indent + 2);\n                                    }\n                                    if (token[a - 2] !== "+") {\n                                        return level.push(-10);\n                                    }\n                                }\n                                return level.push(indent);\n                            }\n                            if (list[list.length - 1] === true) {\n                                if (assignlist[assignlist.length - 1] === true && varline[varline.length - 1] === false) {\n                                    assignlist[assignlist.length - 1] = false;\n                                    varlen[varlen.length - 1]         = [];\n                                }\n                                return (function jspretty__beautify_separator_inList() {\n                                    var c = 0,\n                                        d = 0;\n                                    for (c = a - 1; c > -1; c = c - 1) {\n                                        if (types[c] === "end") {\n                                            d = d + 1;\n                                        }\n                                        if (types[c] === "start") {\n                                            d = d - 1;\n                                        }\n                                        if (d === -1) {\n                                            if (token[c] === "[" && token[c + 1] !== "]" && token[c + 2] !== "]") {\n                                                if (destruct[destruct.length - 1] === false || arrbreak[arrbreak.length - 1] === true) {\n                                                    level[c] = indent;\n                                                } else if (methtest === false && destruct[destruct.length - 1] === true) {\n                                                    level[c] = -20;\n                                                }\n                                                if (token[a - 2] === "+" && ltype === "literal" && level[a - 2] > 0 && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'")) {\n                                                    for (d = a - 2; d > c; d = d - 2) {\n                                                        if (token[d] !== "+") {\n                                                            return;\n                                                        }\n                                                        if (token[d - 1].charAt(0) !== "\\"" && token[d - 1].charAt(0) !== "\'") {\n                                                            level[d] = -10;\n                                                        }\n                                                    }\n                                                    return;\n                                                }\n                                            }\n                                            if (arrbreak[arrbreak.length - 1] === true) {\n                                                return level.push(indent);\n                                            }\n                                            return level.push(-10);\n                                        }\n                                    }\n                                    if (arrbreak[arrbreak.length - 1] === true) {\n                                        return level.push(indent);\n                                    }\n                                    return level.push(-10);\n                                }());\n                            }\n                            if (varline[varline.length - 1] === true && token[begin[a] - 1] !== "for") {\n                                if (ltoke !== "]") {\n                                    (function jspretty__beautify_separator_varline() {\n                                        var c     = 0,\n                                            brace = false;\n                                        for (c = a - 1; c > -1; c = c - 1) {\n                                            if (token[c] === "]") {\n                                                brace = true;\n                                            }\n                                            if (types[c] === "start") {\n                                                if (token[c] === "[" && token[c + 1] !== "]" && brace === false) {\n                                                    level[c] = indent;\n                                                }\n                                                return;\n                                            }\n                                        }\n                                    }());\n                                }\n                                if (ltype === "literal" && token[a - 2] === "+" && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'")) {\n                                    return level.push(indent);\n                                }\n                                return level.push(indent);\n                            }\n                            if (destruct[destruct.length - 1] === true && depth[a] !== "object") {\n                                return level.push(-10);\n                            }\n                            return level.push(indent);\n                        }\n                        if (ctoke === ";" || ctoke === "x;") {\n                            endExtraInd();\n                            if (token[begin[a] - 1] !== "for") {\n                                destructfix(false, false);\n                            }\n                            wordlist[wordlist.length - 1] = false;\n                            if (ctoke === "x;") {\n                                scolon = scolon + 1;\n                            }\n                            level[a - 1] = -20;\n                            if (varline[varline.length - 1] === true) {\n                                varline[varline.length - 1] = false;\n                                if (depth[a] !== "method" && varlen.length > 0 && varlen[varlen.length - 1].length > 1) {\n                                    varlist.push(varlen[varlen.length - 1]);\n                                }\n                                varlen[varlen.length - 1] = [];\n                                (function jspretty__beautify_separator_varlinefix() {\n                                    var c = 0,\n                                        d = 0;\n                                    for (c = a - 1; c > -1; c = c - 1) {\n                                        if (types[c] === "start") {\n                                            d = d + 1;\n                                        }\n                                        if (types[c] === "end") {\n                                            d = d - 1;\n                                        }\n                                        if (d > 0) {\n                                            return;\n                                        }\n                                        if (d === 0) {\n                                            if (token[c] === "var" || token[c] === "let" || token[c] === "const") {\n                                                return;\n                                            }\n                                            if (token[c] === ",") {\n                                                indent = indent - 1;\n                                                return;\n                                            }\n                                        }\n                                    }\n                                }());\n                            }\n                            if (begin[a] > 0 && token[begin[a] - 1] === "for" && depth[a] !== "for") {\n                                return level.push(-10);\n                            }\n                            return level.push(indent);\n                        }\n                    },\n                    start         = function jspretty__beautify_start() {\n                        var deep   = depth[a],\n                            deeper = (a === 0)\n                                ? depth[a]\n                                : depth[a - 1];\n                        if (ltoke === ")" || ((deeper === "object" || deeper === "array") && ltoke !== "]")) {\n                            if (deep !== "method" || (deep === "method" && token[a + 1] !== ")" && token[a + 2] !== ")")) {\n                                if (ltoke === ")" && (deep !== "function" || token[begin[begin[a - 1] - 1]] === "(" || token[begin[begin[a - 1] - 1]] === "x(")) {\n                                    destructfix(false, false);\n                                } else if (types[a + 1] !== "end" && types[a + 2] !== "end") {\n                                    destructfix(true, false);\n                                }\n                            }\n                        }\n                        list.push(false);\n                        extraindent.push([]);\n                        assignlist.push(false);\n                        arrbreak.push(false);\n                        wordlist.push(false);\n                        itemcount.push(0);\n                        varlen.push([]);\n                        if (options.neverflatten === true || options.qml === true || deep === "attribute" || ltype === "generic" || (deep === "class" && ltoke !== "(" && ltoke !== "x(") || (ctoke === "[" && token[a + 1] === "function")) {\n                            destruct.push(false);\n                        } else {\n                            if (deep === "expression" || deep === "method") {\n                                destruct.push(true);\n                            } else if ((deep === "object" || deep === "class") && (ltoke === "(" || ltoke === "x(" || ltype === "word")) {\n                                //array or object literal following `return` or `(`\n                                destruct.push(true);\n                            } else if (deep === "array" || ctoke === "(" || ctoke === "x(") {\n                                //array, method, paren\n                                destruct.push(true);\n                            } else if (ctoke === "{" && deep === "object" && ltype !== "operator" && ltype !== "start" && ltype !== "literal" && deeper !== "object" && deeper !== "array" && a > 0) {\n                                //curly brace not in a list and not assigned\n                                destruct.push(true);\n                            } else {\n                                //not destructured (multiline)\n                                destruct.push(false);\n                            }\n                        }\n                        if (ctoke !== "(" && ctoke !== "x(" && depth[a] !== "attribute") {\n                            //if (ctoke !== "[" || (ctoke === "[" && token[a + 1] !== "(")) {\n                                indent = indent + 1;\n                            //}\n                        }\n                        if (ctoke === "{" || ctoke === "x{") {\n                            if (ctoke === "{") {\n                                varline.push(false);\n                            }\n                            if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\n                                if (ltype === "markup") {\n                                    level[a - 1] = indent;\n                                } else if (options.braces === true && ltype !== "operator" && ltoke !== "return") {\n                                    level[a - 1] = indent - 1;\n                                } else if (deep === "function" || ltoke === ")" || ltoke === "x)" || ltoke === "," || ltoke === "}" || ltype === "markup") {\n                                    level[a - 1] = -10;\n                                } else if (ltoke === "{" || ltoke === "x{" || ltoke === "[" || ltoke === "}" || ltoke === "x}") {\n                                    level[a - 1] = indent - 1;\n                                }\n                            }\n                            if (deep === "object") {\n                                if (options.formatObject === "indent") {\n                                    destruct[destruct.length - 1] = false;\n                                    return level.push(indent);\n                                }\n                                if (options.formatObject === "inline") {\n                                    destruct[destruct.length - 1] = true;\n                                    return level.push(-20);\n                                }\n                            }\n                            if (deep === "switch") {\n                                if (options.nocaseindent === true) {\n                                    return level.push(indent - 1);\n                                }\n                                indent = indent + 1;\n                                return level.push(indent);\n                            }\n                            if (destruct[destruct.length - 1] === true) {\n                                if (ltype !== "word") {\n                                    return level.push(-20);\n                                }\n                            }\n                            return level.push(indent);\n                        }\n                        if (ctoke === "(" || ctoke === "x(") {\n                            if (ltoke === "-" && (token[a - 2] === "(" || token[a - 2] === "x(")) {\n                                level[a - 2] = -20;\n                            }\n                            // the start of scope, at least for counting, is pushed back from the opening of\n                            // the block to the paranthesis containing arguments so that the arguments can\n                            // be tagged as variables of the coming scope\n                            if (options.jsscope !== "none" || options.mode === "minify") {\n                                // a 0 is pushed into the start of scope, but this number is updated in the\n                                // "end" function to indicate the index where the scope ends\n                                if (ltoke === "function" || token[a - 2] === "function") {\n                                    meta[meta.length - 1] = 0;\n                                }\n                            }\n                            if (ltype === "end" && deeper !== "if" && deeper !== "for" && deeper !== "catch" && deeper !== "else" && deeper !== "do" && deeper !== "try" && deeper !== "finally" && deeper !== "catch") {\n                                if (types[a - 1] === "comment" || types[a - 1] === "comment-inline") {\n                                    level[a - 1] = indent;\n                                } else {\n                                    level[a - 1] = -20;\n                                }\n                            }\n                            if (ltoke === "async") {\n                                level[a - 1] = -10;\n                            } else if (deep === "method" || (token[a - 2] === "function" && ltype === "word")) {\n                                if (ltoke === "import" || ltoke === "in" || options.functionname === true) {\n                                    level[a - 1] = -10;\n                                } else if ((ltoke === "}" && depth[a - 1] === "function") || ltype === "word") {\n                                    level[a - 1] = -20;\n                                } else if (deeper !== "method" && deep !== "method") {\n                                    level[a - 1] = indent;\n                                }\n                            }\n                            if (ltoke === "+" && (token[a - 2].charAt(0) === "\\"" || token[a - 2].charAt(0) === "\'")) {\n                                return level.push(indent);\n                            }\n                            if (ltoke === "}" || ltoke === "x}") {\n                                return level.push(-20);\n                            }\n                            if ((ltoke === "-" && (a < 2 || (token[a - 2] !== ")" && token[a - 2] !== "x)" && token[a - 2] !== "]" && types[a - 2] !== "word" && types[a - 2] !== "literal"))) || (options.space === false && ltoke === "function")) {\n                                level[a - 1] = -20;\n                            }\n                            return level.push(-20);\n                        }\n                        if (ctoke === "[") {\n                            if (ltoke === "[") {\n                                list[list.length - 2] = true;\n                            }\n                            if (ltoke === "return" || ltoke === "var" || ltoke === "let" || ltoke === "const") {\n                                level[a - 1] = -10;\n                            } else if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline" && depth[a - 1] !== "attribute" && (ltype === "end" || ltype === "word")) {\n                                level[a - 1] = -20;\n                            } else if (ltoke !== "{" && (ltoke === "[" || ltoke === "{" || ltoke === "x{")) {\n                                level[a - 1] = indent - 1;\n                            }\n                            if (depth[a] === "attribute") {\n                                return level.push(-20);\n                            }\n                            if (options.formatArray === "indent") {\n                                destruct[destruct.length - 1] = false;\n                                return level.push(indent);\n                            }\n                            if (options.formatArray === "inline") {\n                                destruct[destruct.length - 1] = true;\n                                return level.push(-20);\n                            }\n                            if (deep === "method" || destruct[destruct.length - 1] === true) {\n                                return level.push(-20);\n                            }\n                            return (function jspretty__beautify_start_squareBrace() {\n                                var c = 0;\n                                for (c = a + 1; c < b; c = c + 1) {\n                                    if (token[c] === "]") {\n                                        return level.push(-20);\n                                    }\n                                    if (token[c] === ",") {\n                                        return level.push(indent);\n                                    }\n                                }\n                                return level.push(-20);\n                            }());\n                        }\n                    },\n                    end           = function jspretty__beautify_end() {\n                        var ei = (extraindent[extraindent.length - 1] === undefined)\n                            ? []\n                            : extraindent[extraindent.length - 1];\n                        if (ctoke === ")" && token[a + 1] === "." && ei[ei.length - 1] > -1 && token[ei[0]] !== ":") {\n                            (function jspretty__beautify_end_brokenParen() {\n                                var c = begin[a],\n                                    d = false,\n                                    e = false;\n                                do {\n                                    c = c - 1;\n                                } while (c > 0 && level[c] < -9);\n                                d = (level[c] === indent);\n                                c = a + 1;\n                                do {\n                                    c = c + 1;\n                                    if (token[c] === "{") {\n                                        e = true;\n                                        break;\n                                    }\n                                    if (begin[c] === begin[a + 1] && (types[c] === "separator" || types[c] === "end")) {\n                                        break;\n                                    }\n                                } while (c < b);\n                                if (d === false && e === true && extraindent.length > 1) {\n                                    extraindent[extraindent.length - 2].push(begin[a]);\n                                    indent = indent + 1;\n                                }\n                            }());\n                        }\n                        if (token[a + 1] === "," && (depth[a] === "object" || depth[a] === "array")) {\n                            destructfix(true, false);\n                        }\n                        if ((token[a + 1] === "}" || token[a + 1] === "]") && (depth[a] === "object" || depth[a] === "array") && token[begin[a] - 1] === ",") {\n                            destructfix(true, false);\n                        }\n                        if (depth[a] !== "attribute") {\n                            if (ctoke !== ")" && ctoke !== "x)" && (ltype !== "markup" || (ltype === "markup" && token[a - 2] !== "return"))) {\n                                indent = indent - 1;\n                            }\n                            if (ctoke === "}" && depth[a] === "switch" && options.nocaseindent === false) {\n                                indent = indent - 1;\n                            }\n                        }\n                        if (ctoke === "}" || ctoke === "x}") {\n                            if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline" && ltoke !== "{" && ltoke !== "x{" && ltype !== "end" && ltype !== "literal" && ltype !== "separator" && ltoke !== "++" && ltoke !== "--" && varline[varline.length - 1] === false && (a < 2 || token[a - 2] !== ";" || token[a - 2] !== "x;" || ltoke === "break" || ltoke === "return")) {\n                                (function jspretty__beautify_end_curlyBrace() {\n                                    var c       = 0,\n                                        d       = 1,\n                                        assign  = false,\n                                        listlen = list.length;\n                                    for (c = a - 1; c > -1; c = c - 1) {\n                                        if (types[c] === "end") {\n                                            d = d + 1;\n                                        }\n                                        if (types[c] === "start") {\n                                            d = d - 1;\n                                        }\n                                        if (d === 1) {\n                                            if (token[c] === "=" || token[c] === ";" || token[c] === "x;") {\n                                                assign = true;\n                                            }\n                                            if (c > 0 && token[c] === "return" && (token[c - 1] === ")" || token[c - 1] === "x)" || token[c - 1] === "{" || token[c - 1] === "x{" || token[c - 1] === "}" || token[c - 1] === "x}" || token[c - 1] === ";" || token[c - 1] === "x;")) {\n                                                indent       = indent - 1;\n                                                level[a - 1] = indent;\n                                                return;\n                                            }\n                                            if ((token[c] === ":" && ternary.length === 0) || (token[c] === "," && assign === false && varline[varline.length - 1] === false)) {\n                                                return;\n                                            }\n                                            if ((c === 0 || token[c - 1] === "{" || token[c - 1] === "x{") || token[c] === "for" || token[c] === "if" || token[c] === "do" || token[c] === "function" || token[c] === "while" || token[c] === "var" || token[c] === "let" || token[c] === "const" || token[c] === "with") {\n                                                if (list[listlen - 1] === false && listlen > 1 && (a === b - 1 || (token[a + 1] !== ")" && token[a + 1] !== "x)")) && depth[a] !== "object") {\n                                                    indent = indent - 1;\n                                                }\n                                                if (varline[varline.length - 1] === true) {\n                                                    indent = indent - 1;\n                                                }\n                                                return;\n                                            }\n                                        }\n                                    }\n                                }());\n                            }\n                            //this is the bulk of logic identifying scope start and end\n                            if (depth[a] === "function" && (options.jsscope !== "none" || options.mode === "minify")) {\n                                (function jspretty__beautify_end_jsscope() {\n                                    var c     = 0,\n                                        d     = 1,\n                                        build = [],\n                                        paren = false;\n                                    for (c = a - 1; c > -1; c = c - 1) {\n                                        if (types[c] === "end") {\n                                            d = d + 1;\n                                        } else if (types[c] === "start") {\n                                            d = d - 1;\n                                        }\n                                        if (d < 0) {\n                                            return;\n                                        }\n                                        if (meta[c] === "v" && token[c] !== build[build.length - 1]) {\n                                            build.push(token[c]);\n                                        } else if (d === 1 && token[c] === ")") {\n                                            paren = true;\n                                        } else if (d === 1 && paren === true && types[c] === "word" && token[c] !== build[build.length - 1]) {\n                                            build.push(token[c]);\n                                        }\n                                        if (c === lettest) {\n                                            meta[c] = a - 1;\n                                            if (token[c] === "let" || token[c] === "const") {\n                                                meta[meta.length - 2] = [build, true];\n                                            }\n                                            build   = [];\n                                            lettest = -1;\n                                        }\n                                        if (c > 0 && token[c - 1] === "function" && types[c] === "word" && token[c] !== build[build.length - 1]) {\n                                            build.push(token[c]);\n                                        }\n                                        if (d === 0) {\n                                            if (token[c] === "function") {\n                                                if (types[c + 1] === "word") {\n                                                    meta[c + 2] = a;\n                                                } else {\n                                                    meta[c + 1] = a;\n                                                }\n                                                meta[meta.length - 1] = [build, false];\n                                                return;\n                                            }\n                                        }\n                                    }\n                                }());\n                            }\n                        }\n                        if (options.bracepadding === false && ctoke !== "}" && ltype !== "markup") {\n                            level[a - 1] = -20;\n                        }\n                        if (options.bracepadding === true && ltype !== "start" && ltoke !== ";" && (level[begin[a]] < -9 || destruct[destruct.length - 1] === true)) {\n                            level[begin[a]] = -10;\n                            level[a - 1]    = -10;\n                            level.push(-20);\n                        } else if (options.qml === true) {\n                            if (ltype === "start" || ctoke === ")" || ctoke === "x)") {\n                                level[a - 1] = -20;\n                            } else {\n                                level[a - 1] = indent;\n                            }\n                            level.push(indent);\n                        } else if (depth[a] === "attribute") {\n                            level[a - 1] = -20;\n                            level.push(indent);\n                        } else if (depth[a] === "array" && (ei.length > 0 || arrbreak[arrbreak.length - 1] === true)) {\n                            endExtraInd();\n                            destruct[destruct.length - 1] = false;\n                            level[begin[a]]               = indent + 1;\n                            level[a - 1]                  = indent;\n                            level.push(-20);\n                        } else if ((depth[a] === "object" || (begin[a] === 0 && ctoke === "}")) && ei.length > 0) {\n                            endExtraInd();\n                            destruct[destruct.length - 1] = false;\n                            level[begin[a]]               = indent + 1;\n                            level[a - 1]                  = indent;\n                            level.push(-20);\n                        } else if (ctoke === ")" || ctoke === "x)") {\n                            if (options.wrap > 0 && ctoke === ")") {\n                                (function jspretty__beautify_end_parenWrap() {\n                                    var len   = 0,\n                                        aa    = 0,\n                                        short = 0,\n                                        first = 0,\n                                        inc   = 0,\n                                        comma = false,\n                                        array = false,\n                                        wrap  = options.wrap,\n                                        open  = begin[a],\n                                        ind   = (indent + 1),\n                                        exl   = ei.length,\n                                        ready = false,\n                                        mark  = false,\n                                        tern  = false;\n                                    if (level[open] < -9) {\n                                        aa = open;\n                                        do {\n                                            aa = aa + 1;\n                                        } while (aa < a && level[aa] < -9);\n                                        first = aa;\n                                        do {\n                                            len = len + token[aa].length;\n                                            if (level[aa] === -10) {\n                                                len = len + 1;\n                                            }\n                                            if (token[aa] === "(" && short > 0 && short < wrap - 1 && first === a) {\n                                                short = -1;\n                                            }\n                                            if (token[aa] === ")") {\n                                                inc = inc - 1;\n                                            } else if (token[aa] === "(") {\n                                                inc = inc + 1;\n                                            }\n                                            if (aa === open && inc > 0) {\n                                                short = len;\n                                            }\n                                            aa = aa - 1;\n                                        } while (aa > 0 && level[aa] < -9);\n                                        if (token[aa + 1] === ".") {\n                                            ind = level[aa] + 1;\n                                        }\n                                        if (len > wrap - 1 && ltoke !== "(" && short !== -1 && destruct[destruct.length - 2] === false) {\n                                            if ((token[open - 1] === "if" && list[list.length - 1] === true) || token[open - 1] !== "if") {\n                                                level[open] = ind;\n                                                if (token[open - 1] === "for") {\n                                                    aa = open;\n                                                    do {\n                                                        aa = aa + 1;\n                                                        if (token[aa] === ";" && begin[aa] === open) {\n                                                            level[aa] = ind;\n                                                        }\n                                                    } while (aa < a);\n                                                }\n                                            }\n                                        }\n                                    }\n                                    aa  = a;\n                                    len = 0;\n                                    do {\n                                        aa = aa - 1;\n                                        if (depth[aa] === "function") {\n                                            aa = begin[aa];\n                                        } else if (begin[aa] === open) {\n                                            if (token[aa] === "?") {\n                                                tern = true;\n                                            } else if (token[aa] === "," && comma === false) {\n                                                comma = true;\n                                                if (len >= wrap) {\n                                                    ready = true;\n                                                }\n                                            } else if (types[aa] === "markup" && mark === false) {\n                                                mark = true;\n                                            }\n                                            if (level[aa] > -9 && token[aa] !== "," && types[aa] !== "markup") {\n                                                len = 0;\n                                            } else {\n                                                if (level[aa] === -10) {\n                                                    len = len + 1;\n                                                }\n                                                len = len + token[aa].length;\n                                                if (len >= wrap && (comma === true || mark === true)) {\n                                                    ready = true;\n                                                }\n                                            }\n                                        } else {\n                                            if (level[aa] > -9) {\n                                                len = 0;\n                                            } else {\n                                                len = len + token[aa].length;\n                                                if (len >= wrap && (comma === true || mark === true)) {\n                                                    ready = true;\n                                                }\n                                            }\n                                        }\n                                    } while (aa > open && ready === false);\n                                    if (((comma === true || mark === true) && len >= wrap) || level[open] > -9) {\n                                        if (tern === true) {\n                                            ind = level[open];\n                                            if (token[open - 1] === "[") {\n                                                aa = a;\n                                                do {\n                                                    aa = aa + 1;\n                                                    if (types[aa] === "end" || token[aa] === "," || token[aa] === ";") {\n                                                        break;\n                                                    }\n                                                } while (aa < b);\n                                                if (token[aa] === "]") {\n                                                    ind = ind - 1;\n                                                    array = true;\n                                                }\n                                            }\n                                        } else if (exl > 0 && ei[exl - 1] > aa) {\n                                            ind = ind - exl;\n                                        }\n                                        destruct[destruct.length - 1] = false;\n                                        aa = a;\n                                        do {\n                                            aa = aa - 1;\n                                            if (begin[aa] === open) {\n                                                if (token[aa].indexOf("=") > -1 && types[aa] === "operator" && token[aa].indexOf("!") < 0 && token[aa].indexOf("==") < 0 && token[aa] !== "<=" && token[aa].indexOf(">") < 0) {\n                                                    len = aa;\n                                                    do {\n                                                        len = len - 1;\n                                                        if (begin[len] === open && (token[len] === ";" || token[len] === "," || len === open)) {\n                                                            break;\n                                                        }\n                                                    } while (len > open);\n                                                    if (token[len] !== ";" && varlen.length > 0) {\n                                                        varlen[varlen.length - 1].push(aa - 1);\n                                                    }\n                                                } else if (token[aa] === ",") {\n                                                    level[aa] = ind;\n                                                } else if (level[aa] > -9 && array === false && (token[open - 1] !== "for" || token[aa + 1] === "?" || token[aa + 1] === ":") && (token[begin[a]] !== "(" || token[aa] !== "+")) {\n                                                    level[aa] = level[aa] + 1;\n                                                }\n                                            } else if (level[aa] > -9 && array === false) {\n                                                level[aa] = level[aa] + 1;\n                                            }\n                                        } while (aa > open);\n                                        level[open]  = ind;\n                                        level[a - 1] = ind - 1;\n                                    } else {\n                                        level[a - 1] = -20;\n                                    }\n                                }());\n                                if (token[begin[a] - 1] === "+" && level[begin[a]] > -9) {\n                                    level[begin[a] - 1] = -10;\n                                }\n                            } else {\n                                level[a - 1] = -20;\n                            }\n                            level.push(-20);\n                        } else if (destruct[destruct.length - 1] === true) {\n                            if (ctoke === "]" && begin[a] - 1 > 0 && token[begin[begin[a] - 1]] === "[") {\n                                destruct[destruct.length - 2] = false;\n                            }\n                            if (begin[a] < level.length) {\n                                level[begin[a]] = -20;\n                            }\n                            level[a - 1] = -20;\n                            level.push(-20);\n                        } else if ((types[a - 1] === "comment" && token[a - 1].substr(0, 2) === "//") || types[a - 1] === "comment-inline") {\n                            if (token[a - 2] === "x}") {\n                                level[a - 3] = indent + 1;\n                            }\n                            level[a - 1] = indent;\n                            level.push(-20);\n                        } else if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline" && ((ltoke === "{" && ctoke === "}") || (ltoke === "[" && ctoke === "]"))) {\n                            level[a - 1] = -20;\n                            if (ctoke === "}" && options.titanium === true) {\n                                level.push(indent);\n                            } else {\n                                level.push(-20);\n                            }\n                        } else if (ctoke === "]") {\n                            if ((list[list.length - 1] === true && destruct[destruct.length - 1] === false) || (ltoke === "]" && level[a - 2] === indent + 1)) {\n                                level[a - 1]    = indent;\n                                level[begin[a]] = indent + 1;\n                            } else if (level[a - 1] === -10) {\n                                level[a - 1] = -20;\n                            }\n                            if (token[begin[a] + 1] === "function") {\n                                level[a - 1] = indent;\n                            } else if (list[list.length - 1] === false) {\n                                if (ltoke === "}" || ltoke === "x}") {\n                                    level[a - 1] = indent;\n                                }\n                                (function jspretty__beautify_end_squareBrace() {\n                                    var c = 0,\n                                        d = 1;\n                                    for (c = a - 1; c > -1; c = c - 1) {\n                                        if (token[c] === "]") {\n                                            d = d + 1;\n                                        }\n                                        if (token[c] === "[") {\n                                            d = d - 1;\n                                            if (d === 0) {\n                                                if (c > 0 && (token[c + 1] === "{" || token[c + 1] === "x{" || token[c + 1] === "[")) {\n                                                    level[c] = indent + 1;\n                                                    return;\n                                                }\n                                                if (token[c + 1] !== "[" || lastlist === false) {\n                                                    level[c] = -20;\n                                                    return;\n                                                }\n                                                return;\n                                            }\n                                        }\n                                        if (d === 1 && token[c] === "+" && level[c] > 1) {\n                                            level[c] = level[c] - 1;\n                                        }\n                                    }\n                                }());\n                            }\n                            level.push(-20);\n                        } else if (ctoke === "}" || ctoke === "x}" || list[list.length - 1] === true) {\n                            if (ctoke === "}" && ltoke === "x}" && token[a + 1] === "else") {\n                                level[a - 2] = indent + 2;\n                                level.push(-20);\n                            } else {\n                                level.push(indent);\n                            }\n                            level[a - 1] = indent;\n                        } else {\n                            level.push(-20);\n                        }\n                        endExtraInd();\n                        lastlist = list[list.length - 1];\n                        list.pop();\n                        extraindent.pop();\n                        arrbreak.pop();\n                        itemcount.pop();\n                        if (ctoke === "}" || (ctoke === ")" && level[a - 1] > -9)) {\n                            if (varline[varline.length - 1] === true || ltoke !== "{" || token[begin[a] - 2] === "interface") {\n                                if (varlen.length > 0 && varlen[varlen.length - 1].length > 1 && destruct[destruct.length - 1] === false) {\n                                    varlist.push(varlen[varlen.length - 1]);\n                                }\n                            }\n                            if (ctoke === "}") {\n                                varline.pop();\n                            }\n                        }\n                        wordlist.pop();\n                        varlen.pop();\n                        destruct.pop();\n                        assignlist.pop();\n                    },\n                    operator      = function jspretty__beautify_operator() {\n                        var ei = (extraindent[extraindent.length - 1] === undefined)\n                            ? []\n                            : extraindent[extraindent.length - 1];\n                        if (ei.length > 0 && ei[ei.length - 1] > -1 && depth[a] === "array") {\n                            arrbreak[arrbreak.length - 1] = true;\n                        }\n                        if (ctoke !== ":") {\n                            if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && destruct.length > 0) {\n                                destructfix(true, false);\n                            }\n                            if (ctoke !== "?" && token[ei[ei.length - 1]] === ".") {\n                                (function jspretty__beautify_operator_question() {\n                                    var c = a,\n                                        d = begin[c],\n                                        e = 0;\n                                    do {\n                                        if (begin[c] === d) {\n                                            if (token[c + 1] === "{" || token[c + 1] === "[" || token[c] === "function") {\n                                                return;\n                                            }\n                                            if (token[c] === "," || token[c] === ";" || types[c] === "end" || token[c] === ":") {\n                                                ei.pop();\n                                                indent = indent - 1;\n                                                return;\n                                            }\n                                            if (token[c] === "?" || token[c] === ":") {\n                                                if (token[ei[ei.length - 1]] === "." && e < 2) {\n                                                    ei[ei.length - 1] = d + 1;\n                                                }\n                                                return;\n                                            }\n                                            if (token[c] === ".") {\n                                                e = e + 1;\n                                            }\n                                        }\n                                        c = c + 1;\n                                    } while (c < b);\n                                }());\n                            }\n                        }\n                        if (ctoke === "!" || ctoke === "...") {\n                            if (ltoke === "}" || ltoke === "x}") {\n                                level[a - 1] = indent;\n                            }\n                            return level.push(-20);\n                        }\n                        if (ltoke === ";" || ltoke === "x;") {\n                            if (token[begin[a] - 1] !== "for") {\n                                level[a - 1] = indent;\n                            }\n                            return level.push(-20);\n                        }\n                        if (ctoke === "*") {\n                            if (ltoke === "function" || ltoke === "yield") {\n                                level[a - 1] = -20;\n                            } else {\n                                level[a - 1] = -10;\n                            }\n                            return level.push(-10);\n                        }\n                        if (ctoke === "?") {\n                            if (lines[a] === 0 && types[a - 2] === "word" && token[a - 2] !== "return" && token[a - 2] !== "in" && token[a - 2] !== "instanceof" && token[a - 2] !== "typeof" && ltype === "word") {\n                                if (types[a + 1] === "word" || ((token[a + 1] === "(" || token[a + 1] === "x(") && token[a - 2] === "new")) {\n                                    level[a - 1] = -20;\n                                    if (types[a + 1] === "word") {\n                                        return level.push(-10);\n                                    }\n                                    return level.push(-20);\n                                }\n                            }\n                            if (token[a + 1] === ":") {\n                                level[a - 1] = -20;\n                                return level.push(-20);\n                            }\n                            if (options.ternaryline === true) {\n                                level[a - 1] = -10;\n                            } else {\n                                (function jspretty__beautify_operator_ternObj() {\n                                    var c = a - 1;\n                                    do {\n                                        c = c - 1;\n                                    } while (c > -1 && level[c] < -9);\n                                    ei.push(a);\n                                    ternary.push(a);\n                                    indent = indent + 1;\n                                    if (level[c] === indent && token[c + 1] !== ":") {\n                                        indent = indent + 1;\n                                        ei.push(a);\n                                    }\n                                    level[a - 1] = indent;\n                                    if (token[begin[a]] === "(" && (ei.length < 2 || ei[0] === ei[1])) {\n                                        destruct[destruct.length - 1] = false;\n                                        if (a - 2 === begin[a]) {\n                                            level[begin[a]] = indent - 1;\n                                        } else {\n                                            level[begin[a]] = indent;\n                                        }\n                                        c = a - 2;\n                                        do {\n                                            if (types[c] === "end" && level[c - 1] > -1) {\n                                                break;\n                                            }\n                                            if (level[c] > -1) {\n                                                level[c] = level[c] + 1;\n                                            }\n                                            c = c - 1;\n                                        } while (c > begin[a]);\n                                    }\n                                }());\n                            }\n                        }\n                        if (ctoke === ":") {\n                            if (token[a - 2] === "where" && depth[a - 2] === depth[a]) {\n                                level[a - 1] = -10;\n                                return level.push(-10);\n                            }\n                            if ((token[a - 2] === "var" || token[a - 2] === "let" || token[a - 2] === "const" || token[a - 2] === "," || (depth[a] === "global" && options.jsx === true && ternary.length < 1)) && ltype === "word" && token[begin[a]] !== "(" && token[begin[a]] !== "x(") {\n                                level[a - 1] = -20;\n                                if (depth[a] === "object" || (varline[varline.length - 1] === true && token[begin[a]] !== "(" && token[begin[a]] !== "x(")) {\n                                    if (varlen.length > 0 && varlen[varlen.length - 1].length > 0 && token[varlen[varlen.length - 1][varlen[varlen.length - 1].length - 1] + 1] !== ctoke) {\n                                        if (varlen[varlen.length - 1].length > 1) {\n                                            varlist.push(varlen[varlen.length - 1]);\n                                        }\n                                        varlen[varlen.length - 1] = [];\n                                    }\n                                    varlen[varlen.length - 1].push(a - 1);\n                                }\n                                return level.push(-10);\n                            }\n                            if ((ltoke === ")" || ltoke === "x)") && token[begin[a - 1] - 2] === "function") {\n                                level[a - 1] = -20;\n                                return level.push(-10);\n                            }\n                            if (depth[a] === "attribute") {\n                                level[a - 1] = -20;\n                                return level.push(-10);\n                            }\n                            if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && (ltype === "word" || ltoke === ")" || ltoke === "]" || ltoke === "?") && (depth[a] === "map" || depth[a] === "class" || types[a + 1] === "word") && (ternary.length === 0 || ternary[ternary.length - 1] < begin[a]) && ("mapclassexpressionmethodglobalparen".indexOf(depth[a]) > -1 || (types[a - 2] === "word" && depth[a] !== "switch"))) {\n                                level[a - 1] = -20;\n                                varlen[varlen.length - 1].push(a - 1);\n                                return level.push(-10);\n                            }\n                            if (depth[a] === "switch" && (ternary.length < 1 || ternary[ternary.length - 1] < begin[a])) {\n                                level[a - 1] = -20;\n                                return level.push(indent);\n                            }\n                            if (ternary.length > 0 && ternary[ternary.length - 1] > begin[a]) {\n                                (function jspretty_beautify_operator_colon() {\n                                    var c = a,\n                                        d = begin[a];\n                                    do {\n                                        c = c - 1;\n                                        if (begin[c] === d) {\n                                            if (token[c] === "," || token[c] === ";") {\n                                                level[a - 1] = -20;\n                                                return;\n                                            }\n                                            if (token[c] === "?") {\n                                                ternary.pop();\n                                                return endExtraInd();\n                                            }\n                                        }\n                                    } while (c > d);\n                                }());\n                            } else if (depth[a] === "object") {\n                                level[a - 1] = -20;\n                                varlen[varlen.length - 1].push(a - 1);\n                            } else if (ternary.length > 0) {\n                                level[a - 1] = indent;\n                            } else {\n                                level[a - 1] = -10;\n                            }\n                            return level.push(-10);\n                        }\n                        if (ctoke === "++" || ctoke === "--") {\n                            if (ltype === "literal" || ltype === "word") {\n                                level[a - 1] = -20;\n                                level.push(-10);\n                            } else if (a < b - 1 && (types[a + 1] === "literal" || types[a + 1] === "word")) {\n                                level.push(-20);\n                            } else {\n                                level.push(-10);\n                            }\n                            return;\n                        }\n                        if (ctoke === "+") {\n                            if (ltype === "start") {\n                                level[a - 1] = -20;\n                            } else {\n                                level[a - 1] = -10;\n                            }\n                            if (options.wrap < 1 || token[begin[a]] === "x(") {\n                                return level.push(-10);\n                            }\n                            return (function jspretty__beautify_operator_plus() {\n                                var line = 0,\n                                    next = 0,\n                                    c    = a,\n                                    ind  = indent + 2,\n                                    aa   = token[a + 1],\n                                    meth = 0;\n                                if (aa === undefined) {\n                                    return level.push(-10);\n                                }\n                                if (types[a - 1] === "operator" || types[a - 1] === "start") {\n                                    if (types[a + 1] === "word" || aa === "(" || aa === "[") {\n                                        return level.push(-20);\n                                    }\n                                    if (isNaN(aa.slice(1, -1)) === false && ((/\\d/).test(aa.charAt(1)) === true || aa.charAt(1) === "." || aa.charAt(1) === "-" || aa.charAt(1) === "+")) {\n                                        return level.push(-20);\n                                    }\n                                }\n                                do {\n                                    c = c - 1;\n                                    if (token[begin[a]] === "(") {\n                                        if (c === begin[a]) {\n                                            meth = line;\n                                        }\n                                        if (token[c] === "," && begin[c] === begin[a] && list[list.length - 1] === true) {\n                                            break;\n                                        }\n                                    }\n                                    if (line > options.wrap - 1) {\n                                        break;\n                                    }\n                                    if (level[c] > -9) {\n                                        break;\n                                    }\n                                    if (types[c] === "operator" && token[c] !== "=" && token[c] !== "+" && begin[c] === begin[a]) {\n                                        break;\n                                    }\n                                    line = line + token[c].length;\n                                    if (c === begin[a] && token[c] === "[" && line < options.wrap - 1) {\n                                        break;\n                                    }\n                                    if (token[c] === "." && level[c] > -9) {\n                                        break;\n                                    }\n                                    if (level[c] === -10) {\n                                        line = line + 1;\n                                    }\n                                } while (c > 0);\n                                if (meth > 0) {\n                                    meth = meth + aa.length;\n                                }\n                                line = line + aa.length;\n                                next = c;\n                                if (line > options.wrap - 1 && level[c] < -9) {\n                                    do {\n                                        next = next - 1;\n                                    } while (next > 0 && level[next] < -9);\n                                }\n                                if (token[next + 1] === "." && begin[a] <= begin[next]) {\n                                    ind = ind + 1;\n                                } else if (token[next] === "+") {\n                                    ind = level[next];\n                                }\n                                next = aa.length;\n                                if (line + next < options.wrap) {\n                                    level.push(-10);\n                                } else {\n                                    if (token[begin[a]] === "(" && (token[ei[0]] === ":" || token[ei[0]] === "?")) {\n                                        ind = indent + 3;\n                                    } else if (depth[a] === "method") {\n                                        level[begin[a]] = indent;\n                                        if (list[list.length - 1] === true) {\n                                            ind = indent + 3;\n                                        } else {\n                                            ind = indent + 1;\n                                        }\n                                    } else if (depth[a] === "object" || depth[a] === "array") {\n                                        destructfix(true, false);\n                                    }\n                                    if (token[c] === "var" || token[c] === "let" || token[c] === "const") {\n                                        line = line - (options.insize * options.inchar.length * 2);\n                                    }\n                                    if (meth > 0) {\n                                        c = options.wrap - meth;\n                                    } else {\n                                        c = options.wrap - line;\n                                    }\n                                    if (c > 0 && c < 5) {\n                                        level.push(ind);\n                                        if (token[a].charAt(0) === "\\"" || token[a].charAt(0) === "\'") {\n                                            a = a + 1;\n                                            if (token[a].length > options.wrap) {\n                                                strwrap(0);\n                                            } else {\n                                                level.push(-10);\n                                            }\n                                        }\n                                    } else if (token[begin[a]] !== "(" || meth > options.wrap - 1 || meth === 0) {\n                                        if (meth > 0) {\n                                            line = meth;\n                                        }\n                                        if (line - aa.length < options.wrap - 1 && (aa.charAt(0) === "\\"" || aa.charAt(0) === "\'")) {\n                                            a = a + 1;\n                                            if (line - aa.length > options.wrap - 4) {\n                                                level.push(ind);\n                                            } else {\n                                                level.push(-10);\n                                            }\n                                            if (varline[varline.length - 1] === true && token[c] === "=") {\n                                                line = line + (options.inchar.length * options.insize) - 1;\n                                            } else {\n                                                line = line + 3;\n                                            }\n                                            strwrap(options.wrap - (line - aa.length));\n                                        } else {\n                                            level.push(ind);\n                                        }\n                                    } else {\n                                        level.push(-10);\n                                    }\n                                }\n                            }());\n                        }\n                        if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\n                            if (ltoke === "(") {\n                                level[a - 1] = -20;\n                            } else if (ctoke === "*" && depth[a] === "object" && types[a + 1] === "word" && (ltoke === "{" || ltoke === ",")) {\n                                level[a - 1] = indent;\n                            } else if (ctoke !== "?" || ternary.length === 0) {\n                                level[a - 1] = -10;\n                            }\n                        }\n                        if (ctoke.indexOf("=") > -1 && ctoke !== "==" && ctoke !== "===" && ctoke !== "!=" && ctoke !== "!==" && ctoke !== ">=" && ctoke !== "<=" && ctoke !== "=>" && depth[a] !== "method" && depth[a] !== "object") {\n                            if (assignlist[assignlist.length - 1] === true && token[begin[a] - 1] !== "for") {\n                                (function jspretty__beautify_operator_assignTest() {\n                                    var c = 0,\n                                        d = "",\n                                        e = begin[a];\n                                    if (depth[a] === "class") {\n                                        varlen[varlen.length - 1].push(a - 1);\n                                    } else {\n                                        for (c = a - 1; c > e; c = c - 1) {\n                                            d = token[c];\n                                            if (d === ";" || d === "x;" || d === "," || d === "?" || d === ":" || c === e + 1) {\n                                                return varlen[varlen.length - 1].push(a - 1);\n                                            }\n                                            if (d.indexOf("=") > -1 && d !== "==" && d !== "===" && d !== "!=" && d !== "!==" && d !== ">=" && d !== "<=") {\n                                                return;\n                                            }\n                                        }\n                                    }\n                                }());\n                            }\n                            (function jspretty__beautify_operator_assignSpaces() {\n                                var c = 0,\n                                    d = 0,\n                                    e = false,\n                                    f = "";\n                                if ((token[begin[a]] === "(" || token[begin[a]] === "x(") && token[a + 1] !== "function") {\n                                    return;\n                                }\n                                for (c = a + 1; c < b; c = c + 1) {\n                                    if (types[c] === "start") {\n                                        if (e === true && token[c] !== "[") {\n                                            if (assignlist[assignlist.length - 1] === true) {\n                                                assignlist[assignlist.length - 1] = false;\n                                                if (varlen[varlen.length - 1].length > 1) {\n                                                    varlist.push(varlen[varlen.length - 1]);\n                                                }\n                                                varlen[varlen.length - 1] = [];\n                                            }\n                                            break;\n                                        }\n                                        d = d + 1;\n                                    }\n                                    if (types[c] === "end") {\n                                        d = d - 1;\n                                    }\n                                    if (d < 0) {\n                                        if (assignlist[assignlist.length - 1] === true) {\n                                            assignlist[assignlist.length - 1] = false;\n                                            if (varlen[varlen.length - 1].length > 1) {\n                                                varlist.push(varlen[varlen.length - 1]);\n                                            }\n                                            varlen[varlen.length - 1] = [];\n                                        }\n                                        break;\n                                    }\n                                    if (d === 0) {\n                                        f = token[c];\n                                        if (e === true) {\n                                            if (types[c] === "operator" || token[c] === ";" || token[c] === "x;" || token[c] === "?" || token[c] === "var" || token[c] === "let" || token[c] === "const") {\n                                                if (f !== undefined && (f === "?" || (f.indexOf("=") > -1 && f !== "==" && f !== "===" && f !== "!=" && f !== "!==" && f !== ">=" && f !== "<="))) {\n                                                    if (assignlist[assignlist.length - 1] === false && (varlen[varlen.length - 1].length === 0 || token[varlen[varlen.length - 1][varlen[varlen.length - 1].length - 1] + 1] === ctoke)) {\n                                                        varlen[varlen.length - 1].push(a - 1);\n                                                        assignlist[assignlist.length - 1] = true;\n                                                    }\n                                                }\n                                                if ((f === ";" || f === "x;" || f === "var" || f === "let" || f === "const") && assignlist[assignlist.length - 1] === true) {\n                                                    assignlist[assignlist.length - 1] = false;\n                                                    if (varlen[varlen.length - 1].length > 1) {\n                                                        varlist.push(varlen[varlen.length - 1]);\n                                                    }\n                                                    varlen[varlen.length - 1] = [];\n                                                }\n                                                break;\n                                            }\n                                            if (assignlist[assignlist.length - 1] === true && (f === "return" || f === "break" || f === "continue" || f === "throw")) {\n                                                assignlist[assignlist.length - 1] = false;\n                                                if (varlen[varlen.length - 1].length > 1) {\n                                                    varlist.push(varlen[varlen.length - 1]);\n                                                }\n                                                varlen[varlen.length - 1] = [];\n                                            }\n                                        }\n                                        if (f === ";" || f === "x;" || f === ",") {\n                                            e = true;\n                                        }\n                                    }\n                                }\n                            }());\n                        }\n                        if ((ctoke === "-" && ltoke === "return") || ltoke === "=") {\n                            return level.push(-20);\n                        }\n                        if (ltype === "operator" && types[a + 1] === "word" && ltoke !== "--" && ltoke !== "++" && ctoke !== "&&" && ctoke !== "||") {\n                            return level.push(-20);\n                        }\n                        level.push(-10);\n                    },\n                    word          = function jspretty__beautify_word() {\n                        var next    = token[a + 1],\n                            compare = (\n                                next !== undefined && next !== "==" && next !== "===" && next !== "!=" && next !== "!==" && next === ">=" && next !== "<=" && next.indexOf("=") > -1\n                            );\n                        if (varline[varline.length - 1] === true && (ltoke === "," || ltoke === "var" || ltoke === "let" || ltoke === "const")) {\n                            if (token[begin[a] - 1] !== "for" && depth[a] !== "method" && token[begin[a]] !== "(" && token[begin[a]] !== "x(") {\n                                if (types[a + 1] === "operator" && compare === true && token[varlen[varlen.length - 1][varlen[varlen.length - 1].length - 1] + 1] !== ":") {\n                                    varlen[varlen.length - 1].push(a);\n                                }\n                            }\n                            if (options.jsscope !== "none" || options.mode === "minify") {\n                                meta[meta.length - 1] = "v";\n                            }\n                        } else if ((options.jsscope !== "none" || options.mode === "minify") && ltoke === "function") {\n                            meta[meta.length - 1] = "v";\n                        }\n                        if ((ltoke === ")" || ltoke === "x)") && depth[a] === "class" && (token[begin[a - 1] - 1] === "static" || token[begin[a - 1] - 1] === "final" || token[begin[a - 1] - 1] === "void")) {\n                            level[a - 1]            = -10;\n                            level[begin[a - 1] - 1] = -10;\n                        }\n                        if (ltoke === "]") {\n                            level[a - 1] = -10;\n                        }\n                        if (ltoke === "}" || ltoke === "x}") {\n                            level[a - 1] = indent;\n                        }\n                        if (ctoke === "else" && ltoke === "}" && token[a - 2] === "x}") {\n                            level[a - 3] = level[a - 3] - 1;\n                        }\n                        if (varline.length === 1 && varline[0] === true && (ltoke === "var" || ltoke === "let" || ltoke === "const" || ltoke === "," || (ltoke === "function" && depth[a + 1] === "method"))) {\n                            globals.push(ctoke);\n                        }\n                        if ((ctoke === "let" || ctoke === "const") && lettest < 0) {\n                            lettest = a;\n                        }\n                        if (ctoke === "new") {\n                            (function jspretty__beautify_word_new() {\n                                var c       = 0,\n                                    nextish = (typeof next === "string")\n                                        ? next\n                                        : "",\n                                    apiword = (nextish === "")\n                                        ? []\n                                        : [\n                                            "ActiveXObject",\n                                            "ArrayBuffer",\n                                            "AudioContext",\n                                            "Canvas",\n                                            "CustomAnimation",\n                                            "DOMParser",\n                                            "DataView",\n                                            "Date",\n                                            "Error",\n                                            "EvalError",\n                                            "FadeAnimation",\n                                            "FileReader",\n                                            "Flash",\n                                            "Float32Array",\n                                            "Float64Array",\n                                            "FormField",\n                                            "Frame",\n                                            "Generator",\n                                            "HotKey",\n                                            "Image",\n                                            "Iterator",\n                                            "Intl",\n                                            "Int16Array",\n                                            "Int32Array",\n                                            "Int8Array",\n                                            "InternalError",\n                                            "Loader",\n                                            "Map",\n                                            "MenuItem",\n                                            "MoveAnimation",\n                                            "Notification",\n                                            "ParallelArray",\n                                            "Point",\n                                            "Promise",\n                                            "Proxy",\n                                            "RangeError",\n                                            "Rectangle",\n                                            "ReferenceError",\n                                            "Reflect",\n                                            "RegExp",\n                                            "ResizeAnimation",\n                                            "RotateAnimation",\n                                            "Set",\n                                            "SQLite",\n                                            "ScrollBar",\n                                            "Set",\n                                            "Shadow",\n                                            "StopIteration",\n                                            "Symbol",\n                                            "SyntaxError",\n                                            "Text",\n                                            "TextArea",\n                                            "Timer",\n                                            "TypeError",\n                                            "URL",\n                                            "Uint16Array",\n                                            "Uint32Array",\n                                            "Uint8Array",\n                                            "Uint8ClampedArray",\n                                            "URIError",\n                                            "WeakMap",\n                                            "WeakSet",\n                                            "Web",\n                                            "Window",\n                                            "XMLHttpRequest"\n                                        ],\n                                    apilen  = apiword.length;\n                                for (c = 0; c < apilen; c = c + 1) {\n                                    if (nextish === apiword[c]) {\n                                        return;\n                                    }\n                                }\n                                news = news + 1;\n                                if (options.jsscope !== "none") {\n                                    token[a] = "<strong class=\'new\'>new</strong>";\n                                }\n                            }());\n                        }\n                        if (ctoke === "from" && ltype === "end" && a > 0 && (token[begin[a - 1] - 1] === "import" || token[begin[a - 1] - 1] === ",")) {\n                            level[a - 1] = -10;\n                        }\n                        if (ctoke === "this" && options.jsscope !== "none") {\n                            token[a] = "<strong class=\'new\'>this</strong>";\n                        }\n                        if (ctoke === "function") {\n                            if (options.space === false && a < b - 1 && (token[a + 1] === "(" || token[a + 1] === "x(")) {\n                                return level.push(-20);\n                            }\n                            return level.push(-10);\n                        }\n                        if (ltype === "literal" && ltoke.charAt(ltoke.length - 1) === "{" && options.bracepadding === false) {\n                            level[a - 1] = -20;\n                        } else if (ltoke === "-" && a > 1) {\n                            if (types[a - 2] === "operator" || token[a - 2] === ",") {\n                                level[a - 1] = -20;\n                            } else if (types[a - 2] === "start") {\n                                level[a - 2] = -20;\n                                level[a - 1] = -20;\n                            }\n                        } else if (ctoke === "while" && (ltoke === "}" || ltoke === "x}")) {\n                            //verify if this is a do/while block\n                            (function jspretty__beautify_word_curlyBrace() {\n                                var c = 0,\n                                    d = 0;\n                                for (c = a - 1; c > -1; c = c - 1) {\n                                    if (token[c] === "}" || token[c] === "x}") {\n                                        d = d + 1;\n                                    }\n                                    if (token[c] === "{" || token[c] === "x{") {\n                                        d = d - 1;\n                                    }\n                                    if (d === 0) {\n                                        if (token[c - 1] === "do") {\n                                            level[a - 1] = -10;\n                                            return;\n                                        }\n                                        level[a - 1] = indent;\n                                        return;\n                                    }\n                                }\n                            }());\n                        } else if (ctoke === "in" || (((ctoke === "else" && options.elseline === false) || ctoke === "catch") && (ltoke === "}" || ltoke === "x}"))) {\n                            level[a - 1] = -10;\n                        } else if (ctoke === "var" || ctoke === "let" || ctoke === "const") {\n                            if (assignlist[assignlist.length - 1] === true && varlen.length > 0 && varlen[varlen.length - 1].length > 1) {\n                                assignlist[assignlist.length - 1] = false;\n                                varlist.push(varlen[varlen.length - 1]);\n                                varlen[varlen.length - 1] = [];\n                            } else if (depth[a] !== "method") {\n                                varlen[varlen.length - 1] = [];\n                            }\n                            if (ltype === "end") {\n                                level[a - 1] = indent;\n                            }\n                            if (token[begin[a] - 1] !== "for") {\n                                if (varline.length === 0) {\n                                    varline.push(true);\n                                } else {\n                                    varline[varline.length - 1] = true;\n                                }\n                                (function jspretty__beautify_word_varlisttest() {\n                                    var c = 0,\n                                        d = 0;\n                                    for (c = a + 1; c < b; c = c + 1) {\n                                        if (types[c] === "end") {\n                                            d = d - 1;\n                                        }\n                                        if (types[c] === "start") {\n                                            d = d + 1;\n                                        }\n                                        if (d < 0 || (d === 0 && (token[c] === ";" || token[c] === ","))) {\n                                            break;\n                                        }\n                                    }\n                                    if (token[c] === ",") {\n                                        indent = indent + 1;\n                                    }\n                                }());\n                            }\n                        } else if ((ctoke === "default" || ctoke === "case") && ltype !== "word" && depth[a] === "switch") {\n                            level[a - 1] = indent - 1;\n                            return level.push(-10);\n                        }\n                        if (ctoke === "catch" && ltoke === ".") {\n                            level[a - 1] = -20;\n                            return level.push(-20);\n                        }\n                        if (ctoke === "catch" || ctoke === "finally") {\n                            level[a - 1] = -10;\n                            return level.push(-10);\n                        }\n                        if (options.bracepadding === false && a < b - 1 && token[a + 1].charAt(0) === "}") {\n                            return level.push(-20);\n                        }\n                        if (depth[a] === "object" && (ltoke === "{" || ltoke === ",") && (token[a + 1] === "(" || token[a + 1] === "x(")) {\n                            return level.push(-20);\n                        }\n                        level.push(-10);\n                    };\n                if (options.titanium === true) {\n                    indent = indent - 1;\n                }\n                for (a = 0; a < b; a = a + 1) {\n                    if (options.jsscope !== "none" || options.mode === "minify") {\n                        meta.push("");\n                    }\n                    ctype = types[a];\n                    ctoke = token[a];\n                    if (ctype === "comment") {\n                        comment();\n                    } else if (ctype === "comment-inline") {\n                        commentInline();\n                    } else if (ctype === "regex") {\n                        level.push(-20);\n                    } else if (ctype === "literal") {\n                        literal();\n                    } else if (ctype === "separator") {\n                        separator();\n                    } else if (ctype === "start") {\n                        start();\n                    } else if (ctype === "end") {\n                        end();\n                    } else if (ctype === "operator") {\n                        operator();\n                    } else if (ctype === "word") {\n                        word();\n                    } else if (ctype === "markup") {\n                        markup();\n                    } else if (ctype.indexOf("template") === 0) {\n                        template();\n                    } else if (ctype === "generic") {\n                        if (ltoke !== "return" && ltoke.charAt(0) !== "#" && ltype !== "operator" && ltoke !== "public" && ltoke !== "private" && ltoke !== "static" && ltoke !== "final" && ltoke !== "implements" && ltoke !== "class" && ltoke !== "void") {\n                            level[a - 1] = -20;\n                        }\n                        if (token[a + 1] === "(" || token[a + 1] === "x(") {\n                            level.push(-20);\n                        } else {\n                            level.push(-10);\n                        }\n                    }\n                    if (ctype !== "comment" && ctype !== "comment-inline") {\n                        ltype = ctype;\n                        ltoke = ctoke;\n                    }\n                }\n                if (assignlist[assignlist.length - 1] === true && varlen[varlen.length - 1].length > 1 && ltoke === ";") {\n                    varlist.push(varlen[varlen.length - 1]);\n                }\n            }());\n        }\n        if (options.titanium === true) {\n            token[0] = "";\n            types[0] = "";\n            lines[0] = 0;\n        }\n        if (options.mode === "minify") {\n            result = (function jspretty__minify() {\n                var a        = 0,\n                    linelen  = 0,\n                    length   = token.length,\n                    comtest  = (options.topcoms === false),\n                    build    = [],\n                    lastsemi = function jspretty__minify_lastsemi() {\n                        var aa = 0,\n                            bb = 0;\n                        for (aa = a; aa > -1; aa = aa - 1) {\n                            if (types[aa] === "end") {\n                                bb = bb + 1;\n                            } else if (types[aa] === "start") {\n                                bb = bb - 1;\n                            }\n                            if (bb < 0) {\n                                if (token[aa - 1] === "for") {\n                                    build.push(";");\n                                }\n                                return;\n                            }\n                        }\n                    };\n                for (a = 0; a < length; a = a + 1) {\n                    if (types[a] !== "comment") {\n                        comtest = true;\n                    }\n                    if (types[a - 1] === "operator" && types[a] === "operator" && token[a] !== "!") {\n                        build.push(" ");\n                    }\n                    if (types[a] === "markup" && typeof global.prettydiff.markuppretty === "function") {\n                        build.push(extlib({jsx: true, mode: "minify", source: token[a]}));\n                    } else if (types[a] === "word" && (types[a + 1] === "word" || types[a + 1] === "literal" || token[a + 1] === "x{" || types[a + 1] === "comment" || types[a + 1] === "comment-inline")) {\n                        if (types[a - 1] === "literal" && token[a - 1].charAt(0) !== "\\"" && token[a - 1].charAt(0) !== "\'") {\n                            build.push(" ");\n                        }\n                        build.push(token[a]);\n                        build.push(" ");\n                    } else if (types[a] === "comment" && comtest === false) {\n                        build.push(token[a]);\n                        build.push(lf);\n                    } else if (token[a] === "x;" && token[a + 1] !== "}") {\n                        build.push(";");\n                    } else if (token[a] === ";" && token[a + 1] === "}") {\n                        lastsemi();\n                    } else if (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x)" && token[a] !== "x(" && types[a] !== "comment" && types[a] !== "comment-inline") {\n                        build.push(token[a]);\n                    }\n                    if (options.wrap > 0) {\n                        if (types[a] !== "comment" && types[a] !== "comment-inline") {\n                            linelen = linelen + token[a].length;\n                        }\n                        if ((types[a] === "operator" || types[a] === "separator" || types[a] === "start") && a < length - 1 && linelen + token[a + 1].length > options.wrap) {\n                            build.push(lf);\n                            linelen = 0;\n                        }\n                    }\n                }\n                if (options.newline === true) {\n                    if (options.crlf === true) {\n                        build.push("\\r\\n");\n                    } else {\n                        build.push("\\n");\n                    }\n                }\n                if (options.nodeasync === true) {\n                    return [build.join(""), globalerror];\n                }\n                return build.join("");\n            }());\n        } else {\n            //the result function generates the out\n            (function jspretty__result() {\n                var tab      = (function jspretty__result_tab() {\n                        var aa = options.inchar,\n                            bb = options.insize,\n                            cc = [];\n                        for (bb = bb; bb > 0; bb = bb - 1) {\n                            cc.push(aa);\n                        }\n                        return cc.join("");\n                    }()),\n                    vertical = function jspretty__result_vertical() {\n                        var aa          = 0,\n                            lastListLen = 0,\n                            cc          = 0,\n                            dd          = 0,\n                            longest     = 0,\n                            longTest    = 0,\n                            strlongest  = 0,\n                            isvar       = false,\n                            isvartoken  = 0,\n                            strspace    = "",\n                            tokenInList = "",\n                            longList    = [],\n                            joins       = function jspretty__result_vertical_joins(x) {\n                                var xlen = token[x].length,\n                                    y    = x;\n                                if (level[x] === 0) {\n                                    return xlen;\n                                }\n                                if (level[x] < -9) {\n                                    do {\n                                        y = y - 1;\n                                        if (level[y] > -9) {\n                                            break;\n                                        }\n                                        if (level[y] === -10) {\n                                            xlen = xlen + 1;\n                                        }\n                                        xlen = xlen + token[y].length;\n                                    } while (y > 0);\n                                    if (level[y] > 0) {\n                                        xlen = xlen + (options.inchar.length * options.insize * level[y]);\n                                    }\n                                } else {\n                                    xlen = xlen + (options.inchar.length * options.insize * level[x]);\n                                }\n                                if (depth[x] === "global" && varlist[0][0] === x && options.lang !== "javascript") {\n                                    y = x;\n                                    do {\n                                        y = y - 1;\n                                    } while (y > -1 && level[y] < -9);\n                                    if (y < 0) {\n                                        xlen = xlen + (options.inchar.length * options.insize * options.inlevel);\n                                    }\n                                }\n                                return xlen;\n                            };\n                        for (aa = varlist.length - 1; aa > -1; aa = aa - 1) {\n                            if (varlist[aa] !== undefined) {\n                                lastListLen = varlist[aa].length;\n                                longest     = 0;\n                                longList    = [];\n                                isvartoken  = token[varlist[aa][0] - 1];\n                                isvar       = (\n                                    isvartoken === "var" || isvartoken === "let" || isvartoken === "const"\n                                );\n                                for (cc = 0; cc < lastListLen; cc = cc + 1) {\n                                    longTest = joins(varlist[aa][cc], isvar);\n                                    if (longTest > longest) {\n                                        longest = longTest;\n                                    }\n                                    longList.push(longTest);\n                                }\n                                strspace = "";\n                                if (longest > options.insize) {\n                                    strlongest = longest - options.insize;\n                                } else if (longest < options.insize) {\n                                    strlongest = options.insize - longest;\n                                }\n                                if (token[varlist[aa][0] - 1] === "var" || token[varlist[aa][0] - 1] === "let" || token[varlist[aa][0] - 1] === "const") {\n                                    strlongest = strlongest - options.insize;\n                                } else if (token[varlist[aa][0] + 1] === "=") {\n                                    strlongest = strlongest + 1;\n                                }\n                                if (longest !== options.insize && strlongest > 0) {\n                                    do {\n                                        strspace   = strspace + " ";\n                                        strlongest = strlongest - 1;\n                                    } while (strlongest > -1);\n                                }\n                                for (cc = 0; cc < lastListLen; cc = cc + 1) {\n                                    tokenInList = token[varlist[aa][cc]];\n                                    if (longList[cc] < longest) {\n                                        do {\n                                            tokenInList  = tokenInList + " ";\n                                            longList[cc] = longList[cc] + 1;\n                                        } while (longList[cc] < longest);\n                                    }\n                                    token[varlist[aa][cc]] = tokenInList;\n                                    if (token[varlist[aa][cc] + 2] !== undefined && token[varlist[aa][cc] + 2].length === options.wrap + 2 && token[varlist[aa][cc] + 3] === "+" && token[varlist[aa][cc] + 4] !== undefined && options.styleguide !== "crockford" && options.styleguide !== "jslint" && (token[varlist[aa][cc] + 4].charAt(0) === "\\"" || token[varlist[aa][cc] + 4].charAt(0) === "\'")) {\n                                        if (longest <= options.insize) {\n                                            strspace = "";\n                                            dd       = 0;\n                                            do {\n                                                dd       = dd + 1;\n                                                strspace = strspace + " ";\n                                            } while (dd < longest + 1);\n                                            dd = varlist[aa][cc] + 4;\n                                            do {\n                                                token[dd]     = strspace + tab + tab + token[dd];\n                                                level[dd - 1] = level[dd - 1] - 1;\n                                                dd            = dd + 2;\n                                            } while (types[dd] === "literal" && types[dd - 1] !== "separator");\n                                        } else {\n                                            dd = varlist[aa][cc] + 4;\n                                            do {\n                                                token[dd]     = strspace + tab + tab + token[dd];\n                                                level[dd - 1] = 0;\n                                                dd            = dd + 2;\n                                            } while (types[dd] === "literal" && types[dd - 1] !== "separator");\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    };\n                if (options.jsscope !== "none") {\n                    result = (function jspretty__result_scope() {\n                        var a                  = 0,\n                            b                  = token.length,\n                            build              = [],\n                            linecount          = 2,\n                            last               = "",\n                            scope              = 1,\n                            buildlen           = 0,\n                            commentfix         = (function jspretty__result_scope_commentfix() {\n                                var aa = 1,\n                                    bb = 1;\n                                if (types[0] !== "comment" || (token[0].indexOf("//") === 0 && lines[0] > 0) || types[1] !== "comment") {\n                                    return 1;\n                                }\n                                do {\n                                    if (token[aa].indexOf("/*") === 0) {\n                                        bb = bb + 1;\n                                    }\n                                    aa = aa + 1;\n                                } while (types[aa] === "comment" && aa < b);\n                                return bb + 1;\n                            }()),\n                            folderItem         = [],\n                            comfold            = -1,\n                            //if current folding is for comment\n                            data               = [\n                                "<div class=\'beautify\' data-prettydiff-ignore=\'true\'><ol class=\'count\'>", "<li>", 1, "</li>"\n                            ],\n                            //applies folding to comments and functions\n                            //\n                            // Folder uses the i variable to determine how far back into the data array to\n                            // look.  i must be multiplied by 3 because each line number is three indexes in\n                            // the data array: <li>, line #, </li>.\n                            //\n                            //i is incremented for:\n                            // * block comments following one or more line  comments that follow one or more\n                            // block comments\n                            //* if last comment in a series is a block comment  and not the first token\n                            // * block comments with a new line that are either  the first token or not\n                            // followed by another block\n                            //* if a block comment is followed by another block  comment\n                            //\n                            //i is decremented for:\n                            //* line comment following a block comment\n                            //* block comment if "i" is greater than 1 and  inside a function fold\n                            // * if a line comment is not preceeded by another  comment and is followed by a\n                            // block comment\n                            //\n                            // If closing a fold and token is a comment and not token 0 then decrement by\n                            // commentfix.\n                            folder             = function jspretty__result_scope_folder() {\n                                var datalen = (data.length - (commentfix * 3) > 0)\n                                        ? data.length - (commentfix * 3)\n                                        : 1,\n                                    index   = a,\n                                    start   = data[datalen + 1] || 1,\n                                    assign  = true,\n                                    kk      = index;\n                                if (types[a] === "comment" && comfold === -1) {\n                                    comfold = a;\n                                } else if (types[a] !== "comment") {\n                                    index = meta[a];\n                                    do {\n                                        kk = kk - 1;\n                                    } while (token[kk] !== "function" && kk > -1);\n                                    kk = kk - 1;\n                                    if (token[kk] === "(" || token[kk] === "x(") {\n                                        do {\n                                            kk = kk - 1;\n                                        } while (kk > -1 && (token[kk] === "(" || token[kk] === "x("));\n                                    }\n                                    if (token[kk] === "=" || token[kk] === ":" || token[kk] === "," || token[kk + 1] === "(" || token[kk + 1] === "x(") {\n                                        assign = false;\n                                    }\n                                }\n                                if (types[a] === "comment" && lines[a] > 1) {\n                                    datalen = datalen - 3;\n                                    start   = start - 1;\n                                }\n                                data[datalen]     = "<li class=\'fold\' title=\'folds from line " + start + " to line " +\n                                        "xxx\'>";\n                                data[datalen + 1] = "- " + start;\n                                folderItem.push([datalen, index, assign]);\n                            },\n                            // determines where folding ends function assignments require one more line for\n                            // closing than everything else\n                            foldclose          = function jspretty__result_scope_foldclose() {\n                                var end  = (function jspretty__result_scope_foldclose_end() {\n                                        if (comfold > -1 || folderItem[folderItem.length - 1][2] === true) {\n                                            return linecount - commentfix - 1;\n                                        }\n                                        return linecount - commentfix;\n                                    }()),\n                                    semi = (/(>;<\\/em>)$/).test(token[a]),\n                                    gg   = 0,\n                                    lets = false;\n                                if (semi === true) {\n                                    end = end - 1;\n                                    for (gg = build.length - 1; gg > 0; gg = gg - 1) {\n                                        if (build[gg] === "let" || build[gg] === "const") {\n                                            lets = true;\n                                        }\n                                        if (build[gg].indexOf("><li") > 0) {\n                                            build[gg] = build[gg].replace(/class\\=\'l\\d+\'/, "class=\'l" + (\n                                                scope + 1\n                                            ) + "\'");\n                                            if (lets === true) {\n                                                break;\n                                            }\n                                        }\n                                        if (build[gg].indexOf("<em class=\'l" + scope + "\'>" + tab) > -1) {\n                                            build[gg] = build[gg].replace(\n                                                "<em class=\'l" + scope + "\'>" + tab,\n                                                "<em class=\'l" + (\n                                                    scope + 1\n                                                ) + "\'>" + tab\n                                            );\n                                        }\n                                    }\n                                }\n                                if (a > 1 && token[a].indexOf("}</em>") === token[a].length - 6 && token[a - 1].indexOf("{</em>") === token[a - 1].length - 6) {\n                                    for (gg = data.length - 1; gg > 0; gg = gg - 1) {\n                                        if (typeof data[gg] === "string" && data[gg].charAt(0) === "-") {\n                                            data[gg - 1] = "<li>";\n                                            data[gg]     = Number(data[gg].substr(1));\n                                            folderItem.pop();\n                                            return;\n                                        }\n                                    }\n                                }\n                                if (folderItem[folderItem.length - 1][1] === b - 1 && token[a].indexOf("<em ") === 0) {\n                                    end = end + 1;\n                                }\n                                data[folderItem[folderItem.length - 1][0]] = data[folderItem[folderItem.length - 1][0]].replace(\n                                    "xxx",\n                                    end\n                                );\n                                folderItem.pop();\n                            },\n                            // splits block comments, which are single tokens, into multiple lines of output\n                            blockline          = function jspretty__result_scope_blockline(x) {\n                                var commentLines = x.split(lf),\n                                    hh           = 0,\n                                    ii           = commentLines.length - 1;\n                                if (lines[a] > 0) {\n                                    data.push("<li>");\n                                    data.push(linecount);\n                                    data.push("</li>");\n                                    linecount = linecount + 1;\n                                }\n                                for (hh = 0; hh < ii; hh = hh + 1) {\n                                    data.push("<li>");\n                                    data.push(linecount);\n                                    data.push("</li>");\n                                    linecount        = linecount + 1;\n                                    commentLines[hh] = commentLines[hh] + "<em>&#xA;</em></li><li class=\'c0\'>";\n                                }\n                                return commentLines.join("");\n                            },\n                            //finds the variables if the jsscope option is true\n                            findvars           = function jspretty__result_scope_findvars(x) {\n                                var metax         = meta[x],\n                                    metameta      = meta[metax][0],\n                                    lettest       = false,\n                                    ee            = 0,\n                                    ff            = 0,\n                                    hh            = 0,\n                                    adjustment    = 1,\n                                    functionBlock = true,\n                                    varbuild      = [],\n                                    varbuildlen   = 0,\n                                    letcomma      = function jspretty__result_scope_findvars_letcomma() {\n                                        var aa = 0,\n                                            bb = 0;\n                                        for (aa = a; aa > -1; aa = aa - 1) {\n                                            if (types[aa] === "end") {\n                                                bb = bb - 1;\n                                            }\n                                            if (types[aa] === "start") {\n                                                bb = bb + 1;\n                                            }\n                                            if (bb > 0) {\n                                                return;\n                                            }\n                                            if (bb === 0) {\n                                                if (token[aa] === "var" || token[aa] === ";" || token[aa] === "x;") {\n                                                    return;\n                                                }\n                                                if (token[aa] === "let" || token[aa] === "const") {\n                                                    token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\n                                                }\n                                            }\n                                        }\n                                    };\n                                if (metameta === undefined) {\n                                    return;\n                                }\n                                lettest = meta[metax][1];\n                                hh      = metameta.length;\n                                if (types[a - 1] === "word" && token[a - 1] !== "function" && lettest === false) {\n                                    varbuild     = token[a - 1].split(" ");\n                                    token[a - 1] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\n                                    varbuildlen  = varbuild.length;\n                                    if (varbuildlen > 1) {\n                                        do {\n                                            token[ee]   = token[ee] + " ";\n                                            varbuildlen = varbuildlen - 1;\n                                        } while (varbuildlen > 1);\n                                    }\n                                }\n                                if (hh > 0) {\n                                    ee = metax - 1;\n                                    if (lettest === true) {\n                                        ee = ee - 1;\n                                    }\n                                    for (ee = ee; ee > a; ee = ee - 1) {\n                                        if (types[ee] === "word") {\n                                            varbuild = token[ee].split(" ");\n                                            for (ff = 0; ff < hh; ff = ff + 1) {\n                                                if (varbuild[0] === metameta[ff] && token[ee - 1] !== ".") {\n                                                    if (token[ee - 1] === "function" && token[ee + 1] === "(") {\n                                                        token[ee]   = "<em class=\'s" + (\n                                                            scope + 1\n                                                        ) + "\'>" + varbuild[0] + "</em>";\n                                                        varbuildlen = varbuild.length;\n                                                        if (varbuildlen > 1) {\n                                                            do {\n                                                                token[ee]   = token[ee] + " ";\n                                                                varbuildlen = varbuildlen - 1;\n                                                            } while (varbuildlen > 1);\n                                                        }\n                                                    } else if (token[ee - 1] === "case" || token[ee + 1] !== ":" || (token[ee + 1] === ":" && level[ee] > -20)) {\n                                                        if (lettest === true) {\n                                                            if (token[ee - 1] === "let" || token[ee - 1] === "const") {\n                                                                token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\n                                                            } else if (token[ee - 1] === ",") {\n                                                                letcomma();\n                                                            } else {\n                                                                token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\n                                                            }\n                                                        } else {\n                                                            token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\n                                                        }\n                                                        varbuildlen = varbuild.length;\n                                                        if (varbuildlen > 1) {\n                                                            do {\n                                                                token[ee]   = token[ee] + " ";\n                                                                varbuildlen = varbuildlen - 1;\n                                                            } while (varbuildlen > 1);\n                                                        }\n                                                    }\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        if (functionBlock === true) {\n                                            if (types[ee] === "end") {\n                                                adjustment = adjustment + 1;\n                                            } else if (types[ee] === "start") {\n                                                adjustment = adjustment - 1;\n                                            }\n                                            if (adjustment === 0 && token[ee] === "{") {\n                                                token[ee]     = "<em class=\'s" + scope + "\'>{</em>";\n                                                functionBlock = false;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    ee = a + 1;\n                                    if (lettest === true) {\n                                        ee = ee - 1;\n                                    }\n                                    for (ee = ee; ee < metax; ee = ee + 1) {\n                                        if (types[ee] === "end") {\n                                            adjustment = adjustment - 1;\n                                        } else if (types[ee] === "start") {\n                                            adjustment = adjustment + 1;\n                                        }\n                                        if (adjustment === 1 && token[ee] === "{") {\n                                            token[ee] = "<em class=\'s" + scope + "\'>{</em>";\n                                            return;\n                                        }\n                                    }\n                                }\n                            },\n                            indent             = options.inlevel,\n                            //some prebuilt color coded tabs\n                            lscope             = [\n                                "<em class=\'l0\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\n                                        tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em><em class=\'l14\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em><em class=\'l14\'>" + tab + "</em><em" +\n                                        " class=\'l15\'>" + tab + "</em>",\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em><em class=\'l14\'>" + tab + "</em><em" +\n                                        " class=\'l15\'>" + tab + "</em><em class=\'l16\'>" + tab + "</em>"\n                            ],\n                            //a function for calculating indentation after each new line\n                            nl                 = function jspretty__result_scope_nl(x, linetest) {\n                                var dd = 0;\n                                if (token[a] !== "x}" || (token[a] === "x}" && token[a + 1] !== "}")) {\n                                    data.push("<li>");\n                                    data.push(linecount);\n                                    data.push("</li>");\n                                    linecount = linecount + 1;\n                                    if (a < b - 1 && token[a + 1].indexOf("/*") === 0) {\n                                        build.push("<em>&#xA;</em></li><li class=\'c0\'>");\n                                    } else {\n                                        build.push("<em>&#xA;</em></li><li class=\'l" + scope + "\'>");\n                                        if (x > 0) {\n                                            dd = scope;\n                                            if (scope > 0) {\n                                                if (scope === x + 1 && x > 0 && linetest !== true) {\n                                                    dd = dd - 1;\n                                                }\n                                                build.push(lscope[dd - 1]);\n                                            }\n                                        } else if (linetest === true) {\n                                            build.push(lscope[0]);\n                                        }\n                                    }\n                                } else {\n                                    if (x > 0) {\n                                        dd = scope;\n                                        if (scope > 0) {\n                                            if (scope === x + 1 && x > 0 && linetest !== true) {\n                                                dd = dd - 1;\n                                            }\n                                            build.push(lscope[dd - 1]);\n                                        }\n                                    }\n                                }\n                                for (dd = dd; dd < x; dd = dd + 1) {\n                                    build.push(tab);\n                                }\n                            },\n                            rl                 = function jspretty__result_scope_rl(x) {\n                                var bb = token.length,\n                                    cc = 2,\n                                    dd = 0;\n                                for (dd = a + 2; dd < bb; dd = dd + 1) {\n                                    if (token[dd] === "x}") {\n                                        cc = cc + 1;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                                nl(x - cc);\n                                a = a + 1;\n                            },\n                            markupBuild        = function jspretty__result_scope_markupBuild() {\n                                var mindent  = (function jspretty__result_scope_markupBuild_offset() {\n                                        var d = 0;\n                                        if (a === markupvar[0]) {\n                                            markupvar.splice(0, 1);\n                                            return 1;\n                                        }\n                                        if (token[d] === "return" || token[0] === "{") {\n                                            return 1;\n                                        }\n                                        if (level[a] < -9) {\n                                            return 0;\n                                        }\n                                        for (d = a - 1; d > -1; d = d - 1) {\n                                            if (token[d] !== "(" && token[d] !== "x(") {\n                                                if (token[d] === "=") {\n                                                    return 1;\n                                                }\n                                                return 0;\n                                            }\n                                        }\n                                        return 0;\n                                    }()),\n                                    markup   = (function jspretty__result_scope_markupBuild_varscope() {\n                                        var item    = "",\n                                            emscope = function jsscope__result_scope_markupBuild_varscope_emscope(x) {\n                                                return "<em class=\'s" + x\n                                                    .replace("[pdjsxem", "")\n                                                    .replace("]", "") + "\'>";\n                                            },\n                                            word    = "",\n                                            newword = "",\n                                            inca    = 0,\n                                            incb    = 0,\n                                            lena    = meta.length,\n                                            lenb    = 0,\n                                            vars    = [],\n                                            mode    = options.mode,\n                                            inle    = options.inlevel,\n                                            jsx     = options.jsx;\n                                        options.source  = token[a];\n                                        options.mode    = "beautify";\n                                        options.inlevel = mindent;\n                                        options.jsx     = true;\n                                        item            = extlib().replace(/return\\s+</g, "return <");\n                                        options.mode    = mode;\n                                        options.inlevel = inle;\n                                        options.jsx     = jsx;\n                                        if (item.indexOf("[pdjsxscope]") < 0) {\n                                            return item\n                                                .replace(/&/g, "&amp;")\n                                                .replace(/</g, "&lt;")\n                                                .replace(/>/g, "&gt;")\n                                                .split(lf);\n                                        }\n                                        do {\n                                            newword = "";\n                                            vars    = [];\n                                            word    = item.substring(\n                                                item.indexOf("[pdjsxscope]") + 12,\n                                                item.indexOf("[/pdjsxscope]")\n                                            );\n                                            for (inca = 0; inca < lena; inca = inca + 1) {\n                                                if (typeof meta[inca] === "number" && inca < a && a < meta[inca]) {\n                                                    vars.push(meta[inca]);\n                                                    lenb = meta[meta[inca]].length;\n                                                    for (incb = 0; incb < lenb; incb = incb + 1) {\n                                                        if (meta[meta[inca]][incb] === word) {\n                                                            newword = "[pdjsxem" + (\n                                                                vars.length + 1\n                                                            ) + "]" + word + "[/pdjsxem]";\n                                                        }\n                                                    }\n                                                    if (incb < lenb) {\n                                                        break;\n                                                    }\n                                                    vars.pop();\n                                                }\n                                            }\n                                            if (newword === "") {\n                                                lenb = globals.length;\n                                                for (incb = 0; incb < lenb; incb = incb + 1) {\n                                                    if (word === globals[incb]) {\n                                                        newword = "[pdjsxem0]" + word + "[/pdjsxem]";\n                                                    }\n                                                }\n                                                if (newword === "") {\n                                                    newword = word;\n                                                }\n                                            }\n                                            item = item.replace("[pdjsxscope]" + word + "[/pdjsxscope]", newword);\n                                        } while (item.indexOf("[pdjsxscope]") > -1);\n                                        return item\n                                            .replace(/&/g, "&amp;")\n                                            .replace(/</g, "&lt;")\n                                            .replace(/>/g, "&gt;")\n                                            .replace(/\\[pdjsxem\\d+\\]/g, emscope)\n                                            .replace(/\\[\\/pdjsxem\\]/g, "</em>")\n                                            .split(lf);\n                                    }()),\n                                    len      = 0,\n                                    c        = 0,\n                                    spaces   = 0,\n                                    synthtab = "\\\\" + tab.charAt(0),\n                                    tabreg   = {};\n                                len = tab.length;\n                                for (c = 1; c < len; c = c + 1) {\n                                    synthtab = synthtab + "\\\\" + tab.charAt(c);\n                                }\n                                tabreg  = new RegExp("^(" + synthtab + "+)");\n                                mindent = indent + 2;\n                                if (level[a] < -9) {\n                                    markup[0] = markup[0].replace(tabreg, "");\n                                    mindent   = mindent - 1;\n                                }\n                                len = markup.length;\n                                for (c = 0; c < len - 1; c = c + 1) {\n                                    if (markup[c].indexOf(tab) !== 0 && c > 0) {\n                                        spaces = markup[c - 1]\n                                            .split(tab)\n                                            .length - 1;\n                                        do {\n                                            spaces    = spaces - 1;\n                                            markup[c] = tab + markup[c];\n                                        } while (spaces > 0);\n                                    }\n                                    build.push(markup[c]);\n                                    nl(mindent - 1);\n                                }\n                                build.push(markup[markup.length - 1]);\n                            },\n                            multiline          = function jspretty__result_scope_multiline(x) {\n                                var temparray = x.split(lf),\n                                    c         = 0,\n                                    d         = temparray.length;\n                                build.push(temparray[0]);\n                                for (c = 1; c < d; c = c + 1) {\n                                    nl(indent);\n                                    build.push(temparray[c]);\n                                }\n                            },\n                            endcomma_multiline = function jspretty__result_scope_endcommaMultiline() {\n                                var c = a;\n                                if (types[c] === "comment" || types[c] === "comment-inline") {\n                                    do {\n                                        c = c - 1;\n                                    } while (c > 0 && (types[c] === "comment" || types[c] === "comment-inline"));\n                                }\n                                token[c] = token[c] + ",";\n                            };\n                        if (verticalop === true) {\n                            vertical();\n                        }\n                        if (types[a] === "comment" && token[a].indexOf("/*") === 0) {\n                            build.push("<ol class=\'data\'><li class=\'c0\'>");\n                        } else {\n                            build.push("<ol class=\'data\'><li>");\n                        }\n                        for (a = 0; a < indent; a = a + 1) {\n                            build.push(tab);\n                        }\n                        // its important to find the variables separately from building the output so\n                        // that recursive flows in the loop incrementation do not present simple\n                        // counting collisions as to what gets modified versus what gets included\n                        for (a = b - 1; a > -1; a = a - 1) {\n                            if (typeof meta[a] === "number") {\n                                scope = scope - 1;\n                                findvars(a);\n                            } else if (meta[a] !== undefined && typeof meta[a] !== "string" && typeof meta[a] !== "number" && a > 0 && token[a] !== "x;" && token[a] !== "x}" && token[a] !== "x{" && token[a] !== "x(" && token[a] !== "x)") {\n                                token[a] = "<em class=\'s" + scope + "\'>" + token[a] + "</em>";\n                                scope    = scope + 1;\n                                if (scope > 16) {\n                                    scope = 16;\n                                }\n                            }\n                        }\n                        (function jspretty__result_scope_globals() {\n                            var aa          = 0,\n                                bb          = token.length,\n                                globalLocal = globals,\n                                dd          = globalLocal.length,\n                                ee          = 0,\n                                word        = [],\n                                wordlen     = 0;\n                            for (aa = bb - 1; aa > 0; aa = aa - 1) {\n                                if (types[aa] === "word" && (token[aa + 1] !== ":" || (token[aa + 1] === ":" && level[aa + 1] === -20)) && token[aa].indexOf("<em ") < 0) {\n                                    word = token[aa].split(" ");\n                                    for (ee = dd - 1; ee > -1; ee = ee - 1) {\n                                        if (word[0] === globalLocal[ee] && token[aa - 1] !== ".") {\n                                            if (token[aa - 1] === "function" && depth[aa + 1] === "method") {\n                                                token[aa] = "<em class=\'s1\'>" + word[0] + "</em>";\n                                                wordlen   = word.length;\n                                                if (wordlen > 1) {\n                                                    do {\n                                                        token[aa] = token[aa] + " ";\n                                                        wordlen   = wordlen - 1;\n                                                    } while (wordlen > 1);\n                                                }\n                                            } else {\n                                                token[aa] = "<em class=\'s0\'>" + word[0] + "</em>";\n                                                wordlen   = word.length;\n                                                if (wordlen > 1) {\n                                                    do {\n                                                        token[aa] = token[aa] + " ";\n                                                        wordlen   = wordlen - 1;\n                                                    } while (wordlen > 1);\n                                                }\n                                            }\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }());\n                        scope = 0;\n                        // this loops combines the white space as determined from the algorithm with the\n                        // tokens to create the output\n                        for (a = 0; a < b; a = a + 1) {\n                            if (typeof meta[a] === "number") {\n                                folder();\n                            }\n                            if (comfold === -1 && types[a] === "comment" && ((token[a].indexOf("/*") === 0 && token[a].indexOf("\\n") > 0) || types[a + 1] === "comment" || lines[a] > 1)) {\n                                folder();\n                                comfold = a;\n                            }\n                            if (comfold > -1 && types[a] !== "comment") {\n                                foldclose();\n                                comfold = -1;\n                            }\n                            if (options.endcomma === "multiline" && (token[a + 1] === "]" || token[a + 1] === "}") && level[a] !== -20) {\n                                endcomma_multiline();\n                            }\n                            if (types[a] === "comment" && token[a].indexOf("/*") === 0) {\n                                build.push(blockline(token[a]));\n                            } else if (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x(" && token[a] !== "x)") {\n                                if (typeof meta[a] === "number") {\n                                    scope = scope + 1;\n                                    if (scope > 16) {\n                                        scope = 16;\n                                    }\n                                    build.push(token[a]);\n                                } else if (typeof meta[a] !== "string" && typeof meta[a] !== "number") {\n                                    build.push(token[a]);\n                                    scope    = scope - 1;\n                                    buildlen = build.length - 1;\n                                    do {\n                                        buildlen = buildlen - 1;\n                                    } while (buildlen > 0 && build[buildlen].indexOf("</li><li") < 0);\n                                    build[buildlen] = build[buildlen].replace(\n                                        /class\\=\'l\\d+\'/,\n                                        "class=\'l" + scope + "\'"\n                                    );\n                                } else if (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x(" && token[a] !== "x)") {\n                                    if (types[a] === "markup") {\n                                        if (level[a] > -9) {\n                                            if (types[a - 1] === "operator") {\n                                                nl(indent);\n                                            } else if (token[a - 1] !== "return") {\n                                                nl(indent + 1);\n                                            }\n                                        }\n                                        if (typeof global.prettydiff.markuppretty === "function") {\n                                            markupBuild();\n                                        } else {\n                                            build.push(token[a].replace(/\\r?\\n(\\s*)/g, " "));\n                                        }\n                                    } else if (types[a] === "comment") {\n                                        if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\n                                            nl(indent);\n                                        }\n                                        if (a === 0) {\n                                            build[0] = "<ol class=\'data\'><li class=\'c0\'>";\n                                        } else {\n                                            buildlen = build.length - 1;\n                                            if (build[buildlen].indexOf("<li") < 0) {\n                                                do {\n                                                    build[buildlen] = build[buildlen]\n                                                        .replace(/<em\\u0020class\\=\'[a-z]\\d+\'>/g, "")\n                                                        .replace(/<\\/em>/g, "");\n                                                    buildlen        = buildlen - 1;\n                                                    if (buildlen > 0 && build[buildlen] === undefined) {\n                                                        buildlen = buildlen - 1;\n                                                    }\n                                                } while (\n                                                    buildlen > 0 && build[buildlen - 1] !== undefined && build[buildlen].indexOf("<li") < 0\n                                                );\n                                            }\n                                            if ((/^(<em>&#xA;<\\/em><\\/li><li\\u0020class=\'l\\d+\'>)$/).test(build[buildlen - 1]) === true) {\n                                                build[buildlen - 1] = build[buildlen - 1].replace(\n                                                    /class\\=\'l\\d+\'/,\n                                                    "class=\'c0\'"\n                                                );\n                                            }\n                                            build[buildlen] = build[buildlen].replace(/class\\=\'l\\d+\'/, "class=\'c0\'");\n                                        }\n                                        build.push(token[a]);\n                                    } else {\n                                        if (types[a] === "literal" && token[a].indexOf("\\n") > 0) {\n                                            multiline(token[a]);\n                                        } else {\n                                            build.push(token[a]);\n                                        }\n                                    }\n                                }\n                            }\n                            // this condition performs additional calculations for options.preserve.\n                            // options.preserve determines whether empty lines should be preserved from the\n                            // code input\n                            if (options.preserve > 0 && lines[a] > 0 && level[a] > -9 && token[a] !== "+") {\n                                //special treatment for math operators\n                                if (token[a] === "+" || token[a] === "-" || token[a] === "*" || token[a] === "/") {\n                                    //comments get special treatment\n                                    if (a < b - 1 && types[a + 1] !== "comment" && types[a + 1] !== "comment-inline") {\n                                        nl(level[a]);\n                                        build.push(tab);\n                                        level[a] = -20;\n                                    } else {\n                                        indent = level[a];\n                                        if (lines[a] > 1) {\n                                            do {\n                                                build.push(lf);\n                                                lines[a] = lines[a] - 1;\n                                            } while (lines[a] > 1);\n                                        }\n                                        nl(indent);\n                                        build.push(tab);\n                                        build.push(token[a + 1]);\n                                        nl(indent);\n                                        build.push(tab);\n                                        level[a + 1] = -20;\n                                        a            = a + 1;\n                                    }\n                                } else if (lines[a] > 1 && token[a].charAt(0) !== "=" && token[a].charAt(0) !== "!" && (types[a] !== "start" || (a < b - 1 && types[a + 1] !== "end"))) {\n                                    if ((token[a] !== "x}" || isNaN(level[a]) === true) && (a < b - 1 && (types[a + 1] === "comment" || types[a + 1] === "comment-inline" || (token[a] !== "." && types[a + 1] !== "separator")))) {\n                                        do {\n                                            nl(0, true);\n                                            lines[a] = lines[a] - 1;\n                                        } while (lines[a] > 1);\n                                        if (types[a] === "comment") {\n                                            build.push("<em>&#xA;</em></li><li class=\'c0\'>");\n                                        } else {\n                                            commentfix = commentfix + 1;\n                                            nl(level[a], true);\n                                        }\n                                    }\n                                }\n                            }\n                            if ((token[a] === ";" || token[a] === "x;") && token[a + 1] === "x}" && ((/<em\\u0020class=\'s\\d+\'>\\}<\\/em>/).test(token[a + 2]) === true || token[a + 2] === "x}")) {\n                                rl(indent);\n                            } else if (token[a] === "x{" && level[a] === -10 && level[a - 1] === -10) {\n                                build.push("");\n                            } else if (a < b - 1 && types[a + 1] === "comment" && options.comments === "noindent") {\n                                nl(options.inlevel);\n                            } else if (level[a] === -10 && token[a] !== "x}") {\n                                build.push(" ");\n                            } else if (token[a] !== "" && level[a] !== -20 && (token[a] !== "x}" || (token[a] === "x}" && (token[a - 1] === "x;" || token[a - 1] === ";") && types[a + 1] !== "word") || lines[a] > 1)) {\n                                indent = level[a];\n                                nl(indent);\n                            }\n                            if (folderItem.length > 0) {\n                                if (a === folderItem[folderItem.length - 1][1] && comfold === -1) {\n                                    foldclose();\n                                }\n                            }\n                        }\n                        for (a = build.length - 1; a > -1; a = a - 1) {\n                            if (build[a] === tab) {\n                                build.pop();\n                            } else {\n                                break;\n                            }\n                        }\n                        //this logic is necessary to some line counting corrections to the HTML output\n                        last = build[build.length - 1];\n                        if (last.indexOf("<li") > 0) {\n                            build[build.length - 1] = "<em>&#xA;</em></li>";\n                        } else if (last.indexOf("</li>") < 0) {\n                            build.push("<em>&#xA;</em></li>");\n                        }\n                        build.push("</ol></div>");\n                        last = build.join("");\n                        if (last.match(/<li/g) !== null) {\n                            scope = last\n                                .match(/<li/g)\n                                .length;\n                            if (linecount - 1 > scope) {\n                                linecount = linecount - 1;\n                                do {\n                                    data.pop();\n                                    data.pop();\n                                    data.pop();\n                                    linecount = linecount - 1;\n                                } while (linecount > scope);\n                            }\n                        }\n                        data.push("</ol>");\n                        if (options.jsscope === "html") {\n                            data.push(last);\n                            if (options.newline === true) {\n                                if (options.crlf === true) {\n                                    data.push("\\r\\n");\n                                } else {\n                                    data.push("\\n");\n                                }\n                            }\n                            return data.join("");\n                        }\n                        build = [\n                            "<p>Scope analysis does not provide support for undeclared variables.</p>",\n                            "<p><em>",\n                            scolon,\n                            "</em> instances of <strong>missing semicolons</strong> counted.</p>",\n                            "<p><em>",\n                            news,\n                            "</em> unnecessary instances of the keyword <strong>new</strong> counted.</p>",\n                            data.join(""),\n                            last\n                        ];\n                        if (options.newline === true) {\n                            if (options.crlf === true) {\n                                build.push("\\r\\n");\n                            } else {\n                                build.push("\\n");\n                            }\n                        }\n                        if (options.nodeasync === true) {\n                            return [build.join(""), globalerror];\n                        }\n                        return build.join("");\n                    }())\n                        .replace(/(\\s+)$/, "")\n                        .replace(options.functions.binaryCheck, "");\n                } else {\n                    result = (function jspretty__result_standard() {\n                        var a                  = 0,\n                            b                  = token.length,\n                            build              = [],\n                            indent             = options.inlevel,\n                            //a function for calculating indentation after each new line\n                            nl                 = function jspretty__result_standard_nl(x) {\n                                var dd = 0;\n                                build.push(lf);\n                                for (dd = 0; dd < x; dd = dd + 1) {\n                                    build.push(tab);\n                                }\n                            },\n                            rl                 = function jspretty__result_standard_rl(x) {\n                                var bb = token.length,\n                                    cc = 2,\n                                    dd = 0;\n                                for (dd = a + 2; dd < bb; dd = dd + 1) {\n                                    if (token[dd] === "x}") {\n                                        cc = cc + 1;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                                nl(x - cc);\n                                a = a + 1;\n                            },\n                            markupwrapper      = function jspretty__result_standard_markupwrapper() {\n                                var inle = options.inlevel,\n                                    mode = options.mode,\n                                    jsx  = options.jsx,\n                                    nel  = options.newline;\n                                options.source  = token[a];\n                                options.jsx     = true;\n                                options.mode    = "beautify";\n                                options.newline = false;\n                                if (level[a] < -9 || depth[a] === "array" || token[begin[a]] === "(") {\n                                    options.inlevel = indent;\n                                } else {\n                                    options.inlevel = indent + 1;\n                                }\n                                build.push(extlib(options));\n                                options.jsx     = jsx;\n                                options.mode    = mode;\n                                options.inlevel = inle;\n                                options.newline = nel;\n                            },\n                            endcomma_multiline = function jspretty__result_standard_endcommaMultiline() {\n                                var c = a;\n                                if (types[c] === "comment" || types[c] === "comment-inline") {\n                                    do {\n                                        c = c - 1;\n                                    } while (c > 0 && (types[c] === "comment" || types[c] === "comment-inline"));\n                                }\n                                token[c] = token[c] + ",";\n                            };\n                        if (verticalop === true) {\n                            vertical();\n                        }\n                        for (a = 0; a < indent; a = a + 1) {\n                            build.push(tab);\n                        }\n                        // this loops combines the white space as determined from the algorithm with the\n                        // tokens to create the output\n                        for (a = 0; a < b; a = a + 1) {\n                            if (options.endcomma === "multiline" && (token[a + 1] === "]" || token[a + 1] === "}") && level[a] > -20) {\n                                endcomma_multiline();\n                            }\n                            if (types[a] === "comment" || (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x(" && token[a] !== "x)")) {\n                                if (types[a] === "markup") {\n                                    if (level[a - 1] > -9 && token[a - 1] !== "return" && depth[a] !== "global" && depth[a] !== "array" && types[a] !== "markup") {\n                                        build.push(tab);\n                                    }\n                                    if (typeof global.prettydiff.markuppretty === "function") {\n                                        markupwrapper();\n                                    } else {\n                                        build.push(token[a].replace(/\\r?\\n(\\s*)/g, " "));\n                                    }\n                                } else {\n                                    build.push(token[a]);\n                                }\n                            }\n                            // this condition performs additional calculations if options.preserve === true.\n                            // options.preserve determines whether empty lines should be preserved from the\n                            // code input\n                            if (options.preserve > 0 && ((lines[a] > 0 && level[a] > -9 && token[a] !== "+" && options.qml === false) || (options.qml === true && lines[a] > 1))) {\n                                if (options.qml === true) {\n                                    do {\n                                        build.push(lf);\n                                        lines[a] = lines[a] - 1;\n                                    } while (lines[a] > 1);\n                                    //special treatment for math operators\n                                } else if (token[a] === "+" || token[a] === "-" || token[a] === "*" || token[a] === "/") {\n                                    //comments get special treatment\n                                    if (a < b - 1 && types[a + 1] !== "comment" && types[a + 1] !== "comment-inline") {\n                                        nl(level[a]);\n                                        build.push(tab);\n                                        level[a] = -20;\n                                    } else {\n                                        indent = level[a];\n                                        if (lines[a] > 1) {\n                                            do {\n                                                build.push(lf);\n                                                lines[a] = lines[a] - 1;\n                                            } while (lines[a] > 1);\n                                        }\n                                        nl(indent);\n                                        build.push(tab);\n                                        build.push(token[a + 1]);\n                                        nl(indent);\n                                        build.push(tab);\n                                        level[a + 1] = -20;\n                                        a            = a + 1;\n                                    }\n                                } else if (lines[a] > 1 && token[a].charAt(0) !== "=" && token[a].charAt(0) !== "!" && (types[a] !== "start" || (a < b - 1 && types[a + 1] !== "end"))) {\n                                    if (a < b - 1 && (types[a + 1] === "comment" || types[a + 1] === "comment-inline" || (token[a] !== "." && types[a + 1] !== "separator"))) {\n                                        if (token[a] !== "x}" || isNaN(level[a]) === true || level[a] === -20) {\n                                            do {\n                                                build.push(lf);\n                                                lines[a] = lines[a] - 1;\n                                            } while (lines[a] > 1);\n                                        }\n                                    }\n                                }\n                            }\n                            if ((token[a] === ";" || token[a] === "x;") && token[a + 1] === "x}" && (token[a + 2] === "}" || token[a + 2] === "x}")) {\n                                rl(indent);\n                            } else if (token[a] === "x{" && level[a] === -10 && level[a - 1] === -10) {\n                                build.push("");\n                                //adds a new line and no indentation\n                            } else if (a < b - 1 && types[a + 1] === "comment" && options.comments === "noindent") {\n                                nl(options.inlevel);\n                            } else if (level[a] === -10 && token[a] !== "x}") {\n                                build.push(" ");\n                                //adds a new line and indentation\n                            } else if (token[a] !== "" && level[a] !== -20 && (token[a] !== "x}" || (token[a] === "x}" && (token[a - 1] === "x;" || token[a - 1] === ";") && types[a + 1] !== "word") || lines[a] > 1)) {\n                                indent = level[a];\n                                nl(indent);\n                            }\n                        }\n                        for (a = build.length - 1; a > -1; a = a - 1) {\n                            if (build[a] === tab) {\n                                build.pop();\n                            } else {\n                                break;\n                            }\n                        }\n                        if (options.preserve > 0 && lines[lines.length - 1] > 0) {\n                            if (options.nodeasync === true) {\n                                return [\n                                    build\n                                        .join("")\n                                        .replace(/(\\s+)$/, lf),\n                                    globalerror\n                                ];\n                            }\n                            return build\n                                .join("")\n                                .replace(/(\\s+)$/, lf);\n                        }\n                        if (options.newline === true) {\n                            if (options.crlf === true) {\n                                build.push("\\r\\n");\n                            } else {\n                                build.push("\\n");\n                            }\n                        }\n                        if (options.nodeasync === true) {\n                            return [\n                                build\n                                    .join("")\n                                    .replace(/(\\s+)$/, ""),\n                                globalerror\n                            ];\n                        }\n                        return build\n                            .join("")\n                            .replace(/(\\s+)$/, "");\n                    }());\n                }\n            }());\n            //the analysis report is generated in this function\n            if (options.mode === "analysis") {\n                return (function jspretty__report() {\n                    var noOfLines = result\n                            .split(lf)\n                            .length,\n                        newlines  = stats.space.newline,\n                        percent   = 0,\n                        total     = {\n                            chars  : 0,\n                            comment: {\n                                chars: stats.commentBlock.chars + stats.commentLine.chars,\n                                token: stats.commentBlock.token + stats.commentLine.token\n                            },\n                            literal: {\n                                chars: stats.number.chars + stats.regex.chars + stats.string.chars,\n                                token: stats.number.token + stats.regex.token + stats.string.token\n                            },\n                            space  : stats.space.newline + stats.space.other + stats.space.space + stats.space.tab,\n                            syntax : {\n                                chars: 0,\n                                token: stats.string.quote + stats.comma + stats.semicolon + stats.container\n                            },\n                            token  : 0\n                        },\n                        output    = [],\n                        zero      = function jspretty__report_zero(x, y) {\n                            var ratio = 0;\n                            if (y === 0) {\n                                return "0.00%";\n                            }\n                            ratio = ((x / y) * 100);\n                            return ratio.toFixed(2) + "%";\n                        };\n                    total.syntax.chars = total.syntax.token + stats.operator.chars;\n                    total.syntax.token = total.syntax.token + stats.operator.token;\n                    total.token        = stats.server.token + stats.word.token + total.comment.token +\n                            total.literal.token + total.space + total.syntax.token;\n                    total.chars        = stats.server.chars + stats.word.chars + total.comment.chars +\n                            total.literal.chars + total.space + total.syntax.chars;\n                    if (newlines === 0) {\n                        newlines = 1;\n                    }\n                    output.push("<div class=\'report\'>");\n                    if (error.length > 0) {\n                        output.push("<p id=\'jserror\'><strong>Error: ");\n                        output.push(\n                            error[0].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(options.functions.binaryCheck, "")\n                        );\n                        output.push("</strong> <code><span>");\n                        error[1] = error[1]\n                            .replace(/&/g, "&amp;")\n                            .replace(/</g, "&lt;")\n                            .replace(/>/g, "&gt;")\n                            .replace(options.functions.binaryCheck, "")\n                            .replace(/^(\\s+)/, "");\n                        if (error.indexOf("\\n") > 0) {\n                            output.push(error[1].replace(lf, "</span>"));\n                        } else {\n                            output.push(error[1]);\n                            output.push("</span>");\n                        }\n                        output.push("</code></p>");\n                    }\n                    output.push("<p><em>");\n                    output.push(scolon);\n                    output.push("</em> instance");\n                    if (scolon !== 1) {\n                        output.push("s");\n                    }\n                    output.push(" of <strong>missing semicolons</strong> counted.</p>");\n                    output.push("<p><em>");\n                    output.push(news);\n                    output.push("</em> unnessary instance");\n                    if (news !== 1) {\n                        output.push("s");\n                    }\n                    output.push(" of the keyword <strong>new</strong> counted.</p>");\n                    output.push(\n                        "<table class=\'analysis\' summary=\'JavaScript character size comparison\'><captio" +\n                        "n>JavaScript data report</caption><thead><tr><th>Data Label</th><th>Input</th>" +\n                        "<th>Output</th><th>Literal Increase</th><th>Percentage Increase</th></tr>"\n                    );\n                    output.push("</thead><tbody><tr><th>Total Character Size</th><td>");\n                    output.push(originalSize);\n                    output.push("</td><td>");\n                    output.push(result.length);\n                    output.push("</td><td>");\n                    output.push(result.length - originalSize);\n                    output.push("</td><td>");\n                    percent = (((result.length - originalSize) / originalSize) * 100);\n                    output.push(percent.toFixed(2));\n                    output.push("%</td></tr><tr><th>Total Lines of Code</th><td>");\n                    output.push(newlines);\n                    output.push("</td><td>");\n                    output.push(noOfLines);\n                    output.push("</td><td>");\n                    output.push(noOfLines - newlines);\n                    output.push("</td><td>");\n                    percent = (((noOfLines - newlines) / newlines) * 100);\n                    output.push(percent.toFixed(2));\n                    output.push("%</td></tr></tbody></table>");\n                    output.push(\n                        "<table class=\'analysis\' summary=\'JavaScript component analysis\'><caption>JavaS" +\n                        "cript component analysis</caption><thead><tr><th>JavaScript Component</th><th>" +\n                        "Component Quantity</th><th>Percentage Quantity from Section</th>"\n                    );\n                    output.push(\n                        "<th>Percentage Qauntity from Total</th><th>Character Length</th><th>Percentage" +\n                        " Length from Section</th><th>Percentage Length from Total</th></tr></thead><tb" +\n                        "ody>"\n                    );\n                    output.push("<tr><th>Total Accounted</th><td>");\n                    output.push(total.token);\n                    output.push("</td><td>100.00%</td><td>100.00%</td><td>");\n                    output.push(total.chars);\n                    output.push(\n                        "</td><td>100.00%</td><td>100.00%</td></tr><tr><th colspan=\'7\'>Comments</th></t" +\n                        "r><tr><th>Block Comments</th><td>"\n                    );\n                    output.push(stats.commentBlock.token);\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentBlock.token, total.comment.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentBlock.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.commentBlock.chars);\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentBlock.chars, total.comment.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentBlock.chars, total.chars));\n                    output.push("</td></tr><tr><th>Inline Comments</th><td>");\n                    output.push(stats.commentLine.token);\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentLine.token, total.comment.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentLine.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.commentLine.chars);\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentLine.chars, total.comment.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.commentLine.chars, total.chars));\n                    output.push("</td></tr><tr><th>Comment Total</th><td>");\n                    output.push(total.comment.token);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.comment.token, total.token));\n                    output.push("</td><td>");\n                    output.push(total.comment.chars);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.comment.chars, total.chars));\n                    output.push(\n                        "</td></tr><tr><th colspan=\'7\'>Whitespace Outside of Strings and Comments</th><" +\n                        "/tr><tr><th>New Lines</th><td>"\n                    );\n                    output.push(stats.space.newline);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.newline, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.newline, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.space.newline);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.newline, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.newline, total.chars));\n                    output.push("</td></tr><tr><th>Spaces</th><td>");\n                    output.push(stats.space.space);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.space, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.space, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.space.space);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.space, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.space, total.chars));\n                    output.push("</td></tr><tr><th>Tabs</th><td>");\n                    output.push(stats.space.tab);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.tab, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.tab, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.space.tab);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.tab, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.tab, total.chars));\n                    output.push("</td></tr><tr><th>Other Whitespace</th><td>");\n                    output.push(stats.space.other);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.other, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.other, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.space.other);\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.other, total.space));\n                    output.push("</td><td>");\n                    output.push(zero(stats.space.other, total.chars));\n                    output.push("</td></tr><tr><th>Total Whitespace</th><td>");\n                    output.push(total.space);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.space, total.token));\n                    output.push("</td><td>");\n                    output.push(total.space);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.space, total.chars));\n                    output.push(\n                        "</td></tr><tr><th colspan=\'7\'>Literals</th></tr><tr><th>Strings</th><td>"\n                    );\n                    output.push(stats.string.token);\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.token, total.literal.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.string.chars);\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.chars, total.literal.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.chars, total.chars));\n                    output.push("</td></tr><tr><th>Numbers</th><td>");\n                    output.push(stats.number.token);\n                    output.push("</td><td>");\n                    output.push(zero(stats.number.token, total.literal.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.number.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.number.chars);\n                    output.push("</td><td>");\n                    output.push(zero(stats.number.chars, total.literal.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.number.chars, total.chars));\n                    output.push("</td></tr><tr><th>Regular Expressions</th><td>");\n                    output.push(stats.regex.token);\n                    output.push("</td><td>");\n                    output.push(zero(stats.regex.token, total.literal.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.regex.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.regex.chars);\n                    output.push("</td><td>");\n                    output.push(zero(stats.regex.chars, total.literal.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.regex.chars, total.chars));\n                    output.push("</td></tr><tr><th>Total Literals</th><td>");\n                    output.push(total.literal.token);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.literal.token, total.token));\n                    output.push("</td><td>");\n                    output.push(total.literal.chars);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.literal.chars, total.chars));\n                    output.push(\n                        "</td></tr><tr><th colspan=\'7\'>Syntax Characters</th></tr><tr><th>Quote Charact" +\n                        "ers</th><td>"\n                    );\n                    output.push(stats.string.quote);\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.quote, total.syntax.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.quote, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.string.quote);\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.quote, total.syntax.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.string.quote, total.chars));\n                    output.push("</td></tr><tr><th>Commas</th><td>");\n                    output.push(stats.comma);\n                    output.push("</td><td>");\n                    output.push(zero(stats.comma, total.syntax.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.comma, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.comma);\n                    output.push("</td><td>");\n                    output.push(zero(stats.comma, total.syntax.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.comma, total.chars));\n                    output.push("</td></tr><tr><th>Containment Characters</th><td>");\n                    output.push(stats.container);\n                    output.push("</td><td>");\n                    output.push(zero(stats.container, total.syntax.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.container, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.container);\n                    output.push("</td><td>");\n                    output.push(zero(stats.container, total.syntax.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.container, total.chars));\n                    output.push("</td></tr><tr><th>Semicolons</th><td>");\n                    output.push(stats.semicolon);\n                    output.push("</td><td>");\n                    output.push(zero(stats.semicolon, total.syntax.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.semicolon, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.semicolon);\n                    output.push("</td><td>");\n                    output.push(zero(stats.semicolon, total.syntax.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.semicolon, total.chars));\n                    output.push("</td></tr><tr><th>Operators</th><td>");\n                    output.push(stats.operator.token);\n                    output.push("</td><td>");\n                    output.push(zero(stats.operator.token, total.syntax.token));\n                    output.push("</td><td>");\n                    output.push(zero(stats.operator.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.operator.chars);\n                    output.push("</td><td>");\n                    output.push(zero(stats.operator.chars, total.syntax.chars));\n                    output.push("</td><td>");\n                    output.push(zero(stats.operator.chars, total.chars));\n                    output.push("</td></tr><tr><th>Total Syntax Characters</th><td>");\n                    output.push(total.syntax.token);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.syntax.token, total.token));\n                    output.push("</td><td>");\n                    output.push(total.syntax.chars);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(total.syntax.chars, total.chars));\n                    output.push("</td></tr>");\n                    output.push(\n                        "<tr><th colspan=\'7\'>Keywords and Variables</th></tr><tr><th>Words</th><td>"\n                    );\n                    output.push(stats.word.token);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(stats.word.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.word.chars);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(stats.word.chars, total.chars));\n                    output.push("</td></tr>");\n                    output.push(\n                        "<tr><th colspan=\'7\'>Server-side Tags</th></tr><tr><th>Server Tags</th><td>"\n                    );\n                    output.push(stats.server.token);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(stats.server.token, total.token));\n                    output.push("</td><td>");\n                    output.push(stats.server.chars);\n                    output.push("</td><td>100.00%</td><td>");\n                    output.push(zero(stats.server.chars, total.chars));\n                    output.push("</td></tr></tbody></table></div>");\n                    if (options.nodeasync === true) {\n                        return [output.join(""), globalerror];\n                    }\n                    return output.join("");\n                }());\n            }\n        }\n        return result;\n    };\n\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function jspretty_requirejs() {\n            return function jspretty_requirejs_wrapper(x) {\n                return jspretty(x);\n            };\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = jspretty;\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n            (function glib_jspretty() {\n                var localPath = (\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\n                )\n                    ? __dirname\n                    : ".";\n                if (global.prettydiff.markuppretty === undefined) {\n                    global.prettydiff.markuppretty = require(\n                        localPath + "/markuppretty.js"\n                    );\n                }\n            }());\n        }\n    } else {\n        global.prettydiff.jspretty = jspretty;\n    }\n}());\n'},function(n,e,t){"use strict";t(1)(t(46))},function(n,e){n.exports='/*prettydiff.com api.topcoms:true,api.insize:4,api.inchar:" ",api.vertical:true */\n/*jshint laxbreak: true*/\n/*global __dirname, ace, define, global, module, process, require*/\n/***********************************************************************\n markuppretty is written by Austin Cheney on 20 Jun 2015.\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n **********************************************************************/\n/* A simple parser for XML, HTML, and a variety of template schemes. It\n beautifies, minifies, and peforms a series of analysis*/\n(function markuppretty_init() {\n    "use strict";\n    var markuppretty = function markuppretty_(options) {\n        var safeSort    = global.prettydiff.safeSort,\n            output      = "",\n            stats       = {\n                cdata      : [\n                    0, 0\n                ],\n                comment    : [\n                    0, 0\n                ],\n                conditional: [\n                    0, 0\n                ],\n                content    : [\n                    0, 0\n                ],\n                end        : [\n                    0, 0\n                ],\n                ignore     : [\n                    0, 0\n                ],\n                script     : [\n                    0, 0\n                ],\n                sgml       : [\n                    0, 0\n                ],\n                singleton  : [\n                    0, 0\n                ],\n                space      : 0,\n                start      : [\n                    0, 0\n                ],\n                style      : [\n                    0, 0\n                ],\n                template   : [\n                    0, 0\n                ],\n                text       : [\n                    0, 0\n                ],\n                xml        : [0, 0]\n            },\n\n            //parallel arrays\n            // * attrs is a list of arrays, each of which contains (if any) parsed\n            // attributes\n            // * begin stores the index of the current token\'s parent element\n            // * daddy stores the tag name of the parent element\n            // * jscom stores true/false if the current token is a JS comment from JSX\n            // format\n            // * level describes the indentation of a given token level is only used in\n            // beautify and diff modes\n            // * linen stores the input line number on which the token occurs\n            // * lines describes the preceeding space using: 2, 1, or 0 lines is populated\n            // in markuppretty__tokenize_spacer\n            // * presv whether a given token should be preserved as provided\n            // * token stores parsed tokens\n            // * types segments tokens into named groups\n            // * value attribute value if current type is attribute and\n            // options.attributetoken is true\n            attrs       = [],\n            jscom       = [],\n            level       = [],\n            linen       = [],\n            lines       = [],\n            token       = [],\n            types       = [],\n            presv       = [],\n            daddy       = [],\n            begin       = [],\n            value       = [],\n            reqs        = [],\n            ids         = [],\n            parseError  = [],\n            parent      = [\n                ["none", -1]\n            ],\n            line        = 1,\n            wrap        = options.wrap,\n            objsortop   = false,\n            globalerror = "",\n            lf          = (options.crlf === true || options.crlf === "true")\n                ? "\\r\\n"\n                : "\\n",\n            sourceSize  = options.source.length,\n            extlib      = function markuppretty__extlib(type) {\n                var result = "",\n                    newline = options.newline;\n                if (type === "script" && typeof global.prettydiff.jspretty !== "function") {\n                    return options.source;\n                }\n                if (type === "style" && typeof global.prettydiff.csspretty !== "function") {\n                    return options.source;\n                }\n                options.newline = false;\n                result = (type === "script")\n                    ? global\n                        .prettydiff\n                        .jspretty(options)\n                    : global\n                        .prettydiff\n                        .csspretty(options);\n                options.newline = newline;\n                if (options.nodeasync === true) {\n                    if (globalerror === "") {\n                        globalerror = result[1];\n                    }\n                    if (options.mode === "parse") {\n                        if (options.parseFormat === "htmltable") {\n                            if (type === "script") {\n                                return result[0]\n                                    .data\n                                    .replace(\n                                        "<thead>",\n                                        "<thead><tr><th colspan=\\"6\\" class=\\"nested\\">JavaScript tokens</th></tr>"\n                                    );\n                            }\n                            return result[0]\n                                .data\n                                .replace(\n                                    "<thead>",\n                                    "<thead><tr><th colspan=\\"4\\" class=\\"nested\\">CSS tokens</th></tr>"\n                                );\n                        }\n                        return result[0].data;\n                    }\n                    return result[0];\n                }\n                if (options.mode === "parse") {\n                    if (options.parseFormat === "htmltable") {\n                        if (type === "script") {\n                            return result\n                                .data\n                                .replace(\n                                    "<thead>",\n                                    "<thead><tr><th colspan=\\"6\\" class=\\"nested\\">JavaScript tokens</th></tr>"\n                                );\n                        }\n                        return result\n                            .data\n                            .replace(\n                                "<thead>",\n                                "<thead><tr><th colspan=\\"4\\" class=\\"nested\\">CSS tokens</th></tr>"\n                            );\n                    }\n                    return result.data;\n                }\n                return result;\n            },\n            //What is the lowercase tag name of the provided token?\n            tagName     = function markuppretty__tagName(el) {\n                var space = el\n                        .replace(/^(\\{((%-?)|\\{-?)\\s*)/, "%")\n                        .replace(/\\s+/, " ")\n                        .indexOf(" "),\n                    name  = (space < 0)\n                        ? el\n                            .replace(/^(\\{((%-?)|\\{-?)\\s*)/, " ")\n                            .slice(1, el.length - 1)\n                            .toLowerCase()\n                        : el\n                            .replace(/^(\\{((%-?)|\\{-?)\\s*)/, " ")\n                            .slice(1, space)\n                            .toLowerCase();\n                name = name.replace(/(\\}\\})$/, "");\n                if (name.indexOf("(") > 0) {\n                    name = name.slice(0, name.indexOf("("));\n                }\n                return name;\n            };\n\n        (function markuppretty__options() {\n            objsortop      = (\n                options.objsort === true || options.objsort === "true" || options.objsort === "all" || options.objsort === "markup"\n            );\n            options.source = (\n                typeof options.source === "string" && options.source.length > 0\n            )\n                ? options\n                    .source\n                    .replace(/\\r\\n?/g, "\\n")\n                : "Error: no source code supplied to markuppretty!";\n            if (options.mode === "analysis") {\n                options.accessibility = true;\n            }\n        }());\n        //type definitions:\n        // * start      end     type\n        // * <![CDATA[   ]]>    cdata\n        // * \x3c!--       --\x3e     comment\n        // * <#--       --\x3e     comment\n        // * <%--       --%>    comment\n        // * {!         !}      comment\n        // * \x3c!--[if    --\x3e     conditional\n        // * text       text    content\n        // * </         >       end\n        // * <pre       </pre>  ignore (html only)\n        // * text       text    script\n        // * <!         >       sgml\n        // * <          />      singleton\n        // * <          >       start\n        // * text       text    style\n        // * \x3c!--#      --\x3e     template\n        // * <%         %>      template\n        // * {{{        }}}     template\n        // * {{         }}      template\n        // * {%         %}      template\n        // * [%         %]      template\n        // * {@         @}      template\n        // * {#         #}      template\n        // * {#         /}      template\n        // * {?         /}      template\n        // * {^         /}      template\n        // * {@         /}      template\n        // * {<         /}      template\n        // * {+         /}      template\n        // * {~         }       template\n        // * <?         ?>      template\n        // * {:else}            template_else\n        // * <#else     >       template_else\n        // * {@}else{@}         template_else\n        // * <%}else{%>         template_else\n        // * {{         }}      template_end\n        // * <%\\s*}     %>      template_end\n        // * [%\\s*}     %]      template_end\n        // * {@\\s*}     @}      template_end\n        // * {          }       template_end\n        // * {{#        }}      template_start\n        // * <%         {\\s*%>  template_start\n        // * [%         {\\s*%]  template_start\n        // * {@         {\\s*@}  template_start\n        // * {#         }       template_start\n        // * {?         }       template_start\n        // * {^         }       template_start\n        // * {@         }       template_start\n        // * {<         }       template_start\n        // * {+         }       template_start\n        // * <?xml      ?>      xml\n        if (options.mode !== "diff") {\n            options.content = false;\n        }\n        if (options.jsx === true) {\n            options.dustjs = false;\n        }\n        (function markuppretty__tokenize() {\n            var a             = 0,\n                b             = options\n                    .source\n                    .split(""),\n                c             = b.length,\n                minspace      = "",\n                space         = "",\n                list          = 0,\n                litag         = 0,\n                linepreserve  = 0,\n                cftransaction = false,\n                sgmlflag      = 0,\n                ext           = false,\n                //cftags is a list of supported coldfusion tags\n                //* required - means must have a separate matching end tag\n                // * optional - means the tag could have a separate end tag, but is probably a\n                // singleton\n                //* prohibited - means there is not corresponding end tag\n                cftags        = {\n                    cfabort               : "prohibited",\n                    cfajaximport          : "optional",\n                    cfajaxproxy           : "optional",\n                    cfapplet              : "prohibited",\n                    cfapplication         : "prohibited",\n                    cfargument            : "prohibited",\n                    cfassociate           : "prohibited",\n                    cfauthenticate        : "prohibited",\n                    cfbreak               : "prohibited",\n                    cfcache               : "optional",\n                    cfcalendar            : "optional",\n                    cfcase                : "required",\n                    cfcatch               : "required",\n                    cfchart               : "optional",\n                    cfchartdata           : "prohibited",\n                    cfchartseries         : "optional",\n                    cfclient              : "required",\n                    cfclientsettings      : "optional",\n                    cfcol                 : "prohibited",\n                    cfcollection          : "prohibited",\n                    cfcomponent           : "required",\n                    cfcontent             : "optional",\n                    cfcontinue            : "prohibited",\n                    cfcookie              : "prohibited",\n                    cfdbinfo              : "prohibited",\n                    cfdefaultcase         : "required",\n                    cfdirectory           : "prohibited",\n                    cfdiv                 : "optional",\n                    cfdocument            : "optional",\n                    cfdocumentitem        : "optional",\n                    cfdocumentsection     : "optional",\n                    cfdump                : "optional",\n                    cfelse                : "prohibited",\n                    cfelseif              : "prohibited",\n                    cferror               : "prohibited",\n                    cfexchangecalendar    : "optional",\n                    cfexchangeconnection  : "optional",\n                    cfexchangecontact     : "optional",\n                    cfexchangeconversation: "optional",\n                    cfexchangefilter      : "optional",\n                    cfexchangefolder      : "optional",\n                    cfexchangemail        : "optional",\n                    cfexchangetask        : "optional",\n                    cfexecute             : "required",\n                    cfexit                : "prohibited",\n                    cffeed                : "prohibited",\n                    cffile                : "optional",\n                    cffileupload          : "optional",\n                    cffinally             : "required",\n                    cfflush               : "prohibited",\n                    cfform                : "required",\n                    cfformgroup           : "required",\n                    cfformitem            : "optional",\n                    cfforward             : "prohibited",\n                    cfftp                 : "prohibited",\n                    cffunction            : "required",\n                    cfgraph               : "required",\n                    cfgraphdata           : "prohibited",\n                    cfgrid                : "required",\n                    cfgridcolumn          : "optional",\n                    cfgridrow             : "optional",\n                    cfgridupdate          : "optional",\n                    cfheader              : "prohibited",\n                    cfhtmlbody            : "optional",\n                    cfhtmlhead            : "optional",\n                    cfhtmltopdf           : "optional",\n                    cfhtmltopdfitem       : "optional",\n                    cfhttp                : "optional",\n                    cfhttpparam           : "prohibited",\n                    cfif                  : "required",\n                    cfimage               : "prohibited",\n                    cfimap                : "prohibited",\n                    cfimapfilter          : "optional",\n                    cfimport              : "prohibited",\n                    cfinclude             : "prohibited",\n                    cfindex               : "prohibited",\n                    cfinput               : "prohibited",\n                    cfinsert              : "prohibited",\n                    cfinterface           : "required",\n                    cfinvoke              : "optional",\n                    cfinvokeargument      : "prohibited",\n                    cflayout              : "optional",\n                    cflayoutarea          : "optional",\n                    cfldap                : "prohibited",\n                    cflocation            : "prohibited",\n                    cflock                : "required",\n                    cflog                 : "prohibited",\n                    cflogic               : "required",\n                    cfloginuser           : "prohibited",\n                    cflogout              : "prohibited",\n                    cfloop                : "required",\n                    cfmail                : "required",\n                    cfmailparam           : "prohibited",\n                    cfmailpart            : "required",\n                    cfmap                 : "optional",\n                    cfmapitem             : "optional",\n                    cfmediaplayer         : "optional",\n                    cfmenu                : "required",\n                    cfmenuitem            : "optional",\n                    cfmessagebox          : "optional",\n                    cfmodule              : "optional",\n                    cfNTauthenticate      : "optional",\n                    cfoauth               : "optional",\n                    cfobject              : "prohibited",\n                    cfobjectcache         : "prohibited",\n                    cfoutput              : "required",\n                    cfpageencoding        : "optional",\n                    cfparam               : "prohibited",\n                    cfpdf                 : "optional",\n                    cfpdfform             : "optional",\n                    cfpdfformparam        : "optional",\n                    cfpdfparam            : "prohibited",\n                    cfpdfsubform          : "required",\n                    cfpod                 : "optional",\n                    cfpop                 : "prohibited",\n                    cfpresentation        : "required",\n                    cfpresentationslide   : "optional",\n                    cfpresenter           : "optional",\n                    cfprint               : "optional",\n                    cfprocessingdirective : "optional",\n                    cfprocparam           : "prohibited",\n                    cfprocresult          : "prohibited",\n                    cfprogressbar         : "optional",\n                    cfproperty            : "prohibited",\n                    cfquery               : "required",\n                    cfqueryparam          : "prohibited",\n                    cfregistry            : "prohibited",\n                    cfreport              : "optional",\n                    cfreportparam         : "optional",\n                    cfrethrow             : "prohibited",\n                    cfretry               : "prohibited",\n                    cfreturn              : "prohibited",\n                    cfsavecontent         : "required",\n                    cfschedule            : "prohibited",\n                    cfscript              : "required",\n                    cfsearch              : "prohibited",\n                    cfselect              : "required",\n                    cfservlet             : "prohibited",\n                    cfservletparam        : "prohibited",\n                    cfset                 : "prohibited",\n                    cfsetting             : "optional",\n                    cfsharepoint          : "optional",\n                    cfsilent              : "required",\n                    cfsleep               : "prohibited",\n                    cfslider              : "prohibited",\n                    cfspreadsheet         : "optional",\n                    cfsprydataset         : "optional",\n                    cfstatic              : "required",\n                    cfstopwatch           : "required",\n                    cfstoredproc          : "optional",\n                    cfswitch              : "required",\n                    cftable               : "required",\n                    cftextarea            : "optional",\n                    cfthread              : "optional",\n                    cfthrow               : "prohibited",\n                    cftimer               : "required",\n                    cftooltip             : "required",\n                    cftrace               : "optional",\n                    cftransaction         : "required",\n                    cftree                : "required",\n                    cftreeitem            : "optional",\n                    cftry                 : "required",\n                    cfupdate              : "prohibited",\n                    cfvideo               : "prohibited",\n                    cfvideoplayer         : "optional",\n                    cfwddx                : "prohibited",\n                    cfwebsocket           : "optional",\n                    cfwhile               : "required",\n                    cfwindow              : "optional",\n                    cfx_                  : "prohibited",\n                    cfxml                 : "required",\n                    cfzip                 : "optional",\n                    cfzipparam            : "prohibited"\n                },\n                // determine if spaces between nodes are absent, multiline, or merely there 2 -\n                // multiline 1 - space present 0 - no space present\n                spacer        = function markuppretty__tokenize_spacer() {\n                    var linea = 0;\n                    if (space.length > 0) {\n                        stats.space = stats.space + space.length;\n                        linea       = space\n                            .split("\\n")\n                            .length - 1;\n                        if (options.preserve > 0 && linea > 1) {\n                            if (linea > options.preserve + 1) {\n                                lines.push(options.preserve + 1);\n                            } else {\n                                lines.push(linea);\n                            }\n                        } else {\n                            lines.push(1);\n                        }\n                    } else {\n                        lines.push(0);\n                    }\n                    minspace = space;\n                    space    = "";\n                },\n                //parses tags, attributes, and template elements\n                tag           = function markuppretty__tokenize_tag(end) {\n                    var lexer     = [],\n                        bcount    = 0,\n                        e         = 0,\n                        f         = 0,\n                        igcount   = 0,\n                        jsxcount  = 0,\n                        braccount = 0,\n                        parncount = 0,\n                        quote     = "",\n                        element   = "",\n                        lastchar  = "",\n                        jsxquote  = "",\n                        tname     = "",\n                        comment   = false,\n                        cheat     = false,\n                        endtag    = false,\n                        nopush    = false,\n                        nosort    = false,\n                        simple    = false,\n                        preserve  = false,\n                        stest     = false,\n                        liend     = false,\n                        ignoreme  = false,\n                        quotetest = false,\n                        parseFail = false,\n                        singleton = false,\n                        earlyexit = false,\n                        attribute = [],\n                        attstore  = [],\n                        presend   = {\n                            cfquery: true\n                        },\n                        arname    = function markuppretty__tokenize_tag_name(x) {\n                            var eq = x.indexOf("=");\n                            if (eq > 0 && ((eq < x.indexOf("\\"") && x.indexOf("\\"") > 0) || (eq < x.indexOf("\'") && x.indexOf("\'") > 0))) {\n                                return x.slice(0, eq);\n                            }\n                            return x;\n                        },\n                        slashy    = function markuppretty__tokenize_tag_slashy() {\n                            var x = a;\n                            do {\n                                x = x - 1;\n                            } while (b[x] === "\\\\");\n                            x = a - x;\n                            if (x % 2 === 1) {\n                                return false;\n                            }\n                            return true;\n                        },\n                        attrpush  = function markuppretty__tokenize_tag_attrpush(quotes) {\n                            var atty = "",\n                                name = "",\n                                aa   = 0,\n                                bb   = 0;\n                            if (quotes === true) {\n                                if (quote === "\\"" && options.quoteConvert === "single") {\n                                    atty = attribute\n                                        .slice(0, attribute.length - 1)\n                                        .join("")\n                                        .replace(/\'/g, "\\"")\n                                        .replace(/"/, "\'") + "\'";\n                                } else if (quote === "\'" && options.quoteConvert === "double") {\n                                    atty = attribute\n                                        .slice(0, attribute.length - 1)\n                                        .join("")\n                                        .replace(/"/g, "\'")\n                                        .replace(/\'/, "\\"") + "\\"";\n                                } else {\n                                    atty = attribute.join("");\n                                }\n                                name = arname(atty);\n                                if (name === "data-prettydiff-ignore") {\n                                    ignoreme = true;\n                                } else if (name === "id") {\n                                    ids.push(atty.slice(name.length + 2, atty.length - 1));\n                                } else if (name === "schemaLocation") {\n                                    reqs.push(atty.slice(name.length + 2, atty.length - 1));\n                                }\n                                quote = "";\n                            } else {\n                                atty = attribute\n                                    .join("")\n                                    .replace(/\\s+/g, " ");\n                                name = arname(atty);\n                                if (name === "data-prettydiff-ignore") {\n                                    ignoreme = true;\n                                } else if (name === "id") {\n                                    ids.push(element.slice(name.length + 1, atty.length));\n                                }\n                                if (options.jsx === true && attribute[0] === "{" && attribute[attribute.length - 1] === "}") {\n                                    jsxcount = 0;\n                                }\n                            }\n                            if (atty.slice(0, 3) === "<%=" || atty.slice(0, 2) === "{%") {\n                                nosort = true;\n                            }\n                            atty      = atty\n                                .replace(/^\\u0020/, "")\n                                .replace(/\\u0020$/, "");\n                            attribute = atty\n                                .replace(/\\r\\n/g, "\\n")\n                                .split("\\n");\n                            bb        = attribute.length;\n                            for (aa = 0; aa < bb; aa = aa + 1) {\n                                attribute[aa] = attribute[aa].replace(/(\\s+)$/, "");\n                            }\n                            atty = attribute.join(lf);\n                            if (atty === "=") {\n                                attstore[attstore.length - 1] = attstore[attstore.length - 1] + "=";\n                            } else if (atty.charAt(0) === "=" && attstore.length > 0 && attstore[attstore.length - 1].indexOf("=") < 0) {\n                                //if an attribute starts with a `=` then adjoin it to the last attribute\n                                attstore[attstore.length - 1] = attstore[attstore.length - 1] + atty;\n                            } else if (atty.charAt(0) !== "=" && attstore.length > 0 && attstore[attstore.length - 1].indexOf("=") === attstore[attstore.length - 1].length - 1) {\n                                // if an attribute follows an attribute ending with `=` then adjoin it to the\n                                // last attribute\n                                attstore[attstore.length - 1] = attstore[attstore.length - 1] + atty;\n                            } else if (atty !== "" && atty !== " ") {\n                                attstore.push(atty);\n                            }\n                            attribute = [];\n                        };\n                    spacer();\n                    jscom.push(false);\n                    linen.push(line);\n                    value.push("");\n                    ext = false;\n                    // this complex series of conditions determines an elements delimiters look to\n                    // the types being pushed to quickly reason about the logic no type is pushed\n                    // for start tags or singleton tags just yet some types set the `preserve` flag,\n                    // which means to preserve internal white space The `nopush` flag is set when\n                    // parsed tags are to be ignored and forgotten\n                    (function markuppretty__tokenize_types() {\n                        if (end === "]>") {\n                            end      = ">";\n                            sgmlflag = sgmlflag - 1;\n                            types.push("template_end");\n                        } else if (end === "---") {\n                            preserve = true;\n                            types.push("comment");\n                        } else if (b[a] === "<") {\n                            if (b[a + 1] === "/") {\n                                if (b[a + 2] === "#") {\n                                    types.push("template_end");\n                                } else {\n                                    types.push("end");\n                                }\n                                end = ">";\n                            } else if (b[a + 1] === "!") {\n                                if (b[a + 2] === "-" && b[a + 3] === "-") {\n                                    if (b[a + 4] === "#") {\n                                        end = "--\x3e";\n                                        types.push("template");\n                                    } else if (b[a + 4] === "[" && b[a + 5] === "i" && b[a + 6] === "f" && options.conditional === true) {\n                                        end = "--\x3e";\n                                        types.push("conditional");\n                                    } else if (b[a + 4] === "-" && (/<cf[a-z]/i).test(options.source) === true) {\n                                        preserve = true;\n                                        comment  = true;\n                                        end      = "---\x3e";\n                                        types.push("comment");\n                                    } else {\n                                        end = "--\x3e";\n                                        if (options.mode === "minify" || options.comments === "nocomment") {\n                                            nopush  = true;\n                                            comment = true;\n                                        } else {\n                                            if (options.preserveComment === true) {\n                                                preserve = true;\n                                            }\n                                            comment  = true;\n                                            if (options.commline === true) {\n                                                lines[lines.length - 1] = 2;\n                                            }\n                                            types.push("comment");\n                                        }\n                                    }\n                                } else if (b[a + 2] === "[" && b[a + 3] === "C" && b[a + 4] === "D" && b[a + 5] === "A" && b[a + 6] === "T" && b[a + 7] === "A" && b[a + 8] === "[") {\n                                    end      = "]]>";\n                                    preserve = true;\n                                    comment  = true;\n                                    types.push("cdata");\n                                } else {\n                                    end      = ">";\n                                    sgmlflag = sgmlflag + 1;\n                                    types.push("sgml");\n                                }\n                            } else if (b[a + 1] === "?") {\n                                end = "?>";\n                                if (b[a + 2] === "x" && b[a + 3] === "m" && b[a + 4] === "l") {\n                                    types.push("xml");\n                                } else {\n                                    preserve = true;\n                                    types.push("template");\n                                }\n                            } else if (b[a + 1] === "%") {\n                                if (b[a + 2] !== "=") {\n                                    preserve = true;\n                                }\n                                if (b[a + 2] === "-" && b[a + 3] === "-") {\n                                    end     = "--%>";\n                                    comment = true;\n                                    if (options.commline === true) {\n                                        line[line.length - 1] = 2;\n                                    }\n                                    types.push("comment");\n                                } else if (b[a + 2] === "#") {\n                                    end     = "%>";\n                                    comment = true;\n                                    if (options.commline === true) {\n                                        line[line.length - 1] = 2;\n                                    }\n                                    types.push("comment");\n                                } else {\n                                    end = "%>";\n                                    types.push("template");\n                                }\n                            } else if (b[a + 4] !== undefined && b[a + 1].toLowerCase() === "p" && b[a + 2].toLowerCase() === "r" && b[a + 3].toLowerCase() === "e" && (b[a + 4] === ">" || (/\\s/).test(b[a + 4]) === true)) {\n                                end      = "</pre>";\n                                preserve = true;\n                                types.push("ignore");\n                            } else if (b[a + 4] !== undefined && b[a + 1].toLowerCase() === "x" && b[a + 2].toLowerCase() === "s" && b[a + 3].toLowerCase() === "l" && b[a + 4].toLowerCase() === ":" && b[a + 5].toLowerCase() === "t" && b[a + 6].toLowerCase() === "e" && b[a + 7].toLowerCase() === "x" && b[a + 8].toLowerCase() === "t" && (b[a + 9] === ">" || (/\\s/).test(b[a + 9]) === true)) {\n                                end      = "</xsl:text>";\n                                preserve = true;\n                                types.push("ignore");\n                            } else if (b[a + 8] !== undefined && b[a + 1].toLowerCase() === "c" && b[a + 2].toLowerCase() === "f" && b[a + 3].toLowerCase() === "q" && b[a + 4].toLowerCase() === "u" && b[a + 5].toLowerCase() === "e" && b[a + 6].toLowerCase() === "r" && b[a + 7].toLowerCase() === "y" && (b[a + 8] === ">" || (/\\s/).test(b[a + 8]))) {\n                                end          = ">";\n                                linepreserve = linepreserve + 1;\n                                types.push("linepreserve");\n                            } else if (b[a + 1] === "<") {\n                                if (b[a + 2] === "<") {\n                                    end = ">>>";\n                                } else {\n                                    end = ">>";\n                                }\n                                types.push("template");\n                            } else if (b[a + 1] === "#") {\n                                if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {\n                                    end = ">";\n                                    types.push("template_else");\n                                } else if (b[a + 2] === "-" && b[a + 3] === "-") {\n                                    end = "--\x3e";\n                                    types.push("comment");\n                                    preserve = true;\n                                } else {\n                                    end = ">";\n                                    types.push("template_start");\n                                }\n                            } else {\n                                simple = true;\n                                end    = ">";\n                            }\n                        } else if (b[a] === "{") {\n                            preserve = true;\n                            if (options.jsx === true) {\n                                end = "}";\n                                types.push("script");\n                            } else if (options.dustjs === true) {\n                                if (b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {\n                                    a = a + 6;\n                                    token.push("{:else}");\n                                    presv.push(true);\n                                    daddy.push(parent[parent.length - 1][0]);\n                                    begin.push(parent[parent.length - 1][1]);\n                                    attrs.push({});\n                                    stats.template[0] = stats.template[0] + 1;\n                                    stats.template[1] = stats.template[1] + 7;\n                                    earlyexit         = true;\n                                    return types.push("template_else");\n                                }\n                                if (b[a + 1] === "!") {\n                                    end     = "!}";\n                                    comment = true;\n                                    types.push("comment");\n                                } else if (b[a + 1] === "/") {\n                                    end = "}";\n                                    types.push("template_end");\n                                } else if (b[a + 1] === "~") {\n                                    end = "}";\n                                    types.push("singleton");\n                                } else if (b[a + 1] === ">") {\n                                    end = "/}";\n                                    types.push("singleton");\n                                } else if (b[a + 1] === "#" || b[a + 1] === "?" || b[a + 1] === "^" || b[a + 1] === "@" || b[a + 1] === "<" || b[a + 1] === "+") {\n                                    end = "}";\n                                    types.push("template_start");\n                                } else {\n                                    end = "}";\n                                    types.push("template");\n                                }\n                            } else if (b[a + 1] === "{") {\n                                if (b[a + 2] === "{") {\n                                    end = "}}}";\n                                    types.push("template");\n                                } else if (b[a + 2] === "#") {\n                                    end = "}}";\n                                    types.push("template_start");\n                                } else if (b[a + 2] === "/") {\n                                    end = "}}";\n                                    types.push("template_end");\n                                } else if (b[a + 2] === "e" && b[a + 3] === "n" && b[a + 4] === "d") {\n                                    end = "}}";\n                                    types.push("template_end");\n                                } else if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {\n                                    end = "}}";\n                                    types.push("template_else");\n                                } else {\n                                    end = "}}";\n                                    types.push("template");\n                                }\n                            } else if (b[a + 1] === "%") {\n                                end = "%}";\n                                types.push("template");\n                            } else if (b[a + 1] === "#") {\n                                end = "#}";\n                                types.push("comment");\n                                preserve = true;\n                                comment  = true;\n                            } else {\n                                end = b[a + 1] + "}";\n                                types.push("template");\n                            }\n                            if (b[a + 1] === "@" && b[a + 2] === "}" && b[a + 3] === "e" && b[a + 4] === "l" && b[a + 5] === "s" && b[a + 6] === "e" && b[a + 7] === "{" && b[a + 8] === "@" && b[a + 9] === "}") {\n                                a                       = a + 9;\n                                types[types.length - 1] = "template_else";\n                                presv.push(true);\n                                daddy.push(parent[parent.length - 1][0]);\n                                begin.push(parent[parent.length - 1][1]);\n                                attrs.push({});\n                                stats.template[0] = stats.template[0] + 1;\n                                stats.template[1] = stats.template[1] + 10;\n                                earlyexit         = true;\n                                return token.push("{@}else{@}");\n                            }\n                        } else if (b[a] === "[" && b[a + 1] === "%") {\n                            end = "%]";\n                            types.push("template");\n                        } else if (b[a] === "#" && options.apacheVelocity === true) {\n                            if (b[a + 1] === "*") {\n                                preserve = true;\n                                comment  = true;\n                                end      = "*#";\n                                types.push("comment");\n                            } else if (b[a + 1] === "[" && b[a + 2] === "[") {\n                                preserve = true;\n                                comment  = true;\n                                end      = "]]#";\n                                types.push("comment");\n                            } else if (b[a + 1] === "#") {\n                                preserve = true;\n                                comment  = true;\n                                end      = "\\n";\n                                types.push("comment");\n                            } else if (b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (/\\s/).test(b[a + 5]) === true) {\n                                end = "\\n";\n                                types.push("template_else");\n                            } else if (b[a + 1] === "i" && b[a + 2] === "f") {\n                                end = "\\n";\n                                types.push("template_start");\n                            } else if (b[a + 1] === "f" && b[a + 2] === "o" && b[a + 3] === "r" && b[a + 4] === "e" && b[a + 5] === "a" && b[a + 6] === "c" && b[a + 7] === "h") {\n                                end = "\\n";\n                                types.push("template_start");\n                            } else if (b[a + 1] === "e" && b[a + 2] === "n" && b[a + 3] === "d") {\n                                end = "\\n";\n                                types.push("template_end");\n                            } else {\n                                end = "\\n";\n                                types.push("template");\n                            }\n                        } else if (b[a] === "$" && options.apacheVelocity === true) {\n                            end = "\\n";\n                            types.push("template");\n                        }\n                        if (options.unformatted === true) {\n                            preserve = true;\n                        }\n                    }());\n                    if (earlyexit === true) {\n                        return;\n                    }\n                    // This loop is the logic that parses tags and attributes If the attribute\n                    // data-prettydiff-ignore is present the `ignore` flag is set The ignore flag is\n                    // identical to the preserve flag\n                    lastchar = end.charAt(end.length - 1);\n                    for (a = a; a < c; a = a + 1) {\n                        if (b[a] === "\\n") {\n                            line = line + 1;\n                        }\n                        if (preserve === true || (/\\s/).test(b[a]) === false) {\n                            lexer.push(b[a]);\n                        } else if (lexer[lexer.length - 1] !== " ") {\n                            lexer.push(" ");\n                        }\n                        if (comment === true) {\n                            quote = "";\n                            //comments must ignore fancy encapsulations and attribute parsing\n                            if (b[a] === lastchar && lexer.length > end.length + 1) {\n                                //if current character matches the last character of the tag ending sequence\n                                f = lexer.length;\n                                for (e = end.length - 1; e > -1; e = e - 1) {\n                                    f = f - 1;\n                                    if (lexer[f] !== end.charAt(e)) {\n                                        break;\n                                    }\n                                }\n                                if (e < 0) {\n                                    if (end === "endcomment") {\n                                        f = f - 1;\n                                        if ((/\\s/).test(lexer[f]) === true) {\n                                            do {\n                                                f = f - 1;\n                                            } while ((/\\s/).test(lexer[f]) === true);\n                                        }\n                                        if (lexer[f - 1] === "{" && lexer[f] === "%") {\n                                            end      = "%}";\n                                            lastchar = "}";\n                                        }\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        } else {\n                            if (quote === "") {\n                                if (options.jsx === true) {\n                                    if (b[a] === "{") {\n                                        jsxcount = jsxcount + 1;\n                                    } else if (b[a] === "}") {\n                                        jsxcount = jsxcount - 1;\n                                    }\n                                }\n                                if (types[types.length - 1] === "sgml" && b[a] === "[" && lexer.length > 4) {\n                                    types[types.length - 1] = "template_start";\n                                    break;\n                                }\n                                if (b[a] === "<" && preserve === false && lexer.length > 1 && end !== ">>" && end !== ">>>" && simple === true) {\n                                    parseError.push("Parse error on line " + line + " on element: ");\n                                    parseFail = true;\n                                }\n                                if (stest === true && (/\\s/).test(b[a]) === false && b[a] !== lastchar) {\n                                    //attribute start\n                                    stest   = false;\n                                    quote   = jsxquote;\n                                    igcount = 0;\n                                    lexer.pop();\n                                    for (a = a; a < c; a = a + 1) {\n                                        if (b[a] === "\\n") {\n                                            line = line + 1;\n                                        }\n                                        if (options.unformatted === true) {\n                                            lexer.push(b[a]);\n                                        }\n                                        attribute.push(b[a]);\n\n                                        if ((b[a] === "<" || b[a] === ">") && (quote === "" || quote === ">") && options.jsx === false) {\n                                            if (quote === "" && b[a] === "<") {\n                                                quote     = ">";\n                                                braccount = 1;\n                                            } else if (quote === ">") {\n                                                if (b[a] === "<") {\n                                                    braccount = braccount + 1;\n                                                } else if (b[a] === ">") {\n                                                    braccount = braccount - 1;\n                                                    if (braccount === 0) {\n                                                        // the following detects if a coldfusion tag is embedded within another markup\n                                                        // tag\n                                                        tname = tagName(attribute.join(""));\n                                                        if (cftags[tname] === "required") {\n                                                            quote = "</" + tname + ">";\n                                                        } else {\n                                                            quote   = "";\n                                                            igcount = 0;\n                                                            attrpush(false);\n                                                            break;\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        } else if (quote === "") {\n                                            if (b[a + 1] === lastchar) {\n                                                //if at end of tag\n                                                if (attribute[attribute.length - 1] === "/") {\n                                                    attribute.pop();\n                                                    if (preserve === true) {\n                                                        lexer.pop();\n                                                    }\n                                                    a = a - 1;\n                                                }\n                                                if (attribute.length > 0) {\n                                                    attrpush(false);\n                                                }\n                                                break;\n                                            }\n                                            if (b[a] === "{" && b[a - 1] === "=" && options.jsx === false) {\n                                                quote = "}";\n                                            } else if (b[a] === "\\"" || b[a] === "\'") {\n                                                quote = b[a];\n                                                if (b[a - 1] === "=" && (b[a + 1] === "<" || (b[a + 1] === "{" && b[a + 2] === "%") || (/\\s/).test(b[a + 1]) === true)) {\n                                                    igcount = a;\n                                                }\n                                            } else if (b[a] === "(") {\n                                                quote     = ")";\n                                                parncount = 1;\n                                            } else if (options.jsx === true) {\n                                                //jsx variable attribute\n                                                if ((b[a - 1] === "=" || (/\\s/).test(b[a - 1]) === true) && b[a] === "{") {\n                                                    quote  = "}";\n                                                    bcount = 1;\n                                                } else if (b[a] === "/") {\n                                                    //jsx comments\n                                                    if (b[a + 1] === "*") {\n                                                        quote = "*/";\n                                                    } else if (b[a + 1] === "/") {\n                                                        quote = "\\n";\n                                                    }\n                                                }\n                                            } else if (lexer[0] !== "{" && b[a] === "{" && (options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\n                                                //opening embedded template expression\n                                                if (b[a + 1] === "{") {\n                                                    if (b[a + 2] === "{") {\n                                                        quote = "}}}";\n                                                    } else {\n                                                        quote = "}}";\n                                                    }\n                                                } else if (options.dustjs === true) {\n                                                    quote = "}";\n                                                } else {\n                                                    quote = b[a + 1] + "}";\n                                                }\n                                            }\n                                            if ((/\\s/).test(b[a]) === true && quote === "") {\n                                                // testing for a run of spaces between an attribute\'s = and a quoted value.\n                                                // Unquoted values separated by space are separate attributes\n                                                if (attribute[attribute.length - 2] === "=") {\n                                                    for (e = a + 1; e < c; e = e + 1) {\n                                                        if ((/\\s/).test(b[e]) === false) {\n                                                            if (b[e] === "\\"" || b[e] === "\'") {\n                                                                a         = e - 1;\n                                                                quotetest = true;\n                                                                attribute.pop();\n                                                            }\n                                                            break;\n                                                        }\n                                                    }\n                                                }\n                                                if (quotetest === true) {\n                                                    quotetest = false;\n                                                } else if (jsxcount === 0 || (jsxcount === 1 && attribute[0] === "{")) {\n                                                    //if there is an unquoted space attribute is complete\n                                                    attribute.pop();\n                                                    attrpush(false);\n                                                    stest = true;\n                                                    break;\n                                                }\n                                            }\n                                        } else if (b[a] === "(" && quote === ")") {\n                                            parncount = parncount + 1;\n                                        } else if (b[a] === ")" && quote === ")") {\n                                            parncount = parncount - 1;\n                                            if (parncount === 0) {\n                                                quote = "";\n                                                if (b[a + 1] === end.charAt(0)) {\n                                                    attrpush(false);\n                                                    break;\n                                                }\n                                            }\n                                        } else if (options.jsx === true && (quote === "}" || (quote === "\\n" && b[a] === "\\n") || (quote === "*/" && b[a - 1] === "*" && b[a] === "/"))) {\n                                            //jsx attributes\n                                            if (quote === "}") {\n                                                if (b[a] === "{") {\n                                                    bcount = bcount + 1;\n                                                } else if (b[a] === quote) {\n                                                    bcount = bcount - 1;\n                                                    if (bcount === 0) {\n                                                        jsxcount = 0;\n                                                        quote    = "";\n                                                        element  = attribute.join("");\n                                                        if (options.unformatted === false) {\n                                                            if (options.jsx === true) {\n                                                                if ((/^(\\s*)$/).test(element) === false) {\n                                                                    attstore.push(element);\n                                                                }\n                                                            } else {\n                                                                element = element.replace(/\\s+/g, " ");\n                                                                if (element !== " ") {\n                                                                    attstore.push(element);\n                                                                }\n                                                            }\n                                                        } else if ((/^(\\s+)$/).test(element) === false) {\n                                                            attstore.push(element);\n                                                        }\n                                                        attribute = [];\n                                                        break;\n                                                    }\n                                                }\n                                            } else {\n                                                quote                   = "";\n                                                jsxquote                = "";\n                                                jscom[jscom.length - 1] = true;\n                                                element                 = attribute.join("");\n                                                if (element.charAt(1) === "*") {\n                                                    element = element + "\\n";\n                                                }\n                                                attribute = [];\n                                                if (element !== " ") {\n                                                    attstore.push(element);\n                                                }\n                                                break;\n                                            }\n                                        } else if (b[a] === "{" && b[a + 1] === "%" && b[igcount - 1] === "=" && (quote === "\\"" || quote === "\'")) {\n                                            quote   = quote + "{%";\n                                            igcount = 0;\n                                        } else if (b[a - 1] === "%" && b[a] === "}" && (quote === "\\"{%" || quote === "\'{%")) {\n                                            quote   = quote.charAt(0);\n                                            igcount = 0;\n                                        } else if (b[a] === "<" && end === ">" && b[igcount - 1] === "=" && (quote === "\\"" || quote === "\'")) {\n                                            quote   = quote + "<";\n                                            igcount = 0;\n                                        } else if (b[a] === ">" && (quote === "\\"<" || quote === "\'<")) {\n                                            quote   = quote.charAt(0);\n                                            igcount = 0;\n                                        } else if (igcount === 0 && quote !== ">" && (quote.length < 2 || (quote.charAt(0) !== "\\"" && quote.charAt(0) !== "\'"))) {\n                                            //terminate attribute at the conclusion of a quote pair\n                                            f     = 0;\n                                            tname = lexer[1] + lexer[2];\n                                            tname = tname.toLowerCase();\n                                            // in coldfusion quotes are escaped in a string with double the characters:\n                                            // "cat"" and dog"\n                                            if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\\"" || b[a] === "\'")) {\n                                                attribute.push(b[a + 1]);\n                                                a = a + 1;\n                                            } else {\n                                                for (e = quote.length - 1; e > -1; e = e - 1) {\n                                                    if (b[a - f] !== quote.charAt(e)) {\n                                                        break;\n                                                    }\n                                                    f = f + 1;\n                                                }\n                                                if (e < 0) {\n                                                    attrpush(true);\n                                                    if (b[a + 1] === lastchar) {\n                                                        break;\n                                                    }\n                                                }\n                                            }\n                                        } else if (igcount > 0 && (/\\s/).test(b[a]) === false) {\n                                            igcount = 0;\n                                        }\n                                    }\n                                } else if (end !== "%>" && end !== "\\n" && (b[a] === "\\"" || b[a] === "\'")) {\n                                    //opening quote\n                                    quote = b[a];\n                                } else if (comment === false && end !== "\\n" && b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] !== "#" && types[types.length - 1] !== "conditional") {\n                                    quote = "--\x3e";\n                                } else if (lexer[0] !== "{" && end !== "\\n" && b[a] === "{" && end !== "%>" && end !== "%]" && (options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\n                                    //opening embedded template expression\n                                    if (b[a + 1] === "{") {\n                                        if (b[a + 2] === "{") {\n                                            quote = "}}}";\n                                        } else {\n                                            quote = "}}";\n                                        }\n                                    } else if (options.dustjs === true) {\n                                        quote = "}";\n                                    } else {\n                                        quote = b[a + 1] + "}";\n                                    }\n                                    if (quote === end) {\n                                        quote = "";\n                                    }\n                                } else if (simple === true && end !== "\\n" && (/\\s/).test(b[a]) === true && b[a - 1] !== "<") {\n                                    //identify a space in a regular start or singleton tag\n                                    stest = true;\n                                } else if (simple === true && options.jsx === true && b[a] === "/" && (b[a + 1] === "*" || b[a + 1] === "/")) {\n                                    //jsx comment immediately following tag name\n                                    stest                   = true;\n                                    lexer[lexer.length - 1] = " ";\n                                    attribute.push(b[a]);\n                                    if (b[a + 1] === "*") {\n                                        jsxquote = "*/";\n                                    } else {\n                                        jsxquote = "\\n";\n                                    }\n                                } else if ((b[a] === lastchar || (end === "\\n" && b[a + 1] === "<")) && (lexer.length > end.length + 1 || lexer[0] === "]") && (options.jsx === false || jsxcount === 0)) {\n                                    if (end === "\\n") {\n                                        if ((/\\s/).test(lexer[lexer.length - 1]) === true) {\n                                            do {\n                                                lexer.pop();\n                                                a = a - 1;\n                                            } while ((/\\s/).test(lexer[lexer.length - 1]) === true);\n                                        }\n                                        break;\n                                    }\n                                    if (lexer[0] === "{" && lexer[1] === "%" && lexer.join("").replace(/\\s+/g, "") === "{%comment%}") {\n                                        end                     = "endcomment";\n                                        lastchar                = "t";\n                                        preserve                = true;\n                                        comment                 = true;\n                                        types[types.length - 1] = "comment";\n                                    } else {\n                                        //if current character matches the last character of the tag ending sequence\n                                        f = lexer.length;\n                                        for (e = end.length - 1; e > -1; e = e - 1) {\n                                            f = f - 1;\n                                            if (lexer[f] !== end.charAt(e)) {\n                                                break;\n                                            }\n                                        }\n                                        if (e < 0) {\n                                            break;\n                                        }\n                                    }\n                                }\n                            } else if (b[a] === quote.charAt(quote.length - 1) && ((options.jsx === true && end === "}" && (b[a - 1] !== "\\\\" || slashy() === false)) || options.jsx === false || end !== "}")) {\n                                //find the closing quote or embedded template expression\n                                f     = 0;\n                                tname = lexer[1] + lexer[2];\n                                tname = tname.toLowerCase();\n                                // in coldfusion quotes are escaped in a string with double the characters:\n                                // "cat"" and dog"\n                                if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\\"" || b[a] === "\'")) {\n                                    attribute.push(b[a + 1]);\n                                    a = a + 1;\n                                } else {\n                                    for (e = quote.length - 1; e > -1; e = e - 1) {\n                                        if (b[a - f] !== quote.charAt(e)) {\n                                            break;\n                                        }\n                                        f = f + 1;\n                                    }\n                                    if (e < 0) {\n                                        quote = "";\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    //nopush flags mean an early exit\n                    if (nopush === true) {\n                        jscom.pop();\n                        linen.pop();\n                        lines.pop();\n                        value.pop();\n                        space = minspace;\n                        return;\n                    }\n\n                    if (preserve === true) {\n                        presv.push(true);\n                    } else {\n                        presv.push(false);\n                    }\n\n                    if (options.correct === true) {\n                        if (b[a + 1] === ">" && lexer[0] === "<" && lexer[1] !== "<") {\n                            do {\n                                a = a + 1;\n                            } while (b[a + 1] === ">");\n                        } else if (lexer[0] === "<" && lexer[1] === "<" && b[a + 1] !== ">" && lexer[lexer.length - 2] !== ">") {\n                            do {\n                                lexer.splice(1, 1);\n                            } while (lexer[1] === "<");\n                        }\n                    }\n                    igcount = 0;\n                    element = lexer.join("");\n                    if (element.indexOf("{{") === 0 && element.slice(element.length - 2) === "}}") {\n                        if (tagName(element) === "end") {\n                            types[types.length - 1] = "template_end";\n                        } else if (tagName(element) === "else") {\n                            types[types.length - 1] = "template_else";\n                        }\n                    } else if (element.slice(0, 2) === "<%" && element.slice(element.length - 2) === "%>") {\n                        if ((/^(<%\\s*end\\s*-?%>)$/).test(element) === true || (/^(<%\\s*\\}\\s*%>)$/).test(element) === true) {\n                            types[types.length - 1] = "template_end";\n                        } else if ((/^(<%\\s*\\}?\\s*else\\s*\\{?\\s*-?%>)$/).test(element) === true) {\n                            types[types.length - 1] = "template_else";\n                        } else if (element.indexOf("<%=") !== 0) {\n                            types[types.length - 1] = "template_start";\n                        }\n                    }\n                    tname = tagName(element);\n                    if (options.html === true && element.charAt(0) === "<" && element.charAt(1) !== "!" && element.charAt(1) !== "?" && (types.length === 0 || types[types.length - 1].indexOf("template") < 0) && options.jsx === false && cftags[tname] === undefined && cftags[tname.slice(1)] === undefined && tname.slice(0, 3) !== "cf_") {\n                        element = element.toLowerCase();\n                    }\n                    if (tname === "comment" && element.slice(0, 2) === "{%") {\n                        element = element\n                            .replace(/^(\\{%\\s*comment\\s*%\\}\\s*)/, "")\n                            .replace(/(\\s*\\{%\\s*endcomment\\s*%\\})$/, "");\n\n                        attrs.push({});\n                        attrs.push({});\n                        value.push("");\n                        value.push("");\n                        jscom.push(false);\n                        jscom.push(false);\n                        e = linen[linen.length - 1];\n                        linen.push(e);\n                        linen.push(e);\n                        types[types.length - 1] = "template_start";\n                        token.push("{% comment %}");\n                        types.push("comment");\n                        daddy.push(parent[parent.length - 1][0]);\n                        begin.push(parent[parent.length - 1][1]);\n                        stats.template[0] = stats.template[0] + 1;\n                        stats.template[1] = stats.template[1] + 13;\n                        token.push(element);\n                        types.push("template_end");\n                        daddy.push(parent[parent.length - 1][0]);\n                        begin.push(parent[parent.length - 1][1]);\n                        stats.template[0] = stats.template[0] + 1;\n                        stats.template[1] = stats.template[1] + element.length;\n                        return token.push("{% endcomment %}");\n                    }\n\n                    if (end !== "]>" && sgmlflag > 0 && element.charAt(element.length - 1) !== "[" && (element.slice(element.length - 2) === "]>" || (/^(<!((doctype)|(notation))\\s)/i).test(element) === true)) {\n                        sgmlflag = sgmlflag - 1;\n                    }\n\n                    //fix singleton tags and sort attributes\n                    if (attstore.length > 0) {\n                        if (attstore[attstore.length - 1] === "/") {\n                            attstore.pop();\n                            lexer.splice(lexer.length - 1, 0, "/");\n                        }\n                        f = attstore.length;\n                        for (e = 1; e < f; e = e + 1) {\n                            quote = attstore[e - 1];\n                            if (quote.charAt(quote.length - 1) === "=" && attstore[e].indexOf("=") < 0) {\n                                attstore[e - 1] = quote + attstore[e];\n                                attstore.splice(e, 1);\n                                f = f - 1;\n                                e = e - 1;\n                            }\n                        }\n                        if (objsortop === true && jscom[jscom.length - 1] === false && options.jsx === false && nosort === false && tname !== "cfif" && tname !== "cfelseif" && tname !== "cfset") {\n                            attstore = safeSort(attstore);\n                        }\n                    }\n                    attrs.push(function markuppretty__tokenize_attribute() {\n                        var ind    = 0,\n                            len    = attstore.length,\n                            obj    = {},\n                            eq     = 0,\n                            dq     = 0,\n                            sq     = 0,\n                            syntax = "<{\\"\'=/",\n                            slice  = "",\n                            store  = [],\n                            name   = "",\n                            cft    = cftags[tname];\n                        if (tname.slice(0, 3) === "cf_") {\n                            cft = "required";\n                        }\n                        if (objsortop === true && options.jsx === false && cft === undefined) {\n                            attstore = safeSort(attstore);\n                        }\n                        for (ind = 0; ind < len; ind = ind + 1) {\n                            eq = attstore[ind].indexOf("=");\n                            dq = attstore[ind].indexOf("\\"");\n                            sq = attstore[ind].indexOf("\'");\n                            if (eq > -1 && store.length > 0) {\n                                obj[store.join(" ")] = "";\n                                store                = [];\n                                obj[attstore[ind]]   = "";\n                            } else if (cft !== undefined && eq < 0 && attstore[ind].indexOf("=") < 0) {\n                                store.push(attstore[ind]);\n                            } else if ((cft !== undefined && eq < 0) || (dq > 0 && dq < eq) || (sq > 0 && sq < eq) || syntax.indexOf(attstore[ind].charAt(0)) > -1) {\n                                obj[attstore[ind]] = "";\n                            } else if (eq < 0 && cft === undefined) {\n                                name = attstore[ind];\n                                if (options.html === true && options.jsx === false && cft === undefined) {\n                                    name = name.toLowerCase();\n                                }\n                                if (options.quoteConvert === "single") {\n                                    obj[name] = "\'" + attstore[ind] + "\'";\n                                } else {\n                                    obj[name] = "\\"" + attstore[ind] + "\\"";\n                                }\n                            } else {\n                                slice = attstore[ind].slice(eq + 1);\n                                if (syntax.indexOf(slice.charAt(0)) < 0 && cft === undefined) {\n                                    if (options.quoteConvert === "single") {\n                                        slice = "\'" + slice + "\'";\n                                    } else {\n                                        slice = "\\"" + slice + "\\"";\n                                    }\n                                }\n                                name = attstore[ind].slice(0, eq);\n                                if (options.html === true && options.jsx === false && cft === undefined) {\n                                    name = name.toLowerCase();\n                                }\n                                obj[name] = slice;\n                            }\n                        }\n                        if (store.length > 0) {\n                            obj[store.join(" ")] = "";\n                        }\n                        return obj;\n                    }());\n\n                    if (parseFail === true) {\n                        if (element.indexOf("\x3c!--<![") === 0) {\n                            parseError.pop();\n                        } else {\n                            parseError[parseError.length - 1] = parseError[parseError.length - 1] +\n                                    element;\n                            if (element.indexOf("</") > 0) {\n                                token.push(element);\n                                daddy.push(parent[parent.length - 1][0]);\n                                begin.push(parent[parent.length - 1][1]);\n                                stats.end[0] = stats.end[0] + 1;\n                                stats.end[1] = stats.end[1] + token[token.length - 1].length;\n                                return types.push("end");\n                            }\n                        }\n                    }\n                    // cheat identifies HTML singleton elements as singletons even if formatted as\n                    // start tags\n                    cheat = (function markuppretty__tokenize_tag_cheat() {\n                        var atty         = [],\n                            attn         = token[token.length - 1],\n                            atval        = "",\n                            type         = "",\n                            d            = 0,\n                            ee           = 1,\n                            cfval        = "",\n                            ender        = (/(\\/>)$/),\n                            htmlsings    = {\n                                area       : "singleton",\n                                base       : "singleton",\n                                basefont   : "singleton",\n                                br         : "singleton",\n                                col        : "singleton",\n                                embed      : "singleton",\n                                eventsource: "singleton",\n                                frame      : "singleton",\n                                hr         : "singleton",\n                                img        : "singleton",\n                                input      : "singleton",\n                                keygen     : "singleton",\n                                link       : "singleton",\n                                meta       : "singleton",\n                                param      : "singleton",\n                                progress   : "singleton",\n                                source     : "singleton",\n                                wbr        : "singleton"\n                            },\n                            fixsingleton = function markuppretty__tokenize_tag_cheat_fixsingleton() {\n                                var aa    = 0,\n                                    bb    = 0,\n                                    vname = tname.slice(1);\n                                for (aa = token.length - 1; aa > -1; aa = aa - 1) {\n                                    if (types[aa] === "end") {\n                                        bb = bb + 1;\n                                    } else if (types[aa] === "start") {\n                                        bb = bb - 1;\n                                        if (bb < 0) {\n                                            return false;\n                                        }\n                                    }\n                                    if (bb === 0 && token[aa].toLowerCase().indexOf(vname) === 1) {\n                                        if (cftags[tagName(token[aa])] !== undefined) {\n                                            types[aa] = "template_start";\n                                        } else {\n                                            types[aa]          = "start";\n                                            stats.singleton[0] = stats.singleton[0] - 1;\n                                            stats.singleton[1] = stats.singleton[1] - token[token.length - 1].length;\n                                            stats.start[0]     = stats.start[0] + 1;\n                                            stats.start[1]     = stats.start[1] + token[token.length - 1].length;\n                                        }\n                                        if (Object.keys(attrs[aa]).length > 0) {\n                                            token[aa] = token[aa].replace(/(\\s*\\/>)$/, " >");\n                                        } else {\n                                            token[aa] = token[aa].replace(/(\\s*\\/>)$/, ">");\n                                        }\n                                        return false;\n                                    }\n                                }\n                            };\n                        if (presend["/" + tname] === true) {\n                            linepreserve = linepreserve - 1;\n                        }\n                        if (types[types.length - 1] === "end" && tname.slice(0, 3) !== "/cf") {\n                            if (types[types.length - 2] === "singleton" && attn.charAt(attn.length - 2) !== "/" && "/" + tagName(attn) === tname) {\n                                types[types.length - 2] = "start";\n                            } else if ((types[types.length - 2] === "start" || htmlsings[tname.slice(1)] === "singleton") && tname !== "/span" && tname !== "/div" && tname !== "/script" && (options.html === false || (options.html === true && tname !== "/li")) && tname === "/" + tagName(token[token.length - 1]) && options.tagmerge === true) {\n                                types.pop();\n                                attrs.pop();\n                                jscom.pop();\n                                linen.pop();\n                                lines.pop();\n                                presv.pop();\n                                value.pop();\n                                if (types[types.length - 1] === "start") {\n                                    token[token.length - 1] = token[token.length - 1].replace(/>$/, "/>");\n                                }\n                                types[types.length - 1] = "singleton";\n                                singleton               = true;\n                                return;\n                            }\n                        }\n                        for (d = attstore.length - 1; d > -1; d = d - 1) {\n                            atty = arname(attstore[d]);\n                            if (atty[0] === "type") {\n                                type = atty[1];\n                                if (type.charAt(0) === "\\"" || type.charAt(0) === "\'") {\n                                    type = type.slice(1, type.length - 1);\n                                }\n                            } else if (atty[0] === "src" && (tname === "embed" || tname === "img" || tname === "script" || tname === "iframe")) {\n                                atval = atty[1];\n                                if (atval.charAt(0) === "\\"" || atval.charAt(0) === "\'") {\n                                    atval = atval.slice(1, atval.length - 1);\n                                }\n                                reqs.push(atval);\n                            } else if (tname === "link" && atty === "href") {\n                                atval = atty[1];\n                                if (atval.charAt(0) === "\\"" || atval.charAt(0) === "\'") {\n                                    atval = atval.slice(1, atval.length - 1);\n                                }\n                                reqs.push(atval);\n                            }\n                        }\n\n                        if ((tname === "script" || tname === "style" || tname === "cfscript") && element.slice(element.length - 2) !== "/>") {\n                            //identify if there is embedded code requiring an external parser\n                            if (tname === "script" && (type === "" || type === "text/javascript" || type === "babel" || type === "module" || type === "application/javascript" || type === "application/x-javascript" || type === "text/ecmascript" || type === "application/ecmascript" || type === "text/jsx" || type === "application/jsx" || type === "text/cjs")) {\n                                ext = true;\n                            } else if (tname === "style" && (type === "" || type === "text/css")) {\n                                ext = true;\n                            } else if (tname === "cfscript") {\n                                ext = true;\n                            }\n                            if (ext === true) {\n                                for (d = a + 1; d < c; d = d + 1) {\n                                    if ((/\\s/).test(b[d]) === false) {\n                                        if (b[d] === "<") {\n                                            if (b.slice(d + 1, d + 4).join("") === "!--") {\n                                                for (d = d + 4; d < c; d = d + 1) {\n                                                    if ((/\\s/).test(b[d]) === false) {\n                                                        ext = false;\n                                                        break;\n                                                    }\n                                                    if (b[d] === "\\n" || b[d] === "\\r") {\n                                                        break;\n                                                    }\n                                                }\n                                            } else if (b.slice(d + 1, d + 9).join("") !== "![CDATA[") {\n                                                ext = false;\n                                            }\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        if (tname === "/#assign" || tname === "/#global") {\n                            for (d = types.length - 2; d > -1; d = d - 1) {\n                                if (types[d] === "start" || types[d] === "template_start") {\n                                    ee = ee - 1;\n                                } else if (types[d] === "end" || types[d] === "template_end") {\n                                    ee = ee + 1;\n                                }\n                                if (ee === 1) {\n                                    if ((token[d].indexOf("<#assign") === 0 && tname === "/#assign") || (token[d].indexOf("<#global") === 0 && tname === "/#global")) {\n                                        types[d] = "template_start";\n                                        return false;\n                                    }\n                                }\n                                if (ee === 0) {\n                                    return false;\n                                }\n                            }\n                            return false;\n                        }\n                        if (tname.charAt(0) === "#" && types[types.length - 1] === "start" && (tname === "#assign" || tname === "#break" || tname === "#case" || tname === "#default" || tname === "#fallback" || tname === "#flush" || tname === "#ftl" || tname === "#global" || tname === "#import" || tname === "#include" || tname === "#local" || tname === "#t" || tname === "#lt" || tname === "#rt" || tname === "#nested" || tname === "#nt" || tname === "#recover" || tname === "#recurse" || tname === "#return" || tname === "#sep" || tname === "#setting" || tname === "#stop" || tname === "#visit")) {\n                            simple = true;\n                            return true;\n                        }\n                        if (options.html === true) {\n                            //simple means of looking for missing li end tags\n                            if (options.jsx === false) {\n                                if (tname === "li") {\n                                    if (litag === list && (list !== 0 || (list === 0 && types.length > 0 && types[types.length - 1].indexOf("template") < 0))) {\n                                        for (d = types.length - 1; d > -1; d = d - 1) {\n                                            if (types[d] === "start" || types[d] === "template_start") {\n                                                ee = ee - 1;\n                                            } else if (types[d] === "end" || types[d] === "template_end") {\n                                                ee = ee + 1;\n                                            }\n                                            if (ee === -1 && (tagName(token[d]) === "li" || (tagName(token[d + 1]) === "li" && (tagName(token[d]) === "ul" || tagName(token[d]) === "ol")))) {\n                                                liend = true;\n                                                break;\n                                            }\n                                            if (ee < 0) {\n                                                break;\n                                            }\n                                        }\n                                    } else {\n                                        litag = litag + 1;\n                                    }\n                                } else if (tname === "/li" && litag === list) {\n                                    litag = litag - 1;\n                                } else if (tname === "ul" || tname === "ol") {\n                                    list = list + 1;\n                                } else if (tname === "/ul" || tname === "/ol") {\n                                    if (litag === list) {\n                                        liend = true;\n                                        litag = litag - 1;\n\n                                    }\n                                    list = list - 1;\n                                }\n                            }\n                            if (types[types.length - 1] === "end" && htmlsings[tname.slice(1)] === "singleton" && tname !== "/cftransaction") {\n                                return fixsingleton();\n                            }\n                            if (htmlsings[tname] === "singleton") {\n                                if (options.correct === true && ender.test(element) === false) {\n                                    lexer.pop();\n                                    lexer.push(" ");\n                                    lexer.push("/");\n                                    lexer.push(">");\n                                    element = lexer.join("");\n                                }\n                                return true;\n                            }\n                        }\n                        if (types[types.length - 1] === "end" && tname.slice(0, 3) === "/cf" && cftags[tname.slice(1)] !== undefined) {\n                            cfval = cftags[tname.slice(1)];\n                            if (tname === "/cftransaction") {\n                                cftransaction = false;\n                            }\n                            if (cfval !== undefined) {\n                                types[types.length - 1] = "template_end";\n                            }\n                            if ((cfval === "optional" || cfval === "prohibited") && tname !== "/cftransaction") {\n                                return fixsingleton();\n                            }\n                            return false;\n                        }\n                        if (tname.slice(0, 2) === "cf") {\n                            if (tname === "cfelse" || tname === "cfelseif") {\n                                types.push("template_else");\n                                token.push(lexer.join(""));\n                                daddy.push(parent[parent.length - 1][0]);\n                                begin.push(parent[parent.length - 1][1]);\n                                stats.template[0] = stats.template[0] + 1;\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\n                                singleton         = true;\n                                return false;\n                            }\n                            if (tname === "cftransaction" && cftransaction === true) {\n                                cfval = "prohibited";\n                            } else {\n                                cfval = cftags[tname];\n                            }\n                            if (cfval === "optional" || cfval === "prohibited" || tname.slice(0, 3) === "cf_") {\n                                if (options.correct === true && ender.test(element) === false) {\n                                    lexer.pop();\n                                    lexer.push(" ");\n                                    lexer.push("/");\n                                    lexer.push(">");\n                                }\n                                types.push("template");\n                                token.push(lexer.join("").replace(/\\s+/, " "));\n                                daddy.push(parent[parent.length - 1][0]);\n                                begin.push(parent[parent.length - 1][1]);\n                                stats.template[0] = stats.template[0] + 1;\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\n                                singleton         = true;\n                                return false;\n                            }\n                            if (cfval === "required" && tname !== "cfquery") {\n                                if (tname === "cftransaction" && cftransaction === false) {\n                                    cftransaction = true;\n                                }\n                                types.push("template_start");\n                                token.push(lexer.join(""));\n                                daddy.push(parent[parent.length - 1][0]);\n                                if (parent[parent.length - 1][1] === -1) {\n                                    begin.push(token.length - 1);\n                                } else {\n                                    begin.push(parent[parent.length - 1][1]);\n                                }\n                                stats.template[0] = stats.template[0] + 1;\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\n                                singleton         = true;\n                            }\n                            return false;\n                        }\n                        if (options.dustjs === true && types[types.length - 1] === "template_start") {\n                            type  = element.charAt(1);\n                            atval = element.slice(element.length - 2);\n                            if ((atval === "/}" || atval.charAt(0) === type) && (type === "#" || type === "?" || type === "^" || type === "@" || type === "<" || type === "+")) {\n                                types[types.length - 1] = "template";\n                            }\n                        }\n                        return false;\n                    }());\n\n                    if (singleton === true) {\n                        return;\n                    }\n                    //am I a singleton or a start type?\n                    if (simple === true && ignoreme === false) {\n                        if (cheat === true || (lexer[lexer.length - 2] === "/" && lexer[lexer.length - 1] === ">")) {\n                            types.push("singleton");\n                        } else {\n                            types.push("start");\n                        }\n                    }\n                    // additional logic is required to find the end of a tag with the attribute\n                    // data-prettydiff-ignore\n                    if (simple === true && preserve === false && ignoreme === true && end === ">" && element.slice(element.length - 2) !== "/>") {\n                        if (cheat === true) {\n                            types.push("singleton");\n                        } else {\n                            preserve                = true;\n                            presv[presv.length - 1] = true;\n                            types.push("ignore");\n                            a     = a + 1;\n                            quote = "";\n                            for (a = a; a < c; a = a + 1) {\n                                if (b[a] === "\\n") {\n                                    line = line + 1;\n                                }\n                                lexer.push(b[a]);\n                                if (quote === "") {\n                                    if (b[a] === "\\"") {\n                                        quote = "\\"";\n                                    } else if (b[a] === "\'") {\n                                        quote = "\'";\n                                    } else if (lexer[0] !== "{" && b[a] === "{" && (options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\n                                        if (b[a + 1] === "{") {\n                                            if (b[a + 2] === "{") {\n                                                quote = "}}}";\n                                            } else {\n                                                quote = "}}";\n                                            }\n                                        } else if (options.dustjs === true) {\n                                            quote = "}";\n                                        } else {\n                                            quote = b[a + 1] + "}";\n                                        }\n                                    } else if (b[a] === "<" && simple === true) {\n                                        if (b[a + 1] === "/") {\n                                            endtag = true;\n                                        } else {\n                                            endtag = false;\n                                        }\n                                    } else if (b[a] === lastchar) {\n                                        if (b[a - 1] !== "/") {\n                                            if (b[a - 1] !== "/") {\n                                                if (endtag === true) {\n                                                    igcount = igcount - 1;\n                                                    if (igcount < 0) {\n                                                        break;\n                                                    }\n                                                } else {\n                                                    igcount = igcount + 1;\n                                                }\n                                            }\n                                        }\n                                    }\n                                } else if (b[a] === quote.charAt(quote.length - 1)) {\n                                    f = 0;\n                                    for (e = quote.length - 1; e > -1; e = e - 1) {\n                                        if (b[a - f] !== quote.charAt(e)) {\n                                            break;\n                                        }\n                                        f = f + 1;\n                                    }\n                                    if (e < 0) {\n                                        quote = "";\n                                    }\n                                }\n                            }\n                        }\n                        element = lexer.join("");\n                        if (options.mode === "diff") {\n                            element = element.replace(" >", " />");\n                            element = element.slice(0, element.indexOf(" />") + 3);\n                            if (options.quotes === "single") {\n                                attstore = ["data-prettydiff-ignore=\'true\'"];\n                            } else {\n                                attstore = ["data-prettydiff-ignore=\\"true\\""];\n                            }\n                        }\n                    }\n\n                    //some template tags can be evaluated as a block start/end based on syntax alone\n                    e = types.length - 1;\n                    if (types[e].indexOf("template") > -1) {\n                        if (element.slice(0, 2) === "{%") {\n                            lexer = [\n                                "autoescape",\n                                "block",\n                                "capture",\n                                "case",\n                                "comment",\n                                "embed",\n                                "filter",\n                                "for",\n                                "form",\n                                "if",\n                                "macro",\n                                "paginate",\n                                "raw",\n                                "sandbox",\n                                "spaceless",\n                                "tablerow",\n                                "unless",\n                                "verbatim"\n                            ];\n                            if (tname === "else" || tname === "elseif" || tname === "when" || tname === "elif") {\n                                types[e] = "template_else";\n                            } else {\n                                for (f = lexer.length - 1; f > -1; f = f - 1) {\n                                    if (tname === lexer[f]) {\n                                        types[e] = "template_start";\n                                        break;\n                                    }\n                                    if (tname === "end" + lexer[f]) {\n                                        types[e] = "template_end";\n                                        break;\n                                    }\n                                }\n                            }\n                        } else if (element.slice(0, 2) === "{{" && element.charAt(3) !== "{") {\n                            if ((/^(\\{\\{\\s*end\\s*\\}\\})$/).test(element) === true) {\n                                types[e] = "template_end";\n                            } else if (tname === "block" || tname === "define" || tname === "form" || tname === "if" || tname === "range" || tname === "with") {\n                                if (tname !== "block" || (/\\{%\\s*\\w/).test(options.source) === false) {\n                                    types[e] = "template_start";\n                                }\n                            }\n                        } else if (types[e] === "template") {\n                            if (element.indexOf("else") > 2) {\n                                types[e] = "template_else";\n                            } else if ((/^(<%\\s*\\})/).test(element) === true || (/^(\\[%\\s*\\})/).test(element) === true || (/^(\\{@\\s*\\})/).test(element) === true) {\n                                types[e] = "template_end";\n                            } else if ((/(\\{\\s*%>)$/).test(element) === true || (/(\\{\\s*%\\])$/).test(element) === true || (/(\\{\\s*@\\})$/).test(element) === true) {\n                                types[e] = "template_start";\n                            }\n                        }\n                    }\n\n                    // HTML5 does not require an end tag for an opening list item <li> this logic\n                    // temprorarily creates a pseudo end tag\n                    if (liend === true && (options.mode === "beautify" || options.mode === "diff" || options.mode === "parse")) {\n                        token.push("</prettydiffli>");\n                        daddy.push(parent[parent.length - 1][0]);\n                        begin.push(parent[parent.length - 1][1]);\n                        lines.push(lines[lines.length - 1]);\n                        linen.push(line);\n                        lines[lines.length - 2] = 0;\n                        attrs.push({});\n                        if (types[types.length - 1] === "start") {\n                            types.splice(types.length - 1, 0, "end");\n                        } else {\n                            types.push("end");\n                        }\n                        presv.push(false);\n                        jscom.push(false);\n                        value.push("");\n                        if (parent.length > 1) {\n                            parent.pop();\n                        }\n                        stats.end[0] = stats.end[0] + 1;\n                        stats.end[1] = stats.end[1] + 5;\n                    }\n                    if (parent[parent.length - 1][1] === -1) {\n                        parent[parent.length - 1] = ["root", token.length];\n                    }\n                    if (preserve === true) {\n                        token.push(element);\n                        daddy.push(parent[parent.length - 1][0]);\n                        begin.push(parent[parent.length - 1][1]);\n                        stats.ignore[0] = stats.ignore[0] + 1;\n                        stats.ignore[1] = stats.ignore[1] + token[token.length - 1].length;\n                    } else {\n                        if (options.jsx === true) {\n                            token.push(element);\n                        } else {\n                            token.push(element.replace(/\\s+/g, " "));\n                        }\n                        daddy.push(parent[parent.length - 1][0]);\n                        begin.push(parent[parent.length - 1][1]);\n                        if (types[types.length - 1].indexOf("template") > -1) {\n                            stats.template[0] = stats.template[0] + 1;\n                            stats.template[1] = stats.template[1] + token[token.length - 1].length;\n                        } else if (types[types.length - 1].indexOf("linepreserve") > -1) {\n                            stats.ignore[0] = stats.ignore[0] + 1;\n                            stats.ignore[1] = stats.ignore[1] + token[token.length - 1].length;\n                        } else {\n                            stats[types[types.length - 1]][0] = stats[types[types.length - 1]][0] + 1;\n                            stats[types[types.length - 1]][1] = stats[types[types.length - 1]][1] +\n                                    token[token.length - 1].length;\n                        }\n                    }\n                    if (options.tagsort === true && types[types.length - 1] === "end" && types[types.length - 2] !== "start") {\n                        (function markuppretty__tokenize_tag_sorttag() {\n                            var children   = [],\n                                bb         = 0,\n                                d          = 0,\n                                endStore   = 0,\n                                startStore = 0,\n                                endData    = {},\n                                store      = {\n                                    attrs: [],\n                                    begin: [],\n                                    daddy: [],\n                                    jscom: [],\n                                    linen: [],\n                                    lines: [],\n                                    presv: [],\n                                    token: [],\n                                    types: [],\n                                    value: []\n                                },\n                                sortName   = function markuppretty__tokenize_tag_sorttag_sortName(x, y) {\n                                    if (token[x[0]] < token[y[0]]) {\n                                        return 1;\n                                    }\n                                    return -1;\n                                },\n                                pushy      = function markuppretty__tokenize_tag_sorttag_pushy(index) {\n                                    store\n                                        .attrs\n                                        .push(attrs[index]);\n                                    store\n                                        .begin\n                                        .push(begin[index]);\n                                    store\n                                        .daddy\n                                        .push(daddy[index]);\n                                    store\n                                        .jscom\n                                        .push(jscom[index]);\n                                    store\n                                        .linen\n                                        .push(linen[index]);\n                                    store\n                                        .lines\n                                        .push(lines[index]);\n                                    store\n                                        .presv\n                                        .push(presv[index]);\n                                    store\n                                        .token\n                                        .push(token[index]);\n                                    store\n                                        .types\n                                        .push(types[index]);\n                                    store\n                                        .value\n                                        .push(value[index]);\n                                };\n                            for (bb = token.length - 2; bb > -1; bb = bb - 1) {\n                                if (types[bb] === "start") {\n                                    d = d - 1;\n                                    if (d < 0) {\n                                        startStore = bb + 1;\n                                        break;\n                                    }\n                                } else if (types[bb] === "end") {\n                                    d = d + 1;\n                                    if (d === 1) {\n                                        endStore = bb;\n                                    }\n                                }\n                                if (d === 0) {\n                                    if (types[bb] === "start") {\n                                        children.push([bb, endStore]);\n                                    } else {\n                                        children.push([bb, bb]);\n                                    }\n                                }\n                            }\n                            if (children.length < 2) {\n                                return;\n                            }\n                            children.sort(sortName);\n                            for (bb = children.length - 1; bb > -1; bb = bb - 1) {\n                                pushy(children[bb][0]);\n                                if (children[bb][0] !== children[bb][1]) {\n                                    for (d = children[bb][0] + 1; d < children[bb][1]; d = d + 1) {\n                                        pushy(d);\n                                    }\n                                    pushy(children[bb][1]);\n                                }\n                            }\n                            endData.attrs = attrs.pop();\n                            endData.begin = begin.pop();\n                            endData.daddy = daddy.pop();\n                            endData.jscom = jscom.pop();\n                            endData.linen = linen.pop();\n                            endData.lines = lines.pop();\n                            endData.presv = presv.pop();\n                            endData.token = token.pop();\n                            endData.types = types.pop();\n                            endData.value = value.pop();\n                            attrs         = attrs\n                                .slice(0, startStore)\n                                .concat(store.attrs);\n                            begin         = begin\n                                .slice(0, startStore)\n                                .concat(store.begin);\n                            daddy         = daddy\n                                .slice(0, startStore)\n                                .concat(store.daddy);\n                            jscom         = jscom\n                                .slice(0, startStore)\n                                .concat(store.jscom);\n                            linen         = linen\n                                .slice(0, startStore)\n                                .concat(store.linen);\n                            lines         = lines\n                                .slice(0, startStore)\n                                .concat(store.lines);\n                            presv         = presv\n                                .slice(0, startStore)\n                                .concat(store.presv);\n                            token         = token\n                                .slice(0, startStore)\n                                .concat(store.token);\n                            types         = types\n                                .slice(0, startStore)\n                                .concat(store.types);\n                            value         = value\n                                .slice(0, startStore)\n                                .concat(store.value);\n                            attrs.push(endData.attrs);\n                            begin.push(endData.begin);\n                            daddy.push(endData.daddy);\n                            jscom.push(endData.jscom);\n                            linen.push(endData.linen);\n                            lines.push(endData.lines);\n                            presv.push(endData.presv);\n                            token.push(endData.token);\n                            types.push(endData.types);\n                            value.push(endData.value);\n                        }());\n                    }\n                    e = token.length - 1;\n                    if (types[e] === "start") {\n                        parent.push([tname, e]);\n                    } else if (types[e] === "end" && parent.length > 1) {\n                        parent.pop();\n                    }\n                    if (options.attributetoken === true && options.mode === "parse") {\n                        attribute = Object.keys(attrs[e]);\n                        bcount    = attribute.length;\n                        if ((types[e] === "start" || types[e] === "singleton") && bcount > 0) {\n                            for (f = 0; f < bcount; f = f + 1) {\n                                attrs.push({});\n                                begin.push(begin[e]);\n                                if (daddy[e] === "root") {\n                                    daddy.push(tname);\n                                } else {\n                                    daddy.push(daddy[e]);\n                                }\n                                jscom.push(false);\n                                linen.push(linen[e]);\n                                lines.push(0);\n                                presv.push(presv[e]);\n                                token.push(attribute[f]);\n                                if (attribute[f] === "") {\n                                    types.push("template_attribute");\n                                    value.push("");\n                                } else {\n                                    types.push("attribute");\n                                    value.push(attrs[e][attribute[f]]);\n                                }\n                            }\n                        }\n                    }\n                },\n                content       = function markuppretty__tokenize_content() {\n                    var lexer     = [],\n                        quote     = "",\n                        end       = "",\n                        square    = (\n                            types[types.length - 1] === "template_start" && token[token.length - 1].indexOf("<!") === 0 && token[token.length - 1].indexOf("<![") < 0 && token[token.length - 1].charAt(token[token.length - 1].length - 1) === "["\n                        ),\n                        tailSpace = function markuppretty__tokenize_content_tailSpace(spacey) {\n                            if (linepreserve > 0 && spacey.indexOf("\\n") < 0 && spacey.indexOf("\\r") < 0) {\n                                spacey = "";\n                            }\n                            space = spacey;\n                            return "";\n                        },\n                        esctest   = function markuppretty__tokenize_content_esctest() {\n                            var aa = 0,\n                                bb = 0;\n                            if (b[a - 1] !== "\\\\") {\n                                return false;\n                            }\n                            for (aa = a - 1; aa > -1; aa = aa - 1) {\n                                if (b[aa] !== "\\\\") {\n                                    break;\n                                }\n                                bb = bb + 1;\n                            }\n                            if (bb % 2 === 1) {\n                                return true;\n                            }\n                            return false;\n                        },\n                        name      = "";\n                    spacer();\n                    attrs.push({});\n                    jscom.push(false);\n                    linen.push(line);\n                    value.push("");\n                    if (linepreserve > 0) {\n                        presv.push(true);\n                    } else {\n                        presv.push(false);\n                    }\n                    if (ext === true) {\n                        name = tagName(token[token.length - 1]);\n                    }\n                    for (a = a; a < c; a = a + 1) {\n                        if (b[a] === "\\n") {\n                            line = line + 1;\n                        }\n                        // external code requires additional parsing to look for the appropriate end\n                        // tag, but that end tag cannot be quoted or commented\n                        if (ext === true) {\n                            if (quote === "") {\n                                if (b[a] === "/") {\n                                    if (b[a + 1] === "*") {\n                                        quote = "*";\n                                    } else if (b[a + 1] === "/") {\n                                        quote = "/";\n                                    } else if (name === "script" && "([{!=,;.?:&<>".indexOf(b[a - 1]) > -1) {\n                                        quote = "reg";\n                                    }\n                                } else if ((b[a] === "\\"" || b[a] === "\'" || b[a] === "`") && esctest() === false) {\n                                    quote = b[a];\n                                }\n                                end = b\n                                    .slice(a, a + 10)\n                                    .join("")\n                                    .toLowerCase();\n                                if (name === "cfscript" && end === "</cfscript") {\n                                    a   = a - 1;\n                                    ext = false;\n                                    if (lexer.length < 1) {\n                                        attrs.pop();\n                                        jscom.pop();\n                                        linen.pop();\n                                        presv.pop();\n                                        value.pop();\n                                        return lines.pop();\n                                    }\n                                    token.push(lexer.join("").replace(/^(\\s+)/, "").replace(/(\\s+)$/, ""));\n                                    daddy.push(parent[parent.length - 1][0]);\n                                    begin.push(parent[parent.length - 1][1]);\n                                    stats.script[0] = stats.script[0] + 1;\n                                    stats.script[1] = stats.script[1] + token[token.length - 1].length;\n                                    if (typeof global.prettydiff.jspretty === "function") {\n                                        return types.push(name);\n                                    }\n                                    return types.push("content");\n                                }\n                                if (name === "script") {\n                                    if (a === c - 9) {\n                                        end = end.slice(0, end.length - 1);\n                                    } else {\n                                        end = end.slice(0, end.length - 2);\n                                    }\n                                    if (end === "</script") {\n                                        a   = a - 1;\n                                        ext = false;\n                                        if (lexer.length < 1) {\n                                            attrs.pop();\n                                            jscom.pop();\n                                            linen.pop();\n                                            presv.pop();\n                                            value.pop();\n                                            return lines.pop();\n                                        }\n                                        token.push(lexer.join("").replace(/^(\\s+)/, "").replace(/(\\s+)$/, ""));\n                                        daddy.push(parent[parent.length - 1][0]);\n                                        begin.push(parent[parent.length - 1][1]);\n                                        stats.script[0] = stats.script[0] + 1;\n                                        stats.script[1] = stats.script[1] + token[token.length - 1].length;\n                                        if (typeof global.prettydiff.jspretty === "function") {\n                                            return types.push(name);\n                                        }\n                                        return types.push("content");\n                                    }\n                                }\n                                if (name === "style") {\n                                    if (a === c - 8) {\n                                        end = end.slice(0, end.length - 1);\n                                    } else if (a === c - 9) {\n                                        end = end.slice(0, end.length - 2);\n                                    } else {\n                                        end = end.slice(0, end.length - 3);\n                                    }\n                                    if (end === "</style") {\n                                        a   = a - 1;\n                                        ext = false;\n                                        if (lexer.length < 1) {\n                                            attrs.pop();\n                                            jscom.pop();\n                                            linen.pop();\n                                            presv.pop();\n                                            value.pop();\n                                            return lines.pop();\n                                        }\n                                        token.push(lexer.join("").replace(/^(\\s+)/, "").replace(/(\\s+)$/, ""));\n                                        daddy.push(parent[parent.length - 1][0]);\n                                        begin.push(parent[parent.length - 1][1]);\n                                        stats.style[0] = stats.style[0] + 1;\n                                        stats.style[1] = stats.style[1] + token[token.length - 1].length;\n                                        if (typeof global.prettydiff.csspretty === "function") {\n                                            return types.push(name);\n                                        }\n                                        return types.push("content");\n                                    }\n                                }\n                            } else if (quote === b[a] && (quote === "\\"" || quote === "\'" || quote === "`" || (quote === "*" && b[a + 1] === "/")) && esctest() === false) {\n                                quote = "";\n                            } else if (quote === "`" && b[a] === "$" && b[a + 1] === "{" && esctest() === false) {\n                                quote = "}";\n                            } else if (quote === "}" && b[a] === "}" && esctest() === false) {\n                                quote = "`";\n                            } else if (quote === "/" && (b[a] === "\\n" || b[a] === "\\r")) {\n                                quote = "";\n                            } else if (quote === "reg" && b[a] === "/" && esctest() === false) {\n                                quote = "";\n                            } else if (quote === "/" && b[a] === ">" && b[a - 1] === "-" && b[a - 2] === "-") {\n                                end = b\n                                    .slice(a + 1, a + 11)\n                                    .join("")\n                                    .toLowerCase();\n                                if (name === "cfscript" && end === "</cfscript") {\n                                    quote = "";\n                                }\n                                end = end.slice(0, end.length - 2);\n                                if (name === "script" && end === "</script") {\n                                    quote = "";\n                                }\n                                end = end.slice(0, end.length - 1);\n                                if (name === "style" && end === "</style") {\n                                    quote = "";\n                                }\n                            }\n                        }\n                        if (square === true && b[a] === "]") {\n                            a = a - 1;\n                            spacer();\n                            if (options.content === true) {\n                                token.push("text");\n                            } else if (options.textpreserve === true) {\n                                token.push(minspace + lexer.join(""));\n                                lines[lines.length - 1] = 0;\n                            } else if (linepreserve > 0) {\n                                token.push(minspace + lexer.join("").replace(/(\\s+)$/, tailSpace));\n                                lines[lines.length - 1] = 0;\n                            } else {\n                                token.push(lexer.join("").replace(/(\\s+)$/, tailSpace).replace(/\\s+/g, " "));\n                            }\n                            stats.content[0] = stats.content[0] + 1;\n                            stats.content[1] = stats.content[1] + token[token.length - 1].length;\n                            daddy.push(parent[parent.length - 1][0]);\n                            begin.push(parent[parent.length - 1][1]);\n                            return types.push("content");\n                        }\n\n                        if (ext === false && lexer.length > 0 && ((b[a] === "<" && b[a + 1] !== "=" && (/\\s|\\d/).test(b[a + 1]) === false) || (b[a] === "[" && b[a + 1] === "%") || (b[a] === "{" && (options.jsx === true || options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")))) {\n                            if (options.dustjs === true && b[a] === "{" && b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {\n                                a = a + 6;\n                                if (options.content === true) {\n                                    token.push("text");\n                                } else if (options.textpreserve === true) {\n                                    token.push(minspace + lexer.join(""));\n                                    lines[lines.length - 1] = 0;\n                                } else {\n                                    token.push(lexer.join("").replace(/(\\s+)$/, tailSpace).replace(/\\s+/g, " "));\n                                }\n                                stats.content[0] = stats.content[0] + 1;\n                                stats.content[1] = stats.content[1] + token[token.length - 1].length;\n                                types.push("content");\n                                spacer();\n                                attrs.push({});\n                                jscom.push(false);\n                                linen.push(line);\n                                presv.push(false);\n                                token.push("{:else}");\n                                value.push("");\n                                stats.template[0] = stats.template[0] + 1;\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\n                                daddy.push(parent[parent.length - 1][0]);\n                                begin.push(parent[parent.length - 1][1]);\n                                return types.push("template_else");\n                            }\n                            a = a - 1;\n                            if (options.content === true) {\n                                token.push("text");\n                            } else if (options.textpreserve === true) {\n                                token.push(minspace + lexer.join(""));\n                                lines[lines.length - 1] = 0;\n                            } else if (linepreserve > 0) {\n                                token.push(minspace + lexer.join("").replace(/(\\s+)$/, tailSpace));\n                                lines[lines.length - 1] = 0;\n                            } else {\n                                token.push(lexer.join("").replace(/(\\s+)$/, tailSpace).replace(/\\s+/g, " "));\n                            }\n                            stats.content[0] = stats.content[0] + 1;\n                            stats.content[1] = stats.content[1] + token[token.length - 1].length;\n                            daddy.push(parent[parent.length - 1][0]);\n                            begin.push(parent[parent.length - 1][1]);\n                            return types.push("content");\n                        }\n                        lexer.push(b[a]);\n                    }\n                    spacer();\n                    if (options.content === true) {\n                        token.push("text");\n                    } else if (options.textpreserve === true) {\n                        token.push(minspace + lexer.join(""));\n                        lines[lines.length - 1] = 0;\n                    } else {\n                        token.push(lexer.join("").replace(/(\\s+)$/, tailSpace));\n                    }\n                    stats.content[0] = stats.content[0] + 1;\n                    stats.content[1] = stats.content[1] + token[token.length - 1].length;\n                    daddy.push(parent[parent.length - 1][0]);\n                    begin.push(parent[parent.length - 1][1]);\n                    return types.push("content");\n                };\n\n            for (a = 0; a < c; a = a + 1) {\n                if ((/\\s/).test(b[a]) === true) {\n                    space = space + b[a];\n                    if (b[a] === "\\n") {\n                        line = line + 1;\n                    }\n                } else if (ext === true) {\n                    content();\n                } else if (b[a] === "<") {\n                    tag("");\n                } else if (b[a] === "[" && b[a + 1] === "%") {\n                    tag("%]");\n                } else if (b[a] === "{" && (options.jsx === true || options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\n                    tag("");\n                } else if (b[a] === "]" && sgmlflag > 0) {\n                    tag("]>");\n                } else if (b[a] === "-" && b[a + 1] === "-" && b[a + 2] === "-" && options.jekyll === true) {\n                    tag("---");\n                } else if (b[a] === "#" && options.apacheVelocity === true && (/\\d/).test(b[a + 1]) === false && (/\\s/).test(b[a + 1]) === false && ((/\\w/).test(b[a + 1]) === true || b[a + 1] === "*" || b[a + 1] === "#" || (b[a + 1] === "[" && b[a + 2] === "["))) {\n                    tag("");\n                } else if (b[a] === "$" && options.apacheVelocity === true && (/\\d/).test(b[a + 1]) === false && (/\\s/).test(b[a + 1]) === false && b[a + 1] !== "$" && b[a + 1] !== "=" && b[a + 1] !== "[") {\n                    tag("");\n                } else {\n                    content();\n                }\n            }\n            lines[0] = 0;\n        }());\n\n        if (token.length === 0) {\n            if (options.nodeasync === true) {\n                return [options.source, "Error: source does not appear to be markup."];\n            }\n            if (global.prettydiff.meta === undefined) {\n                global.prettydiff.meta = {};\n            }\n            global.prettydiff.meta.error = "Error: source does not appear to be markup.";\n            return options.source;\n        }\n\n        globalerror = (function markuppretty__globalerror() {\n            var startend = stats.start[0] - stats.end[0],\n                error    = "";\n            if (startend > 0) {\n                error = startend + " more start tag";\n                if (startend > 1) {\n                    error = error + "s";\n                }\n                error = error + " than start tag";\n                if (startend > 1) {\n                    error = error + "s";\n                }\n                error = error + "!";\n                return error;\n            } else if (startend < 0) {\n                startend = startend * -1;\n                error    = startend + " more end tag";\n                if (startend > 1) {\n                    error = error + "s";\n                }\n                error = error + " than start tag";\n                if (startend > 1) {\n                    error = error + "s";\n                }\n                error = error + "!";\n                return error;\n            } else {\n                return "";\n            }\n        }());\n\n        if (options.nodeasync === false) {\n            if (global.prettydiff.meta === undefined) {\n                global.prettydiff.meta       = {};\n                global.prettydiff.meta.error = "";\n            }\n            if (global.prettydiff.meta.error === "") {\n                global.prettydiff.meta.error = globalerror;\n            }\n        }\n\n        if (options.mode === "parse") {\n            return (function markuppretty__parse() {\n                var a        = 0,\n                    c        = token.length,\n                    record   = [],\n                    wspace   = "",\n                    data     = {},\n                    def      = {\n                        attrs: "array - List of attributes (if any) for the given token.",\n                        begin: "number - Index where the parent element occurs.",\n                        daddy: "string - Tag name of the parent element. Tokens of type \'template_start\' are n" +\n                                "ot considered as parent elements.  End tags reflect their matching start tag.",\n                        jscom: "boolean - Whether the token is a JavaScript comment if in JSX format.",\n                        linen: "number - The line number in the original source where the token started, which" +\n                                " is used for reporting and analysis.",\n                        lines: "number - Whether the token is preceeded any space and/or line breaks in the or" +\n                                "iginal code source.",\n                        presv: "boolean - Whether the token is preserved verbatim as found.  Useful for commen" +\n                                "ts and HTML \'pre\' tags.",\n                        token: "string - The parsed code tokens.",\n                        types: "string - Data types of the tokens: cdata, comment, conditional, content, end, " +\n                                "ignore, linepreserve, script, sgml, singleton, start, template, template_else," +\n                                " template_end, template_start, xml",\n                        value: "string - The attribute\'s value if the current type is attribute"\n                    },\n                    //white space token to insertion logic\n                    insert   = function markuppretty__parse_insert(string) {\n                        if (types[a] === "content") {\n                            token[a] = string + token[a];\n                            return;\n                        }\n                        if (types[a - 1] === "content" && token[a] !== "content") {\n                            token[a - 1] = token[a - 1] + string;\n                            return;\n                        }\n                        attrs.splice(a, 0, {});\n                        begin.splice(a, 0, begin[a]);\n                        daddy.splice(a, 0, daddy[a]);\n                        jscom.splice(a, 0, false);\n                        linen.splice(a, 0, linen[a]);\n                        lines.splice(a, 0, 1);\n                        presv.splice(a, 0, false);\n                        token.splice(a, 0, string);\n                        types.splice(a, 0, "content");\n                        value.splice(a, 0, "");\n                        c = c + 1;\n                        a = a + 1;\n                    },\n                    attApply = function markuppretty__parse_attApply(atty) {\n                        var string = "",\n                            xlen   = atty.length,\n                            xind   = 0,\n                            toke   = token[a],\n                            atts   = "";\n                        for (xind = 0; xind < xlen; xind = xind + 1) {\n                            if (attrs[a][atty[xind]] === "") {\n                                atts = atts + " " + atty[xind];\n                            } else {\n                                atts = atts + " " + atty[xind] + "=" + attrs[a][atty[xind]];\n                            }\n                        }\n                        if (presv[a] === true) {\n                            token[a] = toke.replace(" ", atts);\n                        } else {\n                            string   = ((/(\\/>)$/).test(toke) === true)\n                                ? "/>"\n                                : ">";\n                            xlen     = (string === "/>")\n                                ? 3\n                                : 2;\n                            token[a] = (toke.slice(0, toke.length - xlen) + atts + string);\n                        }\n                    };\n                if (options.attributetoken === true) {\n                    delete def.attrs;\n                } else {\n                    delete def.value;\n                }\n                for (a = 0; a < c; a = a + 1) {\n                    wspace = "";\n                    record = Object.keys(attrs[a]);\n                    if (record.length > 0 && options.unformatted === false) {\n                        attApply(record);\n                    }\n                    if (token[a] === "</prettydiffli>") {\n                        if (options.correct === true) {\n                            token[a] = "</li>";\n                        } else {\n                            attrs.splice(a, 1);\n                            begin.splice(a, 1);\n                            daddy.splice(a, 1);\n                            jscom.splice(a, 1);\n                            linen.splice(a, 1);\n                            lines.splice(a, 1);\n                            presv.splice(a, 1);\n                            token.splice(a, 1);\n                            types.splice(a, 1);\n                            value.splice(a, 1);\n                            a = a - 1;\n                            c = c - 1;\n                        }\n                    }\n                    if (options.parseFormat !== "htmltable") {\n                        if (types[a] === "script") {\n                            options.source = token[a];\n                            token[a]       = extlib("script");\n                        } else if (types[a] === "style") {\n                            options.source = token[a];\n                            token[a]       = extlib("style");\n                        }\n                    }\n                    if (options.parseSpace === true) {\n                        if (lines[a] > 1) {\n                            if (options.preserve > 1) {\n                                if (options.parseFormat === "htmltable") {\n                                    wspace = "(empty line)";\n                                } else {\n                                    wspace = lf + lf;\n                                }\n                            } else if (types[a] === "singleton" || types[a] === "content" || types[a] === "template") {\n                                wspace = " ";\n                            }\n                        } else if (lines[a] === 1) {\n                            if (types[a] === "singleton" || types[a] === "content" || types[a] === "template") {\n                                wspace = " ";\n                            } else if (types[a] !== types[a - 1] && (types[a - 1] === "singleton" || types[a - 1] === "content" || types[a - 1] === "template")) {\n                                wspace = " ";\n                            }\n                        }\n                        if (wspace !== "") {\n                            if (wspace === " " && options.parseFormat === "htmltable") {\n                                wspace = "(space)";\n                            }\n                            insert(wspace);\n                        }\n                    }\n                }\n                if (options.parseFormat === "sequential") {\n                    if (options.attributetoken === true) {\n                        def.order = "[token, types, value, lines, linen, jscom, presv, daddy, begin]";\n                    } else {\n                        def.order = "[token, types, attrs, lines, linen, jscom, presv, daddy, begin]";\n                    }\n                    for (a = 0; a < c; a = a + 1) {\n                        if (options.attributetoken === true) {\n                            record.push([\n                                token[a],\n                                types[a],\n                                value[a],\n                                lines[a],\n                                linen[a],\n                                jscom[a],\n                                presv[a],\n                                daddy[a],\n                                begin[a]\n                            ]);\n                        } else {\n                            record.push([\n                                token[a],\n                                types[a],\n                                attrs[a],\n                                lines[a],\n                                linen[a],\n                                jscom[a],\n                                presv[a],\n                                daddy[a],\n                                begin[a]\n                            ]);\n                        }\n                    }\n                    if (options.nodeasync === true) {\n                        return [\n                            {\n                                data      : record,\n                                definition: def\n                            },\n                            globalerror\n                        ];\n                    }\n                    return {data: record, definition: def};\n                }\n                if (options.parseFormat === "htmltable") {\n                    return (function markuppretty__parse_html() {\n                        var report = [],\n                            header = "<tr class=\\"header\\"><th>index</th><th>token</th><th>types</th>",\n                            aa     = 0,\n                            len    = 0;\n                        if (options.attributetoken === true) {\n                            header = header + "<th>value</th>";\n                        } else {\n                            header = header + "<th>attrs</th>";\n                        }\n                        header = header + "<th>linen</th><th>jscom</th><th>presv</th><th>daddy</th><th>" +\n                                "begin</th><th>lines</th></tr>";\n                        report.push("<table summary=\'markup parse table\'><thead>");\n                        report.push(header);\n                        report.push("</thead><tbody>");\n                        len = token.length;\n                        for (aa = 0; aa < len; aa = aa + 1) {\n                            if (types[aa] === "script") {\n                                options.source = token[aa];\n                                report.push("<tr><td colspan=\\"10\\" class=\\"nested\\">");\n                                report.push(extlib("script"));\n                                report.push("</td></tr>");\n                                report.push("<tr><th colspan=\\"10\\" class=\\"nested\\">Markup tokens</th></tr>");\n                                report.push(header);\n                            } else if (types[aa] === "style") {\n                                options.source = token[aa];\n                                report.push("<tr><td colspan=\\"10\\" class=\\"nested\\">");\n                                report.push(extlib("style"));\n                                report.push("</td></tr>");\n                                report.push("<tr><th colspan=\\"10\\" class=\\"nested\\">Markup tokens</th></tr>");\n                                report.push(header);\n                            } else {\n                                report.push("<tr><td>");\n                                report.push(aa);\n                                report.push("</td><td style=\\"white-space:pre\\">");\n                                report.push(\n                                    token[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\n                                );\n                                report.push("</td><td>");\n                                report.push(types[aa]);\n                                report.push("</td>");\n                                if (options.attributetoken === true) {\n                                    report.push("<td style=\\"white-space:pre\\">");\n                                    report.push(\n                                        value[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\n                                    );\n                                    report.push("</td><td>");\n                                } else {\n                                    report.push("<td style=\\"white-space:pre\\">");\n                                    report.push(\n                                        JSON.stringify(attrs[aa]).replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\n                                    );\n                                    report.push("</td><td>");\n                                }\n                                report.push(linen[aa]);\n                                report.push("</td><td>");\n                                report.push(jscom[aa]);\n                                report.push("</td><td>");\n                                report.push(presv[aa]);\n                                report.push("</td><td>");\n                                report.push(daddy[aa]);\n                                report.push("</td><td>");\n                                report.push(begin[aa]);\n                                report.push("</td><td>");\n                                report.push(lines[aa]);\n                                report.push("</td></tr>");\n                            }\n                        }\n                        report.push("</tbody></table>");\n                        if (options.nodeasync === true) {\n                            return [\n                                {\n                                    data      : report.join(""),\n                                    definition: def\n                                },\n                                globalerror\n                            ];\n                        }\n                        return {data: report.join(""), definition: def};\n                    }());\n                }\n                if (options.attributetoken === true) {\n                    data.value = value;\n                } else {\n                    data.attrs = attrs;\n                }\n                data.begin = begin;\n                data.daddy = daddy;\n                data.jscom = jscom;\n                data.linen = linen;\n                data.lines = lines;\n                data.presv = presv;\n                data.token = token;\n                data.types = types;\n                if (options.nodeasync === true) {\n                    return [\n                        {\n                            data      : data,\n                            definition: def\n                        },\n                        globalerror\n                    ];\n                }\n                return {data: data, definition: def};\n            }());\n        }\n\n        if (options.mode === "minify") {\n            (function markuppretty__minify() {\n                var a      = 0,\n                    c      = token.length,\n                    script = function markuppretty__minify_script() {\n                        options.source = token[a];\n                        token[a]       = extlib("script");\n                        level.push(-20);\n                    },\n                    style  = function markuppretty__minify_style() {\n                        options.source = token[a];\n                        token[a]       = extlib("style");\n                        level.push(-20);\n                    };\n                for (a = 0; a < c; a = a + 1) {\n                    if (types[a] === "script") {\n                        script();\n                    } else if (types[a] === "style") {\n                        style();\n                    } else if (lines[a] > 0) {\n                        if (types[a] === "singleton" || types[a] === "content" || types[a] === "template") {\n                            level.push(0);\n                        } else if (types[a - 1] === "singleton" || types[a - 1] === "content" || types[a] === "template") {\n                            level.push(0);\n                        } else {\n                            level.push(-20);\n                        }\n                    } else {\n                        level.push(-20);\n                    }\n                }\n            }());\n        }\n\n        output = (function markuppretty__beautify() {\n            var a            = 0,\n                c            = token.length,\n                lprescount   = [],\n                ltype        = "",\n                lline        = 0,\n                indent       = options.inlevel,\n                cdataS       = "",\n                cdataE       = "",\n                commentS     = "",\n                commentE     = "",\n                cdataStart   = (/^(\\s*(\\/)*<!?\\[+[A-Z]+\\[+)/),\n                cdataEnd     = (/((\\/)*\\]+>\\s*)$/),\n                commentStart = (/^(\\s*\x3c!--)/),\n                commentEnd   = (/((\\/\\/)?--\x3e\\s*)$/),\n                tabs         = "",\n                twigStart    = (/^(\\{%\\s+)/),\n                twigEnd      = (/(\\s%\\})$/),\n                xslline      = function markuppretty__beautify_xslline() {\n                    var tname = false;\n                    if (lines[a] > 1 || (types[a] !== "start" && types[a] !== "singleton") || (types[a - 1] === "comment" && lines[a - 1] > 1)) {\n                        return;\n                    }\n                    tname = (tagName(token[a]).indexOf("xsl:") === 0);\n                    if (tname === false) {\n                        return;\n                    }\n                    if (types[a] === "start") {\n                        lines[a] = 2;\n                    } else if (types[a - 1] !== "start" || types[a + 1] !== "end" || (types[a - 1] !== "start" && types[a + 1] !== "end")) {\n                        lines[a] = 2;\n                    }\n                },\n                tab          = (function markuppretty__beautify_tab() {\n                    var b   = options.insize,\n                        ind = [];\n                    for (b = b; b > 0; b = b - 1) {\n                        ind.push(options.inchar);\n                    }\n                    return new RegExp("^(" + ind.join("") + "+)");\n                }()),\n                end          = function markuppretty__beautify_end() {\n                    var b = 0;\n                    indent = indent - 1;\n                    if ((types[a] === "end" && ltype === "start") || (types[a] === "template_end" && ltype === "template_start") || (options.jsx === true && (/^\\s+\\{/).test(token[a - 1]) === true && lines[a] === 0)) {\n                        return level.push(-20);\n                    }\n                    if (lines[a] < 1 && options.html === true && a > 0 && tagName(token[a - 1]) === "/span") {\n                        b = a;\n                        do {\n                            b = b - 1;\n                        } while (lines[b] < 1);\n                        if (types[b] === "content" || types[b] === "singleton" || types[b] === "start" || types[b] === "comment" || types[b].indexOf("template") > -1) {\n                            level[a - 1] = -20;\n                            return level.push(-20);\n                        }\n                    }\n                    if (options.force_indent === false) {\n                        if (lines[a] === 0 && (ltype === "singleton" || ltype === "content" || (ltype === "template" && types[a] !== "template_end"))) {\n                            return level.push(-20);\n                        }\n                        if (ltype === "comment") {\n                            for (b = a - 1; b > -1; b = b - 1) {\n                                if (types[b] !== "comment") {\n                                    if (lines[b + 1] === 0 && (types[b] === "singleton" || types[b] === "content" || ltype === "template")) {\n                                        for (b = b + 1; b < a; b = b + 1) {\n                                            level[b] = -20;\n                                        }\n                                        return level.push(-20);\n                                    }\n                                    return level.push(indent);\n                                }\n                            }\n                        }\n                        return level.push(indent);\n                    }\n                    level.push(indent);\n                },\n                content      = function markuppretty__beautify_content() {\n                    var b       = 0,\n                        spanfix = function markuppretty__beautify_content_spanfix() {\n                            b = b - 1;\n                            if (types[b] === "comment") {\n                                do {\n                                    b = b - 1;\n                                } while (b > 0 && types[b] === "comment" && lines[b] < 1);\n                            }\n                            if (lines[b] === 0 && tagName(token[b]) === "span" && (tagName(token[b - 1]) === "span" || tagName(token[b - 1]) === "/span")) {\n                                do {\n                                    level[b] = -20;\n                                    b        = b - 1;\n                                } while (\n                                    b > 0 && lines[b] < 1 && (tagName(token[b]) === "span" || types[b] === "comment")\n                                );\n                            }\n                        };\n                    if (lines[a] === 0 && options.force_indent === false && (presv[a] === false || types[a] !== "content")) {\n                        if (ltype === "comment" && lline === 0) {\n                            for (b = a - 1; b > -1; b = b - 1) {\n                                if (types[b - 1] !== "comment" && types[b] === "comment") {\n                                    if (lines[b] === 0) {\n                                        for (b = b; b < a; b = b + 1) {\n                                            level[b] = -20;\n                                        }\n                                        if (options.html === true && tagName(token[begin[a]]) === "span") {\n                                            spanfix();\n                                        }\n                                        return level.push(-20);\n                                    }\n                                    return level.push(indent);\n                                }\n                                if (lines[b] > 0) {\n                                    return level.push(indent);\n                                }\n                            }\n                            return level.push(indent);\n                        }\n                        level.push(-20);\n                        if (options.html === true && begin[a] > -1 && tagName(token[begin[a]]) === "span") {\n                            b = a;\n                            spanfix();\n                        }\n                    } else {\n                        level.push(indent);\n                    }\n                },\n                script       = function markuppretty__beautify_script(twig) {\n                    var list    = [],\n                        source  = "",\n                        twigfix = function markuppretty__beautify_script_twigfix(item) {\n                            var fixnumb = function markupretty__beautify_script_twigfix_fixnumb(xx) {\n                                return xx.replace(". .", "..");\n                            };\n                            item = item\n                                .replace(tab, "")\n                                .replace(/\\)\\s*and\\s*\\(/g, ") and (")\n                                .replace(/in\\u0020?\\(?\\d+\\.\\u0020\\.\\d\\(?/g, fixnumb);\n                            if (options.correct === true) {\n                                item = item.replace(/;$/, "") + " %}";\n                            } else {\n                                item = item + " %}";\n                            }\n                            return "{% " + item;\n                        },\n                        inle    = options.inlevel,\n                        mode    = options.mode;\n                    if (twig === true) {\n                        options.twig = true;\n                        token[a]     = token[a]\n                            .replace(twigStart, "")\n                            .replace(twigEnd, "");\n                    }\n                    stats.script[0] = stats.script[0] + 1;\n                    stats.script[1] = stats.script[1] + token[a]\n                        .replace(/\\s+/g, " ")\n                        .length;\n                    if (cdataStart.test(token[a]) === true) {\n                        cdataS   = cdataStart\n                            .exec(token[a])[0]\n                            .replace(/^\\s+/, "") + lf;\n                        token[a] = token[a].replace(cdataStart, "");\n                    } else if (commentStart.test(token[a]) === true) {\n                        commentS = commentStart\n                            .exec(token[a])[0]\n                            .replace(/^\\s+/, "") + lf;\n                        token[a] = token[a].replace(commentStart, "");\n                    }\n                    if (cdataEnd.test(token[a]) === true) {\n                        cdataE   = cdataEnd.exec(token[a])[0];\n                        token[a] = token[a].replace(cdataEnd, "");\n                    } else if (commentEnd.test(token[a]) === true) {\n                        commentE = commentEnd.exec(token[a])[0];\n                        token[a] = token[a].replace(commentEnd, "");\n                    }\n                    source          = token[a].replace(/^(\\s+)/, "");\n                    options.source  = source;\n                    options.inlevel = (options.style === "noinde")\n                        ? 0\n                        : indent;\n                    options.mode    = "beautify";\n                    token[a]        = extlib("script");\n                    options.inlevel = inle;\n                    options.mode    = mode;\n                    options.twig    = false;\n                    list            = tab.exec(token[a]);\n                    if (list !== null) {\n                        tabs = list[0];\n                    }\n                    if (cdataS !== "") {\n                        token[a] = tabs + cdataS + token[a];\n                        cdataS   = "";\n                    } else if (commentS !== "") {\n                        token[a] = tabs + commentS + token[a];\n                        commentS = "";\n                    }\n                    if (cdataE !== "") {\n                        token[a] = token[a] + lf + tabs + cdataE;\n                        cdataE   = "";\n                    } else if (commentE !== "") {\n                        token[a] = token[a] + lf + tabs + commentE;\n                        commentE = "";\n                    }\n                    if ((/^(\\s+\\{)/).test(token[a]) === true && options.jsx === true) {\n                        if (ltype === "content" || ltype === "singleton" || ltype === "template") {\n                            token[a] = token[a].replace(/^(\\s+)/, "");\n                            if (lines[a] < 1) {\n                                level.push(-20);\n                            } else {\n                                level.push(-10);\n                            }\n                        } else {\n                            token[a] = token[a].replace(/^(\\s+)/, "");\n                            if (lines[a] === 0) {\n                                level.push(-20);\n                            } else {\n                                level.push(indent);\n                                token[a] = token[a].replace(/(\\r?\\n\\})$/, lf + tabs + "}");\n                            }\n                        }\n                        if (token[a].indexOf(";") < 0 && token[a].replace(/^(\\{\\s+)/, "").replace(/(\\s+\\})$/, "").indexOf("\\n") < 0) {\n                            token[a] = token[a]\n                                .replace(/^(\\{\\s+)/, "{")\n                                .replace(/(\\s+\\})$/, "}");\n                        }\n                    } else if (twig === true) {\n                        token[a] = twigfix(token[a]);\n                    } else if (twig === true && lines[a] === 0) {\n                        level.push(-20);\n                        types[a] = "singleton";\n                    } else {\n                        level.push(0);\n                    }\n                },\n                style        = function markuppretty__beautify_style() {\n                    var list = [],\n                        inle = options.inlevel,\n                        mode = options.mode;\n                    stats.style[0] = stats.style[0] + 1;\n                    stats.style[1] = stats.style[1] + token[a]\n                        .replace(/\\s+/g, " ")\n                        .length;\n                    if (cdataStart.test(token[a]) === true) {\n                        cdataS   = cdataStart\n                            .exec(token[a])[0]\n                            .replace(/^\\s+/, "") + lf;\n                        token[a] = token[a].replace(cdataStart, "");\n                    } else if (commentStart.test(token[a]) === true) {\n                        commentS = commentStart\n                            .exec(token[a])[0]\n                            .replace(/^\\s+/, "") + lf;\n                        token[a] = token[a].replace(commentStart, "");\n                    }\n                    if (cdataEnd.test(token[a]) === true) {\n                        cdataE   = cdataEnd.exec(token[a])[0];\n                        token[a] = token[a].replace(cdataEnd, "");\n                    } else if (commentEnd.test(token[a]) === true) {\n                        commentE = commentEnd.exec(token[a])[0];\n                        token[a] = token[a].replace(commentEnd, "");\n                    }\n                    options.inlevel = (options.style === "noindent")\n                        ? 0\n                        : indent;\n                    options.mode    = "beautify";\n                    options.source  = token[a].replace(/^(\\s+)/, "");\n                    token[a]        = extlib("style");\n                    options.inlevel = inle;\n                    options.mode    = mode;\n                    list            = tab.exec(token[a]);\n                    if (list !== null) {\n                        tabs = list[0];\n                    }\n                    if (cdataS !== "") {\n                        token[a] = tabs + cdataS + token[a];\n                        cdataS   = "";\n                    } else if (commentS !== "") {\n                        token[a] = tabs + commentS + token[a];\n                        commentS = "";\n                    }\n                    if (cdataE !== "") {\n                        token[a] = token[a] + lf + tabs + cdataE;\n                        cdataE   = "";\n                    } else if (commentE !== "") {\n                        token[a] = token[a] + lf + tabs + commentE;\n                        commentE = "";\n                    }\n                    token[a] = token[a].replace(/(\\s+)$/, "");\n                    level.push(0);\n                },\n                apply        = function markuppretty__beautify_apply() {\n                    var x            = 0,\n                        y            = level.length,\n                        build        = [],\n                        attrib       = [],\n                        //tab builds out the character sequence for one step of indentation\n                        ind          = (function markuppretty__beautify_apply_tab() {\n                            var aa   = 0,\n                                indy = [options.inchar],\n                                size = options.insize - 1;\n                            for (aa = 0; aa < size; aa = aa + 1) {\n                                indy.push(options.inchar);\n                            }\n                            return indy.join("");\n                        }()),\n                        // a new line character plus the correct amount of identation for the given line\n                        // of code\n                        nl           = function markuppretty__beautify_apply_nl(indy, item) {\n                            var aa          = 0,\n                                indentation = [lf];\n                            if (options.mode === "minify") {\n                                return build.push(lf);\n                            }\n                            if (indy === -10) {\n                                item.push(" ");\n                            } else if (indy > -9) {\n                                if (lines[x] > 1 && item === build) {\n                                    do {\n                                        lines[x] = lines[x] - 1;\n                                        indentation.push(lf);\n                                    } while (lines[x] > 1);\n                                }\n                                for (aa = 0; aa < indy; aa = aa + 1) {\n                                    indentation.push(ind);\n                                }\n                                item.push(indentation.join(""));\n                            }\n                        },\n                        // populates attributes onto start and singleton tags it also checks to see if a\n                        // tag or content should wrap\n                        wrapper      = function markuppretty__beautify_apply_wrapper() {\n                            var b      = 0,\n                                len    = 0,\n                                xlen   = 0,\n                                list   = attrib,\n                                lev    = level[x],\n                                atty   = "",\n                                string = "",\n                                indy   = "",\n                                name   = "",\n                                text   = [],\n                                tname  = tagName(token[x]);\n                            if (lev === -20) {\n                                b = x;\n                                do {\n                                    b    = b - 1;\n                                    lev  = level[b];\n                                    xlen = xlen + token[b].length;\n                                } while (lev === -20 && b > -1);\n                                if (lev === -20) {\n                                    lev = 1;\n                                }\n                            }\n                            if (lev === 0) {\n                                lev = lev + options.inlevel;\n                            }\n                            if (list.length > 0) {\n                                if (options.force_attribute === true) {\n                                    len = list.length;\n                                    text.push(list[0]);\n                                    if (len > 1) {\n                                        b = 1;\n                                        do {\n                                            nl(lev + 1, text);\n                                            text.push(list[b]);\n                                            b = b + 1;\n                                        } while (b < len);\n                                        b = 0;\n                                    }\n                                    atty = text.join("");\n                                    text = [];\n                                } else {\n                                    atty = list.join(" ");\n                                }\n                                if ((types[x] === "template_start" || types[x] === "template" || types[x] === "template_else") && options.jsx === false) {\n                                    len = list.length;\n                                    for (b = 0; b < len; b = b + 1) {\n                                        xlen = list[b].indexOf("{");\n                                        if (list[b].indexOf("}") > xlen && xlen > 0) {\n                                            options.source  = list[b].slice(xlen, list[b].indexOf("}") + 1);\n                                            options.inlevel = lev;\n                                            list[b]         = list[b].slice(0, xlen) + extlib("script").replace(/^(\\s+)/, "") +\n                                                    list[b].slice(list[b].indexOf("}") + 1);\n                                        }\n                                    }\n                                }\n                                indy   = (function markuppretty__beautify_apply_wrapper_indy() {\n                                    var atline = lf,\n                                        atnum  = lev + 1;\n                                    do {\n                                        atline = atline + ind;\n                                        atnum  = atnum - 1;\n                                    } while (atnum > 0);\n                                    return atline;\n                                }());\n                                string = tagName(token[x]);\n                                len    = string.length + 3 + atty.length;\n                                if (token[x].charAt(token[x].length - 2) === "/") {\n                                    len = len + 1;\n                                }\n                                if (wrap === 0 || len <= wrap || tname === "cfset" || tname === "cfreturn" || tname === "cfif" || tname === "cfelseif") {\n                                    if (presv[x] === true) {\n                                        token[x] = token[x].replace(" ", " " + atty);\n                                    } else {\n                                        string = ((/(\\/>)$/).test(token[x]) === true)\n                                            ? "/>"\n                                            : ">";\n                                        xlen   = (string === "/>")\n                                            ? 3\n                                            : 2;\n                                        name   = token[x].slice(1, token[x].length - xlen);\n                                        if (options.force_attribute === true) {\n                                            token[x] = "<" + name + indy + atty + string;\n                                        } else {\n                                            token[x] = "<" + name + " " + atty + string;\n                                        }\n                                    }\n                                    if (types[x] === "singleton" || types[x] === "template") {\n                                        if (options.spaceclose === true) {\n                                            token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\n                                        } else {\n                                            token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\n                                        }\n                                    }\n                                    return;\n                                }\n                                text.push(token[x].slice(0, token[x].indexOf(" ")));\n                                len = list.length;\n                                for (b = 0; b < len; b = b + 1) {\n                                    nl(lev + 1, text);\n                                    text.push(list[b]);\n                                }\n                                text.push(token[x].slice(token[x].indexOf(" ") + 1));\n                                token[x] = text.join("");\n                                if (types[x] === "singleton" || types[x] === "template") {\n                                    if ((/(>\\}+\\/>)$/).test(token[x]) === true) {\n                                        b    = 0;\n                                        atty = lf;\n                                        if (lev > 1) {\n                                            do {\n                                                atty = atty + ind;\n                                                b    = b + 1;\n                                            } while (b < lev);\n                                            atty = atty + ind + "}" + atty + "/>";\n                                        } else {\n                                            atty = atty + "}/>";\n                                        }\n                                        token[x] = token[x].replace(/(\\u0020*\\}\\u0020*\\/>)$/, atty);\n                                    } else if (options.spaceclose === true) {\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\n                                    } else {\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\n                                    }\n                                }\n                            } else {\n                                list = token[x]\n                                    .replace(/\\s+/g, " ")\n                                    .split(" ");\n                                len  = list.length;\n                                if (level[x] === -20 && types[x - 1] === "end") {\n                                    b   = x - 1;\n                                    lev = 1;\n                                    do {\n                                        b = b - 1;\n                                        if (types[b] === "start") {\n                                            lev = lev - 1;\n                                        } else if (types[b] === "end") {\n                                            lev = lev + 1;\n                                        }\n                                    } while (lev > 0 && b > 0);\n                                    lev = level[b];\n                                }\n                                for (b = 0; b < len; b = b + 1) {\n                                    string = string + list[b];\n                                    if (list[b + 1] !== undefined && string.length + list[b + 1].length + 1 > wrap - xlen) {\n                                        text.push(string);\n                                        xlen = 0;\n                                        if (level[x] === -20 && types[x - 1] !== "end") {\n                                            nl(lev + 1, text);\n                                        } else {\n                                            nl(lev, text);\n                                        }\n                                        string = "";\n                                    } else {\n                                        string = string + " ";\n                                    }\n                                }\n                                text.push(string.replace(/\\s$/, ""));\n                                token[x] = text.join("");\n                                if (types[x] === "singleton") {\n                                    if (options.spaceclose === true) {\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\n                                    } else {\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\n                                    }\n                                }\n                            }\n                        },\n                        // JSX tags may contain comments, which are captured as attributes in this\n                        // parser.  These attributes demand unique care to be correctly applied.\n                        attrcom      = function markuppretty__beautify_apply_attrcom() {\n                            var toke  = token[x].split(" "),\n                                attr  = attrib,\n                                len   = attr.length,\n                                ilen  = 0,\n                                item  = [toke[0]],\n                                temp  = [],\n                                tempx = [],\n                                index = 0,\n                                b     = 0,\n                                xx    = 0,\n                                yy    = 0;\n                            nl(level[x], build);\n                            for (b = 0; b < len; b = b + 1) {\n                                index = attr[b].indexOf("\\n");\n                                if (index > 0 && index !== attr[b].length - 1 && attr[b].indexOf("/*") === 0) {\n                                    temp = (lf === "\\r\\n")\n                                        ? attr[b].split("\\r\\n")\n                                        : attr[b].split("\\n");\n                                    yy   = temp.length;\n                                    for (xx = 0; xx < yy; xx = xx + 1) {\n                                        if (temp[xx] === "") {\n                                            temp[xx] = lf;\n                                        } else {\n                                            nl(level[x] + 1, tempx);\n                                            tempx.push(temp[xx].replace(/^(\\s+)/, ""));\n                                        }\n                                    }\n                                    tempx.push(lf);\n                                    attr[b] = tempx.join("");\n                                }\n                                if (b > 0 && attr[b - 1].charAt(attr[b - 1].length - 1) === "\\n" && (/^(\\s*\\/\\/)/).test(attr[b]) === false) {\n                                    nl(level[x] + 1, item);\n                                    ilen       = item.length - 1;\n                                    item[ilen] = item[ilen].slice(1);\n                                } else if ((/^\\s/).test(attr[b]) === false && (/^(\\s*\\/\\/)/).test(attr[b - 1]) === false) {\n                                    item.push(" ");\n                                }\n                                item.push(attr[b]);\n                            }\n                            if (attr[len - 1].charAt(attr[len - 1].length - 1) === "\\n") {\n                                nl(level[x], item);\n                                ilen       = item.length - 1;\n                                item[ilen] = item[ilen].slice(1);\n                            }\n                            item.push(toke[1]);\n                            build.push(item.join(""));\n                        },\n                        jsxattribute = function markuppretty__beautify_apply_jsxattribute() {\n                            var attr     = Object.keys(attrs[x]),\n                                b        = 0,\n                                yy       = 0,\n                                xx       = attr.length,\n                                inlevel  = (level[x] < 1)\n                                    ? options.inlevel + 1\n                                    : level[x] + 1,\n                                builder  = "",\n                                inle     = options.inlevel,\n                                mode     = options.mode,\n                                vertical = options.vertical;\n                            for (b = 0; b < xx; b = b + 1) {\n                                if (attrs[x][attr[b]].charAt(0) === "{") {\n                                    options.mode      = "beautify";\n                                    options.inlevel   = inlevel;\n                                    options.source    = attrs[x][attr[b]].slice(1, attrs[x][attr[b]].length - 1);\n                                    options.vertical  = (\n                                        options.vertical === "jsonly" || options.vertical === true || options.vertical === "true"\n                                    );\n                                    attrs[x][attr[b]] = extlib("script");\n                                    options.mode      = mode;\n                                    options.inlevel   = inle;\n                                    options.vertical  = vertical;\n                                    attrib[b]         = attr[b] + "={" + attrs[x][attr[b]].replace(/^\\s+/, "") + "}";\n                                } else if (attr[b].charAt(0) === "/" && attr[b].charAt(1) === "/" && attr[b].charAt(attr[b].length - 1) === "\\n") {\n                                    builder = "";\n                                    yy      = inlevel;\n                                    do {\n                                        builder = builder + ind;\n                                        yy      = yy - 1;\n                                    } while (yy > 0);\n                                    if (b < attrib.length - 1) {\n                                        builder = lf + builder + attr[b].slice(0, attr[b].length - 1) + lf +\n                                                builder;\n                                    } else {\n                                        builder = lf + builder + attr[b].slice(0, attr[b].length - 1) + lf;\n                                    }\n                                    attrib[b] = builder;\n                                }\n                            }\n                        },\n                        linepreserve = function markuppretty__beautify_apply_linepreserve() {\n                            var str  = token[x]\n                                    .replace(/\\r\\n/g, "\\n")\n                                    .replace(/^(\\n)/, ""),\n                                item = str.split("\\n"),\n                                aa   = 0,\n                                bb   = item.length,\n                                out  = [],\n                                taby = new RegExp("^(" + ind + "+)");\n                            lines[x] = 1;\n                            for (aa = 0; aa < bb; aa = aa + 1) {\n                                item[aa] = item[aa]\n                                    .replace(/^(\\s+)/, "")\n                                    .replace(taby, "");\n                                if (item[aa] === "" && item[aa - 1] !== "" && aa < bb - 1) {\n                                    nl(0, out);\n                                } else if (item[aa] !== "") {\n                                    if (aa > 0) {\n                                        nl(level[x], out);\n                                    }\n                                    if (item[aa].indexOf(ind) === 0) {\n                                        do {\n                                            item[aa] = item[aa].slice(ind.length);\n                                        } while (item[aa].indexOf(ind) === 0);\n                                    }\n                                    out.push(item[aa].replace(/(\\s+)$/, ""));\n                                }\n                            }\n                            if (out[out.length - 1] === "") {\n                                out.pop();\n                            }\n                            if (types[x + 1] === "template_end" && out[out.length - 1].indexOf(ind) > 0 && (/^(\\s+)$/).test(out[out.length - 1]) === false) {\n                                out.pop();\n                            }\n                            token[x] = out.join("");\n                        },\n                        attArray     = function markuppretty__beautify_apply_attArray() {\n                            var list = Object.keys(attrs[x]),\n                                len  = list.length,\n                                b    = 0,\n                                attr = [];\n                            if (len < 1) {\n                                return [];\n                            }\n                            do {\n                                if (attrs[x][list[b]] === "") {\n                                    attr.push(list[b]);\n                                } else {\n                                    attr.push(list[b] + "=" + attrs[x][list[b]]);\n                                }\n                                b = b + 1;\n                            } while (b < len);\n                            return attr;\n                        };\n                    for (x = 0; x < y; x = x + 1) {\n                        attrib = attArray();\n                        if (options.jsx === true && attrib.length > 0) {\n                            jsxattribute();\n                        }\n                        if (jscom[x] === true) {\n                            attrcom();\n                        } else if (types[x] === "content" && x < y - 1) {\n                            if (presv[x] === true) {\n                                linepreserve();\n                            } else if (wrap > 0 && token[x].length > wrap && (options.mode === "beautify" || options.mode === "diff")) {\n                                wrapper();\n                            }\n                        } else if (types[x] !== "content" && options.unformatted === false && (options.mode === "beautify" || options.mode === "diff") && presv[x] === false && (attrib.length > 0 || (wrap > 0 && token[x].length > wrap)) && (types[x] === "content" || types[x] === "start" || types[x] === "singleton" || types[x] === "template_start" || types[x] === "template" || types[x] === "comment") && (types[x] !== "singleton" || token[x].charAt(0) !== "{")) {\n                            wrapper();\n                        } else if (options.unformatted === false && attrib.length > 0) {\n                            token[x] = token[x].replace(" ", " " + attrib.join(" "));\n                        } else if (types[x] === "singleton") {\n                            if (options.spaceclose === true) {\n                                token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\n                            } else {\n                                token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\n                            }\n                        }\n                        if (token[x] === "</prettydiffli>" && options.correct === true) {\n                            token[x] = "</li>";\n                        }\n                        if (token[x] !== "</prettydiffli>" && jscom[x] === false) {\n                            if ((types[x] === "template" || types[x] === "template_start") && types[x - 1] === "content" && presv[x - 1] === true && options.mode === "beautify" && level[x] === -20) {\n                                build.push(" ");\n                            }\n                            if (level[x] > -9) {\n                                if (options.mode === "minify") {\n                                    build.push(" ");\n                                } else {\n                                    nl(level[x], build);\n                                }\n                            } else if (level[x] === -10) {\n                                build.push(" ");\n                            }\n                            build.push(token[x]);\n                        }\n                    }\n                    if (build[0] === lf || build[0] === " ") {\n                        build[0] = "";\n                    }\n                    if (options.newline === true) {\n                        if (options.crlf === true) {\n                            build.push("\\r\\n");\n                        } else {\n                            build.push("\\n");\n                        }\n                    }\n                    if (options.nodeasync === true) {\n                        return [build.join(""), globalerror];\n                    }\n                    return build.join("");\n                };\n\n            if (options.mode !== "minify") {\n                for (a = 0; a < c; a = a + 1) {\n                    if (twigStart.test(token[a]) === true && twigEnd.test(token[a]) === true && (a === 0 || (tagName(token[a - 1]) !== "script" && tagName(token[a - 1]) !== "style")) && (/\\D-+\\D/).test(token[a]) === false && (/^(\\{%\\s*((comment)|(else))\\s*)/).test(token[a]) === false) {\n                        script(true);\n                    }\n                    if (types[a] === "start") {\n                        level.push(indent);\n                        indent = indent + 1;\n                        xslline();\n                    } else if (types[a] === "template_start" || types[a] === "linepreserve") {\n                        if (types[a] === "linepreserve") {\n                            lprescount.push(tagName(token[a]));\n                        }\n                        level.push(indent);\n                        indent = indent + 1;\n                    } else if (types[a] === "template_else") {\n                        level.push(indent - 1);\n                    } else if (types[a] === "end") {\n                        end();\n                    } else if (types[a] === "template_end") {\n                        if (lprescount.length > 0 && tagName(token[a]) === "/" + lprescount[lprescount.length - 1]) {\n                            lprescount.pop();\n                        }\n                        end();\n                    } else if (lines[a] === 0 && (types[a] === "singleton" || types[a] === "content" || types[a] === "template")) {\n                        if (types[a] === "content" && options.textpreserve === true) {\n                            level.push(-20);\n                        } else {\n                            content();\n                        }\n                        xslline();\n                    } else if (types[a] === "script" || types[a] === "cfscript") {\n                        script(false);\n                    } else if (types[a] === "style") {\n                        style();\n                    } else if (types[a] === "comment" && options.comments === "noindent") {\n                        level.push(0);\n                    } else if (types[a] === "linepreserve") {\n                        level.push(indent);\n                    } else {\n                        level.push(indent);\n                        xslline();\n                    }\n                    if (types[a] !== "content" && types[a] !== "comment" && types[a - 1] === "content" && types[a - 2] !== "linepreserve" && lprescount.length > 0) {\n                        level[a] = -20;\n                    }\n                    if (lines[a] === 0 && (ltype === "content" || (ltype === "script" && token[a - 1].charAt(0) === "{" && options.jsx === true))) {\n                        level[a] = -20;\n                    }\n                    ltype = types[a];\n                    lline = lines[a];\n                }\n            }\n            level[0] = 0;\n            return apply();\n        }());\n\n        if (options.mode === "analysis") {\n            options.accessibility = true;\n            return (function markuppretty__beautify_apply_summary() {\n                var len           = token.length,\n                    sum           = [],\n                    data          = {\n                        violations: 0\n                    },\n                    numformat     = function markuppretty__beautify_apply_summary_numformat(x) {\n                        var y    = String(x).split(""),\n                            z    = 0,\n                            xlen = y.length,\n                            dif  = 0;\n                        if (xlen % 3 === 2) {\n                            dif = 2;\n                        } else if (xlen % 3 === 1) {\n                            dif = 1;\n                        }\n                        for (z = xlen - 1; z > 0; z = z - 1) {\n                            if ((z % 3) - dif === 0) {\n                                y[z] = "," + y[z];\n                            }\n                        }\n                        return y.join("");\n                    },\n                    analysis      = function markuppretty__beautify_apply_summary_analysis(arr) {\n                        var x       = arr.length,\n                            idtest  = (arr === ids),\n                            y       = 0,\n                            adata   = [],\n                            content = [];\n                        if (x > 0) {\n                            arr = safeSort(arr);\n                            for (y = 0; y < x; y = y + 1) {\n                                if (arr[y] === arr[y + 1]) {\n                                    if (idtest === true && (adata.length === 0 || adata[adata.length - 1][1] !== arr[y])) {\n                                        adata.push([\n                                            2, arr[y]\n                                        ]);\n                                    }\n                                    if (adata.length > 0) {\n                                        adata[adata.length - 1][0] = adata[adata.length - 1][0] + 1;\n                                    }\n                                } else if (idtest === false) {\n                                    adata.push([\n                                        1, arr[y]\n                                    ]);\n                                }\n                            }\n                            x = adata.length;\n                            if (idtest === true) {\n                                if (x === 0) {\n                                    return "";\n                                }\n                                content.push("<h4>Duplicate id attribute values</h4>");\n                            } else {\n                                content.push("<h4>HTTP requests:</h4>");\n                            }\n                            content.push("<ul>");\n                            for (y = 0; y < x; y = y + 1) {\n                                if (idtest === true && adata[y][0] > 1) {\n                                    data.violations = data.violations + (adata[y][0] - 1);\n                                }\n                                content.push("<li>");\n                                content.push(adata[y][0]);\n                                content.push("x - ");\n                                content.push(adata[y][1].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(\n                                    />/g,\n                                    "&gt;"\n                                ));\n                                content.push("</li>");\n                            }\n                            content.push("</ul>");\n                            return content.join("");\n                        }\n                        return "";\n                    },\n                    accessibility = (\n                        function markuppretty__beautify_apply_summary_accessibility() {\n                            var findings   = [],\n                                tagsbyname = function markuppretty__beautify_apply_summary_accessibility_tagsbyname() {\n                                    var b            = 0,\n                                        c            = 0,\n                                        x            = 0,\n                                        y            = 0,\n                                        z            = 0,\n                                        tagname      = "",\n                                        tabindex     = "",\n                                        alttest      = false,\n                                        id           = false,\n                                        fortest      = false,\n                                        hidden       = false,\n                                        html         = false,\n                                        headtest     = (/^(h\\d)$/),\n                                        obsoleteAttr = [\n                                            "alink",\n                                            "align",\n                                            "background",\n                                            "border",\n                                            "color",\n                                            "compact",\n                                            "face",\n                                            "height",\n                                            "language",\n                                            "link",\n                                            "nowrap",\n                                            "size",\n                                            "start",\n                                            "text",\n                                            "version",\n                                            "vlink",\n                                            "width"\n                                        ],\n                                        attr         = [],\n                                        formID       = [],\n                                        labelFor     = [],\n                                        nofor        = [],\n                                        namestack    = [];\n\n                                    // badnest - checks for improperly orderd tags [tagname, start index, end index]\n                                    data.badnest      = [];\n                                    // obsoleteTags - checks for obsolete or presentation only tag names of start\n                                    // and singleton tags token index\n                                    data.obsoleteTags = [];\n                                    // obsoleteAttr - checks for obsolete or presentation attribute names [token\n                                    // index, attr index]\n                                    data.obsoleteAttr = [];\n                                    // headings - stores heading tag data [token index, number from tag name, if\n                                    // violation]\n                                    data.headings     = [];\n                                    // emptyalt - if an img tag contains an alt attribute with no values token index\n                                    data.emptyalt     = [];\n                                    //noalt - if an img tag does not contain an alt attribute token index\n                                    data.noalt        = [];\n                                    //formNoId - if a form control is missing an id attribute token index\n                                    data.formNoId     = [];\n                                    // formNoLabel - if a form control is missing a binding to a label [token index,\n                                    // id attr index]\n                                    data.formNoLabel  = [];\n                                    // tabindex - identifies elements with a tabindex attribute [token index, if\n                                    // value is greater than 0]\n                                    data.tabindex     = [];\n                                    // htmllang - if there is an <html> tag does it contain a lang or xml:lang\n                                    // attribute? boolean\n                                    data.htmllang     = false;\n\n                                    c                 = token.length;\n                                    for (b = 0; b < c; b = b + 1) {\n                                        hidden  = false;\n                                        tagname = tagName(token[b]);\n                                        if ((types[b] === "start" || types[b] === "singleton") && (tagname === "font" || tagname === "center" || tagname === "basefont" || tagname === "b" || tagname === "i" || tagname === "u" || tagname === "small" || tagname === "big" || tagname === "blink" || tagname === "plaintext" || tagname === "spacer" || tagname === "strike" || tagname === "tt" || tagname === "xmp")) {\n                                            data\n                                                .obsoleteTags\n                                                .push(b);\n                                        } else {\n                                            if (types[b] === "start" && headtest.test(tagname) === true) {\n                                                z = Number(tagname.charAt(1));\n                                                if (data.headings.length > 0 && z - data.headings[data.headings.length - 1][1] > 1) {\n                                                    data.violations = data.violations + 1;\n                                                    data\n                                                        .headings\n                                                        .push([b, z, true]);\n                                                } else {\n                                                    data\n                                                        .headings\n                                                        .push([b, z, false]);\n                                                }\n                                            }\n                                            if (attrs[b].alt !== undefined && tagname === "img") {\n                                                alttest = true;\n                                                if (attrs[b].alt === "") {\n                                                    data\n                                                        .emptyalt\n                                                        .push(b);\n                                                }\n                                            }\n                                            if (attrs[b].for !== undefined && tagname === "label") {\n                                                labelFor.push(attrs[b].for);\n                                                fortest = true;\n                                            }\n                                            if (tagname === "select" || tagname === "input" || tagname === "textarea") {\n                                                if (typeof attrs[b].id === "string" || (tagname === "input" && typeof attrs[b].type === "string" && (attrs[b].type.toLowerCase() === "hidden" || attrs[b].type.toLowerCase() === "submit"))) {\n                                                    id = true;\n                                                    if (tagname === "input" && attrs[b].type === "hidden") {\n                                                        hidden = true;\n                                                    }\n                                                    if (typeof attrs[b].id === "string") {\n                                                        formID.push(b);\n                                                    }\n                                                } else {\n                                                    z = namestack.length;\n                                                    if (z > 0) {\n                                                        do {\n                                                            z = z - 1;\n                                                        } while (z > 0 && namestack[z][0] === "span");\n                                                        if (namestack[z][0] === "label") {\n                                                            hidden = true;\n                                                        }\n                                                    }\n                                                }\n                                            } else if (tagname === "html") {\n                                                html = true;\n                                                if (typeof attrs[b].lang === "string" || typeof attrs[b]["xml:lang"] === "string") {\n                                                    data.htmllang = true;\n                                                }\n                                            }\n                                            if (data.obsoleteTags[data.obsoleteTags.length - 1] !== b) {\n                                                if (typeof attrs[b].name === "string" && tagname !== "meta" && tagname !== "iframe" && tagname !== "select" && tagname !== "input" && tagname !== "textarea") {\n                                                    data\n                                                        .obsoleteAttr\n                                                        .push([b, "name"]);\n                                                }\n                                                if (typeof attrs[b].type === "string" && tagname !== "script" && tagname !== "style" && tagname !== "input" && tagname !== "button" && tagname !== "link") {\n                                                    data\n                                                        .obsoleteAttr\n                                                        .push([b, "type"]);\n                                                }\n                                                if (typeof attrs[b].value === "string" && tagname !== "input" && tagname !== "option" && tagname !== "textarea" && tagname !== "button") {\n                                                    data\n                                                        .obsoleteAttr\n                                                        .push([b, "value"]);\n                                                }\n                                                z = obsoleteAttr.length;\n                                                for (y = 0; y < z; y = y + 1) {\n                                                    if (typeof attrs[b][obsoleteAttr[y]] === "string") {\n                                                        data\n                                                            .obsoleteAttr\n                                                            .push([\n                                                                b, obsoleteAttr[y]\n                                                            ]);\n                                                    }\n                                                }\n                                            }\n                                            if (typeof attrs[b].tabindex === "string") {\n                                                tabindex = attrs[b]\n                                                    .tabindex\n                                                    .slice(1, attrs[b].tabindex.length - 1);\n                                                if (isNaN(tabindex) === true || Number(tabindex) > 0) {\n                                                    data\n                                                        .tabindex\n                                                        .push([b, true]);\n                                                    data.violations = data.violations + 1;\n                                                } else {\n                                                    data\n                                                        .tabindex\n                                                        .push([b, false]);\n                                                }\n                                            }\n                                            if (fortest === true) {\n                                                fortest = false;\n                                            } else if (tagname === "label") {\n                                                nofor.push(b);\n                                            }\n                                            if (id === true) {\n                                                id = false;\n                                            } else if (hidden === false && (tagname === "select" || tagname === "input" || tagname === "textarea")) {\n                                                data\n                                                    .formNoId\n                                                    .push(b);\n                                            }\n                                            if (alttest === true) {\n                                                alttest = false;\n                                            } else if (tagname === "img") {\n                                                data\n                                                    .noalt\n                                                    .push(b);\n                                            }\n                                        }\n                                        if (types[b] === "start" || types[b] === "template_start") {\n                                            namestack.push([tagname, b]);\n                                        } else if (types[b] === "end" || types[b] === "template_end") {\n                                            if (namestack.length > 0 && tagname !== "/" + namestack[namestack.length - 1][0]) {\n                                                namestack[namestack.length - 1].push(b);\n                                                data\n                                                    .badnest\n                                                    .push(namestack[namestack.length - 1]);\n                                            }\n                                            namestack.pop();\n                                        }\n                                    }\n                                    attr = [];\n                                    if (html === false) {\n                                        data.htmllang = true;\n                                    }\n                                    attr.push("<div id=\'a11y\'>");\n                                    //missing lang attribute\n                                    if (data.htmllang === false) {\n                                        data.violations = data.violations + 1;\n                                        attr.push(\n                                            "<div><h4>HTML tag is a <strong>missing</strong> lang or xml:lang attribute</h4>"\n                                        );\n                                        attr.push(\n                                            "<p>The lang attribute ensures the natural language is properly understood by a" +\n                                            "ssisting applications.</p></div>"\n                                        );\n                                    } else {\n                                        attr.push("<div><h4>HTML lang or xml:lang attribute is present</h4></div>");\n                                    }\n                                    //improperly nested tags\n                                    b               = data.badnest.length;\n                                    data.violations = data.violations + b;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        attr.push(b);\n                                        attr.push("</strong> improperly nested tag");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            "</h4> <p>Improperly nested tags produce unexpected behaviors.</p> <ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            attr.push(\n                                                token[data.badnest[x][2]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.badnest[x][2]]);\n                                            attr.push(" does not match start tag <code>");\n                                            attr.push(\n                                                token[data.badnest[x][1]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            attr.push("</code> from input line number ");\n                                            attr.push(linen[data.badnest[x][1]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push("<div><h4><strong>0</strong> improperly nested tags</h4>");\n                                        attr.push("<p>Improperly nested tags produce unexpected behaviors.</p></div>");\n                                    }\n                                    //obsolete tags\n                                    b               = data.obsoleteTags.length;\n                                    data.violations = data.violations + b;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        attr.push(b);\n                                        attr.push("</strong> obsolete HTML tag");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            "</h4> <p>Obsolete elements do not appropriately describe content.</p> <ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            attr.push(\n                                                token[data.obsoleteTags[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.obsoleteTags[x]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push("<div><h4><strong>0</strong> obsolete HTML tags</h4>");\n                                        attr.push("<p>Obsolete elements do not appropriately describe content.</p></div>");\n                                    }\n                                    //obsolete attributes\n                                    b = data.obsoleteAttr.length;\n                                    if (b > 0) {\n                                        z = 0;\n                                        attr.push("<div><h4><strong>");\n                                        y = attr.length;\n                                        attr.push("</strong> HTML tag");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            " containing obsolete or inappropriate attributes</h4> <p>Obsolete attributes d" +\n                                            "o not appropriately describe content.</p> <ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            tagname = token[data.obsoleteAttr[x][0]]\n                                                .replace(/&/g, "&amp;")\n                                                .replace(/</g, "&lt;")\n                                                .replace(/>/g, "&gt;")\n                                                .replace(\n                                                    attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x][1]],\n                                                    "<strong>" + attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x][1]] + "</stron" +\n                                                            "g>"\n                                                );\n                                            if (x < b - 1 && data.obsoleteAttr[x][0] === data.obsoleteAttr[x + 1][0]) {\n                                                do {\n                                                    tagname = tagname.replace(\n                                                        attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x + 1][1]],\n                                                        "<strong>" + attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x + 1][1]] + "</s" +\n                                                                "trong>"\n                                                    );\n                                                    x       = x + 1;\n                                                } while (x < b - 1 && data.obsoleteAttr[x][0] === data.obsoleteAttr[x + 1][0]);\n                                            }\n                                            z = z + 1;\n                                            attr.push("<li><code>");\n                                            attr.push(tagname);\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.obsoleteAttr[x][0]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.splice(y, 0, z);\n                                        data.violations = data.violations + z;\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push(\n                                            "<div><h4><strong>0</strong> HTML tags containing obsolete or inappropriate attribut" +\n                                            "es</h4>"\n                                        );\n                                        attr.push("<p>Obsolete attributes do not appropriately describe content.</p></div>");\n                                    }\n                                    //form controls missing a required \'id\' attribute\n                                    b               = data.formNoId.length;\n                                    data.violations = data.violations + b;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        attr.push(b);\n                                        attr.push("</strong> form control element");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            " missing a required <em>id</em> attribute</h4> <p>The id attribute is required" +\n                                            " to bind a point of interaction to an HTML label.</p> <ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            attr.push(\n                                                token[data.formNoId[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.formNoId[x]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push(\n                                            "<div><h4><strong>0</strong> form control elements missing a required <em>id</em> at" +\n                                            "tribute</h4> <p>The id attribute is required to bind a point of interaction to" +\n                                            " an HTML label.</p></div>"\n                                        );\n                                    }\n                                    //form controls missing a binding to a label\n                                    b                = formID.length;\n                                    data.formNoLabel = [];\n                                    for (x = 0; x < b; x = x + 1) {\n                                        for (y = labelFor.length - 1; y > -1; y = y - 1) {\n                                            if (attrs[formID[x]].id === labelFor[y]) {\n                                                break;\n                                            }\n                                        }\n                                        if (y < 0) {\n                                            data\n                                                .formNoLabel\n                                                .push(formID[x]);\n                                        }\n                                    }\n                                    b               = data.formNoLabel.length;\n                                    data.violations = data.violations + b;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        attr.push(b);\n                                        attr.push("</strong> form control element");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            " not bound to a label</h4> <p>The <em>id</em> of a form control must match the" +\n                                            " <em>for</em> of a label.</p><ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            attr.push(\n                                                token[data.formNoLabel[x][0]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.formNoLabel[x][0]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push(\n                                            "<div><h4><strong>0</strong> form control elements not bound to a label</h4> <p>The " +\n                                            "<em>id</em> of a form control must match the <em>for</em> of a label.</p></div>"\n                                        );\n                                    }\n                                    //elements with tabindex\n                                    b = data.tabindex.length;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        y = attr.length;\n                                        z = 0;\n                                        attr.push(0);\n                                        attr.push("</strong> <em>tabindex</em>");\n                                        attr.push(" violation");\n                                        attr.push(\n                                            "</h4> <p>The tabindex attribute should have a 0 or -1 value and should not be " +\n                                            "over used. Only tabindexes with a value greater than 0 are counted as violatio" +\n                                            "ns, but every element with a tabindex attribute is listed to quickly indicate " +\n                                            "if it used excessively.</p> <ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            if (data.tabindex[x][1] === true) {\n                                                attr.push("<strong>");\n                                                z = z + 1;\n                                            }\n                                            attr.push(\n                                                token[data.tabindex[x][0]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            if (data.tabindex[x][1] === true) {\n                                                attr.push("</strong>");\n                                            }\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.tabindex[x][0]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr[y] = z;\n                                        if (z !== 1) {\n                                            attr[y + 2] = attr[y + 2] + "s";\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push(\n                                            "<div><h4><strong>0</strong> elements with a <em>tabindex</em> attribute</h4> <p>The" +\n                                            " tabindex attribute should have a 0 or -1 value and should not be over used.</" +\n                                            "p></div>"\n                                        );\n                                    }\n                                    //headings\n                                    b = data.headings.length;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        attr.push(b);\n                                        attr.push("</strong> HTML heading tag");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            " and their order</h4> <p>Poorly ordered tags are described with a <strong>stro" +\n                                            "ng</strong> tag (color red).</p> <ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            if (data.headings[x][2] === true) {\n                                                attr.push("<strong>");\n                                            }\n                                            attr.push(\n                                                token[data.headings[x][0]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            if (data.headings[x][2] === true) {\n                                                attr.push("</strong>");\n                                            }\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.headings[x][0]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push("<div><h4><strong>0</strong> HTML heading elements</h4>");\n                                        attr.push(\n                                            "<p>When heading tags are present it is important they are properly ordered so " +\n                                            "that the content they describe can be navigated in the proper order.</p></div>"\n                                        );\n                                    }\n                                    //missing alt attributes on images\n                                    b               = data.noalt.length;\n                                    data.violations = data.violations + b;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        attr.push(b);\n                                        attr.push("</strong> image");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            " missing a required <em>alt</em> attribute</h4> <p>The alt attribute is requir" +\n                                            "ed even if it contains no value.</p> <ol>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            attr.push(\n                                                token[data.noalt[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.noalt[x]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push(\n                                            "<div><h4><strong>0</strong> images missing a required <em>alt</em> attribute</h4> <" +\n                                            "p>The alt attribute is required even if it contains no value.</p></div>"\n                                        );\n                                    }\n                                    //alt attributes with empty values\n                                    b               = data.emptyalt.length;\n                                    data.violations = data.violations + b;\n                                    if (b > 0) {\n                                        attr.push("<div><h4><strong>");\n                                        attr.push(b);\n                                        attr.push("</strong> image");\n                                        if (b > 1) {\n                                            attr.push("s");\n                                        }\n                                        attr.push(\n                                            " have an empty <em>alt</em> attribute value</h4> <p>Empty alt text is not nece" +\n                                            "ssarily a violation, such as the case of tracking pixels. If an image has embe" +\n                                            "dded text this content should be supplied in the alt attribute.</p>"\n                                        );\n                                        for (x = 0; x < b; x = x + 1) {\n                                            attr.push("<li><code>");\n                                            attr.push(\n                                                token[data.emptyalt[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\n                                            );\n                                            attr.push("</code> on input line number ");\n                                            attr.push(linen[data.emptyalt[x]]);\n                                            attr.push("</li>");\n                                        }\n                                        attr.push("</ol></div>");\n                                    } else {\n                                        attr.push(\n                                            "<div><h4><strong>0</strong> images have an empty <em>alt</em> attribute value</h4>"\n                                        );\n                                        attr.push(\n                                            "<p>Empty alt text is not necessarily a violation, such as the case of tracking" +\n                                            " pixels. If an image has embedded text this content should be supplied in the " +\n                                            "alt attribute.</p></div>"\n                                        );\n                                    }\n                                    attr.push("</div>");\n                                    return attr.join("");\n                                };\n                            if (options.accessibility === false) {\n                                return "";\n                            }\n                            findings.push(tagsbyname());\n                            return findings.join("");\n                        }()\n                    ),\n                    parseErrors   = (function markuppretty__beautify_apply_summary_parseErrors() {\n                        var x     = parseError.length,\n                            y     = 0,\n                            fails = [];\n                        data.violations = data.violations + x;\n                        if (parseError.length > 1) {\n                            globalerror = parseError[0].replace(options.functions.binaryCheck, "");\n                        }\n                        if (x === 0) {\n                            return "";\n                        }\n                        fails.push("<h4><strong>");\n                        fails.push(x);\n                        fails.push("</strong> errors interpreting markup</h4> <ol>");\n                        for (y = 0; y < x; y = y + 1) {\n                            fails.push("<li>");\n                            fails.push(\n                                parseError[y].replace(options.functions.binaryCheck, "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace("element: ", "element: <code>")\n                            );\n                            fails.push("</code></li>");\n                        }\n                        fails.push("</ol>");\n                        return fails.join("");\n                    }()),\n                    sizes         = (function markuppretty__beautify_apply_summary_sizes() {\n                        var table      = [],\n                            outlines   = output\n                                .split(lf)\n                                .length,\n                            outsize    = output.length,\n                            linechange = (outlines / line) * 100,\n                            charchange = (outsize / sourceSize) * 100;\n                        table.push("<h4>Data sizes</h4>");\n                        table.push(\n                            "<table class=\'analysis\' summary=\'Data sizes\'><caption>This table shows changes" +\n                            " in sizes of the data due to beautification.</caption>"\n                        );\n                        table.push(\n                            "<thead><tr><th>Data figure</th><th>Input</th><th>Output</th><th>Percent change" +\n                            "</th></tr></thead><tbody>"\n                        );\n                        table.push("<tr><th>Lines of code</th><td>");\n                        table.push(numformat(line));\n                        table.push("</td><td>");\n                        table.push(numformat(outlines));\n                        table.push("</td><td>");\n                        table.push(linechange.toFixed(2));\n                        table.push("%</td></tr>");\n                        table.push("<tr><th>Character size</th><td>");\n                        table.push(numformat(sourceSize));\n                        table.push("</td><td>");\n                        table.push(numformat(outsize));\n                        table.push("</td><td>");\n                        table.push(charchange.toFixed(2));\n                        table.push("%</td></tr>");\n                        table.push("</tbody></table>");\n                        return table.join("");\n                    }()),\n                    statistics    = (function markuppretty__beautify_apply_summary_statistics() {\n                        var stat       = [],\n                            totalItems = stats.cdata[0] + stats.comment[0] + stats.content[0] + stats.end[0] +\n                                    stats.ignore[0] + stats.script[0] + stats.sgml[0] + stats.singleton[0] +\n                                    stats.start[0] + stats.style[0] + stats.template[0] + stats.text[0] + stats.xml[0],\n                            totalSizes = stats.cdata[1] + stats.comment[1] + stats.content[1] + stats.end[1] +\n                                    stats.ignore[1] + stats.script[1] + stats.sgml[1] + stats.singleton[1] +\n                                    stats.start[1] + stats.style[1] + stats.template[1] + stats.text[1] + stats.xml[1],\n                            rowBuilder = function markuppretty__beautify_apply_summary_statistics_rowBuilder(\n                                type\n                            ) {\n                                var itema = (type === "Total*")\n                                        ? totalItems\n                                        : stats[type][0],\n                                    itemb = (type === "Total*")\n                                        ? totalSizes\n                                        : stats[type][1],\n                                    ratio = 0;\n                                stat.push("<tr><th>");\n                                stat.push(type);\n                                if (itema > 0 && (type === "script" || type === "style")) {\n                                    stat.push("**");\n                                }\n                                stat.push("</th><td");\n                                if ((globalerror.indexOf(" more start tag") || globalerror.indexOf(" more end tag")) && (type === "start" || type === "end")) {\n                                    stat.push(" class=\\"bad\\"");\n                                }\n                                stat.push(">");\n                                stat.push(itema);\n                                stat.push("</td><td>");\n                                ratio = ((itema / totalItems) * 100);\n                                stat.push(ratio.toFixed(2));\n                                stat.push("%</td><td>");\n                                stat.push(itemb);\n                                stat.push("</td><td");\n                                if (itema > 0 && (type === "script" || type === "style")) {\n                                    stat.push(" class=\'bad\'");\n                                }\n                                stat.push(">");\n                                ratio = ((itemb / totalSizes) * 100);\n                                stat.push(ratio.toFixed(2));\n                                stat.push("%</td></tr>");\n                            };\n                        stat.push("<h4>Statistics and analysis of parsed code</h4>");\n                        stat.push(\n                            "<table class=\'analysis\' summary=\'Statistics\'><caption>This table provides basi" +\n                            "c statistics about the parsed components of the given code sample after beauti" +\n                            "fication.</caption>"\n                        );\n                        stat.push(\n                            "<thead><tr><th>Item type</th><th>Number of instances</th><th>Percentage of tot" +\n                            "al items</th><th>Character size</th><th>Percentage of total size</th></tr></th" +\n                            "ead>"\n                        );\n                        stat.push("<tbody>");\n                        rowBuilder("Total*");\n                        rowBuilder("cdata");\n                        rowBuilder("comment");\n                        rowBuilder("content");\n                        rowBuilder("end");\n                        rowBuilder("ignore");\n                        rowBuilder("script");\n                        rowBuilder("sgml");\n                        rowBuilder("singleton");\n                        rowBuilder("start");\n                        rowBuilder("style");\n                        rowBuilder("template");\n                        rowBuilder("text");\n                        rowBuilder("xml");\n                        stat.push("<tr><th>space between tags***</th><td colspan=\'4\'>");\n                        stat.push(stats.space);\n                        stat.push("</td></tr>");\n                        stat.push("</tbody></table> ");\n                        stat.push(\n                            "<p>* Totals are accounted for parsed code/content tokens only and not extraneo" +\n                            "us space for beautification.</p> "\n                        );\n                        stat.push(\n                            "<p>** Script and Style code is measured with minimal white space.</p>"\n                        );\n                        stat.push(\n                            "<p>*** This is space that is not associated with text, tags, script, or css.</" +\n                            "p> "\n                        );\n                        return stat.join("");\n                    }()),\n                    zipf          = (function markuppretty__beautify_apply_summary_zipf() {\n                        var x          = 0,\n                            ratio      = 0,\n                            wordlen    = 0,\n                            wordcount  = 0,\n                            word       = "",\n                            wordlist   = [],\n                            wordtotal  = [],\n                            wordproper = [],\n                            zipfout    = [],\n                            identical  = true,\n                            sortchild  = function markuppretty__beautify_apply_summary_zipf_sortchild(y, z) {\n                                return z[0] - y[0];\n                            };\n                        for (x = x; x < len; x = x + 1) {\n                            if (types[x] === "content") {\n                                wordlist.push(token[x]);\n                            }\n                        }\n                        wordlist = safeSort(\n                            wordlist.join(" ").replace(options.functions.binaryCheck, "").toLowerCase().replace(/&nbsp;/gi, " ").replace(/(,|\\.|\\?|!|:|\\(|\\)|"|\\{|\\}|\\[|\\])/g, "").replace(/\\s+/g, " ").replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").split(" ")\n                        );\n                        wordlen  = wordlist.length;\n                        for (x = 0; x < wordlen; x = x + 1) {\n                            word = wordlist[x];\n                            if (word.length > 2 && word.length < 30 && (/&#?\\w+;/).test(word) === false && word !== "the" && word !== "and" && word !== "for" && word !== "are" && word !== "this" && word !== "from" && word !== "with" && word !== "that" && word !== "to") {\n                                if (wordproper.length === 0 || word !== wordproper[wordproper.length - 1][1]) {\n                                    wordproper.push([1, word]);\n                                } else {\n                                    wordproper[wordproper.length - 1][0] = wordproper[wordproper.length - 1][0] + 1;\n                                }\n                            }\n                            if (word !== wordlist[x - 1]) {\n                                wordtotal.push([1, word]);\n                            } else {\n                                wordtotal[wordtotal.length - 1][0] = wordtotal[wordtotal.length - 1][0] + 1;\n                            }\n                        }\n                        wordtotal  = wordtotal\n                            .sort(sortchild)\n                            .slice(0, 11);\n                        wordproper = wordproper\n                            .sort(sortchild)\n                            .slice(0, 11);\n                        wordlen    = (wordproper.length > 10)\n                            ? 11\n                            : wordproper.length;\n                        for (x = 0; x < wordlen; x = x + 1) {\n                            if (wordtotal[x][1] !== wordproper[x][1]) {\n                                identical = false;\n                                break;\n                            }\n                        }\n                        wordlen = (wordtotal.length > 10)\n                            ? 10\n                            : wordtotal.length;\n                        if (wordlen > 1) {\n                            wordcount = wordlist.length;\n                            zipfout.push("<h4>Zipf\'s Law analysis of content</h4>");\n                            zipfout.push(\n                                "<table class=\'analysis\' summary=\'Zipf&#39;s Law\'><caption>This table demonstra" +\n                                "tes <em>Zipf&#39;s Law</em> by listing the 10 most occuring words in the conte" +\n                                "nt and the number of times they occurred.</caption>"\n                            );\n                            zipfout.push(\n                                "<thead><tr><th>Word Rank</th><th>Most Occurring Word by Rank</th><th>Number of" +\n                                " Instances</th><th>Ratio Increased Over Next Most Frequence Occurance</th><th>" +\n                                "Percentage from "\n                            );\n                            zipfout.push(wordcount);\n                            zipfout.push(" total words</th></tr></thead><tbody>");\n                            if (identical === false) {\n                                zipfout.push("<tr><th colspan=\'5\'>Unfiltered Word Set</th></tr>");\n                            }\n                            for (x = 0; x < wordlen; x = x + 1) {\n                                ratio = (wordtotal[x + 1] !== undefined)\n                                    ? (wordtotal[x][0] / wordtotal[x + 1][0])\n                                    : 1;\n                                zipfout.push("<tr><td>");\n                                zipfout.push(x + 1);\n                                zipfout.push("</td><td>");\n                                zipfout.push(wordtotal[x][1]);\n                                zipfout.push("</td><td>");\n                                zipfout.push(wordtotal[x][0]);\n                                zipfout.push("</td><td>");\n                                zipfout.push(ratio.toFixed(2));\n                                zipfout.push("</td><td>");\n                                ratio = ((wordtotal[x][0] / wordcount) * 100);\n                                zipfout.push(ratio.toFixed(2));\n                                zipfout.push("%</td></tr>");\n                            }\n                            wordlen = (wordproper.length > 10)\n                                ? 10\n                                : wordproper.length;\n                            if (wordlen > 1 && identical === false) {\n                                zipfout.push("<tr><th colspan=\'5\'>Filtered Word Set</th></tr>");\n                                for (x = 0; x < wordlen; x = x + 1) {\n                                    ratio = (wordproper[x + 1] !== undefined)\n                                        ? (wordproper[x][0] / wordproper[x + 1][0])\n                                        : 1;\n                                    zipfout.push("<tr><td>");\n                                    zipfout.push(x + 1);\n                                    zipfout.push("</td><td>");\n                                    zipfout.push(wordproper[x][1]);\n                                    zipfout.push("</td><td>");\n                                    zipfout.push(wordproper[x][0]);\n                                    zipfout.push("</td><td>");\n                                    zipfout.push(ratio.toFixed(2));\n                                    zipfout.push("</td><td>");\n                                    ratio = ((wordproper[x][0] / wordcount) * 100);\n                                    zipfout.push(ratio.toFixed(2));\n                                    zipfout.push("%</td></tr>");\n                                }\n                            }\n                            zipfout.push("</tbody></table>");\n                        }\n                        return zipfout.join("");\n                    }());\n\n                sum.push(\n                    "<p><strong>Total number of HTTP requests (presuming HTML or XML Schema):</stro" +\n                    "ng> <em>"\n                );\n                sum.push(reqs.length);\n                sum.push("</em></p>");\n                sum.push("<div class=\'report\'>");\n                sum.push(analysis(ids));\n                sum.push(sizes);\n                sum.push(parseErrors);\n                if (options.accessibility === true) {\n                    sum.push(accessibility);\n                }\n                sum.push(statistics);\n                sum.push(analysis(reqs));\n                sum.push(zipf);\n                sum.push("</div>");\n                if (options.accessibility === true) {\n                    if (options.nodeasync === true) {\n                        return [\n                            sum\n                                .join("")\n                                .replace(\n                                    "<div class=\'report\'>",\n                                    "<p><strong>Total potential accessibility violations:</strong> <em>" + data.violations +\n                                            "</em></p> <div class=\'report\'>"\n                                ),\n                            globalerror\n                        ];\n                    }\n                    return sum\n                        .join("")\n                        .replace(\n                            "<div class=\'report\'>",\n                            "<p><strong>Total potential accessibility violations:</strong> <em>" + data.violations +\n                                    "</em></p> <div class=\'report\'>"\n                        );\n                }\n                if (options.nodeasync === true) {\n                    return [sum.join(""), globalerror];\n                }\n                return sum.join("");\n            }());\n        }\n        return output;\n    };\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        //requirejs support\n        define(function markuppretty_requirejs() {\n            return function markuppretty_requirejs_wrapper(x) {\n                return markuppretty(x);\n            };\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports = markuppretty;\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n            (function glib_markuppretty() {\n                var localPath = (\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\n                )\n                    ? __dirname\n                    : ".";\n                if (global.prettydiff.csspretty === undefined) {\n                    global.prettydiff.csspretty = require(\n                        localPath + "/csspretty.js"\n                    );\n                }\n                if (global.prettydiff.jspretty === undefined) {\n                    global.prettydiff.jspretty = require(\n                        localPath + "/jspretty.js"\n                    );\n                }\n                if (global.prettydiff.safeSort === undefined) {\n                    global.prettydiff.safeSort = require(\n                        localPath + "/safeSort.js"\n                    );\n                }\n            }());\n        }\n    } else {\n        global.prettydiff.markuppretty = markuppretty;\n    }\n}());\n'},function(n,e){n.exports='/*prettydiff.com topcoms: true, insize: 4, inchar: " ", vertical: true */\n/*jshint laxbreak: true*/\n/*global __dirname, ace, console, define, global, module, options, performance, process, require */\n/*\n\n Execute in a NodeJS app:\n\n    var prettydiff = require("prettydiff"),\n        args       = {\n            source: "asdf",\n            diff  : "asdd",\n            lang  : "text"\n        },\n        output     = prettydiff(args);\n\n Execute on command line with NodeJS:\n\n    node api/node-local.js source:"c:\\mydirectory\\myfile.js" readmethod:"file" diff:"c:\\myotherfile.js"\n\n Execute from JavaScript:\n    var global = {},\n        args   = {\n            source: "asdf",\n            diff  : "asdd",\n            lang  : "text"\n        },\n        output = prettydiff(args);\n\n Manage with biddle\n     biddle install http://prettydiff.com/downloads/prettydiff/prettydiff_latest.zip\n     biddle global prettydiff\n     prettydiff source:"c:\\mydirectory\\myfile.js" readmethod:"file" diff:"c:\\myotherfile.js"\n\n Please see the license.txt file associated with the Pretty Diff\n application for license information.\n\n Special thanks to:\n\n * Harry Whitfield for the numerous test cases provided against\n JSPretty.  http://g6auc.me.uk/\n\n * Andreas Greuel for contributing samples to test diffview.js\n https://plus.google.com/105958105635636993368/posts\n\n */\n(function prettydiff_init() {\n    "use strict";\n    var prettydiff = function prettydiff_(api) {\n        var startTime = Date.now(),\n            core      = function core_(api) {\n                var spacetest    = (/^\\s+$/g),\n                    apioutput    = "",\n                    apidiffout   = "",\n                    metaerror    = "",\n                    finalFile    = global.prettydiff.finalFile,\n                    options      = global\n                        .prettydiff\n                        .options\n                        .functions\n                        .validate(api),\n                    jspretty     = function core__jspretty() {\n                        var jsout = global\n                            .prettydiff\n                            .jspretty(options);\n                        if (options.nodeasync === true) {\n                            metaerror = jsout[1];\n                            return jsout[0];\n                        }\n                        metaerror = global.prettydiff.meta.error;\n                        return jsout;\n                    },\n                    markuppretty = function core__markuppretty() {\n                        var markout = global\n                            .prettydiff\n                            .markuppretty(options);\n                        if (options.nodeasync === true) {\n                            metaerror = markout[1];\n                            if (options.mode === "beautify" && options.inchar !== "\\t") {\n                                markout[0] = markout[0].replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\n                            } else if (options.mode === "diff") {\n                                markout[0] = markout[0].replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\n                            }\n                            return markout[0];\n                        }\n                        metaerror = global.prettydiff.meta.error;\n                        if (options.mode === "beautify" && options.inchar !== "\\t") {\n                            markout = markout.replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\n                        } else if (options.mode === "diff") {\n                            markout = markout.replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\n                        }\n                        return markout;\n                    },\n                    csspretty    = function core__markupcss() {\n                        var cssout = global\n                            .prettydiff\n                            .csspretty(options);\n                        if (options.nodeasync === true) {\n                            metaerror = cssout[1];\n                            return cssout[0];\n                        }\n                        metaerror = global.prettydiff.meta.error;\n                        return cssout;\n                    },\n                    proctime     = function core__proctime() {\n                        var minuteString = "",\n                            hourString   = "",\n                            minutes      = 0,\n                            hours        = 0,\n                            elapsed      = (Date.now() - startTime) / 1000,\n                            secondString = elapsed + "",\n                            plural       = function core__proctime_plural(x, y) {\n                                var a = x + y;\n                                if (x !== 1) {\n                                    a = a + "s";\n                                }\n                                if (y !== " second") {\n                                    a = a + " ";\n                                }\n                                return a;\n                            },\n                            minute       = function core__proctime_minute() {\n                                minutes      = parseInt((elapsed / 60), 10);\n                                minuteString = plural(minutes, " minute");\n                                minutes      = elapsed - (minutes * 60);\n                                secondString = (minutes === 1)\n                                    ? "1 second"\n                                    : minutes.toFixed(3) + " seconds";\n                            };\n                        if (elapsed >= 60 && elapsed < 3600) {\n                            minute();\n                        } else if (elapsed >= 3600) {\n                            hours      = parseInt((elapsed / 3600), 10);\n                            hourString = hours.toString();\n                            elapsed    = elapsed - (hours * 3600);\n                            hourString = plural(hours, " hour");\n                            minute();\n                        } else {\n                            secondString = plural(secondString, " second");\n                        }\n                        return hourString + minuteString + secondString;\n                    },\n                    output       = function core__output(finalProduct, difftotal, difflines) {\n                        var meta         = {\n                                difflines: 0,\n                                difftotal: 0,\n                                error    : "",\n                                insize   : 0,\n                                lang     : [\n                                    "", "", ""\n                                ],\n                                outsize  : 0,\n                                time     : ""\n                            };\n                        meta.lang   = options.autoval;\n                        meta.time   = proctime();\n                        meta.insize = (options.mode === "diff")\n                            ? options.source.length + options.diff.length\n                            : options.source.length;\n                        if (options.mode === "parse" && options.lang !== "text" && typeof finalProduct === "object" && (options.autoval[0] !== "" || options.lang !== "auto")) {\n                            if (options.parseFormat === "sequential" || options.parseFormat === "htmltable") {\n                                meta.outsize = finalProduct.data.length;\n                            } else {\n                                meta.outsize = finalProduct.data.token.length;\n                            }\n                        } else {\n                            meta.outsize = finalProduct.length;\n                        }\n                        if (options.autoval[0] === "text" && options.mode !== "diff") {\n                            if (options.autoval[2] === "unknown") {\n                                meta.error = "Language is set to auto, but could not be detected. File not parsed.";\n                            } else {\n                                meta.error = "Language is set to text, but plain text is only supported in diff mode. File n" +\n                                        "ot parsed.";\n                            }\n                        }\n                        if (difftotal !== undefined) {\n                            meta.difftotal = difftotal;\n                        }\n                        if (difflines !== undefined) {\n                            meta.difflines = difflines;\n                        }\n                        meta.error = metaerror;\n                        if (options.nodeasync === true) {\n                            return [finalProduct, meta];\n                        }\n                        global.prettydiff.meta = meta;\n                        return finalProduct;\n                    };\n                if (options.source === "" && (options.mode === "beautify" || options.mode === "minify" || options.mode === "analysis" || (options.mode === "diff" && options.diffcli === false) || (options.mode === "parse" && options.parseFormat === "htmltable"))) {\n                    metaerror = "options.source is empty!";\n                    console.log(metaerror);\n                    return output("", 0, 0);\n                }\n                if (options.mode === "diff" && options.diffcli === false) {\n                    if (options.diff === "") {\n                        metaerror = "options.mode is \'diff\' and options.diff is empty!";\n                        console.log(metaerror);\n                        return output("", 0, 0);\n                    }\n                    if (options.lang === "csv") {\n                        options.lang = "text";\n                    }\n                }\n                if (options.autoval[0] === "text" && options.mode !== "diff") {\n                    metaerror = "Language is either text or undetermined, but text is only allowed for the \'dif" +\n                            "f\' mode!";\n                    return output(options.source, 0, 0);\n                }\n                finalFile.order[7] = options.color;\n                if (options.mode === "diff") {\n                    options.vertical = false;\n                    options.jsscope  = "none";\n                    options.preserve = 0;\n                    if (options.diffcomments === false) {\n                        options.comments = "nocomment";\n                    }\n                    if (options.lang === "css") {\n                        apioutput      = csspretty();\n                        options.source = options.diff;\n                        apidiffout     = csspretty();\n                    } else if (options.lang === "csv") {\n                        apioutput  = global\n                            .prettydiff\n                            .csvpretty(options);\n                        apidiffout = global\n                            .prettydiff\n                            .csvpretty(options);\n                    } else if (options.lang === "markup") {\n                        apioutput      = markuppretty();\n                        options.source = options.diff;\n                        apidiffout     = markuppretty();\n                    } else if (options.lang === "text") {\n                        apioutput  = options.source;\n                        apidiffout = options.diff;\n                    } else {\n                        apioutput      = jspretty();\n                        options.source = options.diff;\n                        apidiffout     = jspretty();\n                    }\n                    if (options.quote === true) {\n                        apioutput  = apioutput.replace(/\'/g, "\\"");\n                        apidiffout = apidiffout.replace(/\'/g, "\\"");\n                    }\n                    if (options.semicolon === true) {\n                        apioutput  = apioutput\n                            .replace(/;\\r\\n/g, "\\r\\n")\n                            .replace(/;\\n/g, "\\n");\n                        apidiffout = apidiffout\n                            .replace(/;\\r\\n/g, "\\r\\n")\n                            .replace(/;\\n/g, "\\n");\n                    }\n                    if (options.sourcelabel === "" || spacetest.test(options.sourcelabel)) {\n                        options.sourcelabel = "Base Text";\n                    }\n                    if (options.difflabel === "" || spacetest.test(options.difflabel)) {\n                        options.difflabel = "New Text";\n                    }\n                    if (options.jsx === true) {\n                        options.autoval = ["jsx", "javascript", "React JSX"];\n                    }\n                    return (function core__diff() {\n                        var a = "";\n                        options.diff   = apidiffout;\n                        options.source = apioutput;\n                        if (options.diffcli === true) {\n                            a = global.prettydiff.diffview(options);\n                            return output(a[0], a[1], a[2]);\n                        }\n                        if (apioutput === "Error: This does not appear to be JavaScript." || apidiffout === "Error: This does not appear to be JavaScript.") {\n                            return output(\n                                "<p><strong>Error:</strong> Please try using the option labeled <em>Plain Text " +\n                                "(diff only)</em>. <span style=\'display:block\'>The input does not appear to be " +\n                                "markup, CSS, or JavaScript.</span></p>", 0, 0\n                            );\n                        }\n                        if (options.lang === "text") {\n                            options.inchar = "";\n                        }\n                        a = global\n                            .prettydiff\n                            .diffview(options);\n                        if (options.jsx === true) {\n                            options.autoval = ["jsx", "javascript", "React JSX"];\n                        }\n                        if (options.api === "") {\n                            finalFile.order[10] = a[0];\n                            finalFile.order[12] = finalFile.script.diff;\n                            return output(finalFile.order.join(""), a[1], a[2]);\n                        }\n                        return output(a[0], a[1], a[2]);\n                    }());\n                } else {\n                    if (options.mode === "analysis") {\n                        options.accessibility = true;\n                    }\n                    if (options.lang === "css") {\n                        apioutput = csspretty();\n                    } else if (options.lang === "csv") {\n                        apioutput = global\n                            .prettydiff\n                            .csvpretty(options);\n                    } else if (options.lang === "markup") {\n                        apioutput = markuppretty();\n                    } else if (options.lang === "text") {\n                        apioutput  = options.source;\n                        apidiffout = "";\n                    } else {\n                        apioutput = jspretty();\n                    }\n                    if (options.api === "") {\n                        if (options.mode === "analysis" || (options.mode === "parse" && options.parseFormat === "htmltable")) {\n                            finalFile.order[10] = apidiffout;\n                            apioutput           = finalFile\n                                .order\n                                .join("");\n                        } else if (options.mode === "beautify" && options.jsscope !== "none" && (options.lang === "javascript" || options.lang === "json")) {\n                            finalFile.order[10] = apidiffout;\n                            finalFile.order[12] = finalFile.script.beautify;\n                            apioutput           = finalFile\n                                .order\n                                .join("");\n                        }\n                    }\n                    if (options.jsx === true) {\n                        options.autoval = ["jsx", "javascript", "React JSX"];\n                    }\n                    return output(apioutput, 0, 0);\n                }\n            };\n        return core(api);\n    };\n\n    if (typeof global.prettydiff !== "object") {\n        global.prettydiff = {};\n    }\n    if (typeof global.prettydiff.meta !== "object") {\n        // schema for global.prettydiff.meta lang - array, language detection time -\n        // string, proctime (total execution time minus visual rendering) insize -\n        // number, input size outsize - number, output size difftotal - number,\n        // difference count difflines - number, difference lines\n        global.prettydiff.meta = {\n            difflines: 0,\n            difftotal: 0,\n            error    : "",\n            insize   : 0,\n            lang     : [\n                "", "", ""\n            ],\n            outsize  : 0,\n            time     : ""\n        };\n    }\n    if (typeof process === "object" && Array.isArray(process.argv) === true && process.argv[1].replace(/\\\\/g, "/").replace(".js", "").split("prettydiff/prettydiff")[1] === "") {\n        return console.log("This file \\u001b[31m\\u001b[1mdoes not execute from the command line\\u001b[0m\\u001b[39m.  Use \\u001b[32mapi/node-local.js\\u001b[39m instead.");\n    }\n    if (typeof define === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n        define(function prettydiff_requirejs() {\n            return function prettydiff_requirejs_wrapper(x) {\n                return prettydiff(x);\n            };\n        });\n    } else if (typeof module === "object" && typeof module.parent === "object") {\n        //commonjs and nodejs support\n        module.exports         = function commonjs_prettydiff(x) {\n            return prettydiff(x);\n        };\n        module.exports.edition = global.prettydiff.edition;\n        module.exports.meta    = global.prettydiff.meta;\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\n            (function glib_prettydiff() {\n                var localPath = (\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\n                )\n                    ? __dirname\n                    : ".";\n                if (global.prettydiff.language === undefined) {\n                    global.prettydiff.language = require(\n                        localPath + "/lib/language.js"\n                    );\n                }\n                if (global.prettydiff.finalFile === undefined) {\n                    global.prettydiff.finalFile = require(\n                        localPath + "/lib/finalFile.js"\n                    );\n                }\n                if (global.prettydiff.csspretty === undefined) {\n                    global.prettydiff.csspretty = require(\n                        localPath + "/lib/csspretty.js"\n                    );\n                }\n                if (global.prettydiff.csvpretty === undefined) {\n                    global.prettydiff.csvpretty = require(\n                        localPath + "/lib/csvpretty.js"\n                    );\n                }\n                if (global.prettydiff.diffview === undefined) {\n                    global.prettydiff.diffview = require(\n                        localPath + "/lib/diffview.js"\n                    );\n                }\n                if (global.prettydiff.jspretty === undefined) {\n                    global.prettydiff.jspretty = require(\n                        localPath + "/lib/jspretty.js"\n                    );\n                }\n                if (global.prettydiff.options === undefined) {\n                    global.prettydiff.options = require(\n                        localPath + "/lib/options.js"\n                    );\n                }\n                if (global.prettydiff.safeSort === undefined) {\n                    global.prettydiff.safeSort = require(\n                        localPath + "/lib/safeSort.js"\n                    );\n                }\n                if (global.prettydiff.markuppretty === undefined) {\n                    global.prettydiff.markuppretty = require(\n                        localPath + "/lib/markuppretty.js"\n                    );\n                }\n            }());\n        }\n    } else {\n        global.prettydiff.prettydiff = prettydiff;\n    }\n    global.prettydiff.edition        = {\n        addon        : {\n            ace: 160307\n        },\n        api          : {\n            dom      : 170707, //dom.js\n            nodeLocal: 170707 //node-local.js\n        },\n        css          : 170707, //css files\n        csspretty    : 170707, //csspretty lib\n        csvpretty    : 170514, //csvpretty lib\n        diffview     : 170521, //diffview lib\n        documentation: 170707, //documentation.xhtml and various guide pages\n        finalFile    : 170514, //HTML report generator\n        jspretty     : 170707, //jspretty lib\n        language     : 170514, //language lib\n        latest       : 0,\n        lint         : 170707, //unit test and lint automation as test/lint.js\n        markuppretty : 170707, //markuppretty lib\n        options      : 170521, //options management\n        prettydiff   : 170707, //this file\n        safeSort     : 170514, //safeSort lib\n        version      : "2.2.8", //version number\n        webtool      : 170707\n    };\n    global.prettydiff.edition.latest = (function edition_latest() {\n        return Math.max(\n            global.prettydiff.edition.css,\n            global.prettydiff.edition.csspretty,\n            global.prettydiff.edition.csvpretty,\n            global.prettydiff.edition.diffview,\n            global.prettydiff.edition.documentation,\n            global.prettydiff.edition.finalFile,\n            global.prettydiff.edition.jspretty,\n            global.prettydiff.edition.language,\n            global.prettydiff.edition.markuppretty,\n            global.prettydiff.edition.options,\n            global.prettydiff.edition.prettydiff,\n            global.prettydiff.edition.webtool,\n            global.prettydiff.edition.api.dom,\n            global.prettydiff.edition.api.nodeLocal\n        );\n    }());\n}());\n'}]);