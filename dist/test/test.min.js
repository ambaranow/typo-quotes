/*! typoquotes v0.1.1 */
!function(n){function e(t){if(r[t])return r[t].exports;var a=r[t]={i:t,l:!1,exports:{}};return n[t].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var r={};e.m=n,e.c=r,e.d=function(n,r,t){e.o(n,r)||Object.defineProperty(n,r,{configurable:!1,enumerable:!0,get:t})},e.n=function(n){var r=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(r,"a",r),r},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=26)}([function(n,e,r){"use strict";function t(n,e){return e.forEach(function(e,r){n=n.replace(r,e)}),n}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&function(){return"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener}()?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},function(n,e,r){"use strict";function t(n,e){var r=new Map;return e.map(function(e){n=n.replace(e,function(n){var e=(Math.random()+"").substr(2);return r.set(e,n),"{"+e+"}"})}),{text:n,parts:r}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){return e.forEach(function(e,r){n=n.replace("{"+r+"}",e)}),n}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var t=r(5);e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var a=function(){function n(n,e){for(var r=0;r<e.length;r++){var t=e[r];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}return function(e,r,t){return r&&n(e.prototype,r),t&&n(e,t),e}}(),s=["quotes","dashes","angles","dblspace","specials","mathchars","punctuation","specialspaces","phones","numbers","nbsp","hellip","units"],i=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t(this,n),e.actionlist=e.actionlist||s,e.lang=e.lang||"ru",this.preserveParts=r(2),this.restoreParts=r(3),this.processSpecials=r(6),this.processMath=r(7),this.processMinuses=r(8),this.processPunctuation=r(9),this.processSpecialSpaces=r(10),this.processAngles=r(11),this.processMultipleSpaces=r(12),this.processQuotes=r(13),this.processQuotesInner=r(14),this.processDashes=r(15),this.processPhones=r(16),this.processNumbers=r(17),this.processNbsps=r(18),this.processHellips=r(19),this.processUnits=r(20),this.actions(e.actionlist),this.lang(e.lang),this.m=[],this.tag="untypo",this.s="",this.normsym=["—","«","»","…","©","®","™","←","→","↑","↓","↔","°","́","×","≠","±","↕","‘","’","−","–","“","”","„","≥","≤","§","€","£","″","√","∫","½","¼","¾"," ","‚","¹","²","³","⅓","⅔","⅕","⅖","⅗","⅘","⅙","⅚","⅛","⅜","⅝","⅞","≈","'","⁰","⁴","⁵","⁶","⁷","⁸","⁹","⁺","⁻","⁼","⁽","⁾","ⁿ","ⁱ","₀","₁","₂","₃","₄","₅","₆","₇","₈","₉","₊","₋","₌","₍","₎"],this.htmlsym=["mdash","laquo","raquo","hellip","copy","reg","trade","larr","rarr","uarr","darr","harr","deg","#769","times","ne","plusmn","#8597","lsquo","rsquo","minus","ndash","ldquo","rdquo","bdquo","ge","le","sect","euro","pound","Prime","radic","int","frac12","frac14","frac34","nbsp","sbquo","sup1","sup2","sup3","#8531","#8532","#8533","#8534","#8535","#8536","#8537","#8538","#8539","#8540","#8541","#8542","#8776","quot","#8304","#8308","#8309","#8310","#8311","#8312","#8313","#8314","#8315","#8316","#8317","#8318","#8319","#8305","#8320","#8321","#8322","#8323","#8324","#8325","#8326","#8327","#8328","#8329","#8330","#8331","#8332","#8333","#8334"],this.RegLink=this.r("([  \n\t\v]|^)(((ht|f)tps?://)?([\\-\\w]+:[\\-\\w]+@)?([0-9a-z][\\-0-9a-z]*[0-9a-z]\\.)+[a-z]{2,6}(:\\d{1,5})?([?/\\\\#][?!^$.(){}:|=[\\]+\\-/\\\\*;&~#@,%\\wА-Яа-я]*)?)([  \n\t\v]|$)","gi"),this.RegMail=this.r("([  \n\t\v]|^)([\\-a-z0-9!#$%&'*+\\/=?^_`{|}~]+(\\.[\\-a-z0-9!#$%&'*+\\/=?^_`{|}~]+)*@([a-z0-9]([\\-a-z0-9]{0,61}[a-z0-9])?.)*([a-z]{2,6}))([  \n\t\v]|$)","gi")}return a(n,[{key:"r",value:function(n,e){return RegExp(n,e)}},{key:"actions",value:function(n){this._actions=n}},{key:"lang",value:function(n){var e=["ru","en"],r=e.indexOf(n.toLowerCase());r=r>-1?r:0,this._lang=e[r]}},{key:"requested",value:function(n){return this._actions.includes(n)}},{key:"process",value:function(n){var e=this.prepare(n),r=e.text,t=e.parts;return this.requested("specials")&&(r=this.processSpecials(r)),this.requested("mathchars")&&(r=this.processMath(r)),(this.requested("mathchars")||this.requested("dashes"))&&(r=this.processMinuses(r,this._lang)),this.requested("punctuation")&&(r=this.processPunctuation(r,this._actions)),this.requested("specialspaces")&&(r=this.processSpecialSpaces(r)),this.requested("angles")&&(r=this.processAngles(r)),this.requested("dblspace")&&(r=this.processMultipleSpaces(r)),this.requested("quotes")&&(r=this.processQuotes(r),r=this.processQuotesInner(r,this._lang)),this.requested("dashes")&&(r=this.processDashes(r,this._actions)),this.requested("phones")&&(r=this.processPhones(r,this._lang)),this.requested("numbers")&&(r=this.processNumbers(r,this._lang)),this.requested("nbsp")&&(r=this.processNbsps(r)),this.requested("hellip")&&(r=this.processHellips(r)),this.requested("units")&&(r=this.processUnits(r)),this.ready(r,t)}},{key:"prepare",value:function(n){function e(e){i.s=n.match(i.r("<"+i.tag+">[\\s\\S]+?</"+i.tag+">","g"));var r=0;if(i.s)for(;r<i.s.length;r++){var t=i.s[r].replace(i.r("<\\/?"+i.tag+">","g"),"");i.m.push(t),n=n.replace("<"+i.tag+">"+t+"</"+i.tag+">","UNTYPO"+(r+e)+"S")}return r+e}var r=document.createElement("div");r.innerHTML=n;for(var t=r.querySelectorAll("[data-typo]"),a=t.length;a--;){var s=t[a].innerHTML;t[a].outerHTML=s}n=r.innerHTML;var i=this;n=n.replace(/(\r\n|\r)/g,"\n").replace(/(\[code\]|\[quote[^\]$\n]*\]|<pre[^<>]*?>|\[img\])/g,"<"+this.tag+">$1").replace(/(\[\/code\]|\[\/quote\]|<\/pre>|\[\/img\])/g,"$1</"+this.tag+">").replace(/(<script[^<>]*?>|<style[^<>]*?>)/g,"<"+this.tag+">$1").replace(/(<\/script>|<\/style>)/g,"$1</"+this.tag+">").replace(/(<!--(.|\n)*?-->)/g,"<"+this.tag+">$1</"+this.tag+">").replace(/(\[url[^\[\]]+?\])/g,"<"+this.tag+">$1</"+this.tag+">").replace(/(="[^"\n\r]*")/g,"<"+this.tag+">$1</"+this.tag+">");for(var o=0;o<10;++o)n=n.replace(this.r("(<"+this.tag+">)([\\s\\S]*?)(<\\/?"+this.tag+">)","g"),function(n,e,r,t){return"/"!==t.charAt(1)?e+r:n}),n=n.replace(this.r("(<\\/"+this.tag+">)([\\s\\S]*?)(<\\/?"+this.tag+">)","g"),function(n,e,r,t){return"/"===t.charAt(1)?r+t:n});for(var g=e(0),l=0;l<2;++l)n=n.replace(this.RegLink,"$1<"+this.tag+">$2</"+this.tag+">$9").replace(this.RegMail,"$1<"+this.tag+">$2</"+this.tag+">$7");g=e(g);for(var A=0;A<this.htmlsym.length;++A)n=n.replace(this.r("&"+this.htmlsym[A]+";","g"),this.normsym[A]);var p=[];return this.preserveParts(n,p)}},{key:"ready",value:function(n,e){n=n.replace(/ (\))/g,"$1");for(var r=this.m.length-1;r>=0;--r)n=n.replace("UNTYPO"+r+"S",this.m[r]);return n=n.replace(this.r("(<\\/?"+this.tag+">)+","g"),"$1"),this.restoreParts(n,e)}}]),n}();window.Typoquotes=i,e.default=i,n.exports=e.default},function(n,e,r){"use strict";function t(n){var e=new Map([[/(\([cс]\))|(\{copy\})/gi,"©"],[/(\(r\))|(\{reg\})/gi,"®"],[/(\((тм|tm)\))|(\{(tm|trade)\})/gi,"™"],[/\{(ss|sect)}/g,"§"],[/\{deg}/g,"°"],[/\{rub}|\(rub\)/g,"₽"],[/\{euro}|\(euro\)/g,"€"],[/\{cent}|\(cent\)/g,"¢"],[/\{pound}|\(pound\)/g,"£"],[/\{(yen|yuan)}|\(yen|yuan\)/g,"¥"],[/\{alpha\}/gi,"α"],[/\{beta\}/gi,"β"],[/\{gamma\}/gi,"γ"],[/\{delta\}/gi,"δ"],[/\{epsilon\}/gi,"ε"],[/\{theta\}/gi,"θ"],[/\{lambda\}/gi,"λ"],[/\{mu\}/gi,"μ"],[/\{nu\}/gi,"ν"],[/\{pi\}/gi,"π"],[/\{rho\}/gi,"ρ"],[/\{sigma\}/gi,"σ"],[/\{tau\}/gi,"τ"],[/\{phi\}/gi,"φ"],[/\{psi\}/gi,"Ψ"],[/\{omega\}/gi,"ω"]]);return a(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var a=r(0);n.exports=e.default},function(n,e,r){"use strict";function t(n){n=n.replace(/(\d)(\s)?(.)(\s)?(\d)/g,"$1$3$5");var e=new Map([[/\{!=}/g,"≠"],[/\{~}/g,"≈"],[/\{equal}/g,"≡"],[/\{<=}/g,"⩽"],[/\{=>}/g,"⩾"],[/\+-/g,"±"],[/\{-}/g,"–"],[/\{multiple}/g,"×"],[/\{divide}/g,"÷"],[/<->/g,"↔"],[/<=>/g,"⇔"],[/<-/g,"←"],[/<=/g,"⇐"],[/->/g,"→"],[/=>/g,"⇒"],[/\{\^1}/g,"¹"],[/\{\^2}/g,"²"],[/\{\^3}/g,"³"],[/\{1\/8}/g,"⅛"],[/\{1\/6}/g,"⅙"],[/\{1\/5}/g,"⅕"],[/\{1\/4}/g,"¼"],[/\{1\/3}/g,"⅓"],[/\{1\/2}/g,"½"],[/\{2\/5}/g,"⅖"],[/\{2\/3}/g,"⅔"],[/\{3\/8}/g,"⅜"],[/\{3\/5}/g,"⅗"],[/\{3\/4}/g,"¾"],[/\{4\/5}/g,"⅘"],[/\{5\/6}/g,"⅚"],[/\{5\/8}/g,"⅝"],[/\{7\/8}/g,"⅞"],[/\{part}/g,"∂"],[/\{any}/g,"∀"],[/\{exist}/g,"∃"],[/\{sum}/g,"Σ"],[/\{empty}/g,"∅"],[/\{infinity}/g,"∞"],[/\{belong}/g,"∈"],[/\{!belong}/g,"∉"],[/\{union}/g,"∪"],[/\{intersection}/g,"∩"],[/\{v}/g,"√"],[/\{v3}/g,"∛"],[/\{v4}/g,"∜"],[/\{ang}/g,"∠"]]);return a(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var a=r(0);n.exports=e.default},function(n,e,r){"use strict";function t(n,e){var r=function(n,e){return RegExp(n,e)};if(n=n.replace(/&nbsp;|\u00a0/gi," "),n=n.replace(/([^\s])(\u2014)([^\s])/gm,"$1 $2 $3"),n=n.replace(/\u2012|\u2013|\u002d|\u02d7|\u2212/gm,"-"),n=n.replace(/\s+(-)\s+/gm," $1 "),n=n.replace(/([\u00bb\u201c"],)(-)/gm,"$1 $2"),"ru"===e){n=n.replace(/(\s|^|<p>)([«"„‚]*)(-)([\s]|$)/g,"$1$2—$4"),n=n.replace(/([A-Za-zА-яёЁ0-9]) —/g,"$1 —"),n=n.replace(/([.,!?] |\n|^|<p>)— ([A-Za-zА-яёЁ0-9«"„‚])/g,"$1— $2");var t="(где|зачем|как|какая|какие|каким|каких|какое|какой|какого|каком|какому|кем|когда|кого|ком|кому|кто|куда|откуда|почему|чего|чем|чему|что|чём)";n=n.replace(r("([^А-яёЁ]|^)"+t+"[ ]{2}?(то|либо|нибудь)([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(r("([^А-яёЁ]|^)"+t+"[ ]{2}?(то|либо|нибудь)([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(r("([^А-яёЁ]|^)(кое|кой)[ ]{2}?"+t+"([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(r("([^А-яёЁ]|^)(кое|кой)[ ]{2}?"+t+"([^А-яёЁ]|$)","gi"),"$1$2-$3$4").replace(/([\s]|^)(из)[ ]{2}?(за)([\s]|$)/gi,"$1$2-$3$4").replace(/([\s]|^)(из)[ ]{2}?(под)([\s]|$)/gi,"$1$2-$3$4").replace(/([А-яёЁ]{2,}) (ка|кась)([\s,.?!]|$)/g,"$1-$2$3").replace(/([^А-яёЁ]|^)(вс[ёе]|так)[ ]{2}?(таки)([^А-яёЁ]|$)/gi,"$1$2-$3$4").replace(/(ГОСТ(?:[ ]{2}Р))?[ ]{2}([\d.]+)-([\d]+)/gi,"$1 $2–$3"),n=n.replace(/([IVXLCDM]{1,3})-([IVXLCDM]{1,3})[ ]{2}?вв?\.?([\s.,?!;)])/g,"$1—$2 вв.$3").replace(/([\d]{1,4})-([\d]{1,4})[ ]{2}?гг?\.([\s.,?!;)])/g,"$1–$2 гг.$3").replace(/([^\d]|^)([0-2][0-9]:[0-5][0-9])-([0-2][0-9]:[0-5][0-9])([^\d]|$)/g,"$1$2–$3$4");var a="(?:[ьяюе]|[её]м)",s="(?:[ауе]|ом)",i="(январ"+a+"|феврал"+a+"|март"+s+"|апрел"+a+"|ма(?:[йяюе]|ем)|ию[нл]"+a+"август"+s+"|сентябр"+a+"|ноябр"+a+"|октябр"+a+"|декабр"+a+")";n=n.replace(r("([\\s]|^)([1-3]?[\\d])-([1-3]?[\\d])[ ]{2}?"+i+"([^А-яёЁ]|$)","gi"),"$1$2–$3 $4$5").replace(r("([^А-яёЁ]|^)"+i+"-"+i+"([^А-яёЁ]|&)","gi"),"$1$2—$3$4")}return n=n.replace(/(\d)--(\d)/g,"$1–$2").replace(/([^-]|\s|^)--([^-]|$|\n)/g,"$1—$2").replace(/([^-\d]|^)(\d+)-(\d+)([^-\d]|$)/g,"$1$2–$3$4").replace(/([^a-z][a-z]|[Α-Ωα-ω+=*\/])-(\d)/g,"$1−$2"),n=n.replace(/\s+(-)\s+/gm,"$1")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){n=n.replace(/( |\u00a0){2,}/g," "),n=n.replace(/(\t){2,}/g,"\t"),n=n.replace(/([^.])(\.{2})([^.])/g,"$1.$3"),n=n.replace(/(\.){4,}/g,"."),n=n.replace(/(,|:|;){2,}/g,"$1"),n=n.replace(/(\s*)\n{2,}(\s*)/g,"\n"),n=n.replace(/(\u2028|\u2029){2,}/g,"\u2028");var r=new Map;r.set(/([.,!?:)])(?=[^ \n"'.,;!?&:\])<»”{)])/g,"$1 "),r.set(/[\s]*(?=[.,;!?:])/g,""),r.set(/\s([-\u2013\u2014])/g," $1"),e.includes("nbsp")&&r.set(/\s([-\u2013\u2014])/g,"&nbsp;$1");var t=s(n,[/[\d]+([.,][\d]+)+/g,/^[a-z0-9_.+-]+@[a-z0-9-]+\.[a-z0-9-.]+$/gi,/((([a-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[a-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[a-z0-9.-]+)((?:\/[+~%\/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/gi,/[:;.]['_-]{0,2}[.,edpobnsu*#@|()&$308ехорвъэ]/gi]),o=t.text,g=t.parts;return o=a(o,r),i(o,g)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var a=r(0),s=r(2),i=r(3);n.exports=e.default},function(n,e,r){"use strict";function t(n){var e=new Map([[/([\u2116\u00a7])[\s]*(?=[\d])/g,"$1&nbsp;"],[/([\d])[\s]*(?=\u00b0[CСF])/g,"$1 "],[/([\d])[\s]*(?=%)/g,"$1"]]);return a(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var a=r(0);n.exports=e.default},function(n,e,r){"use strict";function t(n){var e=new Map([[/(\d)\*([\D])/g,"$1°$2"],[/(\d)'/g,"$1′"],[/(^[^"]*\d)"([^"]*$)/g,"$1″$2"],[/("[^"]*\d)"([^"]*?")/g,"$1″$2"]]);return a(n,e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var a=r(0);n.exports=e.default},function(n,e,r){"use strict";function t(n){return n.replace(/[\s]{2,}/g," ")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n){return n=n.replace(/(^|\n|\s|—|-|\()"/g,"$1«").replace(/"($|\n|\s|—|-|\.|,|!|\?|:|;|\))/g,"»$1").replace(/«\)/g,"»)").replace(/«( ?)/g,"«").replace(/( ?)»/g,"»").replace(/>"/g,">«").replace(/"</g,"»<").replace(/«""/g,"«««").replace(/«"/g,"««").replace(/""»/g,"»»»").replace(/"»/g,"»»").replace(/("{2}|"»)/g,"»»").replace(/$"/g,"«").replace(/([A-Za-zа-яА-ЯёЁ])'/g,"$1’"),n=n.replace(/[a-zA-ZА-яёЁ]"-/g,"$1»-").replace(/-"[a-zA-ZА-яёЁ]/g,"-«$1"),n=n.replace(/(^[^«»]*)"/g,"$1«").replace(/"([^«»]*$)/g,"»$1").replace(/«([^«»]*)"/g,"«$1»").replace(/"([^«»]*)»/g,"«$1»")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){for(var r=0,t=0;t<n.length;++t)if("«"===n.charAt(t)){++r;for(var a=t+1;a<n.length;++a)if("«"===n.charAt(a)&&++r,"»"===n.charAt(a)&&--r<=0){n=function(e,r){var t="",a="",s="";0!==e&&(t=n.substring(0,e)),r!==n.length-1&&(s=n.substring(r+1,n.length)),a=n.substring(e,r+1);for(var i=0;i<32;++i)a=a.replace(/«([^«»]*)«([^»]*)»/g,"«$1„$2“"),a=a.replace(/„([^„“]*)„([^“]*)“/g,"„$1‚$2‘");return t+a+s}(t,a),t=a;break}r=0}return"en"===e&&(n=n.replace(/(»|’)(\.|,|!|\?)/g,"$2$1").replace(/«/g,"“").replace(/»/g,"”")),n=n.replace(/([A-z])”([A-z])/g,"$1’$2"),n=n.replace(/«(\d+( |\xA0)[A-z])/g,"“$1"),n=n.replace(/([A-z]( |\xA0)\d+)»/g,"$1”"),n=n.replace(/([^.{2}])(\.{1}»)/g,"$1»."),n=n.replace(/([^.{2}])(\.{1}”)/g,"$1”.")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){return n}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){return n=n.replace(/((тел\.|телефон?[а-я]{1,3})(:?)(\s+?))?(\+7|8)(\s+)?(\(?)(\d{3})(\)?)(\s+)?(\d{3})(\u2012|\u2013|\u2014|\u002d|\u02d7|\u2212)?(\d{2})(\u2012|\u2013|\u2014|\u002d|\u02d7|\u2212)?(\d{2})([^\w])/gi,'$2$3 <span data-typo="" class="nowrap">+7($8) $11–$13–$15</span>$16')}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){return n=n.replace(/( |\xA0|^|\n|\u2028|\u2029)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6&nbsp;$7&nbsp;$8&nbsp;$9"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6&nbsp;$7&nbsp;$8"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6&nbsp;$7"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5&nbsp;$6"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029)(\d{1,3}) ?(\d{3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4&nbsp;$5"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029)(\d{1,3}) ?(\d{3}) ?(\d{3})/g,"$1$2&nbsp;$3&nbsp;$4"),n=n.replace(/( |\xA0|^|\n|\u2028|\u2029)(\d{2,3}) ?(\d{3})/g,"$1$2&nbsp;$3")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n){n=n.replace(/(\s)\/(\s)/g,"&nbsp;/&nbsp;"),n=n.replace(/((^|[\s])[a-zа-яёіїєґ'′]{1,2})[\s]/gi,"$1&nbsp;"),n=n.replace(/(\d)([a-zа-я])/g,"$1&nbsp;$2"),n=n.replace(/(\d)(\s)(\W)/g,"$1&nbsp;$3"),n=n.replace(/(тыс|млн|млрд|трлн|кв\.)(\s)(р\.|руб|кило|тон|кв(\.)?|м(\.)?)/gi,"$1&nbsp;$3");for(var e=["без","безо","в","во","вне","для","до","за","из","изо","из-за","из-под","к","ко","на","над","о","об","обо","около","от","ото","по","по-над","под","подо","при","про","с","со","сквозь","у","через","а","но","и","да","или","иль","либо","не","ни","a","the","at","to","or"],r=0;r<47;r++){var t=RegExp("( |^|\\(|«|„| )("+e[r]+") ","ig");n=n.replace(t,"$1$2&nbsp;")}return n=n.replace(/([А-Я]\.)(\s)?([А-Я]\.)(\s)?([А-Я][А-Яа-я]*)/g,"$1&nbsp;$3&nbsp;$5"),n=n.replace(/([А-Я][А-Яа-я]*)(\s)?([А-Я]\.)(\s)?([А-Я]\.)/g,"$1&nbsp;$3&nbsp;$5")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n){return n=n.replace(/\.{3}/g,"…")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e,r){"use strict";function t(n,e){return n=n.replace(/(\s)?(мкм|мм|см|дм|м|км|µm|mm|cm|m|km)\^?2/gi,"$2²"),n=n.replace(/(\s)?(мкм|мм|см|дм|м|км|µm|mm|cm|m|km)\^?3/gi,"$2³")}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t,n.exports=e.default},function(n,e){},function(n,e,r){"use strict";r(1)(r(47))},,,,function(n,e,r){"use strict";function t(n,e){return e.querySelector(n)}function a(n,e){return e.querySelectorAll(n)}function s(){for(var n=a(".test",document),e=n.length;e--;){var r=n[e].dataset,s=new i({lang:r&&r.lang?r.lang:"ru"}),o=t(".source",n[e]),g=o.innerHTML,l=t(".model",n[e]),A=l.innerHTML,p=t(".result",n[e]),C=s.process(g);C=s.process(C),C=s.process(C);var I=window.global.prettydiff.prettydiff({crlf:!1,html:!1,lang:"markup",langdefault:"markup",newline:!1,source:C,diff:A,diffview:"inline"});p.innerHTML=I}}r(21);var i=r(4);r(27),r(29),r(31),r(33),r(35),r(37),r(39),r(41),r(43),r(45),r(22),r(22),function(n){(document.attachEvent?"complete"===document.readyState:"loading"!==document.readyState)?n():document.addEventListener("DOMContentLoaded",n)}(s)},function(n,e,r){"use strict";r(1)(r(28))},function(n,e){n.exports="/* Always include this library before any other. This library exists only to\r\n * provide a common namespace in the browser to what node provides to simulate a\r\n * browser's global scope\r\n */\r\nvar global = {\r\n    prettydiff: {\r\n        pd: {}\r\n    }\r\n};\r\n"},function(n,e,r){"use strict";r(1)(r(30))},function(n,e){n.exports='/*global ace, define, global, module*/\r\n/*\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n*/\r\n(function language_init() {\r\n    "use strict";\r\n    var language = {};\r\n    global.prettydiff.language = language;\r\n    language.setlangmode = function language_setlangmode(input) {\r\n        var langmap = {\r\n            c_cpp     : "javascript",\r\n            coldfusion: "markup",\r\n            csharp    : "javascript",\r\n            css       : "css",\r\n            csv       : "csv",\r\n            dustjs    : "html",\r\n            ejs       : "html",\r\n            go        : "html",\r\n            handlebars: "html",\r\n            html      : "html",\r\n            html_ruby : "html",\r\n            java      : "javascript",\r\n            javascript: "javascript",\r\n            json      : "json",\r\n            jsp       : "markup",\r\n            jsx       : "javascript",\r\n            less      : "css",\r\n            markup    : "markup",\r\n            php       : "html",\r\n            qml       : "qml",\r\n            scss      : "css",\r\n            swig      : "html",\r\n            text      : "text",\r\n            titanium  : "tss",\r\n            tss       : "tss",\r\n            twig      : "html",\r\n            typescript: "typescript",\r\n            velocity  : "velocity",\r\n            xhtml     : "markup",\r\n            xml       : "markup"\r\n        };\r\n        if (typeof input !== "string") {\r\n            return "javascript";\r\n        }\r\n        if (input.indexOf("html") > -1) {\r\n            return "html";\r\n        }\r\n        if (langmap[input] === undefined) {\r\n            return "javascript";\r\n        }\r\n        return langmap[input];\r\n    };\r\n    language.nameproper  = function language_nameproper(input) {\r\n        var langmap = {\r\n            c_cpp     : "C++ (Not yet supported)",\r\n            coldfusion: "ColdFusion",\r\n            csharp    : "C#",\r\n            dustjs    : "Dust.js",\r\n            ejs       : "EJS Template",\r\n            elm       : "Elm Template",\r\n            go        : "Go Lang Template",\r\n            handlebars: "Handlebars Template",\r\n            html_ruby : "ERB (Ruby) Template",\r\n            java      : "Java",\r\n            javascript: "JavaScript",\r\n            jsp       : "JSTL (JSP)",\r\n            jsx       : "React JSX",\r\n            liquid    : "Liquid Template",\r\n            markup    : "markup",\r\n            scss      : "SCSS",\r\n            text      : "Plain Text",\r\n            titanium  : "Titanium Stylesheets",\r\n            tss       : "Titanium Stylesheets",\r\n            twig      : "HTML TWIG Template",\r\n            typescript: "TypeScript",\r\n            velocity  : "Apache Velocity",\r\n            volt      : "Volt Template"\r\n        };\r\n        if (typeof input !== "string" || langmap[input] === undefined) {\r\n            return input.toUpperCase();\r\n        }\r\n        return langmap[input];\r\n    };\r\n    // [0] = language value for ace mode [1] = prettydiff language category from [0]\r\n    // [2] = pretty formatting for text output to user\r\n    language.auto = function language_auto(sample, defaultLang) {\r\n        var b           = [],\r\n            c           = 0,\r\n            vartest     = (\r\n                /(((var)|(let)|(const)|(function)|(import))\\s+(\\w|\\$)+[a-zA-Z0-9]*)/\r\n            ).test(sample),\r\n            finalstatic = (/((((final)|(public)|(private))\\s+static)|(static\\s+void))/).test(\r\n                sample\r\n            ),\r\n            output      = function language_auto_output(langname) {\r\n                if (langname === "unknown") {\r\n                    return [defaultLang, language.setlangmode(defaultLang), "unknown"];\r\n                }\r\n                if (langname === "xhtml" || langname === "markup") {\r\n                    return ["xml", "html", "XHTML"];\r\n                }\r\n                if (langname === "tss") {\r\n                    return ["tss", "tss", "Titanium Stylesheets"];\r\n                }\r\n                return [langname, language.setlangmode(langname), language.nameproper(langname)];\r\n            },\r\n            cssA        = function language_auto_cssA() {\r\n                if ((/\\$[a-zA-Z]/).test(sample) === true || (/\\{\\s*(\\w|\\.|\\$|#)+\\s*\\{/).test(sample) === true) {\r\n                    return output("scss");\r\n                }\r\n                if ((/@[a-zA-Z]/).test(sample) === true || (/\\{\\s*(\\w|\\.|@|#)+\\s*\\{/).test(sample) === true) {\r\n                    return output("less");\r\n                }\r\n                return output("css");\r\n            },\r\n            notmarkup   = function language_auto_notmarkup() {\r\n                var d               = 0,\r\n                    join            = "",\r\n                    flaga           = false,\r\n                    flagb           = false,\r\n                    publicprivate   = (\r\n                        /((public)|(private))\\s+(static\\s+)?(((v|V)oid)|(class)|(final))/\r\n                    ).test(sample),\r\n                    javascriptA     = function language_auto_notmarkup_javascriptA() {\r\n                        if (sample.indexOf("(") > -1 || sample.indexOf("=") > -1 || (sample.indexOf(";") > -1 && sample.indexOf("{") > -1)) {\r\n                            if (vartest === false && ((/\\n\\s+#region\\s/).test(sample) === true || (/\\[\\w+:/).test(sample) === true)) {\r\n                                return output("csharp");\r\n                            }\r\n                            if (finalstatic === true || (/\\w<\\w+(,\\s+\\w+)*>/).test(sample) === true) {\r\n                                if ((/:\\s*((number)|(string))/).test(sample) === false && vartest === false && (finalstatic === true || publicprivate === true)) {\r\n                                    return output("java");\r\n                                }\r\n                                return output("typescript");\r\n                            }\r\n                            if ((/final\\s+static/).test(sample) === true) {\r\n                                return output("java");\r\n                            }\r\n                            return output("javascript");\r\n                        }\r\n                        return output("unknown");\r\n                    },\r\n                    cssOrJavaScript = function language_auto_notmarkup_cssOrJavaScript() {\r\n                        if ((/:\\s*((number)|(string))/).test(sample) === true && (/((public)|(private))\\s+/).test(sample) === true) {\r\n                            return output("typescript");\r\n                        }\r\n                        if ((/import\\s+java(\\.|(fx))/).test(sample) === true || (/((public)|(private))\\s+static\\s+/).test(sample) === true) {\r\n                            return output("java");\r\n                        }\r\n                        if ((/\\sclass\\s+\\w/).test(sample) === false && (/<[a-zA-Z]/).test(sample) === true && (/<\\/[a-zA-Z]/).test(sample) === true && ((/\\s?\\{%/).test(sample) === true || (/\\{(\\{|#)(?!(\\{|#|=))/).test(sample) === true)) {\r\n                            return output("twig");\r\n                        }\r\n                        if ((/^(\\s*(\\$|@))/).test(sample) === false && (/(\\};?\\s*)$/).test(sample) === true) {\r\n                            if ((/export\\s+default\\s+\\{/).test(sample) === true || (/(\\?|:)\\s*(\\{|\\[)/).test(sample) === true || (/(\\{|\\s|;)render\\s*\\(\\)\\s*\\{/).test(sample) === true || (/^(\\s*return;?\\s*\\{)/).test(sample) === true) {\r\n                                return output("javascript");\r\n                            }\r\n                        }\r\n                        if ((/\\{\\{#/).test(sample) === true && (/\\{\\{\\//).test(sample) === true && (/<\\w/).test(sample) === true) {\r\n                            return output("handlebars");\r\n                        }\r\n                        if ((/\\{\\s*(\\w|\\.|@|#)+\\s*\\{/).test(sample) === true) {\r\n                            return output("less");\r\n                        }\r\n                        if ((/\\$(\\w|-)/).test(sample) === true) {\r\n                            return output("scss");\r\n                        }\r\n                        if ((/(;|\\{|:)\\s*@\\w/).test(sample) === true) {\r\n                            return output("less");\r\n                        }\r\n                        if ((/class\\s+\\w+\\s+\\{/).test(sample) === true) {\r\n                            return output("java");\r\n                        }\r\n                        return output("css");\r\n                    };\r\n                for (d = 1; d < c; d = d + 1) {\r\n                    if (flaga === false) {\r\n                        if (b[d] === "*" && b[d - 1] === "/") {\r\n                            b[d - 1] = "";\r\n                            flaga    = true;\r\n                        } else if (flagb === false && b[d] === "f" && d < c - 6 && b[d + 1] === "i" && b[d + 2] === "l" && b[d + 3] === "t" && b[d + 4] === "e" && b[d + 5] === "r" && b[d + 6] === ":") {\r\n                            flagb = true;\r\n                        }\r\n                    } else if (flaga === true && b[d] === "*" && d !== c - 1 && b[d + 1] === "/") {\r\n                        flaga    = false;\r\n                        b[d]     = "";\r\n                        b[d + 1] = "";\r\n                    } else if (flagb === true && b[d] === ";") {\r\n                        flagb = false;\r\n                        b[d]  = "";\r\n                    }\r\n                    if (flaga === true || flagb === true) {\r\n                        b[d] = "";\r\n                    }\r\n                }\r\n                join = b.join("");\r\n                if ((/\\s\\/\\//).test(sample) === false && (/\\/\\/\\s/).test(sample) === false && (/^(\\s*(\\{|\\[)(?!%))/).test(sample) === true && (/((\\]|\\})\\s*)$/).test(sample) && sample.indexOf(",") !== -1) {\r\n                    return output("json");\r\n                }\r\n                if ((/((\\}?(\\(\\))?\\)*;?\\s*)|([a-z0-9]("|\')?\\)*);?(\\s*\\})*)$/i).test(sample) === true && (vartest === true || publicprivate === true || (/console\\.log\\(/).test(sample) === true || (/export\\s+default\\s+class\\s+/).test(sample) === true || (/document\\.get/).test(sample) === true || (/((\\=|(\\$\\())\\s*function)|(\\s*function\\s+(\\w*\\s+)?\\()/).test(sample) === true || sample.indexOf("{") === -1 || (/^(\\s*if\\s+\\()/).test(sample) === true)) {\r\n                    return javascriptA();\r\n                }\r\n                // * u007b === {\r\n                // * u0024 === $\r\n                // * u002e === .\r\n                if (sample.indexOf("{") > -1 && ((/^(\\s*[\\u007b\\u0024\\u002e#@a-z0-9])/i).test(sample) === true || (/^(\\s*\\/(\\*|\\/))/).test(sample) === true || (/^(\\s*\\*\\s*\\{)/).test(sample) === true) && (/^(\\s*if\\s*\\()/).test(sample) === false && (/\\=\\s*(\\{|\\[|\\()/).test(join) === false && (((/(\\+|-|\\=|\\?)\\=/).test(join) === false || (/\\/\\/\\s*\\=+/).test(join) === true) || ((/\\=+(\'|")?\\)/).test(sample) === true && (/;\\s*base64/).test(sample) === true)) && (/function(\\s+\\w+)*\\s*\\(/).test(join) === false) {\r\n                    if ((/\\s*#((include)|(define)|(endif))\\s+/).test(sample)) {\r\n                        return output("c_cpp");\r\n                    }\r\n                    return cssOrJavaScript();\r\n                }\r\n                if ((/"\\s*:\\s*\\{/).test(sample) === true) {\r\n                    return output("tss");\r\n                }\r\n                if (sample.indexOf("{%") > -1) {\r\n                    return output("twig");\r\n                }\r\n                return output("unknown");\r\n            },\r\n            markup      = function language_auto_markup() {\r\n                var html = function language_auto_markup_html() {\r\n                    if ((/<%\\s*\\}/).test(sample) === true) {\r\n                        return output("ejs");\r\n                    }\r\n                    if ((/<%\\s*end/).test(sample) === true) {\r\n                        return output("html_ruby");\r\n                    }\r\n                    if ((/\\{\\{(#|\\/|\\{)/).test(sample) === true) {\r\n                        return output("handlebars");\r\n                    }\r\n                    if ((/\\{\\{end\\}\\}/).test(sample) === true) {\r\n                        //place holder for Go lang templates\r\n\r\n                        return output("html");\r\n                    }\r\n                    if ((/\\s?\\{%/).test(sample) === true && (/\\{(\\{|#)(?!(\\{|#|\\=))/).test(sample) === true) {\r\n                        return output("twig");\r\n                    }\r\n                    if ((/<\\?/).test(sample) === true) {\r\n                        return output("php");\r\n                    }\r\n                    if ((/<jsp:include\\s/).test(sample) === true || (/<c:((set)|(if))\\s/).test(sample) === true) {\r\n                        return output("jsp");\r\n                    }\r\n                    if ((/\\{(#|\\?|\\^|@|<|\\+|~)/).test(sample) === true && (/\\{\\//).test(sample) === true) {\r\n                        return output("dustjs");\r\n                    }\r\n                    return output("html");\r\n                };\r\n                if ((/^(\\s*<!doctype\\u0020html>)/i).test(sample) === true || (/^(\\s*<html)/i).test(sample) === true || ((/^(\\s*<!DOCTYPE\\s+((html)|(HTML))\\s+PUBLIC\\s+)/).test(sample) === true && (/XHTML\\s+1\\.1/).test(sample) === false && (/XHTML\\s+1\\.0\\s+(S|s)((trict)|(TRICT))/).test(sample) === false)) {\r\n                    return html();\r\n                }\r\n                if ((/<jsp:include\\s/).test(sample) === true || (/<c:((set)|(if))\\s/).test(sample) === true) {\r\n                    return output("jsp");\r\n                }\r\n                if ((/<%\\s*\\}/).test(sample) === true) {\r\n                    return output("ejs");\r\n                }\r\n                if ((/<%\\s*end/).test(sample) === true) {\r\n                    return output("html_ruby");\r\n                }\r\n                if ((/\\{\\{(#|\\/|\\{)/).test(sample) === true) {\r\n                    return output("handlebars");\r\n                }\r\n                if ((/\\{\\{end\\}\\}/).test(sample) === true) {\r\n                    //place holder for Go lang templates\r\n\r\n                    return output("xml");\r\n                }\r\n                if ((/\\s?\\{%/).test(sample) === true && (/\\{\\{(?!(\\{|#|\\=))/).test(sample) === true) {\r\n                    return output("twig");\r\n                }\r\n                if ((/<\\?(?!(xml))/).test(sample) === true) {\r\n                    return output("php");\r\n                }\r\n                if ((/\\{(#|\\?|\\^|@|<|\\+|~)/).test(sample) === true && (/\\{\\//).test(sample) === true) {\r\n                    return output("dustjs");\r\n                }\r\n                if ((/<jsp:include\\s/).test(sample) === true || (/<c:((set)|(if))\\s/).test(sample) === true) {\r\n                    return output("jsp");\r\n                }\r\n                return output("xml");\r\n            };\r\n        if (sample === null) {\r\n            return;\r\n        }\r\n        if ((/^(\\s*<\\!DOCTYPE\\s+html>)/i).test(sample) === true) {\r\n            return output("html");\r\n        }\r\n        if ((/^(\\s*((if)|(for)|(function))\\s*\\()/).test(sample) === false && (/(\\s|;|\\})((if)|(for)|(function\\s*\\w*))\\s*\\(/).test(sample) === false && vartest === false && (/return\\s*\\w*\\s*(;|\\})/).test(sample) === false && (sample === undefined || (/^(\\s*#(?!(!\\/)))/).test(sample) === true || ((/\\n\\s*(\\.|@)\\w+(\\(?|(\\s*:))/).test(sample) === true && (/>\\s*<\\w/).test(sample) === false))) {\r\n            return cssA();\r\n        }\r\n        b = sample\r\n            .replace(/\\[[a-zA-Z][\\w\\-]*\\=("|\')?[a-zA-Z][\\w\\-]*("|\')?\\]/g, "")\r\n            .split("");\r\n        c = b.length;\r\n        if ((/^(\\s*\\{(%|#|\\{))/).test(sample) === true) {\r\n            return markup();\r\n        }\r\n        if (((/^([\\s\\w\\-]*<)/).test(sample) === false && (/(>[\\s\\w\\-]*)$/).test(sample) === false) || finalstatic === true) {\r\n            return notmarkup();\r\n        }\r\n        if ((((/(>[\\w\\s:]*)?<(\\/|!|#)?[\\w\\s:\\-\\[]+/).test(sample) === true || (/^(\\s*<\\?xml)/).test(sample) === true) && ((/^([\\s\\w]*<)/).test(sample) === true || (/(>[\\s\\w]*)$/).test(sample) === true)) || ((/^(\\s*<s((cript)|(tyle)))/i).test(sample) === true && (/(<\\/s((cript)|(tyle))>\\s*)$/i).test(sample) === true)) {\r\n            if ((/^([\\s\\w]*<)/).test(sample) === false || (/(>[\\s\\w]*)$/).test(sample) === false) {\r\n                return notmarkup();\r\n            }\r\n            return markup();\r\n        }\r\n        return output("unknown");\r\n    };\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function language_requirejs() {\r\n            return global.prettydiff.language;\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = global.prettydiff.language;\r\n    }\r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(32))},function(n,e){n.exports='/*global __dirname, ace, define, global, module, process, require, WScript*/\r\n/*jslint for: true, this: true*/\r\n/*\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n\r\n How to define a new option:\r\n\r\n 1. definitions - define the option\r\n 2. validate    - logic to assign values against accepted criteria\r\n 3. pdcomment   - only necessary if option is string type with a list of accepted values\r\n 4. domops      - associate ID names (from HTML) to values for populating the pretty diff comment in the web tool\r\n\r\n Functions map:\r\n\r\n * definitions   - a big object defining all the options\r\n * default       - pulls default values out of the definitions object. This is necessary to prevent collisions when processing multiple files simultanesouly\r\n * versionString - a function to build out human readable messaging about the current version from data in prettydiff.js\r\n * consolePrint  - a handy function to print documentation on all options and usage data to the console in the browser or command line.\r\n    ** to execute in the browser console: global.prettydiff.options.functions.consolePrint()\r\n    ** or use the alias document.consolePrint() from api/dom.js\r\n * pdcomment     - processes option overrides from the prettydiff.com code comment\r\n * validate      - process user input against supported options and their acceptable values.  I have plans to merge this into the definitions object\r\n * domops        - updates the comment string that appears in the options area of the web tool\r\n * node          - parses node arguments into options for submission to the validate function\r\n * binary        - a handy dandy tool to remove control characters from text output\r\n*/\r\n(function options_init() {\r\n    "use strict";\r\n    var options = {\r\n        functions: {}\r\n    };\r\n    global.prettydiff.options = options;\r\n    options.functions.definitions   = {\r\n        apacheVelocity : {\r\n            type      : "boolean",\r\n            definition: "Provides support for Apache Velocity template language.",\r\n            default   : false\r\n        },\r\n        api            : {\r\n            type      : "string",\r\n            definition: "An enternal option to help identify environment specific needs.",\r\n            default   : false\r\n        },\r\n        attributetoken : {\r\n            type      : "boolean",\r\n            definition: "Provides markups attributes as separate tokens in the parse table of mode pars" +\r\n                    "e, otherwise attributes are a data property of their respective element.",\r\n            default   : false\r\n        },\r\n        brace_style    : {\r\n            type      : "string",\r\n            definition: "Emulates JSBeautify\'s brace_style option using existing Pretty Diff options.",\r\n            values    : [\r\n                "collapse", "collapse-preserve-inline", "expand", "none"\r\n            ],\r\n            default   : "none"\r\n        },\r\n        braceline      : {\r\n            type      : "boolean",\r\n            definition: "If true a new line character will be inserted after opening curly braces and b" +\r\n                    "efore closing curly braces.",\r\n            default   : false\r\n        },\r\n        bracepadding   : {\r\n            type      : "boolean",\r\n            definition: "Inserts a space after the start of a contain and before the end of the contain" +\r\n                    "er in JavaScript if the contents of that container are not indented; such as: " +\r\n                    "conditions, function arguments, and escaped sequences of template strings.",\r\n            default   : false\r\n        },\r\n        braces         : {\r\n            type      : "string",\r\n            definition: "If lang is \'javascript\' and mode is \'beautify\' this determines if opening curl" +\r\n                    "y braces will exist on the same line as their condition or be forced onto a ne" +\r\n                    "w line.",\r\n            values    : [\r\n                "knr", "allman"\r\n            ],\r\n            default   : "knr"\r\n        },\r\n        color          : {\r\n            type      : "string",\r\n            definition: "The color scheme of the reports.",\r\n            default   : "white",\r\n            values    : ["canvas", "shadow", "white"]\r\n        },\r\n        comments       : {\r\n            type      : "string",\r\n            definition: "If mode is \'beautify\' this will determine whether comments should always start" +\r\n                    " at position 0 of each line or if comments should be indented according to the" +\r\n                    " code.",\r\n            default   : "indent",\r\n            values    : ["indent", "noindent"]\r\n        },\r\n        commline       : {\r\n            type      : "boolean",\r\n            definition: "If a blank new line should be forced above comments in markup.",\r\n            default   : false\r\n        },\r\n        compressedcss  : {\r\n            type      : "boolean",\r\n            definition: "If CSS should be beautified in a style where the properties and values are min" +\r\n                    "ifed for faster reading of selectors.",\r\n            default   : false\r\n        },\r\n        conditional    : {\r\n            type      : "boolean",\r\n            definition: "If true then conditional comments used by Internet Explorer are preserved at m" +\r\n                    "inification of markup.",\r\n            default   : false\r\n        },\r\n        content        : {\r\n            type      : "boolean",\r\n            definition: "If true and mode is \'diff\' this will normalize all string literals in JavaScri" +\r\n                    "pt to \'text\' and all content in markup to \'text\' so as to eliminate some diffe" +\r\n                    "rences from the HTML diff report.",\r\n            default   : false\r\n        },\r\n        context        : {\r\n            type      : "number",\r\n            definition: "This shortens the diff output by allowing a specified number of equivalent lin" +\r\n                    "es between each line of difference.",\r\n            default   : -1\r\n        },\r\n        correct        : {\r\n            type      : "boolean",\r\n            definition: "Automatically correct some sloppiness in JavaScript and markup.",\r\n            default   : false\r\n        },\r\n        crlf           : {\r\n            type      : "boolean",\r\n            definition: "If line termination should be Windows (CRLF) format.  Unix (LF) format is the " +\r\n                    "default.",\r\n            default   : false\r\n        },\r\n        cssinsertlines : {\r\n            type      : "boolean",\r\n            definition: "Inserts new line characters between every CSS code block.",\r\n            default   : false\r\n        },\r\n        csvchar        : {\r\n            type      : "string",\r\n            definition: "The character to be used as a separator if lang is \'csv\'.  Any string combinat" +\r\n                    "ion is accepted.",\r\n            default   : ","\r\n        },\r\n        diff           : {\r\n            type      : "string",\r\n            definition: "The code sample to be compared to \'source\' option. This is required if mode is" +\r\n                    " \'diff\'.",\r\n            default   : ""\r\n        },\r\n        diffcli        : {\r\n            type      : "boolean",\r\n            definition: "If true only text lines of the code differences are returned instead of an HTM" +\r\n                    "L diff report.",\r\n            default   : false\r\n        },\r\n        diffcomments   : {\r\n            type      : "boolean",\r\n            definition: "If true then comments will be preserved so that both code and comments are com" +\r\n                    "pared by the diff engine.",\r\n            default   : false\r\n        },\r\n        difflabel      : {\r\n            type      : "string",\r\n            definition: "This allows for a descriptive label for the diff file code of the diff HTML ou" +\r\n                    "tput.",\r\n            default   : "New Sample"\r\n        },\r\n        diffspaceignore: {\r\n            type      : "boolean",\r\n            definition: "If white space only differences should be ignored by the diff tool.",\r\n            default   : false\r\n        },\r\n        diffview       : {\r\n            type      : "string",\r\n            definition: "This determines whether the diff HTML output should display as a side-by-side " +\r\n                    "comparison or if the differences should display in a single table column.",\r\n            values    : [\r\n                "inline", "sidebyside"\r\n            ],\r\n            default   : "sidebyside"\r\n        },\r\n        dustjs         : {\r\n            type      : "boolean",\r\n            definition: "If the provided markup code is a Dust.js template.",\r\n            default   : false\r\n        },\r\n        elseline       : {\r\n            type      : "boolean",\r\n            definition: "If elseline is true then the keyword \'else\' is forced onto a new line in JavaS" +\r\n                    "cript beautification.",\r\n            default   : false\r\n        },\r\n        endcomma       : {\r\n            type      : "string",\r\n            definition: "If there should be a trailing comma in JavaScript arrays and objects. Value \\"" +\r\n                    "multiline\\" only applies to modes beautify and diff.",\r\n            values    : [\r\n                "always", "multiline", "never"\r\n            ],\r\n            default   : "never"\r\n        },\r\n        endquietly     : {\r\n            type      : "string",\r\n            definition: "A node only option to determine if terminal logging should be allowed or suppr" +\r\n                    "essed.",\r\n            values    : [\r\n                "", "log", "quiet"\r\n            ],\r\n            default   : ""\r\n        },\r\n        force_attribute: {\r\n            type      : "boolean",\r\n            definition: "If all markup attributes should be indented each onto their own line.",\r\n            default   : false\r\n        },\r\n        force_indent   : {\r\n            type      : "boolean",\r\n            definition: "If lang is \'markup\' this will force indentation upon all content and tags with" +\r\n                    "out regard for the creation of new text nodes.",\r\n            default   : false\r\n        },\r\n        formatArray    : {\r\n            type      : "string",\r\n            definition: "Determines if all JavaScript array indexes should be indented, never indented," +\r\n                    " or left to the default.",\r\n            values    : [\r\n                "default", "indent", "inline"\r\n            ],\r\n            default   : "default"\r\n        },\r\n        formatObject   : {\r\n            type      : "string",\r\n            definition: "Determines if all JavaScript array indexes should be indented, never indented," +\r\n                    " or left to the default.",\r\n            values    : [\r\n                "default", "indent", "inline"\r\n            ],\r\n            default   : "default"\r\n        },\r\n        functionname   : {\r\n            type      : "boolean",\r\n            definition: "If a space should follow a JavaScript function name.",\r\n            default   : false\r\n        },\r\n        help           : {\r\n            type      : "number",\r\n            definition: "A node only option to print documentation to the console. The value determines" +\r\n                    " where to wrap text.",\r\n            default   : 80\r\n        },\r\n        html           : {\r\n            type      : "boolean",\r\n            definition: "If lang is \'markup\' this will provide extra support for HTML specific sloppine" +\r\n                    "ss.",\r\n            default   : false\r\n        },\r\n        inchar         : {\r\n            type      : "string",\r\n            definition: "The string characters to comprise a single indentation. Any string combination" +\r\n                    " is accepted.",\r\n            default   : " "\r\n        },\r\n        inlevel        : {\r\n            type      : "number",\r\n            definition: "How much indentation padding should be applied to JavaScript beautification?",\r\n            default   : 0\r\n        },\r\n        insize         : {\r\n            type      : "number",\r\n            definition: "The number of characters to comprise a single indentation.",\r\n            default   : 4\r\n        },\r\n        jekyll         : {\r\n            type      : "boolean",\r\n            definition: "If YAML Jekyll HTML template comments are supported.",\r\n            default   : false\r\n        },\r\n        jsscope        : {\r\n            type      : "string",\r\n            definition: "An educational tool to generate HTML output of JavaScript code to identify sco" +\r\n                    "pe regions and declared references by color.",\r\n            values    : {\r\n                none  : "prevents use of this option",\r\n                report: "generates HTML output that renders in web browsers",\r\n                html  : "generates HTML output with escaped angle braces and ampersands for embedding a" +\r\n                        "s code, which is handy in code producing tools"\r\n            },\r\n            default   : "none"\r\n        },\r\n        jsx            : {\r\n            type      : "boolean",\r\n            definition: "An internal flag used to identify if a given code sample is React JSX code.",\r\n            default   : false\r\n        },\r\n        lang           : {\r\n            type      : "string",\r\n            definition: "The programming language of the source file.",\r\n            values    : [\r\n                "auto",\r\n                "markup",\r\n                "javascript",\r\n                "css",\r\n                "html",\r\n                "csv",\r\n                "text"\r\n            ],\r\n            default   : "auto"\r\n        },\r\n        langdefault    : {\r\n            type      : "string",\r\n            definition: "The fallback option if option \'lang\' is set to \'auto\' and a language cannot be" +\r\n                    " detected.",\r\n            values    : [\r\n                "markup",\r\n                "javascript",\r\n                "css",\r\n                "html",\r\n                "csv",\r\n                "text"\r\n            ],\r\n            default   : "text"\r\n        },\r\n        listoptions    : {\r\n            type      : "boolean",\r\n            definition: "A Node.js only option that writes current option settings to the console.",\r\n            default   : false\r\n        },\r\n        methodchain    : {\r\n            type      : "string",\r\n            definition: "Whether consecutive JavaScript methods should be chained onto a single line of" +\r\n                    " code instead of indented.",\r\n            values    : [\r\n                "chain", "indent", "none"\r\n            ],\r\n            default   : "indent"\r\n        },\r\n        miniwrap       : {\r\n            type      : "boolean",\r\n            definition: "Whether minified JavaScript should wrap after a specified character width.  Th" +\r\n                    "is option requires a value from option \'wrap\'.",\r\n            default   : false\r\n        },\r\n        mode           : {\r\n            type      : "string",\r\n            definition: "The operation to be performed.",\r\n            values    : {\r\n                analysis: "returns a code examination report",\r\n                beautify: "beautifies code and returns a string",\r\n                diff    : "returns either command line list of differences or an HTML report",\r\n                minify  : "minifies code and returns a string",\r\n                parse   : "using option \'parseFormat\' returns an object with shallow arrays, a multidimen" +\r\n                        "sional array, or an HTML report"\r\n            },\r\n            default   : "diff"\r\n        },\r\n        newline        : {\r\n            type      : "boolean",\r\n            definition: "Insert an empty line at the end of output.",\r\n            default   : false\r\n        },\r\n        neverflatten   : {\r\n            type      : "boolean",\r\n            definition: "If destructured lists in JavaScript should never be flattend.",\r\n            default   : false\r\n        },\r\n        nocaseindent   : {\r\n            type      : "boolean",\r\n            definition: "If a case statement should receive the same indentation as the containing swit" +\r\n                    "ch block.",\r\n            default   : false\r\n        },\r\n        nochainindent  : {\r\n            type      : "boolean",\r\n            definition: "If indentation should be prevent of JavaScript method chains broken onto multi" +\r\n                    "ple lines.",\r\n            default   : false\r\n        },\r\n        nodeasync      : {\r\n            type      : "boolean",\r\n            definition: "An internal option manage processing of multiple files simultanously",\r\n            default   : false\r\n        },\r\n        nodeerror      : {\r\n            type      : "boolean",\r\n            definition: "A Node.js only option if parse errors should be written to the console.",\r\n            default   : false\r\n        },\r\n        noleadzero     : {\r\n            type      : "boolean",\r\n            definition: "Whether leading 0s in CSS values immediately preceeding a decimal should be re" +\r\n                    "moved or prevented.",\r\n            default   : false\r\n        },\r\n        objsort        : {\r\n            type      : "string",\r\n            definition: "Sorts markup attributes and properties by key name in JavaScript and CSS.",\r\n            values    : [\r\n                "all", "css", "js", "markup", "none"\r\n            ],\r\n            default   : "none"\r\n        },\r\n        output         : {\r\n            type      : "string",\r\n            definition: "The path of the directory, if readmethod is value \'directory\', or path and nam" +\r\n                    "e of the file to write the output.  The path will be created or overwritten.",\r\n            default   : ""\r\n        },\r\n        parseFormat    : {\r\n            type      : "string",\r\n            definition: "Determines the output format for \'parse\' mode.",\r\n            values    : {\r\n                htmltable : "generates a human readable report in the format of an HTML table",\r\n                parallel  : "returns a series of parallel arrays",\r\n                sequential: "returns an array where each index is a child array containing the parsed token" +\r\n                        " and all descriptive data"\r\n            },\r\n            default   : "parallel"\r\n        },\r\n        parseSpace     : {\r\n            type      : "boolean",\r\n            definition: "Whether whitespace tokens should be included.",\r\n            default   : false\r\n        },\r\n        preserve       : {\r\n            type      : "number",\r\n            definition: "The maximum number of empty lines to retain.",\r\n            default   : 0\r\n        },\r\n        preserveComment: {\r\n            type      : "boolean",\r\n            definition: "Prevent comment reformatting due to option wrap.",\r\n            default   : false\r\n        },\r\n        qml            : {\r\n            type      : "boolean",\r\n            definition: "Enables QML syntax support in the jspretty library.",\r\n            default   : false\r\n        },\r\n        quote          : {\r\n            type      : "boolean",\r\n            definition: "If true and mode is \'diff\' then all single quote characters will be replaced b" +\r\n                    "y double quote characters in both the source and diff file input so as to elim" +\r\n                    "inate some differences from the diff report HTML output.",\r\n            default   : false\r\n        },\r\n        quoteConvert   : {\r\n            type      : "string",\r\n            definition: "If the quotes of JavaScript strings or markup attributes should be converted t" +\r\n                    "o single quotes or double quotes.",\r\n            values    : [\r\n                "double", "single", "none"\r\n            ],\r\n            default   : "none"\r\n        },\r\n        readmethod     : {\r\n            type      : "string",\r\n            definition: "The readmethod determines how Node.js should receive input and output.",\r\n            values    : {\r\n                auto        : "changes to value subdirectory, file, or screen depending on source resolution",\r\n                screen      : "reads from screen and outputs to screen",\r\n                file        : "reads a file and outputs to a file.  file requires option \'output\'",\r\n                filescreen  : "reads a file and writes to screen",\r\n                directory   : "process all files in the specified directory only",\r\n                subdirectory: "process all files in a directory and its subdirectories"\r\n            },\r\n            default   : "auto"\r\n        },\r\n        selectorlist   : {\r\n            type      : "boolean",\r\n            definition: "If comma separated CSS selectors should be retained on a single line of code.",\r\n            default   : false\r\n        },\r\n        semicolon      : {\r\n            type      : "boolean",\r\n            definition: "If true and mode is \'diff\' and lang is \'javascript\' all semicolon characters t" +\r\n                    "hat immediately preceed any white space containing a new line character will b" +\r\n                    "e removed so as to elimate some differences from the code comparison.",\r\n            default   : false\r\n        },\r\n        source         : {\r\n            type      : "string",\r\n            definition: "The source code or location for interpretation. This option is required for al" +\r\n                    "l modes.",\r\n            default   : ""\r\n        },\r\n        sourcelabel    : {\r\n            type      : "string",\r\n            definition: "This allows for a descriptive label of the source file code of the diff HTML o" +\r\n                    "utput.",\r\n            default   : "Source Sample"\r\n        },\r\n        space          : {\r\n            type      : "boolean",\r\n            definition: "Inserts a space following the function keyword for anonymous functions.",\r\n            default   : true\r\n        },\r\n        spaceclose     : {\r\n            type      : "boolean",\r\n            definition: "Markup self-closing tags end will end with \' />\' instead of \'/>\'.",\r\n            default   : false\r\n        },\r\n        style          : {\r\n            type      : "string",\r\n            definition: "If mode is \'beautify\' and lang is \'markup\' or \'html\' this will determine wheth" +\r\n                    "er the contents of script and style tags should always start at position 0 of " +\r\n                    "each line or if such content should be indented starting from the opening scri" +\r\n                    "pt or style tag.",\r\n            values    : [\r\n                "indent", "noindent"\r\n            ],\r\n            default   : "indent"\r\n        },\r\n        styleguide     : {\r\n            type      : "string",\r\n            definition: "Provides a collection of option presets to easily conform to popular JavaScrip" +\r\n                    "t style guides.",\r\n            values    : [\r\n                "airbnb",\r\n                "crockford",\r\n                "google",\r\n                "grunt",\r\n                "jquery",\r\n                "jslint",\r\n                "mediawiki",\r\n                "meteor",\r\n                "yandex",\r\n                "none"\r\n            ],\r\n            default   : "none"\r\n        },\r\n        summaryonly    : {\r\n            type      : "boolean",\r\n            definition: "Node only option to output only number of differences.",\r\n            default   : false\r\n        },\r\n        tagmerge       : {\r\n            type      : "boolean",\r\n            definition: "Allows immediately adjacement start and end markup tags of the same name to be" +\r\n                    " combined into a single self-closing tag.",\r\n            default   : false\r\n        },\r\n        tagsort        : {\r\n            type      : "boolean",\r\n            definition: "Sort child items of each respective markup parent element.",\r\n            default   : false\r\n        },\r\n        textpreserve   : {\r\n            type      : "boolean",\r\n            definition: "If text in the provided markup code should be preserved exactly as provided. T" +\r\n                    "his option eliminates beautification and wrapping of text content.",\r\n            default   : false\r\n        },\r\n        ternaryline    : {\r\n            type      : "boolean",\r\n            definition: "If ternary operators in JavaScript (? and :) should remain on the same line.",\r\n            default   : false\r\n        },\r\n        titanium       : {\r\n            type      : "boolean",\r\n            definition: "Forces the JavaScript parser to parse Titanium Style Sheets instead of JavaScr" +\r\n                    "ipt.",\r\n            default   : false\r\n        },\r\n        topcoms        : {\r\n            type      : "boolean",\r\n            definition: "If mode is \'minify\' this determines whether comments above the first line of c" +\r\n                    "ode should be kept.",\r\n            default   : false\r\n        },\r\n        twig           : {\r\n            type      : "boolean",\r\n            definition: "If markuppretty is passing twig tag data to jspretty.",\r\n            default   : false\r\n        },\r\n        typescript     : {\r\n            type      : "boolean",\r\n            definition: "Identifies certain edge cases where TypeScript is in conflict with React JSX r" +\r\n                    "egarding type generics",\r\n            default   : false\r\n        },\r\n        unformatted    : {\r\n            type      : "boolean",\r\n            definition: "If markup tags should have their insides preserved.",\r\n            default   : false\r\n        },\r\n        varword        : {\r\n            type      : "string",\r\n            definition: "If consecutive JavaScript variables should be merged into a comma separated li" +\r\n                    "st or if variables in a list should be separated.",\r\n            values    : [\r\n                "each", "list", "none"\r\n            ],\r\n            default   : "none"\r\n        },\r\n        version        : {\r\n            type      : "boolean",\r\n            definition: "A Node.js only option to write the version information to the console.",\r\n            default   : false\r\n        },\r\n        vertical       : {\r\n            type      : "string",\r\n            definition: "If lists of assignments and properties should be vertically aligned.",\r\n            values    : [\r\n                "all", "css", "js", "none"\r\n            ],\r\n            default   : "none"\r\n        },\r\n        wrap           : {\r\n            type      : "number",\r\n            definition: "How many characters long text content in markup or strings in JavaScript can b" +\r\n                    "e before wrapping. A value of 0 turns this feature off. A value of -1 will con" +\r\n                    "catenate strings in JavaScript if separated by a \'+\' operator.",\r\n            default   : 0\r\n        }\r\n    };\r\n    options.functions.default       = function options_default() {\r\n        var keys     = Object.keys(options.functions.definitions),\r\n            populate = function options_default_populate(name) {\r\n                if (name !== "api" && name !== "diff" && name !== "output" && name !== "source" && name !== "nodeasync" && (options.functions.nodeArgs === undefined || options.functions.nodeArgs[name] === undefined)) {\r\n                    options[name] = options\r\n                        .functions\r\n                        .definitions[name]\r\n                        .default;\r\n                }\r\n            };\r\n        keys.forEach(populate);\r\n    };\r\n    options.functions.versionString = function options__versionString() {\r\n        var dstring = "",\r\n            mstring = 0,\r\n            month   = [\r\n                "January",\r\n                "February",\r\n                "March",\r\n                "April",\r\n                "May",\r\n                "June",\r\n                "July",\r\n                "August",\r\n                "September",\r\n                "October",\r\n                "November",\r\n                "December"\r\n            ];\r\n        if (global.prettydiff.edition === undefined) {\r\n            return "";\r\n        }\r\n        dstring = global\r\n            .prettydiff\r\n            .edition\r\n            .latest\r\n            .toString();\r\n        mstring = Number(dstring.slice(2, 4)) - 1;\r\n        return "\\u001B[36mVersion\\u001B[39m: " + global.prettydiff.edition.version + " " +\r\n                "\\u001B[36mDated\\u001B[39m: " + dstring.slice(4, 6) + " " + month[mstring] + " " +\r\n                "20" + dstring.slice(0, 2);\r\n    };\r\n    options.functions.consolePrint  = function options_consolePrint() {\r\n        var list      = Object.keys(options.functions.definitions),\r\n            a         = 0,\r\n            b         = 0,\r\n            longest   = 0,\r\n            len       = list.length,\r\n            def       = "",\r\n            name      = "",\r\n            type      = "",\r\n            vlist     = [],\r\n            names     = [],\r\n            vals      = [],\r\n            lf        = (options.crlf === true)\r\n                ? "\\r\\n"\r\n                : "\\n",\r\n            limit     = (options.help === undefined)\r\n                ? 78\r\n                : options.help - 2,\r\n            namecolor = function options_colorPrint_namecolor(item) {\r\n                return "  * \\"\\u001B[32m" + item.replace("  * \\"", "") + "\\u001B[39m";\r\n            },\r\n            vertical  = function options_consolePrint_vertical(items) {\r\n                var mostest  = 0,\r\n                    x        = 0,\r\n                    y        = 0,\r\n                    leng     = items.length,\r\n                    newitems = [];\r\n                for (x = 0; x < leng; x = x + 1) {\r\n                    if (items[x].length > mostest) {\r\n                        mostest = items[x].length;\r\n                    }\r\n                }\r\n                for (x = 0; x < leng; x = x + 1) {\r\n                    y = items[x].length;\r\n                    newitems.push(items[x]);\r\n                    if (y < mostest) {\r\n                        do {\r\n                            y           = y + 1;\r\n                            newitems[x] = newitems[x] + " ";\r\n                        } while (y < mostest);\r\n                    }\r\n                }\r\n                return [newitems, mostest];\r\n            },\r\n            wrap      = function options_consolePrint_wrap(values) {\r\n                var start   = true,\r\n                    wrapper = [],\r\n                    wrappit = function options_consolePrint_wrap_wrappit() {\r\n                        var indent = (values === true && start === false)\r\n                                ? "     "\r\n                                : "  ",\r\n                            c      = limit - indent.length;\r\n                        name = name.replace(/^(\\s+)/, "");\r\n                        if (name.length < c) {\r\n                            wrapper.push(indent + name);\r\n                            name = "";\r\n                            return;\r\n                        }\r\n                        if (name.charAt(c) !== " " || name.charAt(c - 1) === " ") {\r\n                            do {\r\n                                c = c - 1;\r\n                            } while (c > 0 && (name.charAt(c) !== " " || name.charAt(c - 1) === " "));\r\n                        }\r\n                        if (c === 0) {\r\n                            wrapper.push(indent + name);\r\n                            name = "";\r\n                            return;\r\n                        }\r\n                        wrapper.push(indent + name.slice(0, c));\r\n                        name = name.slice(c);\r\n                    };\r\n                do {\r\n                    wrappit();\r\n                    start = false;\r\n                } while (name.length > 0);\r\n                if (options.crlf === true) {\r\n                    return wrapper.join("\\r\\n");\r\n                }\r\n                return wrapper.join("\\n");\r\n            },\r\n            output    = ["", "\\u001B[1mOptions\\u001B[22m"];\r\n        names   = vertical(list);\r\n        longest = names[1];\r\n        names   = names[0];\r\n        name    = "  Name";\r\n        b       = name.length;\r\n        if (b < longest) {\r\n            do {\r\n                b    = b + 1;\r\n                name = name + " ";\r\n            } while (b < longest);\r\n        }\r\n        name = name + "   - Type    - Default";\r\n        output.push("");\r\n        output.push(name);\r\n        b    = 0;\r\n        name = "";\r\n        do {\r\n            b    = b + 1;\r\n            name = name + "-";\r\n        } while (b < limit + 2);\r\n        output.push(name);\r\n        for (a = 0; a < len; a = a + 1) {\r\n            name = "* \\u001B[32m" + names[a] + "\\u001B[39m";\r\n            type = options\r\n                .functions\r\n                .definitions[list[a]]\r\n                .type;\r\n            if (type === "string") {\r\n                type = "\\u001B[33m" + type + "\\u001B[39m ";\r\n                def  = options\r\n                    .functions\r\n                    .definitions[list[a]]\r\n                    .default;\r\n                if (def === " ") {\r\n                    def = "(space)";\r\n                } else if (def === "") {\r\n                    def = "(empty string)";\r\n                } else {\r\n                    def = "\\"" + def + "\\"";\r\n                }\r\n            } else if (type === "number") {\r\n                type = "\\u001B[36m" + type + "\\u001B[39m ";\r\n                def  = options\r\n                    .functions\r\n                    .definitions[list[a]]\r\n                    .default\r\n                    .toString();\r\n            } else {\r\n                type = "\\u001B[35m" + type + "\\u001B[39m";\r\n                def  = options\r\n                    .functions\r\n                    .definitions[list[a]]\r\n                    .default\r\n                    .toString();\r\n            }\r\n            name = name + " - " + type + " - " + def;\r\n            output.push(name);\r\n            name = options\r\n                .functions\r\n                .definitions[list[a]]\r\n                .definition;\r\n            if (name.length < limit) {\r\n                output.push("  " + name);\r\n            } else {\r\n                output.push(wrap(false));\r\n            }\r\n            vlist = options\r\n                .functions\r\n                .definitions[list[a]]\r\n                .values;\r\n            if (vlist !== undefined) {\r\n                if (typeof vlist.length === "number") {\r\n                    name = "Accepted values: \\"" + vlist\r\n                        .toString()\r\n                        .replace(/,/g, "\\", \\"") + "\\"";\r\n                    name = "\\u001B[31m" + wrap(false);\r\n                    name = name.replace(\r\n                        "Accepted values: \\"",\r\n                        "Accepted values:\\u001B[39m \\"\\u001B[32m"\r\n                    );\r\n                    name = name.replace(/,\\u0020"/g, ", \\"\\u001B[32m");\r\n                    name = name.replace(/",/g, "\\u001B[39m\\",");\r\n                    output.push(name);\r\n                } else {\r\n                    output.push("  \\u001B[31mAccepted values:\\u001B[39m");\r\n                    vlist = Object.keys(options.functions.definitions[list[a]].values);\r\n                    vals  = vertical(vlist)[0];\r\n                    b     = 0;\r\n                    do {\r\n                        vals[b] = vals[b] + " ";\r\n                        name    = "  * \\"" + vals[b].replace(" ", "\\"") + " - " + options\r\n                            .functions\r\n                            .definitions[list[a]]\r\n                            .values[vlist[b]];\r\n                        name    = wrap(true);\r\n                        name    = name.replace(/\\u0020\\u0020\\*\\u0020"\\w+/, namecolor);\r\n                        output.push(name);\r\n                        b = b + 1;\r\n                    } while (b < vlist.length);\r\n                }\r\n            }\r\n            output.push("");\r\n        }\r\n        if (options.api === "node") {\r\n            output.push("\\u001B[1mUsage\\u001B[22m");\r\n            output.push(\r\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32moption1:\\u001B[39m\\u001B[" +\r\n                "33m\\"value\\"\\u001B[39m \\u001B[32moption2:\\u001B[39m\\u001B[33m\\"value\\"\\u001B[3" +\r\n                "9m ..."\r\n            );\r\n            output.push(\r\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32msource:\\u001B[39m\\u001B[3" +\r\n                "3m\\"myApplication.js\\"\\u001B[39m \\u001B[32mreadmethod:\\u001B[39m\\u001B[33m\\"fi" +\r\n                "lescreen\\"\\u001B[39m \\u001B[32mmode:\\u001B[39m\\u001B[33m\\"beautify\\"\\u001B[39m"\r\n            );\r\n            output.push(\r\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32msource:\\u001B[39m\\u001B[3" +\r\n                "3m\\"old_directory\\"\\u001B[39m \\u001B[32mdiff:\\u001B[39m\\u001B[33m\\"new_directo" +\r\n                "ry\\"\\u001B[39m \\u001B[32mreadmethod:\\u001B[39m\\u001B[33m\\"subdirectory\\"\\u001B" +\r\n                "[39m"\r\n            );\r\n            output.push(\r\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32mhelp\\u001B[39m:80     to " +\r\n                "see this help message, the number value sets word wrap"\r\n            );\r\n            output.push(\r\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32mversion\\u001B[39m     to " +\r\n                "see only the version line"\r\n            );\r\n            output.push(\r\n                "\\u001B[35mnode api/node-local.js\\u001B[39m \\u001B[32mlist\\u001B[39m        to " +\r\n                "see the current settings"\r\n            );\r\n            output.push("");\r\n            output.push(options.functions.versionString());\r\n            output.push("");\r\n            return output.join(lf);\r\n        }\r\n        output.push("");\r\n        output.push(options.functions.versionString());\r\n        output.push("");\r\n        return output\r\n            .join(lf)\r\n            .replace(/\\u001b\\[\\d+m/g, "");\r\n    };\r\n    options.functions.pdcomment     = function options_pdcomment() {\r\n        var comment    = options.source,\r\n            type       = "source",\r\n            a          = 0,\r\n            b          = options.source.length,\r\n            strl       = 0,\r\n            strm       = "",\r\n            c          = -1,\r\n            build      = [],\r\n            comma      = -1,\r\n            g          = 0,\r\n            sourceChar = [],\r\n            quote      = "",\r\n            sind       = -1,\r\n            dind       = -1,\r\n            ss         = null,\r\n            sd         = null;\r\n        ss = options\r\n            .source\r\n            .match(/\\/\\*\\s*prettydiff.com/);\r\n        sd = options\r\n            .diff\r\n            .match(/\\/\\*\\s*prettydiff.com/);\r\n        if (ss === null) {\r\n            ss = options\r\n                .source\r\n                .match(/<\\!--+\\s*prettydiff.com/);\r\n            if (ss !== null) {\r\n                strm = ss[0];\r\n                strl = strm.length;\r\n                sind = options\r\n                    .source\r\n                    .indexOf(strm);\r\n                c    = sind + strl;\r\n            }\r\n        } else {\r\n            strm = ss[0];\r\n            strl = strm.length;\r\n            sind = options\r\n                .source\r\n                .indexOf(strm);\r\n            c    = sind + strl;\r\n        }\r\n        if (c < 0) {\r\n            if (sd === null) {\r\n                sd = options\r\n                    .diff\r\n                    .match(/<\\!--+\\s*prettydiff.com/);\r\n                if (sd !== null) {\r\n                    strm    = sd[0];\r\n                    strl    = strm.length;\r\n                    dind    = options\r\n                        .diff\r\n                        .indexOf(strm);\r\n                    c       = dind + strl;\r\n                    comment = options.diff;\r\n                    type    = "diff";\r\n                }\r\n            } else {\r\n                strm    = sd[0];\r\n                strl    = strm.length;\r\n                dind    = options\r\n                    .diff\r\n                    .indexOf(strm);\r\n                c       = dind + strl;\r\n                comment = options.diff;\r\n                type    = "diff";\r\n            }\r\n        }\r\n        if (c < 0) {\r\n            return;\r\n        }\r\n        if ((options.source.charAt(c - (strl + 1)) === "\\"" && options.source.charAt(c) === "\\"") || (sind < 0 && dind < 0)) {\r\n            return;\r\n        }\r\n        if (type === "source" && (/^(\\s*\\{\\s*"token"\\s*:\\s*\\[)/).test(options.source) === true && (/\\],\\s*"types"\\s*:\\s*\\[/).test(options.source) === true) {\r\n            return;\r\n        }\r\n        if (type === "diff" && (/^(\\s*\\{\\s*"token"\\s*:\\s*\\[)/).test(options.diff) === true && (/\\],\\s*"types"\\s*:\\s*\\[/).test(options.diff) === true) {\r\n            return;\r\n        }\r\n        for (c = c; c < b; c = c + 1) {\r\n            if (quote === "") {\r\n                if (comment.charAt(c) === "\\"" || comment.charAt(c) === "\'") {\r\n                    quote = comment.charAt(c);\r\n                    if (comment.charAt(c + 1) === " " && sourceChar[sourceChar.length - 1] === ":") {\r\n                        sourceChar.push("\\\\ ");\r\n                        c = c + 1;\r\n                    }\r\n                } else {\r\n                    if (comment.charAt(c) === "*" && comment.charAt(c + 1) === "/" && strm.slice(0, 2) === "/*") {\r\n                        break;\r\n                    }\r\n                    if (comment.charAt(c) === "-" && comment.charAt(c + 1) === "-" && comment.charAt(\r\n                        c + 2\r\n                    ) === ">" && strm.slice(0, 4) === "\x3c!--") {\r\n                        break;\r\n                    }\r\n                    if (sourceChar[sourceChar.length - 1] !== ":" || (sourceChar[sourceChar.length - 1] === ":" && comment.charAt(c) !== " ")) {\r\n                        sourceChar.push(comment.charAt(c));\r\n                    }\r\n                }\r\n            } else if (comment.charAt(c) === quote) {\r\n                quote = "";\r\n            }\r\n        }\r\n        comment = sourceChar.join("");\r\n        b       = comment.length;\r\n        for (c = 0; c < b; c = c + 1) {\r\n            if ((typeof comment.charAt(c - 1) !== "string" || comment.charAt(c - 1) !== "\\\\") && (comment.charAt(c) === "\\"" || comment.charAt(c) === "\'")) {\r\n                if (quote === "") {\r\n                    quote = comment.charAt(c);\r\n                } else {\r\n                    quote = "";\r\n                }\r\n            }\r\n            if (quote === "") {\r\n                if (comment.charAt(c) === ",") {\r\n                    g     = comma + 1;\r\n                    comma = c;\r\n                    if ((/(\\:\\\\\\s+)$/).test(comment.slice(g, comma)) === true) {\r\n                        build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/:\\\\/, ":"));\r\n                    } else {\r\n                        build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/(\\s*)$/, ""));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        g     = comma + 1;\r\n        comma = comment.length;\r\n        if ((/(\\:\\\\\\s+)$/).test(comment.slice(g, comma)) === true) {\r\n            build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/:\\\\/, ":"));\r\n        } else {\r\n            build.push(comment.slice(g, comma).replace(/^(\\s*)/, "").replace(/(\\s*)$/, ""));\r\n        }\r\n        quote      = "";\r\n        b          = build.length;\r\n        sourceChar = [];\r\n        for (c = 0; c < b; c = c + 1) {\r\n            a = build[c].length;\r\n            for (g = 0; g < a; g = g + 1) {\r\n                if (build[c].indexOf(":") === -1) {\r\n                    build[c] = "";\r\n                    break;\r\n                }\r\n                sourceChar = [];\r\n                if ((typeof build[c].charAt(g - 1) !== "string" || build[c].charAt(g - 1) !== "\\\\") && (build[c].charAt(g) === "\\"" || build[c].charAt(g) === "\'")) {\r\n                    if (quote === "") {\r\n                        quote = build[c].charAt(g);\r\n                    } else {\r\n                        quote = "";\r\n                    }\r\n                }\r\n                if (quote === "") {\r\n                    if (build[c].charAt(g) === ":") {\r\n                        sourceChar.push(build[c].substring(0, g).replace(/(\\s*)$/, ""));\r\n                        sourceChar.push(build[c].substring(g + 1));\r\n                        if (sourceChar[1].charAt(0) === sourceChar[1].charAt(sourceChar[1].length - 1) && sourceChar[1].charAt(sourceChar[1].length - 2) !== "\\\\" && (sourceChar[1].charAt(0) === "\\"" || sourceChar[1].charAt(0) === "\'")) {\r\n                            sourceChar[1] = sourceChar[1].substring(1, sourceChar[1].length - 1);\r\n                        }\r\n                        build[c] = sourceChar;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (c = 0; c < b; c = c + 1) {\r\n            if (typeof build[c][1] === "string") {\r\n                build[c][0] = build[c][0].replace("api.", "");\r\n                if (build[c][0] === "brace_style") {\r\n                    if (build[c][1] === "collapse" || build[c][1] === "collapse-preserve-inline" || build[c][1] === "expand" || build[c][1] === "none") {\r\n                        options.brace_style = build[c][1];\r\n                    }\r\n                }\r\n                if (build[c][0] === "braces" || build[c][0] === "indent") {\r\n                    if (build[c][1] === "knr" || build[c][1] === "allman") {\r\n                        options.braces = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "color") {\r\n                    if (typeof b[c][1] === "string" && b[c][1] !== "") {\r\n                        options.color = b[c][1];\r\n                    }\r\n                } else if (build[c][0] === "comments") {\r\n                    if (build[c][1] === "indent" || build[c][1] === "noindent") {\r\n                        options.comments = "noindent";\r\n                    }\r\n                } else if (build[c][0] === "diffview") {\r\n                    if (build[c][1] === "sidebyside" || build[c][1] === "inline") {\r\n                        options.diffview = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "endcomma") {\r\n                    if (build[c][1] === "true" || build[c][1] === "always") {\r\n                        options.endcomma = "always";\r\n                    } else if (build[c][1] === "false" || build[c][1] === "never") {\r\n                        options.endcomma = "never";\r\n                    } else if (build[c][1] === "multiline") {\r\n                        options.endcomma = "multiline";\r\n                    }\r\n                } else if (build[c][0] === "formatArray" || build[c][0] === "formatObject") {\r\n                    if (build[c][1] === "default" || build[c][1] === "indent" || build[c][1] === "inline") {\r\n                        options[build[c][0]] = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "jsscope") {\r\n                    if (build[c][1] === "html" || build[c][1] === "none" || build[c][1] === "report") {\r\n                        options.jsscope = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "lang" || build[c][0] === "langdefault") {\r\n                    options[build[c][0]] = global\r\n                        .prettydiff\r\n                        .language\r\n                        .setlangmode(build[c][1]);\r\n                } else if (build[c][0] === "mode") {\r\n                    if (build[c][1] === "beautify" || build[c][1] === "minify" || build[c][1] === "diff" || build[c][1] === "parse" || build[c][1] === "analysis") {\r\n                        options.mode = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "objsort") {\r\n                    if (build[c][1] === "all" || build[c][1] === "js" || build[c][1] === "css" || build[c][1] === "markup" || build[c][1] === "none" || build[c][1] === "true" || build[c][1] === "false") {\r\n                        options.objsort = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "parseFormat") {\r\n                    if (build[c][1] === "htmltable" || build[c][1] === "parallel" || build[c][1] === "sequential") {\r\n                        options.parseFormat = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "quoteConvert") {\r\n                    if (build[c][1] === "single" || build[c][1] === "double" || build[c][1] === "none") {\r\n                        options.quoteConvert = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "style") {\r\n                    if (build[c][1] === "indent" || build[c][1] === "noindent") {\r\n                        options.style = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "typescript" && build[c][1] === "true") {\r\n                    options.typescript = true;\r\n                    options.lang       = "typescript";\r\n                } else if (build[c][0] === "varword") {\r\n                    if (build[c][1] === "each" || build[c][1] === "list" || build[c][1] === "none") {\r\n                        options.varword = build[c][1];\r\n                    }\r\n                } else if (build[c][0] === "vertical") {\r\n                    if (build[c][1] === "all" || build[c][1] === "css" || build[c][1] === "js" || build[c][1] === "none") {\r\n                        options.vertical = build[c][1];\r\n                    }\r\n                } else if (options[build[c][0]] !== undefined && options[build[c][1]] !== "") {\r\n                    if (build[c][1] === "true") {\r\n                        options[build[c][0]] = true;\r\n                    } else if (build[c][1] === "false") {\r\n                        options[build[c][0]] = false;\r\n                    } else if (isNaN(build[c][1]) === false && (/\\s+/).test(build[c][1]) === false) {\r\n                        options[build[c][0]] = Number(build[c][1]);\r\n                    } else {\r\n                        if (options.functions.definitions[build[c][0]].type === "string") {\r\n                            options[build[c][0]] = build[c][1];\r\n                        } else {\r\n                            options[build[c][0]] = options\r\n                                .functions\r\n                                .definitions[build[c][0]]\r\n                                .default;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    options.functions.validate      = function options_validate(api) {\r\n        var braceEscape = function diffview__options_braceEscape(input) {\r\n            return input\r\n                .replace(/&/g, "&amp;")\r\n                .replace(/</g, "&lt;")\r\n                .replace(/>/g, "&gt;");\r\n        };\r\n        if (options.api !== "dom") {\r\n            options\r\n                .functions\r\n                .default();\r\n        }\r\n        // apacheVelocity - provides support for Apache Velocity markup templates\r\n        options.apacheVelocity  = (\r\n            api.apacheVelocity === true || api.apacheVelocity === "true"\r\n        );\r\n        // determines api source as necessary to make a decision about whether to supply\r\n        // externally needed JS functions to reports\r\n        options.api             = (api.api === undefined || api.api.length === 0)\r\n            ? "node"\r\n            : api.api;\r\n        // attributetoken - whether attributes should be represented as token items in\r\n        // the parse table or whether they should be a data properties of their element\r\n        options.attributetoken  = (\r\n            api.attributetoken === true || api.attributetoken === "true"\r\n        );\r\n        // brace-style - provided to emulate JSBeautify\'s brace-style option\r\n        options.brace_style     = (\r\n            api.brace_style === "collapse" || api.brace_style === "collapse-preserve-inline" || api.brace_style === "expand"\r\n        )\r\n            ? api.brace_style\r\n            : "none";\r\n        // braceline - should a new line pad the interior of blocks (curly braces) in\r\n        // JavaScript\r\n        options.braceline       = (api.braceline === true || api.braceline === "true");\r\n        //bracepadding - should curly braces be padded with a space in JavaScript?\r\n        options.bracepadding    = (\r\n            api.bracepadding === true || api.bracepadding === "true"\r\n        );\r\n        // indent - should JSPretty format JavaScript in the normal KNR style or push\r\n        // curly braces onto a separate line like the "allman" style\r\n        options.braces          = (\r\n            api.braces === true || api.braces === "true" || api.braces === "allman"\r\n        )\r\n            ? "allman"\r\n            : "knr";\r\n        //color scheme of generated HTML artifacts\r\n        options.color           = (api.color === "canvas" || api.color === "shadow")\r\n            ? api.color\r\n            : "white";\r\n        //comments - if comments should receive indentation or not\r\n        options.comments        = (api.comments === "noindent")\r\n            ? "noindent"\r\n            : ((api.comments === "nocomment")\r\n                ? "nocomment"\r\n                : "indent");\r\n        //commline - If in markup a newline should be forced above comments\r\n        options.commline        = (api.commline === true || api.commline === "true");\r\n        // compressedcss - If the beautified CSS should contain minified properties\r\n        options.compressedcss   = (\r\n            api.compressedcss === true || api.compressedcss === "true"\r\n        );\r\n        // conditional - should IE conditional comments be preserved during markup\r\n        // minification\r\n        options.conditional     = (\r\n            api.conditional === true || api.conditional === "true" || api.html === true\r\n        );\r\n        //content - should content be normalized during a diff operation\r\n        options.content         = (api.content === true || api.content === "true");\r\n        // context - should the diff report only include the differences, if so then\r\n        // buffered by how many lines of code\r\n        options.context         = (\r\n            isNaN(api.context) === true || api.context === "" || Number(api.context) < 0\r\n        )\r\n            ? -1\r\n            : Number(api.context);\r\n        //correct - should JSPretty make some corrections for sloppy JS\r\n        options.correct         = (api.correct === true || api.correct === "true");\r\n        //crlf - if output should use \\r\\n (Windows compatible) for line termination\r\n        options.crlf            = (api.crlf === true || api.crlf === "true");\r\n        //cssinsertlines = if a new line should be forced between each css block\r\n        options.cssinsertlines = (\r\n            api.cssinsertlines === true || api.cssinsertlines === "true"\r\n        );\r\n        //csvchar - what character should be used as a separator\r\n        options.csvchar         = (typeof api.csvchar === "string" && api.csvchar.length > 0)\r\n            ? api.csvchar\r\n            : ",";\r\n        //diff - source code to compare with\r\n        options.diff            = (\r\n            typeof api.diff === "string" && api.diff.length > 0 && (/^(\\s+)$/).test(api.diff) === false\r\n        )\r\n            ? api.diff\r\n            : "";\r\n        // diffcli - if operating from Node.js and set to true diff output will be\r\n        // printed to stdout just like git diff\r\n        options.diffcli         = (api.diffcli === true || api.diffcli === "true");\r\n        //diffcomments - should comments be included in the diff operation\r\n        options.diffcomments    = (\r\n            api.diffcomments === true || api.diffcomments === "true"\r\n        );\r\n        //difflabel - a text label to describe the diff code\r\n        options.difflabel       = (\r\n            typeof api.difflabel === "string" && api.difflabel.length > 0\r\n        )\r\n            ? braceEscape(api.difflabel)\r\n            : "New Sample";\r\n        // diffspaceignore - If white space differences should be ignored by the diff\r\n        // tool\r\n        options.diffspaceignore = (\r\n            api.diffspaceignore === true || api.diffspaceignore === "true"\r\n        );\r\n        // diffview - should the diff report be a single column showing both sources\r\n        // simultaneously "inline" or showing the sources in separate columns\r\n        // "sidebyside"\r\n        options.diffview        = (api.diffview === "inline")\r\n            ? "inline"\r\n            : "sidebyside";\r\n        //dustjs - support for this specific templating scheme\r\n        options.dustjs          = (api.dustjs === true || api.dustjs === "true");\r\n        //elseline - for the \'else\' keyword onto a new line in JavaScript\r\n        options.elseline        = (api.elseline === true || api.elseline === "true");\r\n        // endcomma - if a trailing comma should be injected at the end of arrays and\r\n        // object literals in JavaScript\r\n        options.endcomma        = (\r\n            api.endcomma === true || api.endcomma === "true" || api.endcomma === "always"\r\n        )\r\n            ? "always"\r\n            : (api.endcomma === "multiline")\r\n                ? "multiline"\r\n                : "never";\r\n        // endquietly - a node only option to prevent writing anything to console as\r\n        // stdout\r\n        options.endquietly      = (api.endquietly === "log" || api.endquietly === "quiet")\r\n            ? api.endquietly\r\n            : "";\r\n        // force_attribute - forces indentation of all markup attriubtes\r\n        options.force_attribute = (\r\n            api.force_attribute === true || api.force_attribute === "true"\r\n        );\r\n        // force_indent - should markup beautification always force indentation even if\r\n        // disruptive\r\n        options.force_indent    = (\r\n            api.force_indent === true || api.force_indent === "true"\r\n        );\r\n        // formatArray - defines whether JavaScript array keys should be indented or\r\n        // kept on a single line\r\n        options.formatArray     = (\r\n            api.formatArray === "indent" || api.formatArray === "inline"\r\n        )\r\n            ? api.formatArray\r\n            : "default";\r\n        // formatObject - defines whether JavaScript object properties should be\r\n        // indented or kept on a single line\r\n        options.formatObject    = (\r\n            api.formatObject === "indent" || api.formatObject === "inline"\r\n        )\r\n            ? api.formatObject\r\n            : "default";\r\n        // functionname - if a space should occur between a function name and its\r\n        // arguments paren\r\n        options.functionname    = (\r\n            api.functionname === true || api.functionname === "true"\r\n        );\r\n        options.help            = (isNaN(api.help) === true || api.help === "")\r\n            ? 80\r\n            : Number(api.help);\r\n        // html - should markup be presumed to be HTML with all the aloppiness HTML\r\n        // allows\r\n        options.html            = (\r\n            api.html === true || api.html === "true" || api.html === "html-yes"\r\n        );\r\n        //inchar - what character(s) should be used to create a single identation\r\n        options.inchar          = (typeof api.inchar === "string" && api.inchar.length > 0)\r\n            ? api\r\n                .inchar\r\n                .replace(/\\\\t/g, "\\u0009")\r\n                .replace(/\\\\n/g, "\\u000a")\r\n                .replace(/\\\\r/g, "\\u000d")\r\n                .replace(/\\\\f/g, "\\u000c")\r\n                .replace(/\\\\b/g, "\\u0008")\r\n            : " ";\r\n        // inlevel - should indentation in JSPretty be buffered with additional\r\n        // indentation?  Useful when supplying code to sites accepting markdown\r\n        options.inlevel         = (\r\n            isNaN(api.inlevel) === true || api.inlevel === "" || Number(api.inlevel) < 1\r\n        )\r\n            ? 0\r\n            : Number(api.inlevel);\r\n        // insize - how many characters from api.inchar should constitute a single\r\n        // indentation\r\n        options.insize          = (isNaN(api.insize) === true || api.insize === "")\r\n            ? 4\r\n            : Number(api.insize);\r\n        // jekyll - If the delimiter "---" should be used to create comments in markup.\r\n        options.jekyll          = (api.jekyll === true || api.jekyll === "true");\r\n        // jsscope - do you want to enable the jsscope feature of JSPretty?  This\r\n        // feature will output formatted HTML instead of text code showing which\r\n        // variables are declared at which functional depth\r\n        options.jsscope         = (\r\n            api.jsscope === true || api.jsscope === "true" || api.jsscope === "report"\r\n        )\r\n            ? "report"\r\n            : (api.jsscope === "html")\r\n                ? "html"\r\n                : "none";\r\n        // jsx - an internal option that is tripped to true when JSX code is\r\n        // encountered.  This option allows the markuppretty and jspretty parsers know\r\n        // to recursively hand off to each other.\r\n        options.jsx             = false;\r\n        //lang - which programming language will we be analyzing\r\n        options.lang            = (typeof api.lang === "string" && api.lang !== "auto")\r\n            ? global\r\n                .prettydiff\r\n                .language\r\n                .setlangmode(api.lang.toLowerCase())\r\n            : "auto";\r\n        // langdefault - what language should lang value "auto" resort to when it cannot\r\n        // determine the language\r\n        options.langdefault     = (typeof api.langdefault === "string")\r\n            ? global\r\n                .prettydiff\r\n                .language\r\n                .setlangmode(api.langdefault.toLowerCase())\r\n            : "text";\r\n        // listoptions - a node only option to output the current options object to the\r\n        // console\r\n        options.listoptions     = (\r\n            api.listoptions === true || api.listoptions === "true" || api.listoptions === "l" || api.listoptions === "list"\r\n        );\r\n        // methodchain - if JavaScript method chains should be strung onto a single line\r\n        // instead of indented\r\n        options.methodchain     = (\r\n            api.methodchain === true || api.methodchain === "true" || api.methodchain === "chain"\r\n        )\r\n            ? "chain"\r\n            : (api.methodchain === "none")\r\n                ? "none"\r\n                : "indent";\r\n        // miniwrap - when language is JavaScript and mode is \'minify\' if option \'jwrap\'\r\n        // should be applied to all code\r\n        options.miniwrap        = (api.miniwrap === true || api.miniwrap === "true");\r\n        //mode - is this a minify, beautify, or diff operation\r\n        options.mode            = (\r\n            api.mode === "minify" || api.mode === "beautify" || api.mode === "parse" || api.mode === "analysis"\r\n        )\r\n            ? api.mode\r\n            : "diff";\r\n        //newline - Insert an empty line at the end of output.\r\n        options.newline         = (\r\n            api.newline === true || api.newline === "true"\r\n        );\r\n        //neverflatten - prevent flattening of destructured lists in JavaScript\r\n        options.neverflatten    = (\r\n            api.neverflatten === true || api.neverflatten === "true"\r\n        );\r\n        //nocaseindent - if a \'case\' should be indented to its parent \'switch\'\r\n        options.nocaseindent    = (\r\n            api.nocaseindent === true || api.nocaseindent === "true"\r\n        );\r\n        // nochainindent - prevent indentation when JavaScript chains of methods are\r\n        // broken onto multiple lines\r\n        options.nochainindent   = (\r\n            api.nochainindent === true || api.nochainindent === "true"\r\n        );\r\n        // nodeasync - meta data has to be passed in the output for bulk async\r\n        // operations otherwise there is cross-talk, which means prettydiff has to\r\n        // return an array of [data, meta] instead of a single string\r\n        options.nodeasync       = (api.nodeasync === true || api.nodeasync === "true");\r\n        // nodeerror - nodeonly rule about whether parse errors should be logged to the\r\n        // console\r\n        options.nodeerror       = (api.nodeerror === true || api.nodeerror === "true");\r\n        // noleadzero - in CSS removes and prevents a run of 0s from appearing\r\n        // immediately before a value\'s decimal.\r\n        options.noleadzero      = (api.noleadzero === true || api.noleadzero === "true");\r\n        //objsort will alphabetize object keys in JavaScript\r\n        options.objsort         = (\r\n            api.objsort === "all" || api.objsort === "js" || api.objsort === "css" || api.objsort === "markup" || api.objsort === true || api.objsort === "true"\r\n        )\r\n            ? api.objsort\r\n            : "none";\r\n        // output - a node only option of where to write the output into the file system\r\n        options.output          = (\r\n            typeof api.output === "string" && api.output.length > 0 && (/^(\\s+)$/).test(api.output) === false\r\n        )\r\n            ? api.output\r\n            : "";\r\n        //parseFormat - determine how the parse tree should be organized and formatted\r\n        options.parseFormat     = (\r\n            api.parseFormat === "sequential" || api.parseFormat === "htmltable"\r\n        )\r\n            ? api.parseFormat\r\n            : "parallel";\r\n        // parseSpace - whether whitespace tokens between tags should be included in the\r\n        // parse tree output\r\n        options.parseSpace      = (api.parseSpace === true || api.parseSpace === "true");\r\n        //preserve - should empty lines be preserved in beautify operations of JSPretty?\r\n        options.preserve        = (function core__optionPreserve() {\r\n            if (api.preserve === 1 || api.preserve === undefined || api.preserve === true || api.preserve === "all" || api.preserve === "js" || api.preserve === "css") {\r\n                return 1;\r\n            }\r\n            if (api.preserve === false || api.preserve === "" || isNaN(api.preserve) === true || Number(api.preserve) < 1 || api.preserve === "none") {\r\n                return 0;\r\n            }\r\n            return Number(api.preserve);\r\n        }());\r\n        // preserveComment - prevent comment reformatting due to option wrap\r\n        options.preserveComment = (api.preserveComment === true || api.preserveComment === "true");\r\n        // qml - if the language is qml (beautified as JavaScript that looks like CSS)\r\n        options.qml             = (api.qml === true || api.qml === "true");\r\n        // quoteConvert - convert " to \' (or \' to ") of string literals or markup\r\n        // attributes\r\n        options.quoteConvert    = (\r\n            api.quoteConvert === "single" || api.quoteConvert === "double"\r\n        )\r\n            ? api.quoteConvert\r\n            : "none";\r\n        // readmethod - a node only option to determine scope of operations (how to\r\n        // proceeed with source and diff options as text or file system properties)\r\n        options.readmethod      = (\r\n            api.readmethod === "subdirectory" || api.readmethod === "directory" || api.readmethod === "file" || api.readmethod === "filescreen" || api.readmethod === "screen"\r\n        )\r\n            ? api.readmethod\r\n            : "auto";\r\n        //selectorlist - should comma separated CSS selector lists be on one line\r\n        options.selectorlist    = (\r\n            api.selectorlist === true || api.selectorlist === "true"\r\n        );\r\n        // semicolon - should trailing semicolons be removed during a diff operation to\r\n        // reduce the number of false positive comparisons\r\n        options.semicolon       = (api.semicolon === true || api.semicolon === "true");\r\n        // source - the source code in minify and beautify operations or "base" code in\r\n        // operations\r\n        options.source          = (\r\n            typeof api.source === "string" && api.source.length > 0 && (/^(\\s+)$/).test(api.source) === false\r\n        )\r\n            ? api.source\r\n            : "";\r\n        //sourcelabel - a text label to describe the api.source code for the diff report\r\n        options.sourcelabel     = (\r\n            typeof api.sourcelabel === "string" && api.sourcelabel.length > 0\r\n        )\r\n            ? braceEscape(api.sourcelabel)\r\n            : "Base Sample";\r\n        // space - should JSPretty include a space between a function keyword and the\r\n        // next adjacent opening parenthesis character in beautification operations\r\n        options.space           = (api.space !== false && api.space !== "false");\r\n        //spaceclose - If markup self-closing tags should end with " />" instead of "/>"\r\n        options.spaceclose      = (api.spaceclose === true || api.spaceclose === "true");\r\n        // style - should JavaScript and CSS code receive indentation if embedded inline\r\n        // in markup\r\n        options.style           = (api.style === "noindent")\r\n            ? "noindent"\r\n            : "indent";\r\n        // styleguide - preset of beautification options to bring a JavaScript sample\r\n        // closer to conformance of a given style guide\r\n        options.styleguide      = (typeof api.styleguide === "string")\r\n            ? api\r\n                .styleguide\r\n                .toLowerCase()\r\n                .replace(/\\s+/g, "")\r\n            : "none";\r\n        // summaryonly - node only option to output only the diff summary\r\n        options.summaryonly     = (api.summaryonly === true || api.summaryonly === "true");\r\n        // tagmerge - Allows combining immediately adjacent start and end tags of the\r\n        // same name into a single self-closing tag:  <a href="home"></a> into\r\n        // <a//href="home"/>\r\n        options.tagmerge = (api.tagmerge === true || api.tagmerge === "true");\r\n        //sort markup child nodes alphabetically\r\n        options.tagsort         = (api.tagsort === true || api.tagsort === "true");\r\n        // textpreserve - Force the markup beautifier to retain text (white space and\r\n        // all) exactly as provided.\r\n        options.ternaryline     = (api.ternaryline === true || api.ternaryline === "true");\r\n        options.textpreserve    = (\r\n            api.textpreserve === true || api.textpreserve === "true"\r\n        );\r\n        // titanium - TSS document support via option, because this is a uniquely\r\n        // modified form of JSON\r\n        options.titanium        = (api.titanium === true || api.titanium === "true");\r\n        // topcoms - should comments at the top of a JavaScript or CSS source be\r\n        // preserved during minify operations\r\n        options.topcoms         = (api.topcoms === true || api.topcoms === "true");\r\n        // twig - if markuppretty is passing twig tag data to jspretty\r\n        options.twig            = (api.twig === true || api.twig === "true");\r\n        options.typescript      = (api.typescript === true || api.typescript === "true");\r\n        // unformatted - if the internals of markup tags should be preserved\r\n        options.unformatted     = (api.unformatted === true || api.unformatted === "true");\r\n        // varword - should consecutive variables be merged into a comma separated list\r\n        // or the opposite\r\n        options.varword         = (api.varword === "each" || api.varword === "list")\r\n            ? api.varword\r\n            : "none";\r\n        // version - a node only option to output the version number to command line\r\n        options.version         = (\r\n            api.version === true || api.version === "true" || api.version === "version" || api.version === "v"\r\n        );\r\n        // vertical - whether or not to vertically align lists of assigns in CSS and\r\n        // JavaScript\r\n        options.vertical        = (\r\n            api.vertical === "all" || api.vertical === "css" || api.vertical === "js"\r\n        )\r\n            ? api.vertical\r\n            : "none";\r\n        // wrap - in markup beautification should text content wrap after the first\r\n        // complete word up to a certain character length\r\n        options.wrap            = (\r\n            isNaN(api.wrap) === true || api.wrap === "" || options.textpreserve === true\r\n        )\r\n            ? 0\r\n            : Number(api.wrap);\r\n        options.autoval         = ["", "", ""];\r\n        if (options.lang === "auto") {\r\n            options.autoval = global\r\n                .prettydiff\r\n                .language\r\n                .auto(options.source, options.langdefault);\r\n            options.lang    = options.autoval[1];\r\n        } else if (options.lang === "qml") {\r\n            options.qml  = true;\r\n            options.lang = "javascript";\r\n        } else if (options.lang === "velocity") {\r\n            options.apacheVelocity = true;\r\n            options.lang           = "markup";\r\n        } else if (options.api === "dom") {\r\n            options.autoval = [options.lang, options.lang, options.lang];\r\n        } else {\r\n            options.lang = global\r\n                .prettydiff\r\n                .language\r\n                .setlangmode(options.lang);\r\n        }\r\n        if (options.lang === "typescript") {\r\n            options.lang       = "javascript";\r\n            options.typescript = true;\r\n        }\r\n        if (options.apacheVelocity === true) {\r\n            if (options.mode === "minify") {\r\n                options.apacheVelocity = false;\r\n            } else {\r\n                options.lang = "markup";\r\n            }\r\n        }\r\n        if (options.qml === true) {\r\n            if (options.mode === "minify") {\r\n                options.qml = false;\r\n            } else {\r\n                options.lang = "javascript";\r\n            }\r\n        }\r\n        if (api.alphasort === true || api.alphasort === "true" || api.objsort === true || api.objsort === "true") {\r\n            options.objsort = "all";\r\n        }\r\n        if (api.indent === "allman") {\r\n            options.braces = "allman";\r\n        }\r\n        if (api.methodchain === true || api.methodchain === "true") {\r\n            options.methodchain = "chain";\r\n        } else if (api.methodchain === false || api.methodchain === "false") {\r\n            options.methodchain = "indent";\r\n        }\r\n        if (api.vertical === true || api.vertical === "true") {\r\n            options.vertical = "all";\r\n        } else if (api.vertical === "cssonly") {\r\n            options.vertical = "css";\r\n        } else if (api.vertical === "jsonly") {\r\n            options.vertical = "js";\r\n        }\r\n        if (options.autoval[0] === "dustjs") {\r\n            options.dustjs = true;\r\n        }\r\n        if (options.lang === "html") {\r\n            options.html = true;\r\n            options.lang = "markup";\r\n        } else if (options.lang === "tss" || options.lang === "titanium") {\r\n            options.titanium = true;\r\n            options.lang     = "javscript";\r\n        }\r\n        if (options.qml === true) {\r\n            options.correct = false;\r\n            options.jsx     = false;\r\n        }\r\n        if (options.mode !== "beautify" && options.mode !== "diff" && options.endcomma === "multiline") {\r\n            options.endcomma = "never";\r\n        }\r\n        if (options.mode === "minify") {\r\n            if (options.wrap < 1) {\r\n                options.miniwrap = false;\r\n            } else if (options.miniwrap === false) {\r\n                options.wrap = -1;\r\n            }\r\n            options.correct = true;\r\n        } else if (options.jsscope !== "none") {\r\n            if (options.mode !== "beautify") {\r\n                options.jsscope = "none";\r\n            } else {\r\n                // wrap is disabled for jsscope because it can break HTML character entities in\r\n                // strings, which is fine in JS, but breaks things when rendered in the browser.\r\n                options.wrap = 0;\r\n            }\r\n        }\r\n\r\n        // old diff api\r\n        if (typeof options.baseTextLines === "string") {\r\n            options.source = options\r\n                .baseTextLines\r\n                .replace(options.functions.binaryCheck, "")\r\n                .replace(/\\r\\n?/g, "\\n");\r\n        }\r\n        if (typeof options.baseTextName === "string") {\r\n            options.sourcelabel = braceEscape(options.baseTextName);\r\n        }\r\n        if (typeof options.newTextLines === "string") {\r\n            options.diff = options\r\n                .newTextLines\r\n                .replace(options.functions.binaryCheck, "")\r\n                .replace(/\\r\\n?/g, "\\n");\r\n        }\r\n        if (typeof options.newTextName === "string") {\r\n            options.difflabel = braceEscape(options.newTextName);\r\n        }\r\n        if ((/^([0-9]+)$/).test(options.contextSize) === true) {\r\n            options.context = Number(options.contextSize);\r\n        }\r\n        if (typeof options.tchar === "string") {\r\n            options.inchar = options.tchar;\r\n        }\r\n        if ((/^([0-9]+)$/).test(options.tsize) === true) {\r\n            options.insize = Number(options.tsize);\r\n        }\r\n        //end old diff api\r\n\r\n        options\r\n            .functions\r\n            .pdcomment();\r\n        return options;\r\n    };\r\n    options.functions.domops        = function options_domops(id, value, commentString) {\r\n        var a    = 0,\r\n            data = [];\r\n        if (id === "adustno" || id === "bdustno" || id === "ddustno" || id === "mdustno" || id === "pdustno") {\r\n            data = ["dustjs", "false"];\r\n        } else if (id === "adustyes" || id === "bdustyes" || id === "ddustyes" || id === "mdustyes" || id === "pdustyes") {\r\n            data = ["dustjs", "true"];\r\n        } else if (id === "ahtml-no" || id === "htmld-no" || id === "html-no" || id === "htmlm-no" || id === "phtml-no") {\r\n            data = ["html", "false"];\r\n        } else if (id === "ahtml-no" || id === "htmld-yes" || id === "html-yes" || id === "htmlm-yes" || id === "phtml-yes") {\r\n            data = ["html", "true"];\r\n        } else if (id === "ajekyll-no" || id === "bjekyll-no" || id === "djekyll-no" || id === "mjekyll-no" || id === "pjekyll-no") {\r\n            data = ["jekyll", "false"];\r\n        } else if (id === "ajekyll-yes" || id === "bjekyll-yes" || id === "djekyll-yes" || id === "mjekyll-yes" || id === "pjekyll-yes") {\r\n            data = ["jekyll", "true"];\r\n        } else if (id === "attributetoken-no") {\r\n            data = ["attributetoken", "false"];\r\n        } else if (id === "attributetoken-yes") {\r\n            data = ["attributetoken", "true"];\r\n        } else if (id === "baselabel") {\r\n            data = ["sourcelabel", value];\r\n        } else if (id === "bbracestyle-collapse" || id === "dbracestyle-collapse") {\r\n            data = ["brace_style", "collapse"];\r\n        } else if (id === "bbracestyle-expand" || id === "dbracestyle-expand") {\r\n            data = ["brace_style", "expand"];\r\n        } else if (id === "bbracestyle-inline" || id === "dbracestyle-inline") {\r\n            data = ["brace_style", "collapse-preserve-inline"];\r\n        } else if (id === "bbracestyle-none" || id === "dbracestyle-none") {\r\n            data = ["brace_style", "none"];\r\n        } else if (id === "bbraceline-no" || id === "dbraceline-no") {\r\n            data = ["braceline", "false"];\r\n        } else if (id === "bbraceline-yes" || id === "dbraceline-yes") {\r\n            data = ["braceline", "true"];\r\n        } else if (id === "bbracepadding-no" || id === "dbracepadding-no") {\r\n            data = ["bracepadding", "false"];\r\n        } else if (id === "bbracepadding-yes" || id === "dbracepadding-yes") {\r\n            data = ["bracepadding", "true"];\r\n        } else if (id === "bcommline-no") {\r\n            data = ["commline", "false"];\r\n        } else if (id === "bcommline-yes") {\r\n            data = ["commline", "true"];\r\n        } else if (id === "bcompressedcss-no" || id === "dcompressedcss-no") {\r\n            data = ["compressedcss", "false"];\r\n        } else if (id === "bcompressedcss-yes" || id === "dcompressedcss-yes") {\r\n            data = ["compressedcss", "true"];\r\n        } else if (id === "beau-wrap" || id === "diff-wrap" || id === "mini-wrap") {\r\n            data = ["wrap", value];\r\n        } else if (id === "bendcomma-always" || id === "dendcomma-always") {\r\n            data = ["endcomma", "always"];\r\n        } else if (id === "bendcomma-multiline" || id === "dendcomma-multiline") {\r\n            data = ["endcomma", "multiline"];\r\n        } else if (id === "bendcomma-never" || id === "dendcomma-never") {\r\n            data = ["endcomma", "never"];\r\n        } else if (id === "bforce_attribute-no" || id === "dforce_attribute-no") {\r\n            data = ["force_attribute", "false"];\r\n        } else if (id === "bforce_attribute-yes" || id === "dforce_attribute-yes") {\r\n            data = ["force_attribute", "true"];\r\n        } else if (id === "bforce_indent-no" || id === "dforce_indent-no") {\r\n            data = ["force_indent", "false"];\r\n        } else if (id === "bforce_indent-yes" || id === "dforce_indent-yes") {\r\n            data = ["force_indent", "true"];\r\n        } else if (id === "bformatarray-default" || id === "dformatarray-default") {\r\n            data = ["formatArray", "default"];\r\n        } else if (id === "bformatarray-indent" || id === "dformatarray-indent") {\r\n            data = ["formatArray", "indent"];\r\n        } else if (id === "bformatarray-inline" || id === "dformatarray-inline") {\r\n            data = ["formatArray", "inline"];\r\n        } else if (id === "bformatobject-default" || id === "dformatobject-default") {\r\n            data = ["formatObject", "default"];\r\n        } else if (id === "bformatobject-indent" || id === "dformatobject-indent") {\r\n            data = ["formatObject", "indent"];\r\n        } else if (id === "bformatobject-inline" || id === "dformatobject-inline") {\r\n            data = ["formatObject", "inline"];\r\n        } else if (id === "bfunctionname-no" || id === "dfunctionname-no") {\r\n            data = ["functionname", "false"];\r\n        } else if (id === "bfunctionname-yes" || id === "dfunctionname-yes") {\r\n            data = ["functionname", "true"];\r\n        } else if (id === "bpreserve" || id === "dpreserve") {\r\n            data = ["preserve", value];\r\n        } else if (id === "bpreserveComment-false" || id === "dpreserveComment-false") {\r\n            data = ["preserveComment", "false"];\r\n        } else if (id === "bpreserveComment-true" || id === "dpreserveComment-true") {\r\n            data = ["preserveComment", "true"];\r\n        } else if (id === "bmethodchain-chain" || id === "dmethodchain-chain") {\r\n            data = ["methodchain", "chain"];\r\n        } else if (id === "bmethodchain-indent" || id === "dmethodchain-indent") {\r\n            data = ["methodchain", "indent"];\r\n        } else if (id === "bmethodchain-none" || id === "dmethodchain-none") {\r\n            data = ["methodchain", "none"];\r\n        } else if (id === "bnocaseindent-no" || id === "dnocaseindent-no") {\r\n            data = ["nocaseindent", "false"];\r\n        } else if (id === "bnocaseindent-yes" || id === "dnocaseindent-yes") {\r\n            data = ["nocaseindent", "true"];\r\n        } else if (id === "bnochainindent-no" || id === "dnochainindent-no") {\r\n            data = ["nochainindent", "false"];\r\n        } else if (id === "bnochainindent-yes" || id === "dnochainindent-yes") {\r\n            data = ["nochainindent", "true"];\r\n        } else if (id === "bnoleadzero-no") {\r\n            data = ["noleadzero", "false"];\r\n        } else if (id === "bnoleadzero-yes") {\r\n            data = ["noleadzero", "true"];\r\n        } else if (id === "bobjsort-all" || id === "dobjsort-all" || id === "mobjsort-all" || id === "pobjsort-all") {\r\n            data = ["objsort", "all"];\r\n        } else if (id === "bobjsort-cssonly" || id === "dobjsort-cssonly" || id === "mobjsort-cssonly" || id === "pobjsort-cssonly") {\r\n            data = ["objsort", "css"];\r\n        } else if (id === "bobjsort-jsonly" || id === "dobjsort-jsonly" || id === "mobjsort-jsonly" || id === "pobjsort-jsonly") {\r\n            data = ["objsort", "js"];\r\n        } else if (id === "bobjsort-markuponly" || id === "dobjsort-markuponly" || id === "mobjsort-markuponly" || id === "pobjsort-markuponly") {\r\n            data = ["objsort", "markup"];\r\n        } else if (id === "bobjsort-none" || id === "dobjsort-none" || id === "mobjsort-none" || id === "pobjsort-none") {\r\n            data = ["objsort", "none"];\r\n        } else if (id === "bquoteconvert-double" || id === "mquoteconvert-double") {\r\n            data = ["quoteConvert", "double"];\r\n        } else if (id === "bquoteconvert-none" || id === "mquoteconvert-none") {\r\n            data = ["quoteConvert", "none"];\r\n        } else if (id === "bquoteconvert-single" || id === "mquoteconvert-single") {\r\n            data = ["quoteConvert", "single"];\r\n        } else if (id === "bselectorlist-no" || id === "dselectorlist-no") {\r\n            data = ["selectorlist", "false"];\r\n        } else if (id === "bselectorlist-yes" || id === "dselectorlist-yes") {\r\n            data = ["selectorlist", "true"];\r\n        } else if (id === "bspaceclose-no") {\r\n            data = ["spaceclose", "false"];\r\n        } else if (id === "bspaceclose-yes") {\r\n            data = ["spaceclose", "true"];\r\n        } else if (id === "bstyleguide") {\r\n            if (value === "") {\r\n                data = ["styleguide", ""];\r\n            } else {\r\n                data = ["styleguide", value];\r\n            }\r\n        } else if (id === "btagmerge-no" || id === "dtagmerge-no" || id === "mtagmerge-no" || id === "ptagmerge-no") {\r\n            data = ["tagmerge", "false"];\r\n        } else if (id === "btagmerge-yes" || id === "dtagmerge-yes" || id === "mtagmerge-yes" || id === "ptagmerge-yes") {\r\n            data = ["tagmerge", "true"];\r\n        } else if (id === "btagsort-no" || id === "dtagsort-no" || id === "mtagsort-no" || id === "ptagsort-no") {\r\n            data = ["tagsort", "false"];\r\n        } else if (id === "btagsort-yes" || id === "dtagsort-yes" || id === "mtagsort-yes" || id === "ptagsort-yes") {\r\n            data = ["tagsort", "true"];\r\n        } else if (id === "bternaryline-no" || id === "dternaryline-no") {\r\n            data = ["ternaryline", "false"];\r\n        } else if (id === "bternaryline-yes" || id === "dternaryline-yes") {\r\n            data = ["ternaryline", "true"];\r\n        } else if (id === "btextpreserveno" || id === "dtextpreserveno" || id === "mtextpreserveno" || id === "ptextpreserveno") {\r\n            data = ["textpreserve", "false"];\r\n        } else if (id === "btextpreserveyes" || id === "dtextpreserveyes" || id === "mtextpreserveyes" || id === "ptextpreserveyes") {\r\n            data = ["textpreserve", "true"];\r\n        } else if (id === "bunformatted-no" || id === "dunformatted-no" || id === "munformatted-no" || id === "punformatted-no") {\r\n            data = ["unformatted", "false"];\r\n        } else if (id === "bunformatted-yes" || id === "dunformatted-yes" || id === "munformatted-yes" || id === "punformatted-yes") {\r\n            data = ["unformatted", "true"];\r\n        } else if (id === "bvarword-each" || id === "dvarword-each" || id === "mvarword-each" || id === "pvarword-each") {\r\n            data = ["varword", "each"];\r\n        } else if (id === "bvarword-list" || id === "dvarword-list" || id === "mvarword-list" || id === "pvarword-list") {\r\n            data = ["varword", "list"];\r\n        } else if (id === "bvarword-none" || id === "dvarword-none" || id === "mvarword-none" || id === "pvarword-none") {\r\n            data = ["varword", "none"];\r\n        } else if (id === "conditionald-no" || id === "conditionalm-no") {\r\n            data = ["conditional", "false"];\r\n        } else if (id === "conditionald-yes" || id === "conditionalm-yes") {\r\n            data = ["conditional", "true"];\r\n        } else if (id === "contextSize") {\r\n            data = ["context", value];\r\n        } else if (id === "csvchar") {\r\n            data = ["csvchar", value];\r\n        } else if (id === "cssinsertlines-no") {\r\n            data = ["cssinsertlines", "false"];\r\n        } else if (id === "cssinsertlines-yes") {\r\n            data = ["cssinsertlines", "true"];\r\n        } else if (id === "diff-char" || id === "beau-char") {\r\n            data = ["inchar", value];\r\n        } else if (id === "diff-line" || id === "beau-line") {\r\n            data = ["inchar", "\\n"];\r\n        } else if (id === "diff-quan" || id === "beau-quan" || id === "minn-quan") {\r\n            data = ["insize", value];\r\n        } else if (id === "diff-space" || id === "beau-space") {\r\n            data = ["inchar", " "];\r\n        } else if (id === "diff-tab" || id === "beau-tab") {\r\n            data = ["inchar", "\\t"];\r\n        } else if (id === "diffcontent") {\r\n            data = ["content", "true"];\r\n        } else if (id === "diffcontenty") {\r\n            data = ["content", "false"];\r\n        } else if (id === "diffcli-false") {\r\n            data = ["diffcli", "false"];\r\n        } else if (id === "diffcli-true") {\r\n            data = ["diffcli", "true"];\r\n        } else if (id === "diffcommentsn") {\r\n            data = ["diffcomments", "false"];\r\n        } else if (id === "diffcommentsy") {\r\n            data = ["diffcomments", "true"];\r\n        } else if (id === "difflabel") {\r\n            data = ["difflabel", value];\r\n        } else if (id === "diffscolon") {\r\n            data = ["semicolon", "true"];\r\n        } else if (id === "diffscolony") {\r\n            data = ["semicolon", "false"];\r\n        } else if (id === "diffspaceignoren") {\r\n            data = ["diffspaceignore", "false"];\r\n        } else if (id === "diffspaceignorey") {\r\n            data = ["diffspaceignore", "true"];\r\n        } else if (id === "incomment-no") {\r\n            data = ["comments", "noindent"];\r\n        } else if (id === "incomment-yes") {\r\n            data = ["comments", "indent"];\r\n        } else if (id === "inline") {\r\n            data = ["diffview", "inline"];\r\n        } else if (id === "inlevel") {\r\n            data = ["inlevel", value];\r\n        } else if (id === "inscriptd-no" || id === "inscript-no") {\r\n            data = ["style", "noindent"];\r\n        } else if (id === "inscriptd-yes" || id === "inscript-yes") {\r\n            data = ["style", "indent"];\r\n        } else if (id === "jscorrect-no" || id === "mjscorrect-no") {\r\n            data = ["correct", "false"];\r\n        } else if (id === "jscorrect-yes" || id === "mjscorrect-yes") {\r\n            data = ["correct", "true"];\r\n        } else if (id === "jselseline-no") {\r\n            data = ["elseline", "false"];\r\n        } else if (id === "jselseline-yes") {\r\n            data = ["elseline", "true"];\r\n        } else if (id === "jsindentd-all" || id === "jsindent-all") {\r\n            data = ["indent", "allman"];\r\n        } else if (id === "jsindentd-knr" || id === "jsindent-knr") {\r\n            data = ["indent", "knr"];\r\n        } else if (id === "jsscope-html") {\r\n            data = ["jsscope", "true"];\r\n        } else if (id === "jsscope-no") {\r\n            data = ["jsscope", "none"];\r\n        } else if (id === "jsscope-yes") {\r\n            data = ["jsscope", "html"];\r\n        } else if (id === "jsscope-html") {\r\n            data = ["jsscope", "report"];\r\n        } else if (id === "jsspaced-no" || id === "jsspace-no") {\r\n            data = ["jsspace", "false"];\r\n        } else if (id === "jsspaced-yes" || id === "jsspace-yes") {\r\n            data = ["jsspace", "true"];\r\n        } else if (id === "language") {\r\n            data = ["lang", value];\r\n        } else if (id === "lang-default") {\r\n            data = ["langdefault", value];\r\n        } else if (id === "langauge") {\r\n            data = ["lang", value];\r\n        } else if (id === "lterminator-crlf") {\r\n            data = ["crlf", "true"];\r\n        } else if (id === "lterminator-lf") {\r\n            data = ["crlf", "false"];\r\n        } else if (id === "miniwrapm-no") {\r\n            data = ["miniwrap", "false"];\r\n        } else if (id === "miniwrapm-yes") {\r\n            data = ["miniwrap", "true"];\r\n        } else if (id === "modeanalysis") {\r\n            data = ["mode", "analysis"];\r\n        } else if (id === "modebeautify") {\r\n            data = ["mode", "beautify"];\r\n        } else if (id === "modediff") {\r\n            data = ["mode", "diff"];\r\n        } else if (id === "modeminify") {\r\n            data = ["mode", "minify"];\r\n        } else if (id === "modeparse") {\r\n            data = ["mode", "parse"];\r\n        } else if (id === "newline-no") {\r\n            data = ["newline", "false"];\r\n        } else if (id === "newline-yes") {\r\n            data = ["newline", "true"];\r\n        } else if (id === "parseFormat-htmltable") {\r\n            data = ["parseFormat", "htmltable"];\r\n        } else if (id === "parseFormat-parallel") {\r\n            data = ["parseFormat", "parallel"];\r\n        } else if (id === "parseFormat-sequential") {\r\n            data = ["parseFormat", "sequential"];\r\n        } else if (id === "parsespace-no") {\r\n            data = ["parseSpace", "false"];\r\n        } else if (id === "parsespace-yes") {\r\n            data = ["parseSpace", "true"];\r\n        } else if (id === "sidebyside") {\r\n            data = ["diffview", "sidebyside"];\r\n        } else if (id === "topcoms-yes") {\r\n            data = ["topcoms", "true"];\r\n        } else if (id === "topcoms-no") {\r\n            data = ["topcoms", "false"];\r\n        } else if (id === "vertical-all") {\r\n            data = ["vertical", "all"];\r\n        } else if (id === "vertical-cssonly") {\r\n            data = ["vertical", "css"];\r\n        } else if (id === "vertical-jsonly") {\r\n            data = ["vertical", "js"];\r\n        } else if (id === "vertical-none") {\r\n            data = ["vertical", "none"];\r\n        }\r\n        if (data.length === 0) {\r\n            return commentString;\r\n        }\r\n        if (data[1] !== "true" && data[1] !== "false") {\r\n            data[1] = "\\"" + data[1] + "\\"";\r\n        }\r\n        for (a = commentString.length - 1; a > -1; a = a - 1) {\r\n            if (commentString[a].indexOf(data[0]) > -1) {\r\n                commentString[a] = data.join(": ");\r\n                break;\r\n            }\r\n        }\r\n        if (a < 0) {\r\n            commentString.push(data.join(": "));\r\n            commentString.sort();\r\n        }\r\n        return commentString;\r\n    };\r\n    options.functions.node          = function options_node(a) {\r\n        var b        = 0,\r\n            c        = a.length,\r\n            d        = [],\r\n            e        = [],\r\n            f        = 0,\r\n            opts     = {},\r\n            help     = false,\r\n            langauto = true;\r\n        for (b = 0; b < c; b = b + 1) {\r\n            e = [];\r\n            f = a[b].indexOf(":");\r\n            e.push(a[b].substring(0, f).replace(/(\\s+)$/, ""));\r\n            e.push(a[b].substring(f + 1).replace(/^(\\s+)/, ""));\r\n            d.push(e);\r\n        }\r\n        c = d.length;\r\n        for (b = 0; b < c; b = b + 1) {\r\n            if (d[b].length === 2) {\r\n                opts[d[b][0]] = d[b][1];\r\n                if (d[b][0] === "lang" && d[b][1] !== "auto") {\r\n                    langauto = false;\r\n                }\r\n            } else {\r\n                if (d[b] === "help" || d[b][0] === "help" || d[b][0] === "man" || d[b][0] === "manual") {\r\n                    help = true;\r\n                } else if (d[b] === "v" || d[b] === "version" || d[b][0] === "v" || d[b][0] === "version") {\r\n                    options.version = true;\r\n                } else if (d[b] === "l" || d[b] === "list" || d[b][0] === "l" || d[b][0] === "list") {\r\n                    options.listoptions = true;\r\n                }\r\n            }\r\n        }\r\n        if (Object.keys(opts).length < 2) {\r\n            help = true;\r\n        }\r\n        options.functions.nodeArgs = opts;\r\n        options\r\n            .functions\r\n            .validate(opts);\r\n        return [help, langauto];\r\n    };\r\n    options.functions.binaryCheck   = (\r\n        /\\u0000|\\u0001|\\u0002|\\u0003|\\u0004|\\u0005|\\u0006|\\u0007|\\u000b|\\u000e|\\u000f|\\u0010|\\u0011|\\u0012|\\u0013|\\u0014|\\u0015|\\u0016|\\u0017|\\u0018|\\u0019|\\u001a|\\u001c|\\u001d|\\u001e|\\u001f|\\u007f|\\u0080|\\u0081|\\u0082|\\u0083|\\u0084|\\u0085|\\u0086|\\u0087|\\u0088|\\u0089|\\u008a|\\u008b|\\u008c|\\u008d|\\u008e|\\u008f|\\u0090|\\u0091|\\u0092|\\u0093|\\u0094|\\u0095|\\u0096|\\u0097|\\u0098|\\u0099|\\u009a|\\u009b|\\u009c|\\u009d|\\u009e|\\u009f/g\r\n    );\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function options_requirejs() {\r\n            return global.prettydiff.options;\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = global.prettydiff.options;\r\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n            (function glib_options() {\r\n                var localPath = (\r\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\r\n                )\r\n                    ? __dirname\r\n                    : ".";\r\n                if (global.prettydiff.language === undefined) {\r\n                    global.prettydiff.language = require(\r\n                        localPath + "/lib/language.js"\r\n                    );\r\n                }\r\n            }());\r\n        }\r\n    } \r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(34))},function(n,e){n.exports='/*global ace, define, global, module*/\r\n(function finalFile_init() {\r\n    "use strict";\r\n    var finalFile = {\r\n        css   : {\r\n            color  : {\r\n                canvas: "#prettydiff.canvas{background:#986 url(\\"data:image/png;base64,iVBORw0KGgoAAAA" +\r\n                        "NSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob" +\r\n                        "3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcE" +\r\n                        "RRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRN" +\r\n                        "YAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQpl" +\r\n                        "cAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVA" +\r\n                        "aCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGD" +\r\n                        "IIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBN" +\r\n                        "A/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qI" +\r\n                        "l7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14" +\r\n                        "L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcU" +\r\n                        "l0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZ" +\r\n                        "kmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQii" +\r\n                        "GzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIB" +\r\n                        "BKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogv" +\r\n                        "QZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu" +\r\n                        "4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1h" +\r\n                        "ILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkn" +\r\n                        "eTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR" +\r\n                        "1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3G" +\r\n                        "K+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZ" +\r\n                        "VM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq" +\r\n                        "4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y" +\r\n                        "0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1r" +\r\n                        "i6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8f" +\r\n                        "b8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx" +\r\n                        "83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1ru" +\r\n                        "tu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdW" +\r\n                        "h1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lps" +\r\n                        "bxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ" +\r\n                        "0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r" +\r\n                        "/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pD" +\r\n                        "oVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo" +\r\n                        "3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZAT" +\r\n                        "IhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLx" +\r\n                        "MDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2Q" +\r\n                        "qboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxeds" +\r\n                        "K4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGn" +\r\n                        "Rs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO3" +\r\n                        "19kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +\r\n                        "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3" +\r\n                        "vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3" +\r\n                        "nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDv" +\r\n                        "OXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeO" +\r\n                        "T3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYP" +\r\n                        "P/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/b" +\r\n                        "Xyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GM" +\r\n                        "zLdsAAEFdaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9I" +\r\n                        "lc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1" +\r\n                        "ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvM" +\r\n                        "jAtMDk6NTM6MDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5" +\r\n                        "vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmO" +\r\n                        "mFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4" +\r\n                        "wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tb" +\r\n                        "S8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R" +\r\n                        "5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvY" +\r\n                        "mUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR" +\r\n                        "0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvc" +\r\n                        "D0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGl" +\r\n                        "mZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9I" +\r\n                        "mh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5" +\r\n                        "BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgI" +\r\n                        "CAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxMjoyNDozOC0wNjowMDwveG1wOkNyZWF0ZUR" +\r\n                        "hdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTYtMDEtMTNUMTM6MTg6MDctMDY6MDA8L" +\r\n                        "3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE2LTAxLTEzVDEzOjE" +\r\n                        "4OjA3LTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wL" +\r\n                        "mlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5OS1iYjM5NjA0MDVhOWQ8L3htcE1NOkluc3RhbmNlSUQ" +\r\n                        "+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDoxYzM3NjE4M" +\r\n                        "S1mOWU4LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx" +\r\n                        "4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZjA3LTQ5ZDEtOWIwZC02O" +\r\n                        "DEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3R" +\r\n                        "vcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZ" +\r\n                        "VR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9" +\r\n                        "zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6N" +\r\n                        "mIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZUlEPgogICA" +\r\n                        "gICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2d" +\r\n                        "Dp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3N" +\r\n                        "ob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgI" +\r\n                        "CAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2U" +\r\n                        "iPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +\r\n                        "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ" +\r\n                        "3LThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c" +\r\n                        "3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICA" +\r\n                        "gICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFja" +\r\n                        "W50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5" +\r\n                        "nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgI" +\r\n                        "CAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3R" +\r\n                        "FdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0O" +\r\n                        "nBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9" +\r\n                        "iZS5waG90b3Nob3A8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogI" +\r\n                        "CAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICA" +\r\n                        "gICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgI" +\r\n                        "CA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWR" +\r\n                        "mMzVhMTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxN" +\r\n                        "i0wMS0xM1QxMzoxMzoyMy0wNjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ" +\r\n                        "0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0O" +\r\n                        "nNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmN" +\r\n                        "oYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZ" +\r\n                        "jpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5kZXJ" +\r\n                        "pdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpwYXJhbWV0ZXJzPmNvb" +\r\n                        "nZlcnRlZCBmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nPC9" +\r\n                        "zdEV2dDpwYXJhbWV0ZXJzPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgP" +\r\n                        "HJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp" +\r\n                        "hY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3Rhb" +\r\n                        "mNlSUQ+eG1wLmlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5OS1iYjM5NjA0MDVhOWQ8L3N0RXZ0Oml" +\r\n                        "uc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMDEtMTNUMTM6MTg6M" +\r\n                        "DctMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW5" +\r\n                        "0PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zdEV2dDpzb2Z0d2FyZUFnZW50P" +\r\n                        "gogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICA" +\r\n                        "gICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NO" +\r\n                        "khpc3Rvcnk+CiAgICAgICAgIDx4bXBNTTpEZXJpdmVkRnJvbSByZGY6cGFyc2VUeXBlPSJSZXNvdXJ" +\r\n                        "jZSI+CiAgICAgICAgICAgIDxzdFJlZjppbnN0YW5jZUlEPnhtcC5paWQ6ODNhNzkwYWQtYzBlZC00Y" +\r\n                        "jNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjppbnN0YW5jZUlEPgogICAgICAgICAgICA8c3RSZWY" +\r\n                        "6ZG9jdW1lbnRJRD54bXAuZGlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWRmMzVhMTwvc" +\r\n                        "3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXA" +\r\n                        "uZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjBkLTY4MTMxMWQ3NDAzMTwvc3RSZWY6b3JpZ2luYWxEb" +\r\n                        "2N1bWVudElEPgogICAgICAgICA8L3htcE1NOkRlcml2ZWRGcm9tPgogICAgICAgICA8ZGM6Zm9ybWF" +\r\n                        "0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9wa" +\r\n                        "G90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOklDQ1Byb2ZpbGU+c1JHQiBJRUM" +\r\n                        "2MTk2Ni0yLjE8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvb" +\r\n                        "j4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj4zMDAwMDAwLzE" +\r\n                        "wMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj4zMDAwMDAwL" +\r\n                        "zEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC9" +\r\n                        "0aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb" +\r\n                        "3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjQ8L2V4aWY6UGl4ZWxYRGltZW5" +\r\n                        "zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFlEaW1lbnNpb" +\r\n                        "24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +\r\n                        "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWN" +\r\n                        "rZXQgZW5kPSJ3Ij8+bleIyQAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX" +\r\n                        "8VGAAAANElEQVR42mJ89+4uAwMDAwPD6lkTGd69u/vu3d2ZHXnv3t1lgLPevbvLrCTIEJqWD1EJGAD" +\r\n                        "aTRll80WcLAAAAABJRU5ErkJggg==\\");color:#420}#prettydiff.canvas *:focus{outline" +\r\n                        ":0.1em dashed #f00}#prettydiff.canvas a{color:#039}#prettydiff.canvas .content" +\r\n                        "area,#prettydiff.canvas legend,#prettydiff.canvas fieldset select,#prettydiff." +\r\n                        "canvas .diff td,#prettydiff.canvas .report td,#prettydiff.canvas .data li,#pre" +\r\n                        "ttydiff.canvas .diff-right,#prettydiff.canvas fieldset input{background:#eeeee" +\r\n                        "8;border-color:#420}#prettydiff.canvas select,#prettydiff.canvas input,#pretty" +\r\n                        "diff.canvas .diff,#prettydiff.canvas .beautify,#prettydiff.canvas .report,#pre" +\r\n                        "ttydiff.canvas .beautify h3,#prettydiff.canvas .diff h3,#prettydiff.canvas .be" +\r\n                        "autify h4,#prettydiff.canvas .diff h4,#prettydiff.canvas #report,#prettydiff.c" +\r\n                        "anvas #report .author,#prettydiff.canvas fieldset{background:#ddddd8;border-co" +\r\n                        "lor:#420}#prettydiff.canvas fieldset fieldset{background:#eeeee8}#prettydiff.c" +\r\n                        "anvas fieldset fieldset input,#prettydiff.canvas fieldset fieldset select{back" +\r\n                        "ground:#ddddd8}#prettydiff.canvas h2,#prettydiff.canvas h2 button,#prettydiff." +\r\n                        "canvas h3,#prettydiff.canvas legend{color:#900}#prettydiff.canvas .contentarea" +\r\n                        "{box-shadow:0 1em 1em #b8a899}#prettydiff.canvas .segment{background:#fff}#pre" +\r\n                        "ttydiff.canvas h2 button,#prettydiff.canvas .segment,#prettydiff.canvas ol.seg" +\r\n                        "ment li{border-color:#420}#prettydiff.canvas th{background:#e8ddcc}#prettydiff" +\r\n                        ".canvas li h4{color:#06f}#prettydiff.canvas code{background:#eee;border-color:" +\r\n                        "#eee;color:#00f}#prettydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff" +\r\n                        ".canvas button{background-color:#ddddd8;border-color:#420;box-shadow:0 0.25em " +\r\n                        "0.5em #b8a899;color:#900}#prettydiff.canvas button:hover{background-color:#ccb" +\r\n                        ";border-color:#630;box-shadow:0 0.25em 0.5em #b8a899;color:#630}#prettydiff.ca" +\r\n                        "nvas th{background:#ccccc8}#prettydiff.canvas thead th,#prettydiff.canvas th.h" +\r\n                        "eading{background:#ccb}#prettydiff.canvas .diff h3{background:#ddd;border-colo" +\r\n                        "r:#999}#prettydiff.canvas td,#prettydiff.canvas th,#prettydiff.canvas .segment" +\r\n                        ",#prettydiff.canvas .count li,#prettydiff.canvas .data li,#prettydiff.canvas ." +\r\n                        "diff-right{border-color:#ccccc8}#prettydiff.canvas .count{background:#eed;bord" +\r\n                        "er-color:#999}#prettydiff.canvas .count li.fold{color:#900}#prettydiff.canvas " +\r\n                        "h2 button{background:#f8f8f8;box-shadow:0.1em 0.1em 0.25em #ddd}#prettydiff.ca" +\r\n                        "nvas li h4{color:#00f}#prettydiff.canvas code{background:#eee;border-color:#ee" +\r\n                        "e;color:#009}#prettydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff.ca" +\r\n                        "nvas .data .delete{background:#ffd8d8}#prettydiff.canvas .data .delete em{back" +\r\n                        "ground:#fff8f8;border-color:#c44;color:#900}#prettydiff.canvas .data .insert{b" +\r\n                        "ackground:#d8ffd8}#prettydiff.canvas .data .insert em{background:#f8fff8;borde" +\r\n                        "r-color:#090;color:#363}#prettydiff.canvas .data .replace{background:#fec}#pre" +\r\n                        "ttydiff.canvas .data .replace em{background:#ffe;border-color:#a86;color:#852}" +\r\n                        "#prettydiff.canvas .data .empty{background:#ddd}#prettydiff.canvas .data em.s0" +\r\n                        "{color:#000}#prettydiff.canvas .data em.s1{color:#f66}#prettydiff.canvas .data" +\r\n                        " em.s2{color:#12f}#prettydiff.canvas .data em.s3{color:#090}#prettydiff.canvas" +\r\n                        " .data em.s4{color:#d6d}#prettydiff.canvas .data em.s5{color:#7cc}#prettydiff." +\r\n                        "canvas .data em.s6{color:#c85}#prettydiff.canvas .data em.s7{color:#737}#prett" +\r\n                        "ydiff.canvas .data em.s8{color:#6d0}#prettydiff.canvas .data em.s9{color:#dd0}" +\r\n                        "#prettydiff.canvas .data em.s10{color:#893}#prettydiff.canvas .data em.s11{col" +\r\n                        "or:#b97}#prettydiff.canvas .data em.s12{color:#bbb}#prettydiff.canvas .data em" +\r\n                        ".s13{color:#cc3}#prettydiff.canvas .data em.s14{color:#333}#prettydiff.canvas " +\r\n                        ".data em.s15{color:#9d9}#prettydiff.canvas .data em.s16{color:#880}#prettydiff" +\r\n                        ".canvas .data .l0{background:#eeeee8}#prettydiff.canvas .data .l1{background:#" +\r\n                        "fed}#prettydiff.canvas .data .l2{background:#def}#prettydiff.canvas .data .l3{" +\r\n                        "background:#efe}#prettydiff.canvas .data .l4{background:#fef}#prettydiff.canva" +\r\n                        "s .data .l5{background:#eef}#prettydiff.canvas .data .l6{background:#fff8cc}#p" +\r\n                        "rettydiff.canvas .data .l7{background:#ede}#prettydiff.canvas .data .l8{backgr" +\r\n                        "ound:#efc}#prettydiff.canvas .data .l9{background:#ffd}#prettydiff.canvas .dat" +\r\n                        "a .l10{background:#edc}#prettydiff.canvas .data .l11{background:#fdb}#prettydi" +\r\n                        "ff.canvas .data .l12{background:#f8f8f8}#prettydiff.canvas .data .l13{backgrou" +\r\n                        "nd:#ffb}#prettydiff.canvas .data .l14{background:#eec}#prettydiff.canvas .data" +\r\n                        " .l15{background:#cfc}#prettydiff.canvas .data .l16{background:#eea}#prettydif" +\r\n                        "f.canvas .data .c0{background:inherit}#prettydiff.canvas #report p em{color:#0" +\r\n                        "60}#prettydiff.canvas #report p strong{color:#009}",\r\n                shadow: "#prettydiff.shadow{background:#333 url(\\"data:image/png;base64,iVBORw0KGgoAAAA" +\r\n                        "NSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob" +\r\n                        "3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcE" +\r\n                        "RRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRN" +\r\n                        "YAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQpl" +\r\n                        "cAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVA" +\r\n                        "aCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGD" +\r\n                        "IIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBN" +\r\n                        "A/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qI" +\r\n                        "l7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14" +\r\n                        "L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcU" +\r\n                        "l0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZ" +\r\n                        "kmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQii" +\r\n                        "GzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIB" +\r\n                        "BKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogv" +\r\n                        "QZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu" +\r\n                        "4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1h" +\r\n                        "ILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkn" +\r\n                        "eTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR" +\r\n                        "1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3G" +\r\n                        "K+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZ" +\r\n                        "VM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq" +\r\n                        "4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y" +\r\n                        "0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1r" +\r\n                        "i6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8f" +\r\n                        "b8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx" +\r\n                        "83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1ru" +\r\n                        "tu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdW" +\r\n                        "h1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lps" +\r\n                        "bxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ" +\r\n                        "0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r" +\r\n                        "/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pD" +\r\n                        "oVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo" +\r\n                        "3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZAT" +\r\n                        "IhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLx" +\r\n                        "MDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2Q" +\r\n                        "qboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxeds" +\r\n                        "K4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGn" +\r\n                        "Rs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO3" +\r\n                        "19kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +\r\n                        "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3" +\r\n                        "vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3" +\r\n                        "nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDv" +\r\n                        "OXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeO" +\r\n                        "T3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYP" +\r\n                        "P/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/b" +\r\n                        "Xyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GM" +\r\n                        "zLdsAAEQFaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9I" +\r\n                        "lc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1" +\r\n                        "ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvM" +\r\n                        "jAtMDk6NTM6MDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5" +\r\n                        "vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmO" +\r\n                        "mFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4" +\r\n                        "wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tb" +\r\n                        "S8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R" +\r\n                        "5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvY" +\r\n                        "mUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR" +\r\n                        "0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvc" +\r\n                        "D0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGl" +\r\n                        "mZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9I" +\r\n                        "mh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5" +\r\n                        "BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgI" +\r\n                        "CAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxMjoyNDozOC0wNjowMDwveG1wOkNyZWF0ZUR" +\r\n                        "hdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTYtMDEtMTNUMTU6MTE6MzMtMDY6MDA8L" +\r\n                        "3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE2LTAxLTEzVDE1OjE" +\r\n                        "xOjMzLTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wL" +\r\n                        "mlpZDo4MDAwYTE3Zi1jZTY1LTQ5NTUtYjFmMS05YjVkODIwNDIyNjU8L3htcE1NOkluc3RhbmNlSUQ" +\r\n                        "+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDoxZmZhNDk1Y" +\r\n                        "y1mYTU2LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx" +\r\n                        "4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZjA3LTQ5ZDEtOWIwZC02O" +\r\n                        "DEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3R" +\r\n                        "vcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZ" +\r\n                        "VR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9" +\r\n                        "zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6N" +\r\n                        "mIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZUlEPgogICA" +\r\n                        "gICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2d" +\r\n                        "Dp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3N" +\r\n                        "ob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgI" +\r\n                        "CAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2U" +\r\n                        "iPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +\r\n                        "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ" +\r\n                        "3LThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c" +\r\n                        "3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICA" +\r\n                        "gICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFja" +\r\n                        "W50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5" +\r\n                        "nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgI" +\r\n                        "CAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3R" +\r\n                        "FdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0O" +\r\n                        "nBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9" +\r\n                        "iZS5waG90b3Nob3A8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogI" +\r\n                        "CAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICA" +\r\n                        "gICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgI" +\r\n                        "CA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWR" +\r\n                        "mMzVhMTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxN" +\r\n                        "i0wMS0xM1QxMzoxMzoyMy0wNjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ" +\r\n                        "0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0O" +\r\n                        "nNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmN" +\r\n                        "oYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZ" +\r\n                        "jpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZ" +\r\n                        "lZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAua" +\r\n                        "WlkOjA0ZGYyNDk5LWE1NTktNDE4MC1iNjA1LWI2MTk3MWMxNWEwMzwvc3RFdnQ6aW5zdGFuY2VJRD4" +\r\n                        "KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc" +\r\n                        "3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGh" +\r\n                        "vdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgI" +\r\n                        "CAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDw" +\r\n                        "vcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KI" +\r\n                        "CAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICA" +\r\n                        "gICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvY" +\r\n                        "mUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICA" +\r\n                        "gPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiP" +\r\n                        "gogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICA" +\r\n                        "gICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb" +\r\n                        "24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICA" +\r\n                        "gICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9I" +\r\n                        "lJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN" +\r\n                        "0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgwMDBhMTdmL" +\r\n                        "WNlNjUtNDk1NS1iMWYxLTliNWQ4MjA0MjI2NTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICA" +\r\n                        "gICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc3RFdnQ6d2hlbj4KI" +\r\n                        "CAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDI" +\r\n                        "wMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzd" +\r\n                        "EV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICA" +\r\n                        "gICAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHhtc" +\r\n                        "E1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmV" +\r\n                        "mOmluc3RhbmNlSUQ+eG1wLmlpZDowNGRmMjQ5OS1hNTU5LTQxODAtYjYwNS1iNjE5NzFjMTVhMDM8L" +\r\n                        "3N0UmVmOmluc3RhbmNlSUQ+CiAgICAgICAgICAgIDxzdFJlZjpkb2N1bWVudElEPnhtcC5kaWQ6ODN" +\r\n                        "hNzkwYWQtYzBlZC00YjNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjpkb2N1bWVudElEPgogICAgI" +\r\n                        "CAgICAgICA8c3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NmIyNGUyN2EtY2YwNy00OWQ" +\r\n                        "xLTliMGQtNjgxMzExZDc0MDMxPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwve" +\r\n                        "G1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ" +\r\n                        "+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgI" +\r\n                        "CAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOkl" +\r\n                        "DQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+C" +\r\n                        "iAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24" +\r\n                        "+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb" +\r\n                        "24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiA" +\r\n                        "gICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZ" +\r\n                        "jpQaXhlbFhEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlB" +\r\n                        "peGVsWURpbWVuc2lvbj40PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3Jpc" +\r\n                        "HRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +\r\n                        "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5hSvvCAAAAIGN" +\r\n                        "IUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAlSURBVHjaPMYxAQAwDAMgV" +\r\n                        "kv1VFFRuy9cvN0F7m66JNNhOvwBAPyqCtNeO5K2AAAAAElFTkSuQmCC\\");color:#fff}#prettyd" +\r\n                        "iff.shadow *:focus{outline:0.1em dashed #ff0}#prettydiff.shadow a:visited{colo" +\r\n                        "r:#f93}#prettydiff.shadow a{color:#cf3}#prettydiff.shadow .contentarea,#pretty" +\r\n                        "diff.shadow legend,#prettydiff.shadow fieldset select,#prettydiff.shadow .diff" +\r\n                        " td,#prettydiff.shadow .report td,#prettydiff.shadow .data li,#prettydiff.shad" +\r\n                        "ow .diff-right,#prettydiff.shadow fieldset input{background:#333;border-color:" +\r\n                        "#666}#prettydiff.shadow select,#prettydiff.shadow input,#prettydiff.shadow .di" +\r\n                        "ff,#prettydiff.shadow .beautify,#prettydiff.shadow .report,#prettydiff.shadow " +\r\n                        ".beautify h3,#prettydiff.shadow .diff h3,#prettydiff.shadow .beautify h4,#pret" +\r\n                        "tydiff.shadow .diff h4,#prettydiff.shadow #report,#prettydiff.shadow #report ." +\r\n                        "author,#prettydiff.shadow fieldset{background:#222;border-color:#666}#prettydi" +\r\n                        "ff.shadow fieldset fieldset{background:#333}#prettydiff.shadow fieldset fields" +\r\n                        "et input,#prettydiff.shadow fieldset fieldset select{background:#222}#prettydi" +\r\n                        "ff.shadow h2,#prettydiff.shadow h2 button,#prettydiff.shadow h3,#prettydiff.sh" +\r\n                        "adow input,#prettydiff.shadow option,#prettydiff.shadow select,#prettydiff.sha" +\r\n                        "dow legend{color:#ccc}#prettydiff.shadow .contentarea{box-shadow:0 1em 1em #00" +\r\n                        "0}#prettydiff.shadow .segment{background:#222}#prettydiff.shadow h2 button,#pr" +\r\n                        "ettydiff.shadow td,#prettydiff.shadow th,#prettydiff.shadow .segment,#prettydi" +\r\n                        "ff.shadow ol.segment li{border-color:#666}#prettydiff.shadow .count li.fold{co" +\r\n                        "lor:#cf3}#prettydiff.shadow th{background:#000}#prettydiff.shadow h2 button{ba" +\r\n                        "ckground:#585858;box-shadow:0.1em 0.1em 0.25em #000}#prettydiff.shadow li h4{c" +\r\n                        "olor:#ff0}#prettydiff.shadow code{background:#585858;border-color:#585858;colo" +\r\n                        "r:#ccf}#prettydiff.shadow ol.segment h4 strong{color:#f30}#prettydiff.shadow b" +\r\n                        "utton{background-color:#333;border-color:#666;box-shadow:0 0.25em 0.5em #000;c" +\r\n                        "olor:#ccc}#prettydiff.shadow button:hover{background-color:#777;border-color:#" +\r\n                        "aaa;box-shadow:0 0.25em 0.5em #222;color:#fff}#prettydiff.shadow th{background" +\r\n                        ":#444}#prettydiff.shadow thead th,#prettydiff.shadow th.heading{background:#44" +\r\n                        "4}#prettydiff.shadow .diff h3{background:#000;border-color:#666}#prettydiff.sh" +\r\n                        "adow .segment,#prettydiff.shadow .data li,#prettydiff.shadow .diff-right{borde" +\r\n                        "r-color:#444}#prettydiff.shadow .count li{border-color:#333}#prettydiff.shadow" +\r\n                        " .count{background:#555;border-color:#333}#prettydiff.shadow li h4{color:#ff0}" +\r\n                        "#prettydiff.shadow code{background:#000;border-color:#000;color:#ddd}#prettydi" +\r\n                        "ff.shadow ol.segment h4 strong{color:#c00}#prettydiff.shadow .data .delete{bac" +\r\n                        "kground:#300}#prettydiff.shadow .data .delete em{background:#200;border-color:" +\r\n                        "#c63;color:#c66}#prettydiff.shadow .data .insert{background:#030}#prettydiff.s" +\r\n                        "hadow .data .insert em{background:#010;border-color:#090;color:#6c0}#prettydif" +\r\n                        "f.shadow .data .replace{background:#345}#prettydiff.shadow .data .replace em{b" +\r\n                        "ackground:#023;border-color:#09c;color:#7cf}#prettydiff.shadow .data .empty{ba" +\r\n                        "ckground:#111}#prettydiff.shadow .diff .author{border-color:#666}#prettydiff.s" +\r\n                        "hadow .data em.s0{color:#fff}#prettydiff.shadow .data em.s1{color:#d60}#pretty" +\r\n                        "diff.shadow .data em.s2{color:#aaf}#prettydiff.shadow .data em.s3{color:#0c0}#" +\r\n                        "prettydiff.shadow .data em.s4{color:#f6f}#prettydiff.shadow .data em.s5{color:" +\r\n                        "#0cc}#prettydiff.shadow .data em.s6{color:#dc3}#prettydiff.shadow .data em.s7{" +\r\n                        "color:#a7a}#prettydiff.shadow .data em.s8{color:#7a7}#prettydiff.shadow .data " +\r\n                        "em.s9{color:#ff6}#prettydiff.shadow .data em.s10{color:#33f}#prettydiff.shadow" +\r\n                        " .data em.s11{color:#933}#prettydiff.shadow .data em.s12{color:#990}#prettydif" +\r\n                        "f.shadow .data em.s13{color:#987}#prettydiff.shadow .data em.s14{color:#fc3}#p" +\r\n                        "rettydiff.shadow .data em.s15{color:#897}#prettydiff.shadow .data em.s16{color" +\r\n                        ":#f30}#prettydiff.shadow .data .l0{background:#333}#prettydiff.shadow .data .l" +\r\n                        "1{background:#633}#prettydiff.shadow .data .l2{background:#335}#prettydiff.sha" +\r\n                        "dow .data .l3{background:#353}#prettydiff.shadow .data .l4{background:#636}#pr" +\r\n                        "ettydiff.shadow .data .l5{background:#366}#prettydiff.shadow .data .l6{backgro" +\r\n                        "und:#640}#prettydiff.shadow .data .l7{background:#303}#prettydiff.shadow .data" +\r\n                        " .l8{background:#030}#prettydiff.shadow .data .l9{background:#660}#prettydiff." +\r\n                        "shadow .data .l10{background:#003}#prettydiff.shadow .data .l11{background:#30" +\r\n                        "0}#prettydiff.shadow .data .l12{background:#553}#prettydiff.shadow .data .l13{" +\r\n                        "background:#432}#prettydiff.shadow .data .l14{background:#640}#prettydiff.shad" +\r\n                        "ow .data .l15{background:#562}#prettydiff.shadow .data .l16{background:#600}#p" +\r\n                        "rettydiff.shadow .data .c0{background:inherit}",\r\n                white : "#prettydiff.white{background:#f8f8f8 url(\\"data:image/png;base64,iVBORw0KGgoAA" +\r\n                        "AANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3N" +\r\n                        "ob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVU" +\r\n                        "cERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDN" +\r\n                        "RNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQ" +\r\n                        "plcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCE" +\r\n                        "VAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7A" +\r\n                        "GDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTK" +\r\n                        "BNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/" +\r\n                        "qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf" +\r\n                        "14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSK" +\r\n                        "cUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQC" +\r\n                        "AZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQ" +\r\n                        "iiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcF" +\r\n                        "IBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGo" +\r\n                        "gvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqw" +\r\n                        "Du4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh" +\r\n                        "1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIX" +\r\n                        "kneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoE" +\r\n                        "zR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl" +\r\n                        "3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9r" +\r\n                        "kZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWs" +\r\n                        "Nq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG" +\r\n                        "6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr" +\r\n                        "1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL" +\r\n                        "8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDt" +\r\n                        "Mx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1" +\r\n                        "rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqs" +\r\n                        "dWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+L" +\r\n                        "psbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5" +\r\n                        "PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/" +\r\n                        "3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5" +\r\n                        "pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qP" +\r\n                        "No3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZ" +\r\n                        "ATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepk" +\r\n                        "LxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq" +\r\n                        "2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxe" +\r\n                        "dsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1Yfq" +\r\n                        "GnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9Wt" +\r\n                        "O319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7" +\r\n                        "JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/" +\r\n                        "p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0db" +\r\n                        "q3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7v" +\r\n                        "DvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tW" +\r\n                        "eOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGh" +\r\n                        "YPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O" +\r\n                        "/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/" +\r\n                        "GMzLdsAADo2aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ" +\r\n                        "9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zO" +\r\n                        "m1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDg" +\r\n                        "vMjAtMDk6NTM6MDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53M" +\r\n                        "y5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmR" +\r\n                        "mOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvM" +\r\n                        "S4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9" +\r\n                        "tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc" +\r\n                        "1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmc" +\r\n                        "vZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuY" +\r\n                        "WRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnM" +\r\n                        "uYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb" +\r\n                        "2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2h" +\r\n                        "vcCBDQyAyMDE0IChNYWNpbnRvc2gpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlY" +\r\n                        "XRlRGF0ZT4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICA" +\r\n                        "gPHhtcDpNZXRhZGF0YURhdGU+MjAxNi0wMS0xMlQxMjoyNDozOC0wNjowMDwveG1wOk1ldGFkYXRhR" +\r\n                        "GF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3h" +\r\n                        "tcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmQ1M2M3ODQzL" +\r\n                        "WE1ZjItNDg0Ny04YzQzLTZlMmMwYTQ2OGJlYjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHh" +\r\n                        "tcE1NOkRvY3VtZW50SUQ+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjFjMzc2MTgxLWY5ZTgtMTE3OC05Y" +\r\n                        "TljLWQ4MjVkZmIwYTQ3MDwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmF" +\r\n                        "sRG9jdW1lbnRJRD54bXAuZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjBkLTY4MTMxMWQ3NDAzMTwve" +\r\n                        "G1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICA" +\r\n                        "gICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY" +\r\n                        "2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4" +\r\n                        "KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2YjI0ZTI3YS1jZjA3L" +\r\n                        "TQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICA" +\r\n                        "gIDxzdEV2dDp3aGVuPjIwMTYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgI" +\r\n                        "CAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0ICh" +\r\n                        "NYWNpbnRvc2gpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KI" +\r\n                        "CAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICA" +\r\n                        "gICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgI" +\r\n                        "CAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpkNTNjNzg0My1hNWYyLTQ4NDctOGM0My02ZTJjMGE" +\r\n                        "0NjhiZWI8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwM" +\r\n                        "TYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV" +\r\n                        "2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zdEV2d" +\r\n                        "Dpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDp" +\r\n                        "jaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogI" +\r\n                        "CAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzp" +\r\n                        "mb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZ" +\r\n                        "GU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9" +\r\n                        "zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50Y" +\r\n                        "XRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29" +\r\n                        "sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc" +\r\n                        "29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblV" +\r\n                        "uaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgI" +\r\n                        "CA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDx" +\r\n                        "leGlmOlBpeGVsWURpbWVuc2lvbj40PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6R" +\r\n                        "GVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +\r\n                        "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +\r\n                        "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +\r\n                        "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5cKga" +\r\n                        "XAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAkSURBVHjaPMahA" +\r\n                        "QAwDMCg7P+/KnsPcq4oHqpqdwNmBt3QDX8AeAUmcrZLnM4AAAAASUVORK5CYII=\\")}#prettydiff" +\r\n                        ".white *:focus{outline:0.1em dashed #06f}#prettydiff.white .contentarea,#prett" +\r\n                        "ydiff.white legend,#prettydiff.white fieldset select,#prettydiff.white .diff t" +\r\n                        "d,#prettydiff.white .report td,#prettydiff.white .data li,#prettydiff.white .d" +\r\n                        "iff-right,#prettydiff.white fieldset input{background:#fff;border-color:#999}#" +\r\n                        "prettydiff.white select,#prettydiff.white input,#prettydiff.white .diff,#prett" +\r\n                        "ydiff.white .beautify,#prettydiff.white .report,#prettydiff.white .beautify h3" +\r\n                        ",#prettydiff.white .diff h3,#prettydiff.white .beautify h4,#prettydiff.white ." +\r\n                        "diff h4,#prettydiff.white #pdsamples li div,#prettydiff.white #report,#prettyd" +\r\n                        "iff.white .author,#prettydiff.white #report .author,#prettydiff.white fieldset" +\r\n                        "{background:#eee;border-color:#999}#prettydiff.white .diff h3{background:#ddd;" +\r\n                        "border-color:#999}#prettydiff.white fieldset fieldset{background:#ddd}#prettyd" +\r\n                        "iff.white .contentarea{box-shadow:0 1em 1em #999}#prettydiff.white button{back" +\r\n                        "ground-color:#eee;border-color:#999;box-shadow:0 0.25em 0.5em #ccc;color:#666}" +\r\n                        "#prettydiff.white button:hover{background-color:#def;border-color:#03c;box-sha" +\r\n                        "dow:0 0.25em 0.5em #ccf;color:#03c}#prettydiff.white h2,#prettydiff.white h2 b" +\r\n                        "utton,#prettydiff.white h3{color:#b00}#prettydiff.white th{background:#eee;col" +\r\n                        "or:#333}#prettydiff.white thead th{background:#eef}#prettydiff.white .report s" +\r\n                        "trong{color:#009}#prettydiff.white .report em{color:#080}#prettydiff.white h2 " +\r\n                        "button,#prettydiff.white td,#prettydiff.white th,#prettydiff.white .segment,#p" +\r\n                        "rettydiff.white .count li,#prettydiff.white .diff-right #prettydiff.white ol.s" +\r\n                        "egment li{border-color:#ccc}#prettydiff.white .data li{border-color:#ccc}#pret" +\r\n                        "tydiff.white .count li.fold{color:#900}#prettydiff.white .count{background:#ee" +\r\n                        "d;border-color:#999}#prettydiff.white h2 button{background:#f8f8f8;box-shadow:" +\r\n                        "0.1em 0.1em 0.25em #ddd}#prettydiff.white li h4{color:#00f}#prettydiff.white c" +\r\n                        "ode{background:#eee;border-color:#eee;color:#009}#prettydiff.white ol.segment " +\r\n                        "h4 strong{color:#c00}#prettydiff.white .data .delete{background:#ffd8d8}#prett" +\r\n                        "ydiff.white .data .delete em{background:#fff8f8;border-color:#c44;color:#900}#" +\r\n                        "prettydiff.white .data .insert{background:#d8ffd8}#prettydiff.white .data .ins" +\r\n                        "ert em{background:#f8fff8;border-color:#090;color:#363}#prettydiff.white .data" +\r\n                        " .replace{background:#fec}#prettydiff.white .data .replace em{background:#ffe;" +\r\n                        "border-color:#a86;color:#852}#prettydiff.white .data .empty{background:#ddd}#p" +\r\n                        "rettydiff.white .data em.s0{color:#000}#prettydiff.white .data em.s1{color:#f6" +\r\n                        "6}#prettydiff.white .data em.s2{color:#12f}#prettydiff.white .data em.s3{color" +\r\n                        ":#090}#prettydiff.white .data em.s4{color:#d6d}#prettydiff.white .data em.s5{c" +\r\n                        "olor:#7cc}#prettydiff.white .data em.s6{color:#c85}#prettydiff.white .data em." +\r\n                        "s7{color:#737}#prettydiff.white .data em.s8{color:#6d0}#prettydiff.white .data" +\r\n                        " em.s9{color:#dd0}#prettydiff.white .data em.s10{color:#893}#prettydiff.white " +\r\n                        ".data em.s11{color:#b97}#prettydiff.white .data em.s12{color:#bbb}#prettydiff." +\r\n                        "white .data em.s13{color:#cc3}#prettydiff.white .data em.s14{color:#333}#prett" +\r\n                        "ydiff.white .data em.s15{color:#9d9}#prettydiff.white .data em.s16{color:#880}" +\r\n                        "#prettydiff.white .data .l0{background:#fff}#prettydiff.white .data .l1{backgr" +\r\n                        "ound:#fed}#prettydiff.white .data .l2{background:#def}#prettydiff.white .data " +\r\n                        ".l3{background:#efe}#prettydiff.white .data .l4{background:#fef}#prettydiff.wh" +\r\n                        "ite .data .l5{background:#eef}#prettydiff.white .data .l6{background:#fff8cc}#" +\r\n                        "prettydiff.white .data .l7{background:#ede}#prettydiff.white .data .l8{backgro" +\r\n                        "und:#efc}#prettydiff.white .data .l9{background:#ffd}#prettydiff.white .data ." +\r\n                        "l10{background:#edc}#prettydiff.white .data .l11{background:#fdb}#prettydiff.w" +\r\n                        "hite .data .l12{background:#f8f8f8}#prettydiff.white .data .l13{background:#ff" +\r\n                        "b}#prettydiff.white .data .l14{background:#eec}#prettydiff.white .data .l15{ba" +\r\n                        "ckground:#cfc}#prettydiff.white .data .l16{background:#eea}#prettydiff.white ." +\r\n                        "data .c0{background:inherit}#prettydiff.white #report p em{color:#080}#prettyd" +\r\n                        "iff.white #report p strong{color:#009}"\r\n            },\r\n            global : "#prettydiff{text-align:center;font-size:10px;overflow-y:scroll}#prettydiff .co" +\r\n                    "ntentarea{border-style:solid;border-width:0.1em;font-family:\\"Century Gothic\\"" +\r\n                    ",\\"Trebuchet MS\\";margin:0 auto;max-width:93em;padding:1em;text-align:left}#pr" +\r\n                    "ettydiff dd,#prettydiff dt,#prettydiff p,#prettydiff li,#prettydiff td,#pretty" +\r\n                    "diff blockquote,#prettydiff th{clear:both;font-family:\\"Palatino Linotype\\",\\"" +\r\n                    "Book Antiqua\\",Palatino,serif;font-size:1.6em;line-height:1.6em;text-align:lef" +\r\n                    "t}#prettydiff blockquote{font-style:italic}#prettydiff dt{font-size:1.4em;font" +\r\n                    "-weight:bold;line-height:inherit}#prettydiff li li,#prettydiff li p{font-size:" +\r\n                    "1em}#prettydiff th,#prettydiff td{border-style:solid;border-width:0.1em;paddin" +\r\n                    "g:0.1em 0.2em}#prettydiff td span{display:block}#prettydiff code,#prettydiff t" +\r\n                    "extarea{font-family:\\"Courier New\\",Courier,\\"Lucida Console\\",monospace}#pret" +\r\n                    "tydiff code,#prettydiff textarea{display:block;font-size:0.8em;width:100%}#pre" +\r\n                    "ttydiff code span{display:block;white-space:pre}#prettydiff code{border-style:" +\r\n                    "solid;border-width:0.2em;line-height:1em}#prettydiff textarea{line-height:1.4e" +\r\n                    "m}#prettydiff label{display:inline;font-size:1.4em}#prettydiff legend{border-r" +\r\n                    "adius:1em;border-style:solid;border-width:0.1em;font-size:1.4em;font-weight:bo" +\r\n                    "ld;margin-left:-0.25em;padding:0 0.5em}#prettydiff fieldset fieldset legend{fo" +\r\n                    "nt-size:1.2em}#prettydiff table{border-collapse:collapse}#prettydiff div.repor" +\r\n                    "t{border-style:none}#prettydiff h2,#prettydiff h3,#prettydiff h4{clear:both}#p" +\r\n                    "rettydiff table{margin:0 0 1em}#prettydiff .analysis .bad,#prettydiff .analysi" +\r\n                    "s .good{font-weight:bold}#prettydiff h1{font-size:3em;font-weight:normal;margi" +\r\n                    "n-top:0}#prettydiff h1 span{font-size:0.5em}#prettydiff h1 svg{border-style:so" +\r\n                    "lid;border-width:0.05em;float:left;height:1.5em;margin-right:0.5em;width:1.5em" +\r\n                    "}#prettydiff h2{border-style:none;background:transparent;font-size:1em;box-sha" +\r\n                    "dow:none;margin:0}#prettydiff h2 button{background:transparent;border-style:so" +\r\n                    "lid;cursor:pointer;display:block;font-size:2.5em;font-weight:normal;text-align" +\r\n                    ":left;width:100%;border-width:0.05em;font-weight:normal;margin:1em 0 0;padding" +\r\n                    ":0.1em}#prettydiff h2 span{display:block;float:right;font-size:0.5em}#prettydi" +\r\n                    "ff h3{font-size:2em;margin:0;background:transparent;box-shadow:none;border-sty" +\r\n                    "le:none}#prettydiff h4{font-size:1.6em;font-family:\\"Century Gothic\\",\\"Trebuc" +\r\n                    "het MS\\";margin:0}#prettydiff li h4{font-size:1em}#prettydiff button,#prettydi" +\r\n                    "ff fieldset,#prettydiff div input,#prettydiff textarea{border-style:solid;bord" +\r\n                    "er-width:0.1em}#prettydiff section{border-style:none}#prettydiff h2 button,#pr" +\r\n                    "ettydiff select,#prettydiff option{font-family:inherit}#prettydiff select{bord" +\r\n                    "er-style:inset;border-width:0.1em;width:13.5em}#prettydiff #dcolorScheme{float" +\r\n                    ":right;margin:-3em 0 0}#prettydiff #dcolorScheme label,#prettydiff #dcolorSche" +\r\n                    "me label{display:inline-block;font-size:1em}#prettydiff .clear{clear:both;disp" +\r\n                    "lay:block}#prettydiff caption,#prettydiff .content-hide{height:1em;left:-1000e" +\r\n                    "m;overflow:hidden;position:absolute;top:-1000em;width:1em}",\r\n            reports: "#prettydiff #report.contentarea{font-family:\\"Lucida Sans Unicode\\",\\"Helvetic" +\r\n                    "a\\",\\"Arial\\",sans-serif;max-width:none;overflow:scroll}#prettydiff .diff .rep" +\r\n                    "lace em,#prettydiff .diff .delete em,#prettydiff .diff .insert em{border-style" +\r\n                    ":solid;border-width:0.1em}#prettydiff #report dd,#prettydiff #report dt,#prett" +\r\n                    "ydiff #report p,#prettydiff #report li,#prettydiff #report td,#prettydiff #rep" +\r\n                    "ort blockquote,#prettydiff #report th{font-family:\\"Lucida Sans Unicode\\",\\"He" +\r\n                    "lvetica\\",\\"Arial\\",sans-serif;font-size:1.2em}#prettydiff div#webtool{backgro" +\r\n                    "und:transparent;font-size:inherit;margin:0;padding:0}#prettydiff #jserror span" +\r\n                    "{display:block}#prettydiff #a11y{background:transparent;padding:0}#prettydiff " +\r\n                    "#a11y div{margin:0.5em 0;border-style:solid;border-width:0.1em}#prettydiff #a1" +\r\n                    "1y h4{margin:0.25em 0}#prettydiff #a11y ol{border-style:solid;border-width:0.1" +\r\n                    "em}#prettydiff #cssreport.doc table{clear:none;float:left;margin-left:1em}#pre" +\r\n                    "ttydiff #css-size{left:24em}#prettydiff #css-uri{left:40em}#prettydiff #css-ur" +\r\n                    "i td{text-align:left}#prettydiff .report .analysis th{text-align:left}#prettyd" +\r\n                    "iff .report .analysis .parseData td{font-family:\\"Courier New\\",Courier,\\"Luci" +\r\n                    "da Console\\",monospace;text-align:left;white-space:pre}#prettydiff .report .an" +\r\n                    "alysis td{text-align:right}#prettydiff .analysis{float:left;margin:0 1em 1em 0" +\r\n                    "}#prettydiff .analysis td,#prettydiff .analysis th{padding:0.5em}#prettydiff #" +\r\n                    "statreport div{border-style:none}#prettydiff .diff,#prettydiff .beautify{borde" +\r\n                    "r-style:solid;border-width:0.1em;display:inline-block;margin:0 1em 1em 0;posit" +\r\n                    "ion:relative}#prettydiff .diff,#prettydiff .diff li #prettydiff .diff h3,#pret" +\r\n                    "tydiff .diff h4,#prettydiff .beautify,#prettydiff .beautify li,#prettydiff .be" +\r\n                    "autify h3,#prettydiff .beautify h4{font-family:\\"Courier New\\",Courier,\\"Lucid" +\r\n                    "a Console\\",monospace}#prettydiff .diff li,#prettydiff .beautify li,#prettydif" +\r\n                    "f .diff h3,#prettydiff .diff h4,#prettydiff .beautify h3,#prettydiff .beautify" +\r\n                    " h4{border-style:none none solid none;border-width:0 0 0.1em 0;box-shadow:none" +\r\n                    ";display:block;font-size:1.2em;margin:0 0 0 -.1em;padding:0.2em 2em;text-align" +\r\n                    ":left}#prettydiff .diff .skip{border-style:none none solid;border-width:0 0 0." +\r\n                    "1em}#prettydiff .diff .diff-left{border-style:none;display:table-cell}#prettyd" +\r\n                    "iff .diff .diff-right{border-style:none none none solid;border-width:0 0 0 0.1" +\r\n                    "em;display:table-cell;margin-left:-.1em;min-width:16.5em;right:0;top:0}#pretty" +\r\n                    "diff .diff .data li,#prettydiff .beautify .data li{min-width:16.5em;padding:0." +\r\n                    "5em}#prettydiff .diff li,#prettydiff .diff p,#prettydiff .diff h3,#prettydiff " +\r\n                    ".beautify li,#prettydiff .beautify p,#prettydiff .beautify h3{font-size:1.2em}" +\r\n                    "#prettydiff .diff li em,#prettydiff .beautify li em{font-style:normal;font-wei" +\r\n                    "ght:bold;margin:-0.5em -0.09em}#prettydiff .diff p.author{border-style:solid;b" +\r\n                    "order-width:0.2em 0.1em 0.1em;margin:0;overflow:hidden;padding:0.4em;text-alig" +\r\n                    "n:right}#prettydiff .difflabel{display:block;height:0}#prettydiff .count{borde" +\r\n                    "r-style:solid;border-width:0 0.1em 0 0;font-weight:normal;padding:0;text-align" +\r\n                    ":right}#prettydiff .count li{padding:0.5em 1em;text-align:right}#prettydiff .c" +\r\n                    "ount li.fold{cursor:pointer;font-weight:bold;padding-left:0.5em}#prettydiff .d" +\r\n                    "ata{text-align:left;white-space:pre}#prettydiff .beautify .data em{display:inl" +\r\n                    "ine-block;font-style:normal;font-weight:bold}#prettydiff .beautify li,#prettyd" +\r\n                    "iff .diff li{border-style:none none solid;border-width:0 0 0.1em;display:block" +\r\n                    ";height:1em;line-height:1.2;list-style-type:none;margin:0;white-space:pre}#pre" +\r\n                    "ttydiff .beautify ol,#prettydiff .diff ol{display:table-cell;margin:0;padding:" +\r\n                    "0}#prettydiff .beautify em.l0,#prettydiff .beautify em.l1,#prettydiff .beautif" +\r\n                    "y em.l2,#prettydiff .beautify em.l3,#prettydiff .beautify em.l4,#prettydiff .b" +\r\n                    "eautify em.l5,#prettydiff .beautify em.l6,#prettydiff .beautify em.l7,#prettyd" +\r\n                    "iff .beautify em.l8,#prettydiff .beautify em.l9,#prettydiff .beautify em.l10,#" +\r\n                    "prettydiff .beautify em.l11,#prettydiff .beautify em.l12,#prettydiff .beautify" +\r\n                    " em.l13,#prettydiff .beautify em.l14,#prettydiff .beautify em.l15,#prettydiff " +\r\n                    ".beautify em.l16{height:2.2em;margin:0 0 -1em;position:relative;top:-0.5em}#pr" +\r\n                    "ettydiff .beautify em.l0{margin-left:-0.5em;padding-left:0.5em}#prettydiff #re" +\r\n                    "port .beautify,#prettydiff #report .beautify li,#prettydiff #report .diff,#pre" +\r\n                    "ttydiff #report .diff li{font-family:\\"Courier New\\",Courier,\\"Lucida Console" +\r\n                    "\\",monospace}#prettydiff #report .beautify{border-style:solid}#prettydiff #rep" +\r\n                    "ort .diff h3,#prettydiff #report .beautify h3{margin:0}"\r\n        },\r\n        html  : {\r\n            body  : "/*]]>*\\/</style></head><body id=\\"prettydiff\\" class=\\"",\r\n            color : "white",\r\n            end   : "//]]>\\r\\n<\/script></body></html>",\r\n            head  : "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" ?><!DOCTYPE html PUBLIC \\"-//W3C//DTD" +\r\n                    " XHTML 1.1//EN\\" \\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\"><html xmlns=" +\r\n                    "\\"http://www.w3.org/1999/xhtml\\" xml:lang=\\"en\\"><head><title>Pretty Diff - Th" +\r\n                    "e difference tool</title><meta name=\\"robots\\" content=\\"index, follow\\"/> <me" +\r\n                    "ta name=\\"DC.title\\" content=\\"Pretty Diff - The difference tool\\"/> <link rel" +\r\n                    "=\\"canonical\\" href=\\"http://prettydiff.com/\\" type=\\"application/xhtml+xml\\"/" +\r\n                    "><meta http-equiv=\\"Content-Type\\" content=\\"application/xhtml+xml;charset=UTF" +\r\n                    "-8\\"/><meta http-equiv=\\"Content-Style-Type\\" content=\\"text/css\\"/><style typ" +\r\n                    "e=\\"text/css\\">/*<![CDATA[*\\/",\r\n            intro : "\\"><div class=\\"contentarea\\" id=\\"report\\"><section role=\\"heading\\"><h1><svg" +\r\n                    " height=\\"2000.000000pt\\" id=\\"pdlogo\\" preserveAspectRatio=\\"xMidYMid meet\\" " +\r\n                    "version=\\"1.0\\" viewBox=\\"0 0 2000.000000 2000.000000\\" width=\\"2000.000000pt" +\r\n                    "\\" xmlns=\\"http://www.w3.org/2000/svg\\"><g fill=\\"#999\\" stroke=\\"none\\" trans" +\r\n                    "form=\\"translate(0.000000,2000.000000) scale(0.100000,-0.100000)\\"> <path d=\\"" +\r\n                    "M14871 18523 c-16 -64 -611 -2317 -946 -3588 -175 -660 -319 -1202 -320 -1204 -2" +\r\n                    " -2 -50 39 -107 91 -961 876 -2202 1358 -3498 1358 -1255 0 -2456 -451 -3409 -12" +\r\n                    "79 -161 -140 -424 -408 -560 -571 -507 -607 -870 -1320 -1062 -2090 -58 -232 -38" +\r\n                    "6 -1479 -2309 -8759 -148 -563 -270 -1028 -270 -1033 0 -4 614 -8 1365 -8 l1364 " +\r\n                    "0 10 38 c16 63 611 2316 946 3587 175 660 319 1202 320 1204 2 2 50 -39 107 -91 " +\r\n                    "543 -495 1169 -862 1863 -1093 1707 -568 3581 -211 4965 946 252 210 554 524 767" +\r\n                    " 796 111 143 312 445 408 613 229 406 408 854 525 1320 57 225 380 1451 2310 875" +\r\n                    "9 148 563 270 1028 270 1033 0 4 -614 8 -1365 8 l-1364 0 -10 -37z m-4498 -5957 " +\r\n                    "c477 -77 889 -256 1245 -542 523 -419 850 -998 954 -1689 18 -121 18 -549 0 -670" +\r\n                    " -80 -529 -279 -972 -612 -1359 -412 -480 -967 -779 -1625 -878 -121 -18 -549 -1" +\r\n                    "8 -670 0 -494 74 -918 255 -1283 548 -523 419 -850 998 -954 1689 -18 121 -18 54" +\r\n                    "9 0 670 104 691 431 1270 954 1689 365 293 828 490 1283 545 50 6 104 13 120 15 " +\r\n                    "72 10 495 -3 588 -18z\\"/></g></svg><a href=\\"prettydiff.com.xhtml\\">Pretty Dif" +\r\n                    "f</a></h1><p id=\\"dcolorScheme\\"><label class=\\"label\\" for=\\"colorScheme\\">Co" +\r\n                    "lor Scheme</label><select id=\\"colorScheme\\"><option>Canvas</option><option>Sh" +\r\n                    "adow</option><option selected=\\"selected\\">White</option></select></p><p>Find " +\r\n                    "<a href=\\"https://github.com/prettydiff/prettydiff\\">Pretty Diff on GitHub</a>" +\r\n                    ".</p></section><section role=\\"main\\">",\r\n            script: "</section></div><script type=\\"application/javascript\\">//<![CDATA[\\r\\n"\r\n        },\r\n        script: {\r\n            beautify: "var pd={};pd.colorchange=function(){\\"use strict\\";var options=this.getElement" +\r\n                    "sByTagName(\\"option\\");document.getElementsByTagName(\\"body\\")[0].setAttribute" +\r\n                    "(\\"class\\",options[this.selectedIndex].innerHTML.toLowerCase());};pd.colorsche" +\r\n                    "me=document.getElementById(\\"colorScheme\\");pd.colorscheme.onchange=pd.colorch" +\r\n                    "ange;pd.beaufold=function dom__beaufold(){\\"use strict\\";var self=this,title=s" +\r\n                    "elf.getAttribute(\\"title\\").split(\\"line \\"),min=Number(title[1].substr(0,titl" +\r\n                    "e[1].indexOf(\\" \\"))),max=Number(title[2]),a=0,b=\\"\\",list=[self.parentNode.ge" +\r\n                    "tElementsByTagName(\\"li\\"),self.parentNode.nextSibling.getElementsByTagName(\\"" +\r\n                    "li\\")];if(self.innerHTML.charAt(0)===\\"-\\"){for(a=min;a<max;a=a+1){list[0][a]." +\r\n                    "style.display=\\"none\\";list[1][a].style.display=\\"none\\";}self.innerHTML=\\"+\\"" +\r\n                    "+self.innerHTML.substr(1);}else{for(a=min;a<max;a=a+1){list[0][a].style.displa" +\r\n                    "y=\\"block\\";list[1][a].style.display=\\"block\\";if(list[0][a].getAttribute(\\"cl" +\r\n                    "ass\\")===\\"fold\\"&&list[0][a].innerHTML.charAt(0)===\\"+\\"){b=list[0][a].getAtt" +\r\n                    "ribute(\\"title\\");b=b.substring(b.indexOf(\\"to line \\")+1);a=Number(b)-1;}}sel" +\r\n                    "f.innerHTML=\\"-\\"+self.innerHTML.substr(1);}};(function(){\\"use strict\\";var l" +\r\n                    "ists=document.getElementsByTagName(\\"ol\\"),listslen=lists.length,list=[],listl" +\r\n                    "en=0,a=0,b=0;for(a=0;a<listslen;a+=1){if(lists[a].getAttribute(\\"class\\")===\\"" +\r\n                    "count\\"&&lists[a].parentNode.getAttribute(\\"class\\")===\\"beautify\\"){list=list" +\r\n                    "s[a].getElementsByTagName(\\"li\\");listlen=list.length;for(b=0;b<listlen;b=b+1)" +\r\n                    "{if(list[b].getAttribute(\\"class\\")===\\"fold\\"){list[b].onmousedown=pd.beaufol" +\r\n                    "d;}}}}}());",\r\n            diff    : "var pd={};pd.colorchange=function(){\\"use strict\\";var options=this.getElement" +\r\n                    "sByTagName(\\"option\\");document.getElementsByTagName(\\"body\\")[0].setAttribute" +\r\n                    "(\\"class\\",options[this.selectedIndex].innerHTML.toLowerCase())};pd.difffold=f" +\r\n                    "unction dom__difffold(){\\"use strict\\";var a=0,b=0,self=this,title=self.getAtt" +\r\n                    "ribute(\\"title\\").split(\\"line \\"),min=Number(title[1].substr(0,title[1].index" +\r\n                    "Of(\\" \\"))),max=Number(title[2]),inner=self.innerHTML,lists=[],parent=self.par" +\r\n                    "entNode.parentNode,listnodes=(parent.getAttribute(\\"class\\")===\\"diff\\")?paren" +\r\n                    "t.getElementsByTagName(\\"ol\\"):parent.parentNode.getElementsByTagName(\\"ol\\")," +\r\n                    "listLen=listnodes.length;for(a=0;a<listLen;a=a+1){lists.push(listnodes[a].getE" +\r\n                    "lementsByTagName(\\"li\\"))}max=(max>=lists[0].length)?lists[0].length:max;if(in" +\r\n                    "ner.charAt(0)===\\"-\\"){self.innerHTML=\\"+\\"+inner.substr(1);for(a=min;a<max;a=" +\r\n                    "a+1){for(b=0;b<listLen;b=b+1){lists[b][a].style.display=\\"none\\"}}}else{self.i" +\r\n                    "nnerHTML=\\"-\\"+inner.substr(1);for(a=min;a<max;a=a+1){for(b=0;b<listLen;b=b+1)" +\r\n                    "{lists[b][a].style.display=\\"block\\"}}}};pd.colSliderGrab=function(e){\\"use st" +\r\n                    "rict\\";var event=e||window.event,touch=(e!==null&&e.type===\\"touchstart\\"),nod" +\r\n                    "e=this,diffRight=node.parentNode,diff=diffRight.parentNode,subOffset=0,lists=d" +\r\n                    "iff.getElementsByTagName(\\"ol\\"),counter=lists[0].clientWidth,data=lists[1].cl" +\r\n                    "ientWidth,width=lists[2].parentNode.clientWidth,total=lists[2].parentNode.pare" +\r\n                    "ntNode.clientWidth,offset=lists[2].parentNode.offsetLeft-lists[2].parentNode.p" +\r\n                    "arentNode.offsetLeft,min=((total-counter-data-2)-width),max=(total-width-count" +\r\n                    "er),status=\\"ew\\",minAdjust=min+15,maxAdjust=max-15,withinRange=false,diffLeft" +\r\n                    "=diffRight.previousSibling,drop=function dom__event_colSliderGrab_drop(f){f=f|" +\r\n                    "|window.event;f.preventDefault();node.style.cursor=status+\\"-resize\\";if(touch" +\r\n                    "===true){document.ontouchmove=null;document.ontouchend=null}else{document.onmo" +\r\n                    "usemove=null;document.onmouseup=null}},boxmove=function dom__event_colSliderGr" +\r\n                    "ab_boxmove(f){f=f||window.event;f.preventDefault();if(touch===true){subOffset=" +\r\n                    "offset-f.touches[0].clientX}else{subOffset=offset-f.clientX}if(subOffset>minAd" +\r\n                    "just&&subOffset<maxAdjust){withinRange=true}if(withinRange===true&&subOffset>m" +\r\n                    "axAdjust){diffRight.style.width=((total-counter-2)/10)+\\"em\\";status=\\"e\\"}els" +\r\n                    "e if(withinRange===true&&subOffset<minAdjust){diffRight.style.width=((total-co" +\r\n                    "unter-data-2)/10)+\\"em\\";status=\\"w\\"}else if(subOffset<max&&subOffset>min){di" +\r\n                    "ffRight.style.width=((width+subOffset)/10)+\\"em\\";status=\\"ew\\"}if(touch===tru" +\r\n                    "e){document.ontouchend=drop}else{document.onmouseup=drop}};event.preventDefaul" +\r\n                    "t();if(typeof pd.data===\\"object\\"&&pd.data.node.report.code.box!==null){offse" +\r\n                    "t=offset+pd.data.node.report.code.box.offsetLeft;offset=offset-pd.data.node.re" +\r\n                    "port.code.body.scrollLeft}else{subOffset=(document.body.parentNode.scrollLeft>" +\r\n                    "document.body.scrollLeft)?document.body.parentNode.scrollLeft:document.body.sc" +\r\n                    "rollLeft;offset=offset-subOffset}offset=offset+node.clientWidth;node.style.cur" +\r\n                    "sor=\\"ew-resize\\";diff.style.width=(total/10)+\\"em\\";diff.style.display=\\"inli" +\r\n                    "ne-block\\";if(diffLeft.nodeType!==1){do{diffLeft=diffLeft.previousSibling}whil" +\r\n                    "e(diffLeft.nodeType!==1)}diffLeft.style.display=\\"block\\";diffRight.style.widt" +\r\n                    "h=(diffRight.clientWidth/10)+\\"em\\";diffRight.style.position=\\"absolute\\";if(t" +\r\n                    "ouch===true){document.ontouchmove=boxmove;document.ontouchstart=false}else{doc" +\r\n                    "ument.onmousemove=boxmove;document.onmousedown=null}return false};(function(){" +\r\n                    "\\"use strict\\";var lists=document.getElementById(\\"prettydiff\\").getElementsBy" +\r\n                    "TagName(\\"ol\\"),cells=lists[0].getElementsByTagName(\\"li\\"),len=cells.length,a" +\r\n                    "=0;for(a=0;a<len;a=a+1){if(cells[a].getAttribute(\\"class\\")===\\"fold\\"){cells[" +\r\n                    "a].onclick=pd.difffold}}if(lists.length>3){lists[2].onmousedown=pd.colSliderGr" +\r\n                    "ab;lists[2].ontouchstart=pd.colSliderGrab}pd.colorscheme=document.getElementBy" +\r\n                    "Id(\\"colorScheme\\");pd.colorscheme.onchange=pd.colorchange}());",\r\n            minimal : "var pd={};pd.colorchange=function(){\\"use strict\\";var options=this.getElement" +\r\n                    "sByTagName(\\"option\\");document.getElementsByTagName(\\"body\\")[0].setAttribute" +\r\n                    "(\\"class\\",options[this.selectedIndex].innerHTML.toLowerCase())};document.getE" +\r\n                    "lementById(\\"colorScheme\\").onchange=pd.colorchange;"\r\n        }\r\n    };\r\n    finalFile.order = [\r\n        finalFile.html.head, //0\r\n        finalFile.css.color.canvas, //1\r\n        finalFile.css.color.shadow, //2\r\n        finalFile.css.color.white, //3\r\n        finalFile.css.reports, //4\r\n        finalFile.css.global, //5\r\n        finalFile.html.body, //6\r\n        finalFile.html.color, //7\r\n        finalFile.html.intro, //8\r\n        "", //9 - for meta analysis, like stats and accessibility\r\n        "", //10 - for generated report\r\n        finalFile.html.script, //11\r\n        finalFile.script.minimal, //12\r\n        finalFile.html.end //13\r\n    ];\r\n    global.prettydiff.finalFile = finalFile;\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function finalFile_requirejs() {\r\n            return global.prettydiff.finalFile;\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = global.prettydiff.finalFile;\r\n    }\r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(36))},function(n,e){n.exports='/*prettydiff.com api.topcoms:true,api.insize:4,api.inchar:" ",api.vertical:true */\r\n/*global ace, define, global, module*/\r\n/***********************************************************************\r\n safeSort is written by Austin Cheney on 23 Apr 2015.\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n **********************************************************************/\r\n(function safeSort_init() {\r\n    "use strict";\r\n    var safeSort = function safeSort_(array, operation, recursive) {\r\n        var arTest  = function safeSort_arTest(item) {\r\n                if (typeof item !== "object" || item.length === undefined || item.length < 2) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            },\r\n            extref  = function safeSort__extref() {\r\n                //worthless function for backwards compatibility with older versions of V8 node.\r\n                return;\r\n            },\r\n            normal  = function safeSort__normal(item) {\r\n                var done    = [item[0]],\r\n                    storeb  = item,\r\n                    child   = function safeSort__normal_child() {\r\n                        var a   = 0,\r\n                            len = storeb.length;\r\n                        for (a = 0; a < len; a = a + 1) {\r\n                            if (arTest(storeb[a]) === true) {\r\n                                storeb[a] = safeSort__normal(storeb[a]);\r\n                            }\r\n                        }\r\n                    },\r\n                    recurse = function safeSort__normal_recurse(x) {\r\n                        var a      = 0,\r\n                            storea = [],\r\n                            len    = storeb.length;\r\n                        for (a = 0; a < len; a = a + 1) {\r\n                            if (storeb[a] !== x) {\r\n                                storea.push(storeb[a]);\r\n                            }\r\n                        }\r\n                        storeb = storea;\r\n                        if (storea.length > 0) {\r\n                            done.push(storea[0]);\r\n                            extref(storea[0]);\r\n                        } else {\r\n                            if (recursive === true) {\r\n                                child();\r\n                            }\r\n                            item = storeb;\r\n                        }\r\n                    };\r\n                extref = recurse;\r\n                recurse(array[0]);\r\n            },\r\n            descend = function safeSort__descend(item) {\r\n                var c       = 0,\r\n                    storeb  = item,\r\n                    len     = item.length,\r\n                    child   = function safeSort__descend_child() {\r\n                        var a    = 0,\r\n                            lenc = storeb.length;\r\n                        for (a = 0; a < lenc; a = a + 1) {\r\n                            if (arTest(storeb[a]) === true) {\r\n                                storeb[a] = safeSort__descend(storeb[a]);\r\n                            }\r\n                        }\r\n                    },\r\n                    recurse = function safeSort__descend_recurse() {\r\n                        var a      = 0,\r\n                            b      = 0,\r\n                            d      = 0,\r\n                            e      = 0,\r\n                            ind    = [],\r\n                            key    = storeb[c],\r\n                            tstore = "",\r\n                            tkey   = typeof key;\r\n                        for (a = c; a < len; a = a + 1) {\r\n                            tstore = typeof storeb[a];\r\n                            if (storeb[a] > key || (tstore > tkey)) {\r\n                                key = storeb[a];\r\n                                ind = [a];\r\n                            } else if (storeb[a] === key) {\r\n                                ind.push(a);\r\n                            }\r\n                        }\r\n                        d = ind.length;\r\n                        b = d + c;\r\n                        for (a = c; a < b; a = a + 1) {\r\n                            storeb[ind[e]] = storeb[a];\r\n                            storeb[a]      = key;\r\n                            e              = e + 1;\r\n                        }\r\n                        c = c + d;\r\n                        if (c < len) {\r\n                            extref();\r\n                        } else {\r\n                            if (recursive === true) {\r\n                                child();\r\n                            }\r\n                            item = storeb;\r\n                        }\r\n                    };\r\n                extref = recurse;\r\n                recurse();\r\n                return item;\r\n            },\r\n            ascend  = function safeSort__ascend(item) {\r\n                var c       = 0,\r\n                    storeb  = item,\r\n                    len     = item.length,\r\n                    child   = function safeSort__ascend_child() {\r\n                        var a    = 0,\r\n                            lenc = storeb.length;\r\n                        for (a = 0; a < lenc; a = a + 1) {\r\n                            if (arTest(storeb[a]) === true) {\r\n                                storeb[a] = safeSort__ascend(storeb[a]);\r\n                            }\r\n                        }\r\n                    },\r\n                    recurse = function safeSort__ascend_recurse() {\r\n                        var a      = 0,\r\n                            b      = 0,\r\n                            d      = 0,\r\n                            e      = 0,\r\n                            ind    = [],\r\n                            key    = storeb[c],\r\n                            tstore = "",\r\n                            tkey   = typeof key;\r\n                        for (a = c; a < len; a = a + 1) {\r\n                            tstore = typeof storeb[a];\r\n                            if (storeb[a] < key || tstore < tkey) {\r\n                                key = storeb[a];\r\n                                ind = [a];\r\n                            } else if (storeb[a] === key) {\r\n                                ind.push(a);\r\n                            }\r\n                        }\r\n                        d = ind.length;\r\n                        b = d + c;\r\n                        for (a = c; a < b; a = a + 1) {\r\n                            storeb[ind[e]] = storeb[a];\r\n                            storeb[a]      = key;\r\n                            e              = e + 1;\r\n                        }\r\n                        c = c + d;\r\n                        if (c < len) {\r\n                            extref();\r\n                        } else {\r\n                            if (recursive === true) {\r\n                                child();\r\n                            }\r\n                            item = storeb;\r\n                        }\r\n                    };\r\n                extref = recurse;\r\n                recurse();\r\n                return item;\r\n            };\r\n        if (arTest(array) === false) {\r\n            return array;\r\n        }\r\n        if (recursive === "true") {\r\n            recursive = true;\r\n        } else if (recursive !== true) {\r\n            recursive = false;\r\n        }\r\n        if (operation === "normal") {\r\n            return normal(array);\r\n        }\r\n        if (operation === "descend") {\r\n            return descend(array);\r\n        }\r\n        return ascend(array);\r\n    };\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function safeSort_requirejs() {\r\n            return function safeSort_requirejs_wrapper(x, y, z) {\r\n                return safeSort(x, y, z);\r\n            };\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = safeSort;\r\n    } else {\r\n        global.prettydiff.safeSort = safeSort;\r\n    }\r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(38))},function(n,e){n.exports='/*prettydiff.com topcoms:true,insize:4,inchar:" ",vertical:true */\r\n/*jshint laxbreak: true*/\r\n/*global ace, define, global, module*/\r\n/***********************************************************************\r\n csspretty is written by Austin Cheney on 7 Aug 2014.\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n\r\n **********************************************************************/\r\n/*\r\n This application beautifies CSS code as well as SCSS (Sass) and LESS\r\n variants. This application was written with extension in mind using the\r\n same array based architecture used for the markuppretty and jspretty\r\n libraries.  The architecture focuses on separation of roles.  The first\r\n area of the application reads the code and writes an array of tokens.\r\n The second area is the algorithm that determines what white space and\r\n indentation should be applied.  The final area is a report on the\r\n analysis of the code.\r\n -----------------------------------------------------------------------\r\n */\r\n(function () {\r\n    "use strict";\r\n    var csspretty = function csspretty_(options) {\r\n        var token      = [],\r\n            types      = [],\r\n            lines      = [],\r\n            depth      = [],\r\n            begin      = [],\r\n            uri        = [],\r\n            colors     = [],\r\n            output     = "",\r\n            endline    = false,\r\n            objsortop  = false,\r\n            verticalop = false,\r\n            colorNames = {\r\n                aliceblue           : 0.9288006825347457,\r\n                antiquewhite        : 0.8464695170775405,\r\n                aqua                : 0.7874,\r\n                aquamarine          : 0.8078549208338043,\r\n                azure               : 0.9726526495416643,\r\n                beige               : 0.8988459998705021,\r\n                bisque              : 0.8073232737297876,\r\n                black               : 0,\r\n                blanchedalmond      : 0.8508443960815607,\r\n                blue                : 0.0722,\r\n                blueviolet          : 0.12622014321946043,\r\n                brown               : 0.09822428787651079,\r\n                burlywood           : 0.5155984453389335,\r\n                cadetblue           : 0.29424681085422044,\r\n                chartreuse          : 0.7603202590262282,\r\n                chocolate           : 0.23898526114557292,\r\n                coral               : 0.3701793087292368,\r\n                cornflowerblue      : 0.30318641994179363,\r\n                cornsilk            : 0.9356211037296492,\r\n                crimson             : 0.16042199953025577,\r\n                cyan                : 0.7874,\r\n                darkblue            : 0.018640801980939217,\r\n                darkcyan            : 0.2032931783904645,\r\n                darkgoldenrod       : 0.27264703559992554,\r\n                darkgray            : 0.39675523072562674,\r\n                darkgreen           : 0.09114342904757505,\r\n                darkgrey            : 0.39675523072562674,\r\n                darkkhaki           : 0.45747326349994155,\r\n                darkmagenta         : 0.07353047651207048,\r\n                darkolivegreen      : 0.12651920884889156,\r\n                darkorange          : 0.40016167026523863,\r\n                darkorchid          : 0.1341314217485677,\r\n                darkred             : 0.05488967453113126,\r\n                darksalmon          : 0.4054147156338075,\r\n                darkseagreen        : 0.43789249325969054,\r\n                darkslateblue       : 0.06579284622798763,\r\n                darkslategray       : 0.06760815192804355,\r\n                darkslategrey       : 0.06760815192804355,\r\n                darkturquoise       : 0.4874606277449034,\r\n                darkviolet          : 0.10999048339343433,\r\n                deeppink            : 0.2386689582827583,\r\n                deepskyblue         : 0.444816033955754,\r\n                dimgray             : 0.14126329114027164,\r\n                dimgrey             : 0.14126329114027164,\r\n                dodgerblue          : 0.2744253699145608,\r\n                firebrick           : 0.10724525535015225,\r\n                floralwhite         : 0.9592248482500424,\r\n                forestgreen         : 0.18920812076002244,\r\n                fuchsia             : 0.2848,\r\n                gainsboro           : 0.7156935005064806,\r\n                ghostwhite          : 0.9431126188632283,\r\n                gold                : 0.6986087742815887,\r\n                goldenrod           : 0.41919977809568404,\r\n                gray                : 0.21586050011389915,\r\n                green               : 0.15438342968146068,\r\n                greenyellow         : 0.8060947261145331,\r\n                grey                : 0.21586050011389915,\r\n                honeydew            : 0.9633653555478173,\r\n                hotpink             : 0.3465843816971475,\r\n                indianred           : 0.21406134963884,\r\n                indigo              : 0.031075614863369846,\r\n                ivory               : 0.9907127060061531,\r\n                khaki               : 0.7701234339412052,\r\n                lavendar            : 0.8031875051452125,\r\n                lavendarblush       : 0.9017274863104644,\r\n                lawngreen           : 0.7390589312496334,\r\n                lemonchiffon        : 0.9403899224562171,\r\n                lightblue           : 0.6370914128080659,\r\n                lightcoral          : 0.35522120733134843,\r\n                lightcyan           : 0.9458729349482863,\r\n                lightgoldenrodyellow: 0.9334835101829635,\r\n                lightgray           : 0.651405637419824,\r\n                lightgreen          : 0.6909197995686475,\r\n                lightgrey           : 0.651405637419824,\r\n                lightpink           : 0.5856615273489745,\r\n                lightsalmon         : 0.47806752252059587,\r\n                lightseagreen       : 0.3505014511704197,\r\n                lightskyblue        : 0.5619563761833096,\r\n                lightslategray      : 0.23830165007286924,\r\n                lightslategrey      : 0.23830165007286924,\r\n                lightyellow         : 0.9816181839288161,\r\n                lime                : 0.7152,\r\n                limegreen           : 0.44571042246097864,\r\n                linen               : 0.8835734098437936,\r\n                magenta             : 0.2848,\r\n                maroon              : 0.04589194232421496,\r\n                mediumaquamarine    : 0.4938970331080111,\r\n                mediumblue          : 0.04407778021232784,\r\n                mediumorchid        : 0.21639251153773428,\r\n                mediumpurple        : 0.22905858091648004,\r\n                mediumseagreen      : 0.34393112338131226,\r\n                mediumslateblue     : 0.20284629471622434,\r\n                mediumspringgreen   : 0.7070430819418444,\r\n                mediumturquois      : 0.5133827926447991,\r\n                mediumvioletred     : 0.14371899849357186,\r\n                midnightblue        : 0.020717866350860484,\r\n                mintcream           : 0.9783460494758793,\r\n                mistyrose           : 0.8218304785918541,\r\n                moccasin            : 0.8008300099156694,\r\n                navajowhite         : 0.7651968234278562,\r\n                navy                : 0.015585128108223519,\r\n                oldlace             : 0.9190063340554899,\r\n                olive               : 0.20027537200567563,\r\n                olivedrab           : 0.2259315095192918,\r\n                orange              : 0.48170267036309605,\r\n                orangered           : 0.2551624375341641,\r\n                orchid              : 0.3134880676143873,\r\n                palegoldenrod       : 0.7879264788761452,\r\n                palegreen           : 0.7793675900635259,\r\n                paleturquoise       : 0.764360779217138,\r\n                palevioletred       : 0.2875499411788909,\r\n                papayawhip          : 0.8779710019983541,\r\n                peachpuff           : 0.7490558987825108,\r\n                peru                : 0.3011307487793569,\r\n                pink                : 0.6327107070246611,\r\n                plum                : 0.4573422158796909,\r\n                powderblue          : 0.6825458650060524,\r\n                purple              : 0.061477070432438476,\r\n                red                 : 0.2126,\r\n                rosyblue            : 0.3231945764940708,\r\n                royalblue           : 0.16663210743188323,\r\n                saddlebrown         : 0.09792228502052071,\r\n                salmon              : 0.3697724152759545,\r\n                sandybrown          : 0.46628543696283414,\r\n                seagreen            : 0.1973419970627483,\r\n                seashell            : 0.927378622069223,\r\n                sienna              : 0.13697631337097677,\r\n                silver              : 0.527115125705813,\r\n                skyblue             : 0.5529166851818412,\r\n                slateblue           : 0.14784278062136097,\r\n                slategray           : 0.20896704076536138,\r\n                slategrey           : 0.20896704076536138,\r\n                slightsteelblue     : 0.5398388828466575,\r\n                snow                : 0.9653334183484877,\r\n                springgreen         : 0.7305230606852947,\r\n                steelblue           : 0.20562642207624846,\r\n                tan                 : 0.48237604163921527,\r\n                teal                : 0.1699685577896842,\r\n                thistle             : 0.5681840109373312,\r\n                tomato              : 0.3063861271941505,\r\n                turquoise           : 0.5895536427577983,\r\n                violet              : 0.40315452986676303,\r\n                wheat               : 0.7490970282048214,\r\n                white               : 1,\r\n                whitesmoke          : 0.913098651793419,\r\n                yellow              : 0.9278,\r\n                yellowgreen         : 0.5076295720870697\r\n            },\r\n            stats      = {\r\n                braces    : 0,\r\n                colon     : 0,\r\n                comments  : {\r\n                    chars: 0,\r\n                    count: 0\r\n                },\r\n                properties: {\r\n                    chars: 0,\r\n                    count: 0\r\n                },\r\n                selectors : {\r\n                    chars: 0,\r\n                    count: 0\r\n                },\r\n                semi      : 0,\r\n                space     : 0,\r\n                values    : {\r\n                    chars: 0,\r\n                    count: 0\r\n                },\r\n                variables : {\r\n                    chars: 0,\r\n                    count: 0\r\n                }\r\n            },\r\n            lf         = (options.crlf === true || options.crlf === "true")\r\n                ? "\\r\\n"\r\n                : "\\n";\r\n        (function csspretty__options() {\r\n            objsortop      = (\r\n                options.objsort === true || options.objsort === "true" || options.objsort === "all" || options.objsort === "css"\r\n            );\r\n            verticalop     = (\r\n                options.compressedcss === false && (options.vertical === true || options.vertical === "true" || options.vertical === "all" || options.vertical === "css")\r\n            );\r\n            options.source = (\r\n                typeof options.source === "string" && options.source.length > 0\r\n            )\r\n                ? options\r\n                    .source\r\n                    .replace(/\\r\\n?/g, "\\n") + " "\r\n                : "Error: no source code supplied to csspretty!";\r\n        }());\r\n        if (typeof options.source !== "string" || options.source === "" || (/^(\\s+)$/).test(options.source) === true) {\r\n            if (options.nodeasync === true) {\r\n                return [options.source, "Error: no source supplied to csspretty."];\r\n            }\r\n            if (global.prettydiff.meta === undefined) {\r\n                global.prettydiff.meta = {};\r\n            }\r\n            global.prettydiff.meta.error = options.source;\r\n            return options.source;\r\n        }\r\n        (function csspretty__tokenize() {\r\n            var a          = 0,\r\n                b          = options\r\n                    .source\r\n                    .split(""),\r\n                len        = options.source.length,\r\n                ltype      = "",\r\n                itemsize   = 0,\r\n                space      = "",\r\n                endtest    = false,\r\n                struct     = [0],\r\n                mapper     = [],\r\n                structval  = "root",\r\n                nosort     = [],\r\n                esctest    = function csspretty__tokenize_esctest(xx) {\r\n                    var yy = xx;\r\n                    do {\r\n                        xx = xx - 1;\r\n                    } while (xx > 0 && b[xx] === "\\\\");\r\n                    if ((yy - xx) % 2 === 0) {\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                },\r\n                // Since I am already identifying value types this is a good place to do some\r\n                // quick analysis and clean up on certain value conditions. These things are\r\n                // being corrected:\r\n                //  * fractional values missing a leading 0 are    provided a leading 0\r\n                // * 0 values with a dimension indicator    (px, em) have the dimension\r\n                // indicator    removed\r\n                //  * eliminate unnecessary leading 0s\r\n                //  * url values that are not quoted are wrapped    in double quote characters\r\n                // * color values are set to lowercase and    reduced from 6 to 3 digits if\r\n                // appropriate\r\n                value      = function csspretty__tokenize_item_value(val, font) {\r\n                    var x         = val.split(""),\r\n                        leng      = x.length,\r\n                        cc        = 0,\r\n                        dd        = 0,\r\n                        items     = [],\r\n                        block     = "",\r\n                        values    = [],\r\n                        qchar     = "",\r\n                        qreg      = {},\r\n                        transition = (token[token.length - 3] === "transition"),\r\n                        colorPush = function csspretty__tokenize_item_value_colorPush(value) {\r\n                            var vl = value.toLowerCase();\r\n                            if ((/^(#[0-9a-f]{3,6})$/).test(vl) === true) {\r\n                                colors.push(value);\r\n                            } else if ((/^(rgba?\\()/).test(vl) === true) {\r\n                                colors.push(value);\r\n                            } else if (colorNames[vl] !== undefined) {\r\n                                colors.push(value);\r\n                            }\r\n                            return value;\r\n                        };\r\n                    if (options.quoteConvert === "double") {\r\n                        qchar = "\\"";\r\n                    } else if (options.quoteConvert === "single") {\r\n                        qchar = "\'";\r\n                    }\r\n                    // this loop identifies containment so that tokens/sub-tokens are correctly\r\n                    // taken\r\n                    for (cc = 0; cc < leng; cc = cc + 1) {\r\n                        items.push(x[cc]);\r\n                        if (block === "") {\r\n                            if (x[cc] === "\\"") {\r\n                                block = "\\"";\r\n                                dd    = dd + 1;\r\n                            } else if (x[cc] === "\'") {\r\n                                block = "\'";\r\n                                dd    = dd + 1;\r\n                            } else if (x[cc] === "(") {\r\n                                block = ")";\r\n                                dd    = dd + 1;\r\n                            } else if (x[cc] === "[") {\r\n                                block = "]";\r\n                                dd    = dd + 1;\r\n                            }\r\n                        } else if ((x[cc] === "(" && block === ")") || (x[cc] === "[" && block === "]")) {\r\n                            dd = dd + 1;\r\n                        } else if (x[cc] === block) {\r\n                            dd = dd - 1;\r\n                            if (dd === 0) {\r\n                                block = "";\r\n                            }\r\n                        }\r\n                        if (block === "" && x[cc] === " ") {\r\n                            items.pop();\r\n                            values.push(colorPush(items.join("")));\r\n                            items = [];\r\n                        }\r\n                    }\r\n                    values.push(colorPush(items.join("")));\r\n                    leng = values.length;\r\n                    //This is where the rules mentioned above are applied\r\n                    for (cc = 0; cc < leng; cc = cc + 1) {\r\n                        if (options.noleadzero === false && (/^(\\.\\d)/).test(values[cc]) === true) {\r\n                            values[cc] = "0" + values[cc];\r\n                        } else if (options.noleadzero === true && (/^(0+\\.)/).test(values[cc])) {\r\n                            values[cc] = values[cc].replace(/^(0+\\.)/, ".");\r\n                        } else if ((/^(0+([a-z]{2,3}|%))$/).test(values[cc]) === true && transition === false) {\r\n                            values[cc] = "0";\r\n                        } else if ((/^(0+)/).test(values[cc]) === true) {\r\n                            values[cc] = values[cc].replace(/0+/, "0");\r\n                            if ((/\\d/).test(values[cc].charAt(1)) === true) {\r\n                                values[cc] = values[cc].substr(1);\r\n                            }\r\n                        } else if ((/^url\\((?!\\$)/).test(values[cc]) === true && values[cc].charAt(values[cc].length - 1) === ")") {\r\n                            block = values[cc].charAt(values[cc].indexOf("url(") + 4);\r\n                            if (block !== "@" && block !== "{" && block !== "<") {\r\n                                if (qchar === "") {\r\n                                    values[cc] = values[cc]\r\n                                        .replace(/url\\(\\s*(\'|")?/, "url(\\"")\r\n                                        .replace(/((\'|")?\\s*\\))$/, "\\")");\r\n                                } else {\r\n                                    values[cc] = values[cc]\r\n                                        .replace(/url\\(\\s*(\'|")?/, "url(" + qchar)\r\n                                        .replace(/((\'|")?\\s*\\))$/, qchar + ")");\r\n                                }\r\n                            }\r\n                        } else if (font === true) {\r\n                            if (qchar === "\'") {\r\n                                values[cc] = values[cc].replace(/"/g, "\'");\r\n                            } else {\r\n                                values[cc] = values[cc].replace(/\'/g, "\\"");\r\n                            }\r\n                        } else if (font === false && qchar !== "" && ((qchar === "\\"" && values[cc].charAt(0) === "\'" && values[cc].charAt(values[cc].length - 1) === "\'") || (qchar === "\'" && values[cc].charAt(0) === "\\"" && values[cc].charAt(values[cc].length - 1) === "\\""))) {\r\n                            qreg       = new RegExp(qchar, "g");\r\n                            values[cc] = qchar + values[cc]\r\n                                .slice(1, values[cc].length - 1)\r\n                                .replace(qreg, "\\\\" + qchar) + qchar;\r\n                        }\r\n                    }\r\n                    return values.join(" ");\r\n                },\r\n                //map location of empty lines for beautification\r\n                spacer     = function csspretty__tokenize_space(end) {\r\n                    var slen = space\r\n                            .split(lf)\r\n                            .length - 1,\r\n                        val  = 0;\r\n                    if (token.length === 0 && slen > 0) {\r\n                        slen = slen + 1;\r\n                    }\r\n                    if (slen > 0 && options.preserve > 0) {\r\n                        if (slen > options.preserve) {\r\n                            val = options.preserve + 1;\r\n                        } else {\r\n                            val = slen;\r\n                        }\r\n                    } else if (space.length > 1) {\r\n                        val = 1;\r\n                    } else if (slen === 0 && types[types.length - 1] === "comment" && types[types.length - 2] !== "comment") {\r\n                        types[types.length - 1] = "comment-inline";\r\n                    }\r\n                    if (slen > 1 && end === true && options.preserve > 0) {\r\n                        endline = true;\r\n                        space   = "";\r\n                        return val;\r\n                    }\r\n                    space = "";\r\n                    return val;\r\n                },\r\n                //sort parsed properties intelligently\r\n                objSort    = function csspretty__tokenize_objSort() {\r\n                    var cc        = 0,\r\n                        dd        = 0,\r\n                        ee        = 0,\r\n                        startlen  = token.length - 1,\r\n                        end       = startlen,\r\n                        keys      = [],\r\n                        keylen    = 0,\r\n                        keyend    = 0,\r\n                        start     = 0,\r\n                        sort      = function csspretty__tokenize_objSort_sort(x, y) {\r\n                            var xx = x[0],\r\n                                yy = y[0];\r\n                            if (types[xx] === "comment" || types[xx] === "comment-inline") {\r\n                                do {\r\n                                    xx = xx + 1;\r\n                                } while (\r\n                                    xx < startlen && (types[xx] === "comment" || types[xx] === "comment-inline")\r\n                                );\r\n                            }\r\n                            if (types[yy] === "comment" || types[yy] === "comment-inline") {\r\n                                do {\r\n                                    yy = yy + 1;\r\n                                } while (\r\n                                    yy < startlen && (types[yy] === "comment" || types[yy] === "comment-inline")\r\n                                );\r\n                            }\r\n                            if (types[xx] < types[yy]) {\r\n                                return -1;\r\n                            }\r\n                            if (types[xx] === types[yy] && token[xx].toLowerCase() < token[yy].toLowerCase()) {\r\n                                return -1;\r\n                            }\r\n                            return 1;\r\n                        },\r\n                        semiTest  = true,\r\n                        pairToken = [],\r\n                        pairTypes = [],\r\n                        pairLines = [],\r\n                        pairDepth = [],\r\n                        pairBegin = [];\r\n                    if (types[end] === "comment" || types[end] === "comment-inline") {\r\n                        do {\r\n                            end = end - 1;\r\n                        } while (\r\n                            end > 0 && (types[end] === "comment" || types[end] === "comment-inline")\r\n                        );\r\n                    }\r\n                    for (cc = startlen; cc > -1; cc = cc - 1) {\r\n                        if (types[cc] === "end") {\r\n                            dd = dd + 1;\r\n                        }\r\n                        if (types[cc] === "start") {\r\n                            dd = dd - 1;\r\n                        }\r\n                        if (dd === 0) {\r\n                            if ((types[cc] === "property" || types[cc] === "selector" || types[cc] === "propvar") && types[cc - 1] !== "property" && types[cc - 1] !== "selector") {\r\n                                start = cc;\r\n                                if (types[end + 1] === "comment-inline") {\r\n                                    end = end + 1;\r\n                                }\r\n                                if (types[start - 1] === "comment") {\r\n                                    do {\r\n                                        start = start - 1;\r\n                                    } while (start > -1 && types[start - 1] === "comment");\r\n                                }\r\n                                keys.push([\r\n                                    start, end + 1,\r\n                                    false\r\n                                ]);\r\n                                end = start - 1;\r\n                            }\r\n                        }\r\n                        if (dd < 0 && cc < startlen) {\r\n                            if (keys.length > 1 && (types[cc - 1] === "selector" || types[cc - 1] === "propvar" || (types[cc - 2] === "propvar" && types[cc - 1] === "value") || token[cc - 1] === "=" || token[cc - 1] === ":" || token[cc - 1] === "[" || token[cc - 1] === "{" || (token[cc - 1] === "," && structval !== "map") || cc === 0)) {\r\n                                if (structval === "map" && token[token.length - 1] !== ",") {\r\n                                    token.push(",");\r\n                                    types.push("semi");\r\n                                    lines.push(0);\r\n                                    depth.push(depth[depth.length - 1]);\r\n                                    begin.push(begin[begin.length - 1]);\r\n                                    keys[0][1] = keys[0][1] + 1;\r\n                                }\r\n                                keys.sort(sort);\r\n                                keylen   = keys.length;\r\n                                semiTest = false;\r\n                                for (dd = 0; dd < keylen; dd = dd + 1) {\r\n                                    keyend = keys[dd][1];\r\n                                    for (ee = keys[dd][0]; ee < keyend; ee = ee + 1) {\r\n                                        pairToken.push(token[ee]);\r\n                                        pairTypes.push(types[ee]);\r\n                                        pairLines.push(lines[ee]);\r\n                                        pairDepth.push(depth[ee]);\r\n                                        pairBegin.push(begin[ee]);\r\n                                        if ((token[ee] === ";" && structval === "block") || (token[ee] === "," && structval === "map") || token[ee] === "}") {\r\n                                            semiTest = true;\r\n                                        } else if ((structval === "block" && token[ee] !== ";") && (structval === "map" && token[ee] !== ",") && token[ee] !== "}" && types[ee] !== "comment" && types[ee] !== "comment-inline") {\r\n                                            semiTest = false;\r\n                                        }\r\n                                    }\r\n                                    if (semiTest === false) {\r\n                                        ee = pairTypes.length - 1;\r\n                                        if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {\r\n                                            do {\r\n                                                ee = ee - 1;\r\n                                            } while (\r\n                                                ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\r\n                                            );\r\n                                        }\r\n                                        ee = ee + 1;\r\n                                        if (structval === "map") {\r\n                                            pairToken.splice(ee, 0, ",");\r\n                                        } else {\r\n                                            pairToken.splice(ee, 0, ";");\r\n                                        }\r\n                                        pairTypes.splice(ee, 0, "semi");\r\n                                        pairDepth.splice(ee, 0, pairDepth[ee]);\r\n                                        pairBegin.splice(ee, 0, pairBegin[ee]);\r\n                                        if (pairLines[ee - 1] > 0) {\r\n                                            pairLines[ee - 1] = 0;\r\n                                            pairLines.splice(ee, 0, 1);\r\n                                        } else {\r\n                                            pairLines.splice(ee, 0, 0);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                ee = pairTypes.length - 1;\r\n                                if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {\r\n                                    do {\r\n                                        ee = ee - 1;\r\n                                    } while (\r\n                                        ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\r\n                                    );\r\n                                }\r\n                                keylen = token.length - (cc + 1);\r\n                                token.splice(cc + 1, keylen);\r\n                                types.splice(cc + 1, keylen);\r\n                                lines.splice(cc + 1, keylen);\r\n                                depth.splice(cc + 1, keylen);\r\n                                begin.splice(cc + 1, keylen);\r\n                                token = token.concat(pairToken);\r\n                                types = types.concat(pairTypes);\r\n                                lines = lines.concat(pairLines);\r\n                                depth = depth.concat(pairDepth);\r\n                                begin = begin.concat(pairBegin);\r\n                                if (structval === "map") {\r\n                                    cc = token.length - 1;\r\n                                    if (types[cc].indexOf("comment") === 0) {\r\n                                        do {\r\n                                            cc = cc - 1;\r\n                                        } while (types[cc].indexOf("comment") === 0);\r\n                                    }\r\n                                    if (token[cc] === ",") {\r\n                                        token.splice(cc, 1);\r\n                                        types.splice(cc, 1);\r\n                                        lines.splice(cc, 1);\r\n                                        depth.splice(cc, 1);\r\n                                        begin.splice(cc, 1);\r\n                                    }\r\n                                }\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                },\r\n                //the generic token builder\r\n                buildtoken = function csspretty__tokenize_build() {\r\n                    var aa         = 0,\r\n                        bb         = 0,\r\n                        out        = [],\r\n                        block      = [],\r\n                        outy       = "",\r\n                        mappy      = 0,\r\n                        comma      = (\r\n                            token.length > 0 && token[token.length - 1].charAt(token[token.length - 1].length - 1) === ","\r\n                        ),\r\n                        linev      = spacer(false),\r\n                        spacestart = function () {\r\n                            if ((/\\s/).test(b[aa + 1]) === true) {\r\n                                do {\r\n                                    aa = aa + 1;\r\n                                } while ((/\\s/).test(b[aa + 1]) === true);\r\n                            }\r\n                        };\r\n                    //this loop accounts for grouping mechanisms\r\n                    for (aa = a; aa < len; aa = aa + 1) {\r\n                        out.push(b[aa]);\r\n                        if (b[aa - 1] !== "\\\\" || esctest(aa) === false) {\r\n                            if (b[aa] === "\\"" && block[block.length - 1] !== "\'") {\r\n                                if (block[block.length - 1] === "\\"") {\r\n                                    block.pop();\r\n                                } else {\r\n                                    block.push("\\"");\r\n                                }\r\n                            } else if (b[aa] === "\'" && block[block.length - 1] !== "\\"") {\r\n                                if (block[block.length - 1] === "\'") {\r\n                                    block.pop();\r\n                                } else {\r\n                                    block.push("\'");\r\n                                }\r\n                            } else if (block[block.length - 1] !== "\\"" && block[block.length - 1] !== "\'") {\r\n                                if (b[aa] === "(") {\r\n                                    mappy = mappy + 1;\r\n                                    block.push(")");\r\n                                    spacestart();\r\n                                } else if (b[aa] === "[") {\r\n                                    block.push("]");\r\n                                    spacestart();\r\n                                } else if (b[aa] === "#" && b[aa + 1] === "{") {\r\n                                    out.push("{");\r\n                                    aa = aa + 1;\r\n                                    block.push("}");\r\n                                    spacestart();\r\n                                } else if (b[aa] === block[block.length - 1]) {\r\n                                    block.pop();\r\n                                    if ((/\\s/).test(out[out.length - 2]) === true) {\r\n                                        out.pop();\r\n                                        do {\r\n                                            out.pop();\r\n                                        } while ((/\\s/).test(out[out.length - 1]) === true);\r\n                                        out.push(b[aa]);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if (structval === "map" && block.length === 0 && (b[aa + 1] === "," || b[aa + 1] === ")")) {\r\n                            if (b[aa + 1] === ")" && token[token.length - 1] === "(") {\r\n                                token.pop();\r\n                                types.pop();\r\n                                lines.pop();\r\n                                depth.pop();\r\n                                begin.pop();\r\n                                struct.pop();\r\n                                structval = depth[depth.length - 1];\r\n                                out       = ["("];\r\n                                aa        = a - 1;\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (b[aa + 1] === ":") {\r\n                            bb = aa;\r\n                            if ((/\\s/).test(b[bb]) === true) {\r\n                                do {\r\n                                    bb = bb - 1;\r\n                                } while ((/\\s/).test(b[bb]) === true);\r\n                            }\r\n                            outy = b\r\n                                .slice(bb - 6, bb + 1)\r\n                                .join("");\r\n                            if (outy.indexOf("filter") === outy.length - 6 || outy.indexOf("progid") === outy.length - 6) {\r\n                                outy = "filter";\r\n                            }\r\n                        }\r\n                        if (block.length === 0 && ((b[aa + 1] === ";" && esctest(aa + 1) === false) || (b[aa + 1] === ":" && b[aa] !== ":" && b[aa + 2] !== ":" && outy !== "filter" && outy !== "progid") || b[aa + 1] === "}" || b[aa + 1] === "{" || (b[aa + 1] === "/" && (b[aa + 2] === "*" || b[aa + 2] === "/")))) {\r\n                            bb = out.length - 1;\r\n                            if ((/\\s/).test(out[bb]) === true) {\r\n                                do {\r\n                                    bb = bb - 1;\r\n                                    aa = aa - 1;\r\n                                    out.pop();\r\n                                } while ((/\\s/).test(out[bb]) === true);\r\n                            }\r\n                            break;\r\n                        }\r\n                        if (out[0] === "@" && block.length === 0 && (b[aa + 1] === "\\"" || b[aa + 1] === "\'")) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    a        = aa;\r\n                    itemsize = out.length;\r\n                    if (structval === "map" && out[0] === "(") {\r\n                        mapper[mapper.length - 1] = mapper[mapper.length - 1] - 1;\r\n                    }\r\n                    if (comma === true && structval !== "map" && types[types.length - 1] !== "comment" && types[types.length - 1] !== "comment-inline") {\r\n                        token[token.length - 1] = token[token.length - 1] + out\r\n                            .join("")\r\n                            .replace(/\\s+/g, " ")\r\n                            .replace(/^\\s/, "")\r\n                            .replace(/\\s$/, "");\r\n                        return;\r\n                    }\r\n                    token.push(\r\n                        out.join("").replace(/\\s+/g, " ").replace(/^\\s/, "").replace(/\\s$/, "")\r\n                    );\r\n                    begin.push(struct[struct.length - 1]);\r\n                    depth.push(structval);\r\n                    lines.push(linev);\r\n                    if (token[token.length - 1].indexOf("extend(") === 0) {\r\n                        ltype = "pseudo";\r\n                        types.push("pseudo");\r\n                    } else if ("\\"\'".indexOf(token[token.length - 1].charAt(0)) > -1 && types[types.length - 1] === "propvar") {\r\n                        ltype = "item";\r\n                        types.push("value");\r\n                    } else if (out[0] === "@" || out[0] === "$") {\r\n                        if (types[types.length - 1] === "colon" && (types[types.length - 2] === "property" || types[types.length - 2] === "propvar")) {\r\n                            ltype = "value";\r\n                            types.push("value");\r\n                        } else {\r\n                            ltype = "propvar";\r\n                            types.push("propvar");\r\n                            outy = token[token.length - 1];\r\n                            aa   = outy.indexOf("(");\r\n                            if (outy.charAt(outy.length - 1) === ")" && aa > 0) {\r\n                                outy                    = outy.slice(aa + 1, outy.length - 1);\r\n                                token[token.length - 1] = token[token.length - 1].slice(0, aa + 1) + value(\r\n                                    outy,\r\n                                    false\r\n                                ) + ")";\r\n                            }\r\n                        }\r\n                    } else {\r\n                        ltype = "item";\r\n                        types.push("item");\r\n                    }\r\n                },\r\n                // Some tokens receive a generic type named \'item\' because their type is unknown\r\n                // until we know the following syntax.  This function replaces the type \'item\'\r\n                // with something more specific.\r\n                item       = function csspretty__tokenize_item(type) {\r\n                    var aa    = types.length,\r\n                        bb    = 0,\r\n                        coms  = [],\r\n                        tokel = (token.length > 1)\r\n                            ? token[token.length - 2]\r\n                            : "",\r\n                        toked = tokel.slice(tokel.length - 2);\r\n                    //backtrack through immediately prior comments to find the correct token\r\n                    if (ltype === "comment" || ltype === "comment-inline") {\r\n                        do {\r\n                            aa    = aa - 1;\r\n                            ltype = types[aa];\r\n                            coms.push(token[aa]);\r\n                        } while (aa > 0 && (ltype === "comment" || ltype === "comment-inline"));\r\n                    } else {\r\n                        aa = aa - 1;\r\n                    }\r\n                    //if the last non-comment type is \'item\' then id it\r\n                    if (ltype === "item" && types[aa].indexOf("external") < 0) {\r\n                        if (type === "start") {\r\n                            stats.selectors.count = stats.selectors.count + 1;\r\n                            stats.selectors.chars = stats.selectors.chars + itemsize;\r\n                            if (types[aa - 1] !== "comment" && types[aa - 1] !== "comment-inline" && types[aa - 1] !== "end" && types[aa - 1] !== "start" && types[aa - 1] !== "semi" && types[aa - 1] !== undefined && types[aa - 1].indexOf("external") < 0) {\r\n                                (function csspretty__tokenize_item_selparts() {\r\n                                    var parts = [],\r\n                                        cc    = aa,\r\n                                        dd    = 0;\r\n                                    do {\r\n                                        parts.push(token[cc]);\r\n                                        if (lines[cc] > 0 && token[cc] === ":" && token[cc - 1] !== ":") {\r\n                                            parts.push(" ");\r\n                                        } else if (token[cc] !== ":") {\r\n                                            parts.push(" ");\r\n                                        }\r\n                                        cc = cc - 1;\r\n                                    } while (\r\n                                        cc > -1 && types[cc] !== "comment" && types[cc] !== "comment-inline" && types[cc] !== "end" && types[cc] !== "start" && types[cc] !== "semi" && types[cc] !== undefined\r\n                                    );\r\n                                    parts.reverse();\r\n                                    cc = cc + 1;\r\n                                    dd = aa - cc;\r\n                                    lines[aa] = lines[cc];\r\n                                    token.splice(cc, dd);\r\n                                    types.splice(cc, dd);\r\n                                    lines.splice(cc, dd);\r\n                                    depth.splice(cc, dd);\r\n                                    begin.splice(cc, dd);\r\n                                    aa        = aa - dd;\r\n                                    token[aa] = parts\r\n                                        .join("")\r\n                                        .replace(/:\\u0020/g, ":")\r\n                                        .replace(/(\\s*,\\s*)/g, ",");\r\n                                }());\r\n                            } else {\r\n                                token[aa] = token[aa].replace(/(\\s*,\\s*)/g, ",");\r\n                            }\r\n                            if (options.compressedcss === true) {\r\n                                token[aa] = token[aa]\r\n                                    .replace(/\\s*&/, " &")\r\n                                    .replace(/\\s*>\\s*/g, ">")\r\n                                    .replace(/:\\s+/g, ":")\r\n                                    .replace(/^(\\s+)/, "")\r\n                                    .replace(/(\\s+)$/, "");\r\n                            } else {\r\n                                token[aa] = token[aa]\r\n                                    .replace(/\\s*&/, " &")\r\n                                    .replace(/\\s*>\\s*/g, " > ")\r\n                                    .replace(/:\\s+/g, ": ")\r\n                                    .replace(/^(\\s+)/, "")\r\n                                    .replace(/(\\s+)$/, "");\r\n                            }\r\n                            (function csspretty__tokenize_item_selectorsort() {\r\n                                var y    = 0,\r\n                                    slen = token[aa].length,\r\n                                    z    = "",\r\n                                    mark = 0,\r\n                                    list = [];\r\n                                for (y = 0; y < slen; y = y + 1) {\r\n                                    if (z === "" && token[aa].charAt(y) === ",") {\r\n                                        list.push(token[aa].slice(mark, y));\r\n                                        mark = y + 1;\r\n                                    } else if (token[aa].charAt(y) === "\\"" || token[aa].charAt(y) === "\'" || token[aa].charAt(y) === "(" || token[aa].charAt(y) === "{") {\r\n                                        z = token[aa].charAt(y);\r\n                                    } else if (token[aa].charAt(y) === z && (z === "\\"" || z === "\'\'")) {\r\n                                        z = "";\r\n                                    } else if (token[aa].charAt(y) === ")" && z === "(") {\r\n                                        z = "";\r\n                                    } else if (token[aa].charAt(y) === "}" && z === "{") {\r\n                                        z = "";\r\n                                    }\r\n                                }\r\n                                list.push(token[aa].slice(mark, y));\r\n                                list.sort();\r\n                                token[aa] = list.join(",").replace(/^(\\s+)/, "");\r\n                            }());\r\n                            types[aa] = "selector";\r\n                            ltype     = "selector";\r\n                        } else if (type === "end") {\r\n                            types[aa] = "value";\r\n                            ltype     = "value";\r\n                            if (options.mode !== "diff") {\r\n                                token[aa] = token[aa].replace(/\\s*!\\s+important/, " !important");\r\n                                if (options.quoteConvert !== "none" && (token[aa - 2] === "font" || token[aa - 2] === "font-family")) {\r\n                                    token[aa] = value(token[aa], true);\r\n                                } else {\r\n                                    token[aa] = value(token[aa], false);\r\n                                }\r\n                            }\r\n                            //take comments out until the \'item\' is found and then put the comments back\r\n                            if (options.mode === "beautify" || options.mode === "parse" || (options.mode === "diff" && options.diffcomments === true)) {\r\n                                if (token[token.length - 2] === "{") {\r\n                                    types[types.length - 1] = "propvar";\r\n                                    stats.values.count      = stats.values.count - 1;\r\n                                    stats.values.chars      = stats.values.chars - itemsize;\r\n                                    stats.variables.count   = stats.variables.count + 1;\r\n                                    stats.variables.chars   = stats.variables.chars + itemsize;\r\n                                } else if (structval === "block") {\r\n                                    if (coms.length > 0 && ltype !== "semi" && ltype !== "end" && ltype !== "start") {\r\n                                        aa = coms.length - 1;\r\n                                        do {\r\n                                            token.pop();\r\n                                            types.pop();\r\n                                            lines.pop();\r\n                                            depth.pop();\r\n                                            begin.pop();\r\n                                            aa = aa - 1;\r\n                                        } while (aa > 0);\r\n                                        if (options.mode === "diff") {\r\n                                            token.push("x;");\r\n                                        } else {\r\n                                            token.push(";");\r\n                                        }\r\n                                        depth.push(structval);\r\n                                        begin.push(struct[struct.length - 1]);\r\n                                        types.push("semi");\r\n                                        lines.push(spacer(false));\r\n                                        bb = coms.length - 1;\r\n                                        do {\r\n                                            token.push(coms[aa]);\r\n                                            if (coms[aa].indexOf("//") === 0 && lines[lines.length - 1] === 0) {\r\n                                                types.push("comment-inline");\r\n                                            } else {\r\n                                                types.push("comment");\r\n                                            }\r\n                                            depth.push(structval);\r\n                                            begin.push(struct[struct.length - 1]);\r\n                                            lines.push(0);\r\n                                            aa = aa + 1;\r\n                                        } while (aa < bb);\r\n                                    } else {\r\n                                        if (options.mode === "diff") {\r\n                                            token.push("x;");\r\n                                        } else {\r\n                                            token.push(";");\r\n                                        }\r\n                                        depth.push(structval);\r\n                                        begin.push(struct[struct.length - 1]);\r\n                                        types.push("semi");\r\n                                        lines.push(spacer(false));\r\n                                    }\r\n                                }\r\n                            }\r\n                            stats.values.count = stats.values.count + 1;\r\n                            stats.values.chars = stats.values.chars + itemsize;\r\n                        } else if (type === "semi") {\r\n                            if (types[aa - 1] === "colon") {\r\n                                stats.values.count = stats.values.count + 1;\r\n                                stats.values.chars = stats.values.chars + itemsize;\r\n                                types[aa]          = "value";\r\n                                ltype              = "value";\r\n                                if (options.mode !== "diff") {\r\n                                    token[aa] = token[aa].replace(/\\s*!\\s+important/, " !important");\r\n                                    if (options.quoteConvert !== "none" && (token[aa - 2] === "font" || token[aa - 2] === "font-family")) {\r\n                                        token[aa] = value(token[aa], true);\r\n                                    } else {\r\n                                        token[aa] = value(token[aa], false);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                //properties without values are considered variables\r\n                                if (types[aa] !== "value") {\r\n                                    if (types[aa] === "item" && types[aa - 1] === "value" && (toked === "}}" || toked === "?>" || toked === "->" || toked === "%}" || toked === "%>")) {\r\n                                        if (isNaN(token[token.length - 1]) === true) {\r\n                                            token[token.length - 2] = tokel + token.pop();\r\n                                        } else {\r\n                                            token[token.length - 2] = tokel + " " + token.pop();\r\n                                        }\r\n                                        types.pop();\r\n                                        return;\r\n                                    }\r\n                                    types[aa] = "propvar";\r\n                                    ltype     = "propvar";\r\n                                }\r\n                                if (token[aa].indexOf("\\"") > 0) {\r\n                                    bb        = token[aa].indexOf("\\"");\r\n                                    a         = a - (token[aa].length - bb);\r\n                                    token[aa] = token[aa].slice(0, bb);\r\n                                    buildtoken();\r\n                                } else if (token[aa].indexOf("\'") > 0) {\r\n                                    bb        = token[aa].indexOf("\'");\r\n                                    a         = a - (token[aa].length - bb);\r\n                                    token[aa] = token[aa].slice(0, bb);\r\n                                    buildtoken();\r\n                                } else if ((/\\s/).test(token[aa]) === true) {\r\n                                    bb = token[aa]\r\n                                        .replace(/\\s/, " ")\r\n                                        .indexOf(" ");\r\n                                    if (bb < token[aa].indexOf("(") && bb < token[aa].indexOf("[")) {\r\n                                        a         = a - (token[aa].length - bb);\r\n                                        token[aa] = token[aa].slice(0, bb);\r\n                                        buildtoken();\r\n                                    }\r\n                                }\r\n                                stats.variables.count = stats.variables.count + 1;\r\n                                stats.variables.chars = stats.variables.chars + itemsize;\r\n                            }\r\n                        } else if (type === "colon") {\r\n                            types[aa]              = "property";\r\n                            ltype                  = "property";\r\n                            stats.properties.count = stats.properties.count + 1;\r\n                            stats.properties.chars = stats.properties.chars + itemsize;\r\n                        } else if (token[aa].charAt(0) === "@" && ((types[aa - 2] !== "propvar" && types[aa - 2] !== "property") || types[aa - 1] === "semi")) {\r\n                            types[aa] = "propvar";\r\n                            ltype     = "propvar";\r\n                        }\r\n                    }\r\n                },\r\n                external   = function csspretty__tokenize_external(open, end) {\r\n                    var store  = [],\r\n                        quote  = "",\r\n                        name   = "",\r\n                        endlen = 0,\r\n                        start  = open.length,\r\n                        linev  = spacer(false),\r\n                        exit   = function csspretty__tokenize_external_exit(typename) {\r\n                            var endtype = types[types.length - 2];\r\n                            if (ltype === "item") {\r\n                                if (endtype === "colon") {\r\n                                    types[types.length - 1] = "value";\r\n                                } else {\r\n                                    item(endtype);\r\n                                }\r\n                            }\r\n                            types.push(typename);\r\n                        };\r\n                    nosort[nosort.length - 1] = true;\r\n                    for (a = a; a < len; a = a + 1) {\r\n                        store.push(b[a]);\r\n                        if (quote === "") {\r\n                            if (b[a] === "\\"") {\r\n                                quote = "\\"";\r\n                            } else if (b[a] === "\'") {\r\n                                quote = "\'";\r\n                            } else if (b[a] === "/") {\r\n                                if (b[a + 1] === "/") {\r\n                                    quote = "/";\r\n                                } else if (b[a + 1] === "*") {\r\n                                    quote = "*";\r\n                                }\r\n                            } else if (b[a + 1] === end.charAt(0)) {\r\n                                do {\r\n                                    endlen = endlen + 1;\r\n                                    a      = a + 1;\r\n                                    store.push(b[a]);\r\n                                } while (a < len && endlen < end.length && b[a + 1] === end.charAt(endlen));\r\n                                if (endlen === end.length) {\r\n                                    quote = store.join("");\r\n                                    if ((/\\s/).test(quote.charAt(start)) === true) {\r\n                                        do {\r\n                                            start = start + 1;\r\n                                        } while ((/\\s/).test(quote.charAt(start)) === true);\r\n                                    }\r\n                                    endlen = start;\r\n                                    do {\r\n                                        endlen = endlen + 1;\r\n                                    } while (endlen < end.length && (/\\s/).test(quote.charAt(endlen)) === false);\r\n                                    if (endlen === quote.length) {\r\n                                        endlen = endlen - end.length;\r\n                                    }\r\n                                    if (open === "{%") {\r\n                                        if (quote.indexOf("{%-") === 0) {\r\n                                            quote = quote\r\n                                                .replace(/^(\\{%-\\s*)/, "{%- ")\r\n                                                .replace(/(\\s*-%\\})$/, " -%}");\r\n                                            name  = quote.slice(4);\r\n                                        } else {\r\n                                            quote = quote\r\n                                                .replace(/^(\\{%\\s*)/, "{% ")\r\n                                                .replace(/(\\s*%\\})$/, " %}");\r\n                                            name  = quote.slice(3);\r\n                                        }\r\n                                    }\r\n                                    if (open === "{{") {\r\n                                        quote = quote\r\n                                            .replace(/^(\\{\\{\\s+)/, "{{")\r\n                                            .replace(/(\\s+\\}\\})$/, "}}");\r\n                                    }\r\n                                    if (ltype === "item" && types[types.length - 2] === "colon" && (types[types.length - 3] === "property" || types[types.length - 3] === "propvar")) {\r\n                                        ltype                   = "value";\r\n                                        types[types.length - 1] = "value";\r\n                                        if (isNaN(token[token.length - 1]) === true && token[token.length - 1].charAt(token[token.length - 1].length - 1) !== ")") {\r\n                                            token[token.length - 1] = token[token.length - 1] + quote;\r\n                                        } else {\r\n                                            token[token.length - 1] = token[token.length - 1] + " " + quote;\r\n                                        }\r\n                                        return;\r\n                                    }\r\n                                    lines.push(linev);\r\n                                    token.push(quote);\r\n                                    begin.push(struct[struct.length - 1]);\r\n                                    depth.push(structval);\r\n                                    if (open === "{%") {\r\n                                        name = name.slice(0, name.indexOf(" "));\r\n                                        if (name.indexOf("(") > 0) {\r\n                                            name = name.slice(0, name.indexOf("("));\r\n                                        }\r\n                                        store = [\r\n                                            "autoescape",\r\n                                            "block",\r\n                                            "capture",\r\n                                            "case",\r\n                                            "comment",\r\n                                            "embed",\r\n                                            "filter",\r\n                                            "for",\r\n                                            "form",\r\n                                            "if",\r\n                                            "macro",\r\n                                            "paginate",\r\n                                            "raw",\r\n                                            "sandbox",\r\n                                            "spaceless",\r\n                                            "tablerow",\r\n                                            "unless",\r\n                                            "verbatim"\r\n                                        ];\r\n                                        if (name === "else" || name === "elseif" || name === "when" || name === "elif") {\r\n                                            return exit("external_else");\r\n                                        }\r\n                                        for (endlen = store.length - 1; endlen > -1; endlen = endlen - 1) {\r\n                                            if (name === store[endlen]) {\r\n                                                return exit("external_start");\r\n                                            }\r\n                                            if (name === "end" + store[endlen]) {\r\n                                                return exit("external_end");\r\n                                            }\r\n                                        }\r\n                                    } else if (open === "{{") {\r\n                                        name   = quote.slice(2);\r\n                                        endlen = name.length;\r\n                                        start  = 0;\r\n                                        do {\r\n                                            start = start + 1;\r\n                                        } while (\r\n                                            start < endlen && (/\\s/).test(name.charAt(start)) === false && name.charAt(start) !== "("\r\n                                        );\r\n                                        name = name.slice(0, start);\r\n                                        if (name.charAt(name.length - 2) === "}") {\r\n                                            name = name.slice(0, name.length - 2);\r\n                                        }\r\n                                        if (name === "end") {\r\n                                            return exit("external_end");\r\n                                        }\r\n                                        if (name === "block" || name === "define" || name === "form" || name === "if" || name === "range" || name === "with") {\r\n                                            return exit("external_start");\r\n                                        }\r\n                                    }\r\n                                    return exit("external");\r\n                                }\r\n                                endlen = 0;\r\n                            }\r\n                        } else if (quote === b[a]) {\r\n                            if (quote === "\\"" || quote === "\'") {\r\n                                quote = "";\r\n                            } else if (quote === "/" && (b[a] === "\\r" || b[a] === "\\n")) {\r\n                                quote = "";\r\n                            } else if (quote === "*" && b[a + 1] === "/") {\r\n                                quote = "";\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                //finds comments include those JS looking \'//\' comments\r\n                comment    = function csspretty__tokenize_comment(inline) {\r\n                    var aa        = 0,\r\n                        bb        = 0,\r\n                        out       = [b[a]],\r\n                        type      = "comment",\r\n                        extra     = "",\r\n                        spareType = [],\r\n                        spareToke = [],\r\n                        spareLine = [],\r\n                        spareBegn = [],\r\n                        spareDept = [],\r\n                        linev     = spacer(false);\r\n                    type = (inline === true && linev === 0)\r\n                        ? "comment-inline"\r\n                        : "comment";\r\n                    for (aa = a + 1; aa < len; aa = aa + 1) {\r\n                        out.push(b[aa]);\r\n                        if ((inline === false && b[aa - 1] === "*" && b[aa] === "/") || (inline === true && (b[aa + 1] === "\\n" || b[aa + 1] === "\\r"))) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (ltype === "item") {\r\n                        bb = aa;\r\n                        do {\r\n                            bb = bb + 1;\r\n                            if (b[bb] === "/") {\r\n                                if (b[bb + 1] === "*" || b[bb + 1] === "/") {\r\n                                    extra = b[bb + 1];\r\n                                } else if (b[bb - 1] === "*" && extra === "*") {\r\n                                    extra = "";\r\n                                    bb    = bb + 1;\r\n                                }\r\n                            } else if ((b[bb] === "\\n" || b[bb] === "\\r") && extra === "/") {\r\n                                extra = "";\r\n                                bb    = bb + 1;\r\n                            }\r\n                        } while (\r\n                            bb < len && ((extra === "" && (/\\s/).test(b[bb]) === true) || extra !== "")\r\n                        );\r\n                        if (b[bb] === "{") {\r\n                            item("start");\r\n                        } else if (b[bb] === "}") {\r\n                            item("end");\r\n                        } else if (b[bb] === ";") {\r\n                            item("semi");\r\n                        } else if (b[bb] === ":") {\r\n                            item("colon");\r\n                        } else {\r\n                            item();\r\n                        }\r\n                    }\r\n                    a                    = aa;\r\n                    stats.comments.count = stats.comments.count + 1;\r\n                    stats.comments.chars = stats.comments.chars + out.length;\r\n                    if (options.mode === "minify") {\r\n                        out.push(lf);\r\n                    }\r\n                    if (options.mode === "beautify" || options.mode === "parse" || (options.mode === "diff" && options.diffcomments === true) || (options.mode === "minify" && options.topcoms === true)) {\r\n                        if (token.length > 0 && (ltype === "selector" || ltype === "propvar") && types[types.length - 1] !== "comment" && types[types.length - 1] !== "comment-inline") {\r\n                            spareToke.push(token[token.length - 1]);\r\n                            token.pop();\r\n                            types.pop();\r\n                            lines.pop();\r\n                            begin.pop();\r\n                            depth.pop();\r\n                            begin.push(struct[struct.length - 1]);\r\n                            depth.push(structval);\r\n                            token.push(out.join(""));\r\n                            types.push(type);\r\n                            lines.push(linev);\r\n                            begin.push(struct[struct.length - 1]);\r\n                            depth.push(structval);\r\n                            token.push(spareToke[0]);\r\n                            if (ltype === "propvar") {\r\n                                types.push("propvar");\r\n                            } else {\r\n                                types.push("selector");\r\n                            }\r\n                            lines.push(0);\r\n                        } else if (ltype === "colon" || ltype === "property" || ltype === "value" || ltype === "propvar") {\r\n                            do {\r\n                                spareToke.push(token[token.length - 1]);\r\n                                spareType.push(types[types.length - 1]);\r\n                                spareLine.push(lines[lines.length - 1]);\r\n                                spareDept.push(depth[depth.length - 1]);\r\n                                spareBegn.push(begin[begin.length - 1]);\r\n                                token.pop();\r\n                                types.pop();\r\n                                lines.pop();\r\n                                depth.pop();\r\n                                begin.pop();\r\n                            } while (\r\n                                types.length > 1 && types[types.length - 1] !== "semi" && types[types.length - 1] !== "start"\r\n                            );\r\n                            token.push(out.join(""));\r\n                            types.push(type);\r\n                            lines.push(linev);\r\n                            depth.push(structval);\r\n                            begin.push(struct[struct.length - 1]);\r\n                            do {\r\n                                token.push(spareToke[spareToke.length - 1]);\r\n                                types.push(spareType[spareType.length - 1]);\r\n                                lines.push(spareLine[spareLine.length - 1]);\r\n                                depth.push(spareDept[spareDept.length - 1]);\r\n                                begin.push(spareBegn[spareBegn.length - 1]);\r\n                                spareToke.pop();\r\n                                spareType.pop();\r\n                                spareLine.pop();\r\n                                spareDept.pop();\r\n                                spareBegn.pop();\r\n                            } while (spareToke.length > 0);\r\n                        } else {\r\n                            ltype = type;\r\n                            types.push(type);\r\n                            token.push(out.join(""));\r\n                            lines.push(linev);\r\n                            depth.push(structval);\r\n                            begin.push(struct[struct.length - 1]);\r\n                        }\r\n                    }\r\n                },\r\n                //do fancy things to property types like: sorting, consolidating, and padding\r\n                properties = function csspretty__tokenize_properties() {\r\n                    var aa    = 0,\r\n                        bb    = 1,\r\n                        cc    = 0,\r\n                        dd    = 0,\r\n                        p     = [],\r\n                        set   = [\r\n                            []\r\n                        ],\r\n                        next  = 0,\r\n                        stoke = [],\r\n                        stype = [],\r\n                        sline = [],\r\n                        sdept = [],\r\n                        sbegn = [];\r\n                    //identify properties and build out prop/val sets\r\n                    for (aa = token.length - 1; aa > -1; aa = aa - 1) {\r\n                        if (types[aa] === "start") {\r\n                            bb = bb - 1;\r\n                            if (bb === 0) {\r\n                                next = aa;\r\n                                set.pop();\r\n                                for (aa = set.length - 1; aa > -1; aa = aa - 1) {\r\n                                    set[aa].reverse();\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (types[aa] === "end") {\r\n                            bb = bb + 1;\r\n                        }\r\n                        if (bb === 1 && (types[aa] === "property" || (types[aa] === "propvar" && types[aa + 1] === "colon")) && options.mode === "beautify") {\r\n                            p.push(aa);\r\n                        }\r\n                        set[set.length - 1].push(aa);\r\n                        if (bb === 1 && (types[aa - 1] === "comment" || types[aa - 1] === "comment-inline" || types[aa - 1] === "semi" || types[aa - 1] === "end" || types[aa - 1] === "start") && types[aa] !== "start" && types[aa] !== "end") {\r\n                            set.push([]);\r\n                        }\r\n                    }\r\n                    //this reverse fixes the order of consecutive comments\r\n                    set.reverse();\r\n                    p.reverse();\r\n\r\n                    //consolidate margin and padding\r\n                    (function csspretty__tokenize_properties_propcheck() {\r\n                        var leng      = set.length,\r\n                            fourcount = function csspretty__tokenize_properties_propcheck_fourcount(name) {\r\n                                var test     = [\r\n                                        false, false, false, false\r\n                                    ],\r\n                                    val      = [\r\n                                        "0", "0", "0", "0"\r\n                                    ],\r\n                                    zero     = (/^(0+([a-z]+|%))/),\r\n                                    start    = aa,\r\n                                    yy       = -1,\r\n                                    zz       = 0,\r\n                                    valsplit = [],\r\n                                    store    = function csspretty__tokenize_properties_propcheck_fourcount_store(side) {\r\n                                        yy         = yy + 1;\r\n                                        val[side]  = token[set[aa][2]];\r\n                                        test[side] = true;\r\n                                        if (start < 0) {\r\n                                            start = aa;\r\n                                        }\r\n                                    };\r\n                                for (aa = aa; aa < leng; aa = aa + 1) {\r\n                                    if (token[set[aa][2]] !== undefined && token[set[aa][0]].indexOf(name) === 0) {\r\n                                        if (token[set[aa][0]] === name || token[set[aa][0]].indexOf(name + " ") === 0) {\r\n                                            yy       = yy + 1;\r\n                                            valsplit = token[set[aa][2]].split(" ");\r\n                                            if (valsplit.length === 1) {\r\n                                                val = [\r\n                                                    token[set[aa][2]],\r\n                                                    token[set[aa][2]],\r\n                                                    token[set[aa][2]],\r\n                                                    token[set[aa][2]]\r\n                                                ];\r\n                                            } else if (valsplit.length === 2) {\r\n                                                val = [\r\n                                                    valsplit[0], valsplit[1], valsplit[0], valsplit[1]\r\n                                                ];\r\n                                            } else if (valsplit.length === 3) {\r\n                                                val = [\r\n                                                    valsplit[0], valsplit[1], valsplit[2], valsplit[1]\r\n                                                ];\r\n                                            } else if (valsplit.length === 4) {\r\n                                                val = [\r\n                                                    valsplit[0], valsplit[1], valsplit[2], valsplit[3]\r\n                                                ];\r\n                                            } else {\r\n                                                return;\r\n                                            }\r\n                                            test = [true, true, true, true];\r\n                                        } else if (token[set[aa][0]].indexOf(name + "-bottom") === 0) {\r\n                                            store(2);\r\n                                        } else if (token[set[aa][0]].indexOf(name + "-left") === 0) {\r\n                                            store(3);\r\n                                        } else if (token[set[aa][0]].indexOf(name + "-right") === 0) {\r\n                                            store(1);\r\n                                        } else if (token[set[aa][0]].indexOf(name + "-top") === 0) {\r\n                                            store(0);\r\n                                        }\r\n                                    }\r\n                                    if (set[aa + 1] === undefined || token[set[aa + 1][0]].indexOf(name) < 0 || aa === leng - 1) {\r\n                                        if (test[0] === true && test[1] === true && test[2] === true && test[3] === true) {\r\n                                            set.splice(start + 1, yy);\r\n                                            leng = leng - yy;\r\n                                            aa   = aa - yy;\r\n                                            zz   = 0;\r\n                                            bb   = p.length;\r\n                                            do {\r\n                                                if (p[zz] === set[start][0]) {\r\n                                                    break;\r\n                                                }\r\n                                                zz = zz + 1;\r\n                                            } while (zz < bb);\r\n                                            if (zz < bb) {\r\n                                                p.splice(zz + 1, yy);\r\n                                            }\r\n                                            token[set[start][0]] = name;\r\n                                            if (zero.test(val[0]) === true) {\r\n                                                val[0] = "0";\r\n                                            }\r\n                                            if (zero.test(val[1]) === true) {\r\n                                                val[1] = "0";\r\n                                            }\r\n                                            if (zero.test(val[2]) === true) {\r\n                                                val[2] = "0";\r\n                                            }\r\n                                            if (zero.test(val[3]) === true) {\r\n                                                val[3] = "0";\r\n                                            }\r\n                                            if (val[1] === val[3]) {\r\n                                                val.pop();\r\n                                                if (val[0] === val[2]) {\r\n                                                    val.pop();\r\n                                                    if (val[0] === val[1]) {\r\n                                                        val.pop();\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            token[set[start][2]] = val.join(" ");\r\n                                            if (token[set[start][2]].indexOf("!important") > 0) {\r\n                                                token[set[start][2]] = token[set[start][2]].replace(/\\s!important/g, "") + " !i" +\r\n                                                        "mportant";\r\n                                            }\r\n                                            if (options.mode === "beautify" && verticalop === true) {\r\n                                                if (token[set[start][0]].charAt(token[set[start][0]].length - 1) === " ") {\r\n                                                    yy = token[set[start][0]].length - name.length;\r\n                                                    do {\r\n                                                        name = name + " ";\r\n                                                        yy   = yy - 1;\r\n                                                    } while (yy > 0);\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            };\r\n                        for (aa = 0; aa < leng; aa = aa + 1) {\r\n                            if (types[set[aa][0]] === "property") {\r\n                                if (token[set[aa][0]].indexOf("margin") === 0) {\r\n                                    fourcount("margin");\r\n                                }\r\n                                if (token[set[aa][0]].indexOf("padding") === 0) {\r\n                                    fourcount("padding");\r\n                                }\r\n                            }\r\n                        }\r\n                    }());\r\n\r\n                    //pad out those property names so that the colons are vertically aligned\r\n                    if (verticalop === true) {\r\n                        bb = 0;\r\n                        for (aa = p.length - 1; aa > -1; aa = aa - 1) {\r\n                            if (token[p[aa]].length > bb && token[p[aa]] !== "filter" && token[p[aa]] !== "progid") {\r\n                                bb = token[p[aa]].length;\r\n                            }\r\n                        }\r\n                        for (aa = p.length - 1; aa > -1; aa = aa - 1) {\r\n                            cc = bb - token[p[aa]].length;\r\n                            if (cc > 0 && token[p[aa]] !== "filter" && token[p[aa]] !== "progid") {\r\n                                do {\r\n                                    token[p[aa]] = token[p[aa]] + " ";\r\n                                    cc           = cc - 1;\r\n                                } while (cc > 0);\r\n                            }\r\n                        }\r\n                        if (endtest === false) {\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    bb = set.length;\r\n                    for (aa = 0; aa < bb; aa = aa + 1) {\r\n                        dd = set[aa].length;\r\n                        for (cc = 0; cc < dd; cc = cc + 1) {\r\n                            stoke.push(token[set[aa][cc]]);\r\n                            stype.push(types[set[aa][cc]]);\r\n                            sline.push(lines[set[aa][cc]]);\r\n                            sdept.push(depth[set[aa][cc]]);\r\n                            sbegn.push(begin[set[aa][cc]]);\r\n                        }\r\n                    }\r\n                    //replace a block\'s data with sorted analyzed data\r\n                    token.splice(next + 1, token.length - next - 1);\r\n                    types.splice(next + 1, types.length - next - 1);\r\n                    lines.splice(next + 1, lines.length - next - 1);\r\n                    depth.splice(next + 1, depth.length - next - 1);\r\n                    begin.splice(next + 1, begin.length - next - 1);\r\n                    token = token.concat(stoke);\r\n                    types = types.concat(stype);\r\n                    lines = lines.concat(sline);\r\n                    depth = depth.concat(sdept);\r\n                    begin = begin.concat(sbegn);\r\n                };\r\n            //token building loop\r\n            for (a = 0; a < len; a = a + 1) {\r\n                if (ltype !== "comment" && ltype !== "comment-inline" && ltype !== "" && options.topcoms === true) {\r\n                    options.topcoms = false;\r\n                }\r\n                if ((/\\s/).test(b[a]) === true) {\r\n                    stats.space = stats.space + 1;\r\n                    space       = space + b[a];\r\n                } else if (b[a] === "/" && b[a + 1] === "*") {\r\n                    comment(false);\r\n                } else if (b[a] === "/" && b[a + 1] === "/") {\r\n                    comment(true);\r\n                } else if (b[a] === "<" && b[a + 1] === "?" && b[a + 2] === "p" && b[a + 3] === "h" && b[a + 4] === "p") {\r\n                    //php\r\n                    external("<?php", "?>");\r\n                } else if (b[a] === "<" && b[a + 1] === "%") {\r\n                    //asp\r\n                    external("<%", "%>");\r\n                } else if (b[a] === "{" && b[a + 1] === "%") {\r\n                    //asp\r\n                    external("{%", "%}");\r\n                } else if (b[a] === "{" && b[a + 1] === "{" && b[a + 2] === "{") {\r\n                    //mustache\r\n                    external("{{{", "}}}");\r\n                } else if (b[a] === "{" && b[a + 1] === "{") {\r\n                    //handlebars\r\n                    external("{{", "}}");\r\n                } else if (b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] === "#") {\r\n                    //ssi\r\n                    external("\x3c!--#", "--\x3e");\r\n                } else if (b[a] === "@" && b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (b[a + 5] === "{" || (/\\s/).test(b[a + 5]) === true)) {\r\n                    types.push("external_else");\r\n                    token.push("@else");\r\n                    lines.push(0);\r\n                    depth.push(depth[depth.length - 1]);\r\n                    begin.push(begin[begin.length - 1]);\r\n                    a = a + 4;\r\n                } else if (b[a] === "{" || (b[a] === "(" && token[token.length - 1] === ":" && types[types.length - 2] === "propvar")) {\r\n                    if (b[a] === "{" && token[token.length - 2] === ":") {\r\n                        types[types.length - 1] = "pseudo";\r\n                    }\r\n                    item("start");\r\n                    struct.push(token.length);\r\n                    ltype = "start";\r\n                    types.push("start");\r\n                    token.push(b[a]);\r\n                    begin.push(token.length);\r\n                    if (b[a] === "(") {\r\n                        structval = "map";\r\n                        depth.push("map");\r\n                        mapper.push(0);\r\n                    } else {\r\n                        structval = "block";\r\n                        depth.push("block");\r\n                    }\r\n                    nosort.push(false);\r\n                    lines.push(spacer(false));\r\n                    stats.braces = stats.braces + 1;\r\n                } else if (b[a] === "}" || (b[a] === ")" && structval === "map" && mapper[mapper.length - 1] === 0)) {\r\n                    endtest = true;\r\n                    if (b[a] === "}" && types[types.length - 1] === "item" && token[token.length - 2] === "{" && token[token.length - 3] !== undefined && token[token.length - 3].charAt(token[token.length - 3].length - 1) === "@") {\r\n                        token[token.length - 3] = token[token.length - 3] + "{" + token[token.length - 1] +\r\n                                "}";\r\n                        token.pop();\r\n                        token.pop();\r\n                        types.pop();\r\n                        types.pop();\r\n                        lines.pop();\r\n                        lines.pop();\r\n                        depth.pop();\r\n                        depth.pop();\r\n                        begin.pop();\r\n                        begin.pop();\r\n                    } else {\r\n                        if (b[a] === ")") {\r\n                            mapper.pop();\r\n                        } else if (b[a] === "}" && ltype === "value" && token[token.length - 1] !== ";") {\r\n                            token.push(";");\r\n                            types.push("semi");\r\n                            lines.push(0);\r\n                            depth.push("block");\r\n                            begin.push(begin[begin.length - 1]);\r\n                        }\r\n                        item("end");\r\n                        if (options.mode !== "diff") {\r\n                            properties();\r\n                        }\r\n                        ltype = "end";\r\n                        if (objsortop === true && nosort[nosort.length - 1] === false) {\r\n                            objSort();\r\n                        }\r\n                        nosort.pop();\r\n                        types.push("end");\r\n                        token.push(b[a]);\r\n                        lines.push(spacer(false));\r\n                        depth.push(structval);\r\n                        begin.push(struct[struct.length - 1]);\r\n                        stats.braces = stats.braces + 1;\r\n                    }\r\n                    struct.pop();\r\n                    if (token[struct[struct.length - 1]] === "{") {\r\n                        structval = "block";\r\n                    } else if (token[struct[struct.length - 1]] === "(") {\r\n                        structval = "map";\r\n                    } else {\r\n                        structval = "root";\r\n                    }\r\n                } else if (b[a] === ";" || (b[a] === "," && structval === "map")) {\r\n                    item("semi");\r\n                    if (types[types.length - 1] !== "semi" && types[types.length - 1] !== "start" && esctest(a) === false) {\r\n                        ltype = "semi";\r\n                        types.push("semi");\r\n                        token.push(b[a]);\r\n                        lines.push(spacer(false));\r\n                        depth.push(structval);\r\n                        begin.push(begin[begin.length - 1]);\r\n                    }\r\n                    stats.semi = stats.semi + 1;\r\n                    space      = "";\r\n                } else if (b[a] === ":" && types[types.length - 1] !== "end") {\r\n                    item("colon");\r\n                    types.push("colon");\r\n                    token.push(":");\r\n                    if ((/\\s/).test(b[a - 1]) === true) {\r\n                        lines.push(1);\r\n                    } else {\r\n                        lines.push(0);\r\n                    }\r\n                    ltype       = "colon";\r\n                    stats.colon = stats.colon + 1;\r\n                    space       = "";\r\n                } else {\r\n                    if (structval === "map" && b[a] === "(") {\r\n                        mapper[mapper.length - 1] = mapper[mapper.length - 1] + 1;\r\n                    }\r\n                    buildtoken();\r\n                }\r\n            }\r\n            if (endtest === false && verticalop === true) {\r\n                properties();\r\n            }\r\n        }());\r\n\r\n        if (options.mode === "parse") {\r\n            return (function csspretty__parse() {\r\n                var a      = 0,\r\n                    c      = token.length,\r\n                    record = [],\r\n                    def    = {\r\n                        token: "string - The parsed code tokens",\r\n                        types: "string - Data types of the tokens: colon, comment, comment-inline, end, extern" +\r\n                                "al, external_else, external_end, external_start, item, propvar, pseudo, select" +\r\n                                "or, semi, start, value",\r\n                        lines: "number - Whether the token is preceeded any space and/or line breaks in the or" +\r\n                                "iginal code source",\r\n                        depth: "string - Type of current structure",\r\n                        begin: "number - Index where current structure begins"\r\n                    };\r\n                if (options.parseFormat === "sequential") {\r\n                    for (a = 0; a < c; a = a + 1) {\r\n                        record.push([\r\n                            token[a], types[a], lines[a], depth[a], begin[a]\r\n                        ]);\r\n                    }\r\n                    if (options.nodeasync === true) {\r\n                        return [\r\n                            {\r\n                                data      : record,\r\n                                definition: def\r\n                            },\r\n                            ""\r\n                        ];\r\n                    }\r\n                    return {data: record, definition: def};\r\n                }\r\n                if (options.parseFormat === "htmltable") {\r\n                    return (function csspretty__parse_html() {\r\n                        var report = [],\r\n                            aa     = 0,\r\n                            len    = 0;\r\n                        report.push("<table summary=\'CSS parse table\'><thead><tr><th>index</th>");\r\n                        report.push("<th>token</th>");\r\n                        report.push("<th>types</th>");\r\n                        report.push("<th>lines</th>");\r\n                        report.push("<th>depth</th>");\r\n                        report.push("<th>begin</th>");\r\n                        report.push("</tr></thead><tbody>");\r\n                        len = token.length;\r\n                        for (aa = 0; aa < len; aa = aa + 1) {\r\n                            report.push("<tr><td>");\r\n                            report.push(aa);\r\n                            report.push("</td><td>");\r\n                            report.push(\r\n                                token[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\r\n                            );\r\n                            report.push("</td><td>");\r\n                            report.push(types[aa]);\r\n                            report.push("</td><td>");\r\n                            report.push(lines[aa]);\r\n                            report.push("</td><td>");\r\n                            report.push(depth[aa]);\r\n                            report.push("</td><td>");\r\n                            report.push(begin[aa]);\r\n                            report.push("</td></tr>");\r\n                        }\r\n                        report.push("</tbody></table>");\r\n                        if (options.nodeasync === true) {\r\n                            return [\r\n                                {\r\n                                    data      : report.join(""),\r\n                                    definition: def\r\n                                },\r\n                                ""\r\n                            ];\r\n                        }\r\n                        return {data: report.join(""), definition: def};\r\n                    }());\r\n                }\r\n                if (options.nodeasync === true) {\r\n                    return [\r\n                        {\r\n                            data      : {\r\n                                token: token,\r\n                                types: types,\r\n                                lines: lines,\r\n                                depth: depth,\r\n                                begin: begin\r\n                            },\r\n                            definition: def\r\n                        },\r\n                        ""\r\n                    ];\r\n                }\r\n                return {\r\n                    data      : {\r\n                        token: token,\r\n                        types: types,\r\n                        lines: lines,\r\n                        depth: depth,\r\n                        begin: begin\r\n                    },\r\n                    definition: def\r\n                };\r\n            }());\r\n        }\r\n\r\n        //analysis\r\n        if (options.mode === "analysis") {\r\n            return (function csspretty__summary() {\r\n                var summ  = [],\r\n                    inl   = options.source.length,\r\n                    out   = output.length,\r\n                    uris  = uri.length,\r\n                    uric  = 0,\r\n                    a     = 0,\r\n                    b     = 0,\r\n                    color = [];\r\n                (function csspretty_summary_colorNormalize() {\r\n                    var aa = 0,\r\n                        bb = 0,\r\n                        cc = colors.length;\r\n                    colors.sort();\r\n                    color.push(colors[0]);\r\n                    for (aa = 0; aa < cc; aa = aa + 1) {\r\n                        if (colors[aa] !== color[bb]) {\r\n                            color.push(colors[aa]);\r\n                            bb = bb + 1;\r\n                        }\r\n                    }\r\n                }());\r\n                summ.push(\r\n                    "<div class=\'report\' id=\'cssreport\'><p><strong>Number of HTTP requests:</strong" +\r\n                    "> <em>"\r\n                );\r\n                summ.push(uris);\r\n                summ.push(\r\n                    "</em></p><table class=\'analysis\' id=\'css-parts\' summary=\'Component counts and " +\r\n                    "sizes\'><caption>Component counts and sizes</caption><thead><tr><th>Type Name</" +\r\n                    "th><th>Quantity</th><th>Character Size</th></tr></thead><tbody><tr><th>curly b" +\r\n                    "races</th><td>"\r\n                );\r\n                summ.push(stats.braces);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.braces);\r\n                summ.push("</td></tr><tr><th>colon</th><td>");\r\n                summ.push(stats.colon);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.colon);\r\n                summ.push("</td></tr><tr><th>comments</th><td>");\r\n                summ.push(stats.comments.count);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.comments.chars);\r\n                summ.push("</td></tr><tr><th>properties</th><td>");\r\n                summ.push(stats.properties.count);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.properties.chars);\r\n                summ.push("</td></tr><tr><th>selectors</th><td>");\r\n                summ.push(stats.selectors.count);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.selectors.chars);\r\n                summ.push("</td></tr><tr><th>semicolons</th><td>");\r\n                summ.push(stats.semi);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.semi);\r\n                summ.push("</td></tr><tr><th>white space</th><td>");\r\n                summ.push(stats.space);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.space);\r\n                summ.push("</td></tr><tr><th>values</th><td>");\r\n                summ.push(stats.values.count);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.values.chars);\r\n                summ.push("</td></tr><tr><th>variables</th><td>");\r\n                summ.push(stats.variables.count);\r\n                summ.push("</td><td>");\r\n                summ.push(stats.variables.chars);\r\n                summ.push(\r\n                    "</td></tr></tbody></table><table class=\'analysis\' id=\'css-size\' summary=\'CSS c" +\r\n                    "haracter size change\'><caption>CSS character size change</caption><tbody><tr><" +\r\n                    "th>Input</th><td>"\r\n                );\r\n                summ.push(inl);\r\n                summ.push("</td></tr><tr><th>Output</th><td>");\r\n                summ.push(out);\r\n                summ.push("</td></tr><tr><th>");\r\n                if (out > inl) {\r\n                    summ.push("Increase</th><td>");\r\n                    summ.push(out - inl);\r\n                    summ.push("</td></tr><tr><th>Percent Change</th><td>");\r\n                    a = (((out - inl) / out) * 100);\r\n                    summ.push(a.toFixed(2));\r\n                } else {\r\n                    summ.push("Decrease</th><td>");\r\n                    summ.push(inl - out);\r\n                    summ.push("</td></tr><tr><th>Percent Change</th><td>");\r\n                    a = (((inl - out) / inl) * 100);\r\n                    summ.push(a.toFixed(2));\r\n                }\r\n                summ.push(\r\n                    "%</td></tr></tbody></table><table class=\'analysis\' id=\'css-uri\' summary=\'A lis" +\r\n                    "t of HTTP requests\'><caption>A List of HTTP Requests</caption><thead><tr><th>Q" +\r\n                    "uantity</th><th>URI</th></tr></thead><tbody>"\r\n                );\r\n                for (a = 0; a < uris; a = a + 1) {\r\n                    uric = 1;\r\n                    for (b = a + 1; b < uris; b = b + 1) {\r\n                        if (uri[a] === uri[b]) {\r\n                            uric = uric + 1;\r\n                            uri.splice(b, 1);\r\n                            uris = uris - 1;\r\n                        }\r\n                    }\r\n                    summ.push("<tr><td>");\r\n                    summ.push(uric);\r\n                    summ.push("</td><td>");\r\n                    summ.push(\r\n                        uri[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                    );\r\n                    summ.push("</td></tr>");\r\n                }\r\n                summ.push("</tbody></table>");\r\n                summ.push("</div><span class=\'clear\'></span>");\r\n                if (color.length === 0) {\r\n                    summ.push("<h4>0 colors were identified in the provided code.</h4>");\r\n                } else {\r\n                    summ.push("<h4>These ");\r\n                    summ.push(color.length);\r\n                    if (color.length > 1) {\r\n                        summ.push(" different");\r\n                    }\r\n                    summ.push(" color");\r\n                    if (color.length > 1) {\r\n                        summ.push("s");\r\n                    }\r\n                    summ.push(" were identified in the provided code:</h4><p>");\r\n                    summ.push(color.join(", "));\r\n                    summ.push("</p>");\r\n                    if (options.accessibility === true) {\r\n                        (function csspretty__summary_colorConvert() {\r\n                            var vl        = "",\r\n                                bb        = color.length,\r\n                                aa        = 0,\r\n                                luminance = function csspretty__summary_colorConvert_luminance(rgb) {\r\n                                    var convert = function csspretty__summary_colorConvert_luminance_convert(x) {\r\n                                        if (x === 0) {\r\n                                            return 0;\r\n                                        }\r\n                                        x = (x / 255);\r\n                                        if ((x * 100000) <= 3928) {\r\n                                            return ((x * 100) / 1292) * 10000;\r\n                                        }\r\n                                        x = x * 100000;\r\n                                        return Math.pow(((x + 5500) / 105500), 2.4) * 10000;\r\n                                    };\r\n                                    return (\r\n                                        (2126 * convert(rgb[0])) + (7152 * convert(rgb[1])) + (722 * convert(rgb[2]))\r\n                                    ) / 100000000;\r\n                                },\r\n                                hexToDec  = function csspretty__summary_colorConvert_hexToDec(val) {\r\n                                    var str = val\r\n                                            .slice(1)\r\n                                            .split(""),\r\n                                        rgb = [],\r\n                                        num = [],\r\n                                        aaa = 0,\r\n                                        bbb = str.length;\r\n                                    for (aaa = 0; aaa < bbb; aaa = aaa + 1) {\r\n                                        if (str[aaa] === "a") {\r\n                                            num.push(10);\r\n                                        } else if (str[aaa] === "b") {\r\n                                            num.push(11);\r\n                                        } else if (str[aaa] === "c") {\r\n                                            num.push(12);\r\n                                        } else if (str[aaa] === "d") {\r\n                                            num.push(13);\r\n                                        } else if (str[aaa] === "e") {\r\n                                            num.push(14);\r\n                                        } else if (str[aaa] === "f") {\r\n                                            num.push(15);\r\n                                        } else {\r\n                                            num.push(Number(str[aaa]));\r\n                                        }\r\n                                    }\r\n                                    if (bbb === 3) {\r\n                                        rgb.push((num[0] * 16) + num[0]);\r\n                                        rgb.push((num[1] * 16) + num[1]);\r\n                                        rgb.push((num[2] * 16) + num[2]);\r\n                                    } else {\r\n                                        rgb.push((num[0] * 16) + num[1]);\r\n                                        rgb.push((num[2] * 16) + num[3]);\r\n                                        rgb.push((num[4] * 16) + num[5]);\r\n                                    }\r\n                                    return luminance(rgb);\r\n                                },\r\n                                rgbToDec  = function csspretty__summary_colorConvert_rgbToDec(val) {\r\n                                    var rgb  = [],\r\n                                        rgbs = [],\r\n                                        rr   = 0;\r\n                                    if (vl.charAt(3) === "a") {\r\n                                        vl   = vl\r\n                                            .slice(5, vl.length - 1)\r\n                                            .replace(/\\s+/g, "");\r\n                                        rgbs = vl.split(",");\r\n                                        rgbs.pop();\r\n                                    } else {\r\n                                        vl   = vl\r\n                                            .slice(4, vl.length - 1)\r\n                                            .replace(/\\s+/g, "");\r\n                                        rgbs = vl.split(",");\r\n                                    }\r\n                                    do {\r\n                                        if ((/^([0-9a-f]{2})$/).test(rgbs[rr]) === false) {\r\n                                            if (rgbs[rr].charAt(rgbs[rr].length - 1) === "%") {\r\n                                                vl = rgbs[rr].slice(0, rgbs[rr].length - 1);\r\n                                                if (isNaN(vl) === true) {\r\n                                                    return val;\r\n                                                }\r\n                                                rgb.push(Number(vl));\r\n                                                if (rgb[rr] < 0) {\r\n                                                    rgb[rr] = 0;\r\n                                                } else if (rgb[rr] > 100) {\r\n                                                    rgb[rr] = 100;\r\n                                                }\r\n                                                rgb[rr] = Math.round(2.55 * rgb[rr]);\r\n                                            } else {\r\n                                                if (isNaN(rgbs[rr]) === true) {\r\n                                                    return val;\r\n                                                }\r\n                                                rgb.push(Number(rgbs[rr]));\r\n                                                if (rgb[rr] < 0) {\r\n                                                    rgb[rr] = 0;\r\n                                                } else if (rgb[rr] > 255) {\r\n                                                    rgb[rr] = 255;\r\n                                                }\r\n                                                rgb[rr] = Math.round(rgb[rr]);\r\n                                            }\r\n                                        }\r\n                                        rr = rr + 1;\r\n                                    } while (rr < 3);\r\n                                    return luminance(rgb);\r\n                                };\r\n                            colors = [];\r\n                            for (aa = 0; aa < bb; aa = aa + 1) {\r\n                                if (color[aa] === undefined) {\r\n                                    break;\r\n                                }\r\n                                vl = color[aa].toLowerCase();\r\n                                if ((/^(#[0-9a-f]{3,6})$/).test(vl) === true) {\r\n                                    colors.push(hexToDec(vl.slice(1)));\r\n                                } else if ((/^(rgba?\\()/).test(vl) === true) {\r\n                                    colors.push(rgbToDec(vl));\r\n                                } else if (colorNames[vl] !== undefined) {\r\n                                    colors.push(colorNames[vl]);\r\n                                }\r\n                            }\r\n                        }());\r\n                    }\r\n                }\r\n                if (options.nodeasync === true) {\r\n                    return [summ.join(""), ""];\r\n                }\r\n                return summ.join("");\r\n            }());\r\n        }\r\n\r\n        //beautification\r\n        if (options.mode !== "minify") {\r\n            output = (function csspretty__beautify() {\r\n                var a        = 0,\r\n                    len      = token.length,\r\n                    build    = [],\r\n                    indent   = options.inlevel,\r\n                    mixin    = false,\r\n                    //a single unit of indentation\r\n                    tab      = (function csspretty__beautify_tab() {\r\n                        var aa = 0,\r\n                            bb = [];\r\n                        for (aa = 0; aa < options.insize; aa = aa + 1) {\r\n                            bb.push(options.inchar);\r\n                        }\r\n                        return bb.join("");\r\n                    }()),\r\n                    //new lines plus indentation\r\n                    nl       = function csspretty__beautify_nl(tabs) {\r\n                        var aa = 0;\r\n                        if (build[build.length - 1] === tab) {\r\n                            do {\r\n                                build.pop();\r\n                            } while (build[build.length - 1] === tab);\r\n                        }\r\n                        build.push(lf);\r\n                        for (aa = 0; aa < tabs; aa = aa + 1) {\r\n                            build.push(tab);\r\n                        }\r\n                    },\r\n                    //breaks selector lists onto newlines\r\n                    selector = function csspretty__beautify_selector(item) {\r\n                        var aa    = 0,\r\n                            bb    = 0,\r\n                            cc    = 0,\r\n                            block = "",\r\n                            items = [],\r\n                            leng  = item.length;\r\n                        if (options.compressedcss === true && (/\\)\\s*when\\s*\\(/).test(item) === true) {\r\n                            item = item.replace(\r\n                                /\\)\\s*when\\s*\\(/,\r\n                                ")" + lf + (function csspretty__beautify_selector_whenTab() {\r\n                                    var wtab = "",\r\n                                        aaa  = indent + 1;\r\n                                    do {\r\n                                        wtab = wtab + tab;\r\n                                        aaa  = aaa - 1;\r\n                                    } while (aaa > 0);\r\n                                    return wtab;\r\n                                }()) + "when ("\r\n                            );\r\n                        }\r\n                        for (aa = 0; aa < leng; aa = aa + 1) {\r\n                            if (block === "") {\r\n                                if (item.charAt(aa) === "\\"") {\r\n                                    block = "\\"";\r\n                                    bb    = bb + 1;\r\n                                } else if (item.charAt(aa) === "\'") {\r\n                                    block = "\'";\r\n                                    bb    = bb + 1;\r\n                                } else if (item.charAt(aa) === "(") {\r\n                                    block = ")";\r\n                                    bb    = bb + 1;\r\n                                } else if (item.charAt(aa) === "[") {\r\n                                    block = "]";\r\n                                    bb    = bb + 1;\r\n                                }\r\n                            } else if ((item.charAt(aa) === "(" && block === ")") || (item.charAt(aa) === "[" && block === "]")) {\r\n                                bb = bb + 1;\r\n                            } else if (item.charAt(aa) === block) {\r\n                                bb = bb - 1;\r\n                                if (bb === 0) {\r\n                                    block = "";\r\n                                }\r\n                            }\r\n                            if (block === "" && item.charAt(aa) === ",") {\r\n                                items.push(item.substring(cc, aa + 1));\r\n                                cc = aa + 1;\r\n                            }\r\n                        }\r\n                        if (cc > 0) {\r\n                            items.push(item.substr(cc));\r\n                        }\r\n                        leng = items.length;\r\n                        if (leng === 0) {\r\n                            items.push(item);\r\n                        }\r\n                        if (options.selectorlist === true) {\r\n                            build.push(items.join(" "));\r\n                        } else {\r\n                            build.push(items[0].replace(/,(\\s*)/g, ", ").replace(/(,\\u0020)$/, ","));\r\n                            for (aa = 1; aa < leng; aa = aa + 1) {\r\n                                nl(indent);\r\n                                build.push(items[aa].replace(/,(\\s*)/g, ", ").replace(/(,\\u0020)$/, ","));\r\n                            }\r\n                        }\r\n                        if (options.compressedcss === false) {\r\n                            build.push(" ");\r\n                        }\r\n                    };\r\n                if (options.inlevel > 0) {\r\n                    a = options.inlevel;\r\n                    do {\r\n                        a = a - 1;\r\n                        build.push(tab);\r\n                    } while (a > 0);\r\n                }\r\n\r\n                //beautification loop\r\n                for (a = 0; a < len; a = a + 1) {\r\n                    if (lines[a] > 1 && options.compressedcss === false && (types[a] === "start" || types[a] === "end" || types[a] === "selector" || types[a] === "comment" || types[a] === "property" || types[a] === "propvar" || types[a].indexOf("external") > -1)) {\r\n                        if (options.cssinsertlines === true && types[a] === "selector" && types[a - 1] !== "comment") {\r\n                            lines[a] = lines[a] - 1;\r\n                        }\r\n                        if (build[build.length - 1] === tab) {\r\n                            do {\r\n                                build.pop();\r\n                            } while (build[build.length - 1] === tab);\r\n                        }\r\n                        if (lines[a] > 1) {\r\n                            if (lines[a] > 2) {\r\n                                do {\r\n                                    lines[a] = lines[a] - 1;\r\n                                    build.push(lf);\r\n                                } while (lines[a] > 2);\r\n                            }\r\n                            nl(indent);\r\n                        }\r\n                    }\r\n                    if (types[a] === "start") {\r\n                        if (types[a - 1] === "propvar" && options.compressedcss === false) {\r\n                            build.push(" ");\r\n                        }\r\n                        if (a > 0 && token[a - 1].charAt(token[a - 1].length - 1) === "#") {\r\n                            build.push(token[a]);\r\n                        } else {\r\n                            if (options.braces === true) {\r\n                                if (build[build.length - 1] === " ") {\r\n                                    build.pop();\r\n                                }\r\n                                nl(indent);\r\n                            } else if (types[a - 1] === "colon") {\r\n                                build.push(" ");\r\n                            }\r\n                            build.push(token[a]);\r\n                            indent = indent + 1;\r\n                            if (types[a + 1] !== "end" && (options.compressedcss === false || (options.compressedcss === true && types[a + 1] === "start")) && (types[a + 1] !== "selector" || options.cssinsertlines === false)) {\r\n                                nl(indent);\r\n                            }\r\n                        }\r\n                    } else if (types[a] === "end") {\r\n                        if (types[a + 1] === "external_else") {\r\n                            indent = indent - 1;\r\n                            nl(indent);\r\n                            build.push(token[a]);\r\n                            build.push(" ");\r\n                            build.push(token[a + 1]);\r\n                            build.push(" ");\r\n                            a = a + 1;\r\n                        } else if (mixin === true) {\r\n                            mixin = false;\r\n                            build.push(token[a]);\r\n                            build.push(" ");\r\n                        } else {\r\n                            indent = indent - 1;\r\n                            if (types[a - 1] !== "start" && options.compressedcss === false) {\r\n                                nl(indent);\r\n                            }\r\n                            build.push(token[a]);\r\n                            if (options.compressedcss === true && types[a + 1] === "end") {\r\n                                nl(indent - 1);\r\n                            } else if (options.cssinsertlines === true && types[a + 1] === "selector" && lines[a] < 2 && token[a - 1] !== "{") {\r\n                                build.push(lf);\r\n                            } else if (types[a + 1] !== "end" && types[a + 1] !== "semi" && types[a + 1] !== "comment") {\r\n                                nl(indent);\r\n                            }\r\n                        }\r\n                    } else if (types[a] === "semi") {\r\n                        if (token[a] !== "x;" && (options.compressedcss === false || (options.compressedcss === true && types[a + 1] !== "end"))) {\r\n                            build.push(token[a]);\r\n                        }\r\n                        if (types[a + 1] === "comment-inline") {\r\n                            build.push(" ");\r\n                        } else if (types[a + 1] !== "end" && types[a + 1] !== "comment" && options.compressedcss === false) {\r\n                            if (options.cssinsertlines === true && types[a + 1] === "selector") {\r\n                                build.push(lf);\r\n                            } else if (lines[a + 1] > 0 || (types[a + 1] !== undefined && types[a + 1].indexOf("external") < 0)) {\r\n                                nl(indent);\r\n                            }\r\n                        }\r\n                    } else if (types[a] === "selector") {\r\n                        if (a > 0 && types[a - 1] !== "comment" && (options.cssinsertlines === true || (options.compressedcss === true && (types[a - 1] === "start" || types[a - 1] === "semi")))) {\r\n                            nl(indent);\r\n                        }\r\n                        if (token[a].charAt(token[a].length - 1) === "#") {\r\n                            build.push(token[a]);\r\n                            mixin = true;\r\n                        } else if (token[a].indexOf(",") > -1) {\r\n                            selector(token[a]);\r\n                        } else {\r\n                            if (token[a].charAt(0) === ":" && token[a - 1] === "}" && build[build.length - 1] === " ") {\r\n                                build.pop();\r\n                            }\r\n                            build.push(token[a]);\r\n                            if (options.compressedcss === false) {\r\n                                build.push(" ");\r\n                            }\r\n                        }\r\n                    } else if ((types[a] === "comment" || types[a] === "comment-inline") && types[a - 1] !== "colon" && types[a - 1] !== "property") {\r\n                        if (types[a - 1] === "value" && types[a] === "comment-inline") {\r\n                            build.push(" ");\r\n                        }\r\n                        if (a > 0 && options.compressedcss === true && types[a] === "comment" && types[a - 1] !== "comment") {\r\n                            build.push(lf);\r\n                            nl(indent);\r\n                        } else if (a > 0 && types[a - 1] !== "start" && types[a] !== "comment-inline") {\r\n                            nl(indent);\r\n                        }\r\n                        build.push(token[a]);\r\n                        if (types[a + 1] !== "end" && types[a + 1] !== "comment") {\r\n                            nl(indent);\r\n                        }\r\n                    } else {\r\n                        if (types[a - 1] !== "semi" && options.compressedcss === false && (mixin === false || token[a - 1] === ":") && token[a - 2] !== "filter" && token[a - 2] !== "progid") {\r\n                            if (types[a] === "value" || (types[a].indexOf("external") > -1 && types[a - 1] === "colon")) {\r\n                                build.push(" ");\r\n                            }\r\n                        } else if (options.compressedcss === true && (types[a] === "value" || types[a] === "propvar")) {\r\n                            token[a] = token[a].replace(/(\\s*,\\s*)/g, ",");\r\n                        }\r\n                        if (types[a] === "external_start") {\r\n                            indent = indent + 1;\r\n                        } else if (types[a] === "external_end") {\r\n                            indent = indent - 1;\r\n                            if (build[build.length - 1] === tab) {\r\n                                build.pop();\r\n                            }\r\n                        } else if (types[a] === "external_else" && build[build.length - 1] === tab) {\r\n                            build.pop();\r\n                        }\r\n                        build.push(token[a]);\r\n                        if (types[a].indexOf("external") > -1 && types[a + 1] !== "semi") {\r\n                            if ((types[a + 1] !== undefined && types[a + 1].indexOf("external") > -1) || (lines[a + 1] === 1 && types[a + 1] !== "end") || lines[a + 1] > 1) {\r\n                                nl(indent);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (options.newline === true) {\r\n                    if (options.crlf === true) {\r\n                        build.push("\\r\\n");\r\n                    } else {\r\n                        build.push("\\n");\r\n                    }\r\n                }\r\n                if (options.preserve > 0 && (lines[lines.length - 1] > 0 || endline === true)) {\r\n                    return build\r\n                        .join("")\r\n                        .replace(/(\\s+)$/, lf);\r\n                }\r\n                return build\r\n                    .join("")\r\n                    .replace(/(\\s+)$/, "");\r\n            }());\r\n        } else {\r\n            if (options.newline === true) {\r\n                if (options.crlf === true) {\r\n                    output.push("\\r\\n");\r\n                } else {\r\n                    output.push("\\n");\r\n                }\r\n            }\r\n            output = token\r\n                .join("")\r\n                .replace(/;\\}/g, "}");\r\n        }\r\n        if (options.nodeasync === true) {\r\n            return [output, ""];\r\n        }\r\n        return output;\r\n    };\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function csspretty_requirejs() {\r\n            return function csspretty_requirejs_wrapper(x) {\r\n                return csspretty(x);\r\n            };\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = csspretty;\r\n    } else {\r\n        global.prettydiff.csspretty = csspretty;\r\n    }\r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(40))},function(n,e){n.exports='/*prettydiff.com api.topcoms:true,api.insize:4,api.inchar:" ",api.vertical:true */\r\n/*global ace, define, global, module*/\r\n/***********************************************************************\r\n csvpretty is written by Austin Cheney on 2 Oct 2015.\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n **********************************************************************/\r\n(function () {\r\n    "use strict";\r\n    var csvpretty = function csvpretty_(options) {\r\n        var token = [];\r\n        options.csvchar = (typeof options.csvchar === "string")\r\n            ? options.csvchar\r\n            : ",";\r\n        options.source  = (\r\n            typeof options.source !== "string" || options.source === "" || (/^(\\s+)$/).test(options.source) === true\r\n        )\r\n            ? "Error: no source supplied to csvpretty."\r\n            : options\r\n                .source\r\n                .replace(/\\r\\n/g, "\\n")\r\n                .replace(/\\r/g, "\\n");\r\n        (function csvpretty__tokenize() {\r\n            var input      = options\r\n                    .source\r\n                    .split(""),\r\n                d          = options.csvchar.length,\r\n                e          = 0,\r\n                cell       = [],\r\n                row        = [],\r\n                quote      = false,\r\n                cellCrunch = function csvpretty__tokenize_cellCrunch() {\r\n                    var str = cell.join("");\r\n                    cell = [];\r\n                    if (str !== "") {\r\n                        row.push(str);\r\n                    }\r\n                },\r\n                parse      = function csvpretty__tokenize_parse(item, index, arr) {\r\n                    if (quote === false) {\r\n                        if (cell.length === 0 && item === "\\"" && (arr[index + 1] !== "\\"" || arr[index + 2] === "\\"")) {\r\n                            quote = true;\r\n                        } else if (item === "\\"" && arr[index + 1] === "\\"") {\r\n                            cell.push("\\"");\r\n                            arr[index + 1] = "";\r\n                        } else if (item === "\\n") {\r\n                            cellCrunch();\r\n                            token.push(row);\r\n                            row = [];\r\n                        } else if (item === options.csvchar.charAt(0)) {\r\n                            if (d === 1) {\r\n                                cellCrunch();\r\n                            } else {\r\n                                e = 0;\r\n                                do {\r\n                                    e = e + 1;\r\n                                } while (e < d && arr[index + e] === options.csvchar.charAt(e));\r\n                                if (e === d) {\r\n                                    cellCrunch();\r\n                                    e = 1;\r\n                                    do {\r\n                                        arr[index + e] = "";\r\n                                        e              = e + 1;\r\n                                    } while (e < d);\r\n                                } else if (item !== "") {\r\n                                    cell.push(item);\r\n                                }\r\n                            }\r\n                        } else if (item !== "") {\r\n                            cell.push(item);\r\n                        }\r\n                    } else if (item !== "\\"" && item !== "") {\r\n                        cell.push(item);\r\n                    } else if (item === "\\"" && arr[index + 1] === "\\"") {\r\n                        cell.push("\\"");\r\n                        arr[index + 1] = "";\r\n                    } else if (item === "\\"") {\r\n                        cellCrunch();\r\n                        quote = false;\r\n                    }\r\n                };\r\n            input.forEach(parse);\r\n            if (cell.length > 0) {\r\n                cellCrunch();\r\n                token.push(row);\r\n            }\r\n        }());\r\n        return token;\r\n    };\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function csvpretty_requirejs() {\r\n            return function csvpretty_requirejs_wrapper(x) {\r\n                return csvpretty(x);\r\n            };\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = function commonjs_csvpretty(x) {\r\n            return csvpretty(x);\r\n        };\r\n    } else {\r\n        global.prettydiff.csvpretty = csvpretty;\r\n    }\r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(42))},function(n,e){n.exports='/*global ace, define, global, module*/\r\n/*jshint laxbreak: true*/\r\n/*\r\n\r\nWritten by Austin Cheney on 1 Mar 2017\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n\r\n * Output - an array of three indexes:\r\n * 1) Diff result as a HTML table\r\n * 2) Number of errors after the number of error lines used for total\r\n *    total error count when added to the next index\r\n * 3) Number of error lines in the HTML table\r\n */\r\n(function () {\r\n    "use strict";\r\n    var diffview = function diffview_(options) {\r\n        (function diffview__options() {\r\n            if (typeof options.diff === "string") {\r\n                if (options.functions !== undefined) {\r\n                    options.diff = options\r\n                        .diff\r\n                        .replace(options.functions.binaryCheck, "");\r\n                }\r\n                if (options.semicolon === true) {\r\n                    options.diff = options\r\n                        .diff\r\n                        .replace(/;\\n/g, "\\n")\r\n                        .replace(/;$/, "");\r\n                }\r\n            }\r\n            if (typeof options.source === "string") {\r\n                if (options.functions !== undefined) {\r\n                    options.source = options\r\n                        .source\r\n                        .replace(options.functions.binaryCheck, "");\r\n                }\r\n                if (options.semicolon === true) {\r\n                    options.source = options\r\n                        .source\r\n                        .replace(/;\\n/g, "\\n")\r\n                        .replace(/;$/, "");\r\n                }\r\n            }\r\n            options.diffview        = (options.diffview === "inline")\r\n                ? "inline"\r\n                : "sidebyside";\r\n            options.diffcomments    = (\r\n                options.diffcomments === true || options.diffcomments === "true"\r\n            );\r\n            options.diffspaceignore = (\r\n                options.diffspaceignore === true || options.diffspaceignore === "true"\r\n            );\r\n            options.quote           = (options.quote === true || options.quote === "true");\r\n            options.semicolon       = (\r\n                options.semicolon === true || options.semicolon === "true"\r\n            );\r\n            options.content         = (options.content === true || options.content === "true");\r\n            options.diffcli         = (options.diffcli === true || options.diffcli === "true");\r\n            options.context         = (isNaN(options.context) === false)\r\n                ? Number(options.context)\r\n                : -1;\r\n            if (options.diffcli === true && options.context < 0) {\r\n                options.context = 2;\r\n            }\r\n        }());\r\n        var errorout      = 0,\r\n            //diffline is a count of lines that are not equal\r\n            diffline      = 0,\r\n            //tab is a construct of a standard indentation for code\r\n            tab           = (function diffview__tab() {\r\n                var a      = 0,\r\n                    output = [];\r\n                if (options.inchar === "") {\r\n                    return "";\r\n                }\r\n                for (a = 0; a < options.insize; a = a + 1) {\r\n                    output.push(options.inchar);\r\n                }\r\n                return output.join("");\r\n            }()),\r\n            //translates source code from a string to an array by splitting on line breaks\r\n            stringAsLines = function diffview__stringAsLines(str) {\r\n                var lines = (options.diffcli === true)\r\n                    ? str\r\n                    : str\r\n                        .replace(/&/g, "&amp;")\r\n                        .replace(/&#lt;/g, "$#lt;")\r\n                        .replace(/&#gt;/g, "$#gt;")\r\n                        .replace(/</g, "$#lt;")\r\n                        .replace(/>/g, "$#gt;");\r\n                return lines.split("\\n");\r\n            },\r\n            //array representation of base source\r\n            baseTextArray = (typeof options.source === "string")\r\n                ? stringAsLines(options.source)\r\n                : options.source,\r\n            //array representation of new source\r\n            newTextArray  = (typeof options.diff === "string")\r\n                ? stringAsLines(options.diff)\r\n                : options.diff,\r\n            opcodes       = [],\r\n            codeBuild     = function diffview__opcodes() {\r\n                var table           = {},\r\n                    one             = (typeof options.source === "string")\r\n                        ? options.source.split("\\n")\r\n                        : options.source,\r\n                    two             = (typeof options.diff === "string")\r\n                        ? options.diff.split("\\n")\r\n                        : options.diff,\r\n                    lena            = one.length,\r\n                    lenb            = two.length,\r\n                    a               = 0,\r\n                    b               = 0,\r\n                    c               = 0,\r\n                    d               = 0,\r\n                    codes           = [],\r\n                    fix             = function diffview__opcodes_fix(code) {\r\n                        var prior = codes[codes.length - 1];\r\n                        if (prior !== undefined) {\r\n                            if (prior[0] === code[0]) {\r\n                                if (code[0] === "replace" || code[0] === "equal") {\r\n                                    prior[2] = code[2];\r\n                                    prior[4] = code[4];\r\n                                } else if (code[0] === "delete") {\r\n                                    prior[2] = code[2];\r\n                                } else if (code[0] === "insert") {\r\n                                    prior[4] = code[4];\r\n                                }\r\n                                return;\r\n                            }\r\n                            if (prior[0] === "insert" && prior[4] - prior[3] === 1) {\r\n                                if (code[2] - code[1] === 1) {\r\n                                    if (code[0] === "replace") {\r\n                                        prior[0] = "replace";\r\n                                        prior[1] = code[1];\r\n                                        prior[2] = code[2];\r\n                                        code[0]  = "insert";\r\n                                        code[1]  = -1;\r\n                                        code[2]  = -1;\r\n                                    } else if (code[0] === "delete") {\r\n                                        code[0] = "replace";\r\n                                        code[3] = prior[3];\r\n                                        code[4] = prior[4];\r\n                                        codes.pop();\r\n                                        prior = codes[codes.length - 1];\r\n                                        if (prior[0] === "replace") {\r\n                                            prior[2] = code[2];\r\n                                            prior[4] = code[4];\r\n                                            return;\r\n                                        }\r\n                                    }\r\n                                } else if (code[0] === "delete") {\r\n                                    prior[0] = "replace";\r\n                                    prior[1] = code[1];\r\n                                    prior[2] = code[1] + 1;\r\n                                    code[1]  = code[1] + 1;\r\n                                } else if (code[0] === "replace") {\r\n                                    prior[0] = "replace";\r\n                                    prior[1] = code[1];\r\n                                    prior[2] = code[1] + 1;\r\n                                    c = prior[2];\r\n                                    d = prior[4];\r\n                                    return;\r\n                                }\r\n                            } else if (prior[0] === "insert" && code[0] === "delete" && code[2] - code[1] === 1) {\r\n                                prior[4] = prior[4] - 1;\r\n                                code[0]  = "replace";\r\n                                code[3]  = prior[4];\r\n                                code[4]  = prior[4] + 1;\r\n                            } else if (prior[0] === "delete" && prior[2] - prior[1] === 1) {\r\n                                if (code[4] - code[3] === 1) {\r\n                                    if (code[0] === "replace") {\r\n                                        prior[0] = "replace";\r\n                                        prior[3] = code[3];\r\n                                        prior[4] = code[4];\r\n                                        code[0]  = "delete";\r\n                                        code[3]  = -1;\r\n                                        code[4]  = -1;\r\n                                    } else if (code[0] === "insert") {\r\n                                        code[0] = "replace";\r\n                                        code[1] = prior[1];\r\n                                        code[2] = prior[2];\r\n                                        codes.pop();\r\n                                        prior = codes[codes.length - 1];\r\n                                        if (prior[0] === "replace") {\r\n                                            prior[2] = code[2];\r\n                                            prior[4] = code[4];\r\n                                            return;\r\n                                        }\r\n                                    }\r\n                                } else if (code[0] === "insert") {\r\n                                    prior[0] = "replace";\r\n                                    prior[3] = code[3];\r\n                                    prior[4] = code[3] + 1;\r\n                                    code[3]  = code[3] + 1;\r\n                                } else if (code[0] === "replace") {\r\n                                    prior[0] = "replace";\r\n                                    prior[3] = code[3];\r\n                                    prior[4] = code[4] + 1;\r\n                                    c = prior[2];\r\n                                    d = prior[4];\r\n                                    return;\r\n                                }\r\n                            } else if (prior[0] === "delete" && code[0] === "insert" && code[4] - code[3] === 1) {\r\n                                prior[2] = prior[2] - 1;\r\n                                code[0]  = "replace";\r\n                                code[1]  = prior[2];\r\n                                code[2]  = prior[2] + 1;\r\n                            } else if (prior[0] === "replace") {\r\n                                if (code[0] === "delete") {\r\n                                    if (one[code[2] - 1] === two[prior[4] - 1]) {\r\n                                        if (prior[2] - prior[1] > 1) {\r\n                                            prior[4] = prior[4] - 1;\r\n                                        }\r\n                                        c = c - 1;\r\n                                        d = d - 1;\r\n                                        return;\r\n                                    }\r\n                                    if (one[code[2]] === two[prior[4] - 1]) {\r\n                                        if (prior[2] - prior[1] > 1) {\r\n                                            prior[2]             = prior[2] - 1;\r\n                                            prior[4]             = prior[4] - 11;\r\n                                            table[one[c - 1]][0] = table[one[c - 1]][0] - 1;\r\n                                        }\r\n                                    }\r\n                                } else if (code[0] === "insert") {\r\n                                    if (one[prior[2] - 1] === two[code[4] - 1]) {\r\n                                        if (prior[2] - prior[1] > 1) {\r\n                                            prior[2] = prior[2] - 1;\r\n                                        }\r\n                                        c = c - 1;\r\n                                        d = d - 1;\r\n                                        return;\r\n                                    }\r\n                                    if (one[code[2] - 1] === two[prior[4]]) {\r\n                                        if (prior[4] - prior[3] > 1) {\r\n                                            prior[2]             = prior[2] - 1;\r\n                                            prior[4]             = prior[4] - 1;\r\n                                            table[two[d - 1]][1] = table[two[d - 1]][1] - 1;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        codes.push(code);\r\n                    },\r\n                    equality        = function diffview__opcodes_equality() {\r\n                        do {\r\n                            table[one[c]][0] = table[one[c]][0] - 1;\r\n                            table[one[c]][1] = table[one[c]][1] - 1;\r\n                            c                = c + 1;\r\n                            d                = d + 1;\r\n                        } while (c < lena && d < lenb && one[c] === two[d]);\r\n                        fix(["equal", a, c, b, d]);\r\n                        b = d - 1;\r\n                        a = c - 1;\r\n                    },\r\n                    deletion        = function diffview__opcodes_deletion() {\r\n                        do {\r\n                            table[one[c]][0] = table[one[c]][0] - 1;\r\n                            c                = c + 1;\r\n                        } while (c < lena && table[one[c]][1] < 1);\r\n                        fix(["delete", a, c, -1, -1]);\r\n                        a = c - 1;\r\n                        b = d - 1;\r\n                    },\r\n                    deletionStatic  = function diffview__opcodes_deletionStatic() {\r\n                        table[one[a]][0] = table[one[a]][0] - 1;\r\n                        fix([\r\n                            "delete", a, a + 1,\r\n                            -1,\r\n                            -1\r\n                        ]);\r\n                        a = c;\r\n                        b = d - 1;\r\n                    },\r\n                    insertion       = function diffview__opcodes_insertion() {\r\n                        do {\r\n                            table[two[d]][1] = table[two[d]][1] - 1;\r\n                            d                = d + 1;\r\n                        } while (d < lenb && table[two[d]][0] < 1);\r\n                        fix(["insert", -1, -1, b, d]);\r\n                        a = c - 1;\r\n                        b = d - 1;\r\n                    },\r\n                    insertionStatic = function diffview__opcodes_insertionStatic() {\r\n                        table[two[b]][1] = table[two[b]][1] - 1;\r\n                        fix([\r\n                            "insert", -1, -1, b, b + 1\r\n                        ]);\r\n                        a = c - 1;\r\n                        b = d;\r\n                    },\r\n                    replacement     = function diffview__opcodes_replacement() {\r\n                        do {\r\n                            table[one[c]][0] = table[one[c]][0] - 1;\r\n                            table[two[d]][1] = table[two[d]][1] - 1;\r\n                            c                = c + 1;\r\n                            d                = d + 1;\r\n                        } while (c < lena && d < lenb && table[one[c]][1] > 0 && table[two[d]][0] > 0);\r\n                        fix(["replace", a, c, b, d]);\r\n                        a = c - 1;\r\n                        b = d - 1;\r\n                    },\r\n                    replaceUniques  = function diffview__opcodes_replaceUniques() {\r\n                        do {\r\n                            table[one[c]][0] = table[one[c]][0] - 1;\r\n                            c                = c + 1;\r\n                            d                = d + 1;\r\n                        } while (c < lena && d < lenb && table[one[c]][1] < 1 && table[two[d]][0] < 1);\r\n                        fix(["replace", a, c, b, d]);\r\n                        a = c - 1;\r\n                        b = d - 1;\r\n                    };\r\n\r\n                // * First Pass, account for lines from first file\r\n                // * build the table from the second file\r\n                do {\r\n                    if (options.diffspaceignore === true) {\r\n                        two[b] = two[b].replace(/\\s+/g, "");\r\n                    }\r\n                    if (table[two[b]] === undefined) {\r\n                        table[two[b]] = [0, 1];\r\n                    } else {\r\n                        table[two[b]][1] = table[two[b]][1] + 1;\r\n                    }\r\n                    b = b + 1;\r\n                } while (b < lenb);\r\n\r\n                // * Second Pass, account for lines from second file\r\n                // * build the table from the first file\r\n                lena = one.length;\r\n                a    = 0;\r\n                do {\r\n                    if (options.diffspaceignore === true) {\r\n                        one[a] = one[a].replace(/\\s+/g, "");\r\n                    }\r\n                    if (table[one[a]] === undefined) {\r\n                        table[one[a]] = [1, 0];\r\n                    } else {\r\n                        table[one[a]][0] = table[one[a]][0] + 1;\r\n                    }\r\n                    a = a + 1;\r\n                } while (a < lena);\r\n                a = 0;\r\n                b = 0;\r\n                // find all equality... differences are what\'s left over solve only for the\r\n                // second set test removing reverse test removing undefined checks for table\r\n                // refs\r\n\r\n                do {\r\n                    c = a;\r\n                    d = b;\r\n                    if (one[a] === two[b]) {\r\n                        equality();\r\n                    } else if (table[one[a]][1] < 1 && table[two[b]][0] < 1) {\r\n                        replaceUniques();\r\n                    } else if (table[one[a]][1] < 1 && one[a + 1] !== two[b + 2]) {\r\n                        deletion();\r\n                    } else if (table[two[b]][0] < 1 && one[a + 2] !== two[b + 1]) {\r\n                        insertion();\r\n                    } else if (table[one[a]][0] - table[one[a]][1] === 1 && one[a + 1] !== two[b + 2]) {\r\n                        deletionStatic();\r\n                    } else if (table[two[b]][1] - table[two[b]][0] === 1 && one[a + 2] !== two[b + 1]) {\r\n                        insertionStatic();\r\n                    } else if (one[a + 1] === two[b]) {\r\n                        deletion();\r\n                    } else if (one[a] === two[b + 1]) {\r\n                        insertion();\r\n                    } else {\r\n                        replacement();\r\n                    }\r\n                    a = a + 1;\r\n                    b = b + 1;\r\n                } while (a < lena && b < lenb);\r\n                if (lena - a === lenb - b) {\r\n                    if (one[a] === two[b]) {\r\n                        fix(["equal", a, lena, b, lenb]);\r\n                    } else {\r\n                        fix(["replace", a, lena, b, lenb]);\r\n                    }\r\n                } else if (a < lena) {\r\n                    fix(["delete", a, lena, -1, -1]);\r\n                } else if (b < lenb) {\r\n                    fix(["insert", -1, -1, b, lenb]);\r\n                }\r\n                return codes;\r\n            };\r\n\r\n        if (Array.isArray(options.source) === false && typeof options.source !== "string") {\r\n            return "Error: source value is not a string or array!";\r\n        }\r\n        if (Array.isArray(options.diff) === false && typeof options.diff !== "string") {\r\n            return "Error: diff value is not a string or array!";\r\n        }\r\n\r\n        opcodes = codeBuild();\r\n        //diffview application contains three primary parts\r\n        // 1.  opcodes - performs the \'largest common subsequence\'    calculation to\r\n        // determine which lines are different.  I    did not write this logic.  I have\r\n        // rewritten it for    performance, but original logic is still intact.\r\n        // 2.  charcomp - performs the \'largest common subsequence\' upon    characters\r\n        // of two compared lines.\r\n        // 3.  The construction of the output into the \'node\' array errorout is a count\r\n        // of differences after the opcodes generate the other two core pieces of logic\r\n        // are quaranteened into an anonymous function.\r\n        return (function diffview__report() {\r\n            var a              = 0,\r\n                i              = 0,\r\n                node           = ["<div class=\'diff\'>"],\r\n                data           = (options.diffcli === true)\r\n                    ? []\r\n                    : [\r\n                        [], [], [], []\r\n                    ],\r\n                baseStart      = 0,\r\n                baseEnd        = 0,\r\n                newStart       = 0,\r\n                newEnd         = 0,\r\n                rowcnt         = 0,\r\n                rowItem        = -1,\r\n                rcount         = 0,\r\n                foldcount      = 0,\r\n                foldstart      = -1,\r\n                jump           = 0,\r\n                finaldoc       = "",\r\n                tabFix         = (tab === "")\r\n                    ? ""\r\n                    : new RegExp("^((" + tab.replace(/\\\\/g, "\\\\") + ")+)"),\r\n                noTab          = function diffview__report_noTab(str) {\r\n                    var b      = 0,\r\n                        strLen = str.length,\r\n                        output = [];\r\n                    for (b = 0; b < strLen; b = b + 1) {\r\n                        output.push(str[b].replace(tabFix, ""));\r\n                    }\r\n                    return output;\r\n                },\r\n                htmlfix        = function diffview__report_htmlfix(item) {\r\n                    return item.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");\r\n                },\r\n                baseTab        = (tab === "")\r\n                    ? []\r\n                    : noTab(baseTextArray),\r\n                newTab         = (tab === "")\r\n                    ? []\r\n                    : noTab(newTextArray),\r\n                opcodesLength  = opcodes.length,\r\n                change         = "",\r\n                btest          = false,\r\n                ntest          = false,\r\n                repeat         = false,\r\n                ctest          = true,\r\n                code           = [],\r\n                charcompOutput = [],\r\n                // this is the character comparison logic that performs the \'largest common\r\n                // subsequence\' between two lines of code\r\n                charcomp       = function diffview__report_charcomp(lineA, lineB) {\r\n                    var b             = 0,\r\n                        dataA         = [],\r\n                        dataB         = [],\r\n                        cleanedA      = (options.diffcli === true)\r\n                            ? lineA\r\n                            : lineA\r\n                                .replace(/&#160;/g, " ")\r\n                                .replace(/&nbsp;/g, " ")\r\n                                .replace(/&lt;/g, "<")\r\n                                .replace(/&gt;/g, ">")\r\n                                .replace(/\\$#lt;/g, "<")\r\n                                .replace(/\\$#gt;/g, ">")\r\n                                .replace(/&amp;/g, "&"),\r\n                        cleanedB      = (options.diffcli === true)\r\n                            ? lineB\r\n                            : lineB\r\n                                .replace(/&#160;/g, " ")\r\n                                .replace(/&nbsp;/g, " ")\r\n                                .replace(/&lt;/g, "<")\r\n                                .replace(/&gt;/g, ">")\r\n                                .replace(/\\$#lt;/g, "<")\r\n                                .replace(/\\$#gt;/g, ">")\r\n                                .replace(/&amp;/g, "&"),\r\n                        dataMinLength = 0,\r\n                        currentdiff   = [],\r\n                        regStart      = (/_pdiffdiff\\u005f/g),\r\n                        regEnd        = (/_epdiffdiff\\u005f/g),\r\n                        strStart      = "_pdiffdiff\\u005f",\r\n                        strEnd        = "_epdiffdiff\\u005f",\r\n                        tabdiff       = (function diffview__report_charcomp_tabdiff() {\r\n                            var tabMatchA  = "",\r\n                                tabMatchB  = "",\r\n                                splitA     = "",\r\n                                splitB     = "",\r\n                                analysis   = [],\r\n                                matchListA = cleanedA.match(tabFix),\r\n                                matchListB = cleanedB.match(tabFix);\r\n                            if (matchListA === null || matchListB === null || (matchListA[0] === "" && matchListA.length === 1) || (matchListB[0] === "" && matchListB.length === 1)) {\r\n                                return ["", "", cleanedA, cleanedB];\r\n                            }\r\n                            tabMatchA = matchListA[0];\r\n                            tabMatchB = matchListB[0];\r\n                            splitA    = cleanedA.split(tabMatchA)[1];\r\n                            splitB    = cleanedB.split(tabMatchB)[1];\r\n                            if (tabMatchA.length > tabMatchB.length) {\r\n                                analysis  = tabMatchA.split(tabMatchB);\r\n                                tabMatchA = tabMatchB + strStart + analysis[1] + strEnd;\r\n                                tabMatchB = tabMatchB + strStart + strEnd;\r\n                            } else {\r\n                                analysis  = tabMatchB.split(tabMatchA);\r\n                                tabMatchB = tabMatchA + strStart + analysis[1] + strEnd;\r\n                                tabMatchA = tabMatchA + strStart + strEnd;\r\n                            }\r\n                            return [tabMatchA, tabMatchB, splitA, splitB];\r\n                        }()),\r\n                        whiteout      = function diffview__report_charcomp_whiteout(whitediff) {\r\n                            var spacetest = (/<((em)|(pd))>\\u0020+<\\/((em)|(pd))>/),\r\n                                crtest    = (/<((em)|(pd))>\\r+<\\/((em)|(pd))>/);\r\n                            if (spacetest.test(whitediff) === true) {\r\n                                return whitediff;\r\n                            }\r\n                            if (crtest.test(whitediff) === true) {\r\n                                return whitediff.replace(/\\s+/, "(carriage return)");\r\n                            }\r\n                            return whitediff.replace(/\\s+/, "(white space differences)");\r\n                        },\r\n                        //compare is the fuzzy string comparison algorithm\r\n                        compare       = function diffview__report_charcomp_compare(start) {\r\n                            var x          = 0,\r\n                                y          = 0,\r\n                                max        = Math.max(dataA.length, dataB.length),\r\n                                store      = [],\r\n                                sorta      = function diffview__report_charcomp_compare_sorta(a, b) {\r\n                                    if (a[1] - a[0] < b[1] - b[0]) {\r\n                                        return 1;\r\n                                    }\r\n                                    return -1;\r\n                                },\r\n                                sortb      = function diffview__report_charcomp_compare_sortb(a, b) {\r\n                                    if (a[0] + a[1] > b[0] + b[1]) {\r\n                                        return 1;\r\n                                    }\r\n                                    return -1;\r\n                                },\r\n                                whitetest  = (/^(\\s+)$/),\r\n                                whitespace = false,\r\n                                wordtest   = false;\r\n                            //first gather a list of all matching indexes into an array\r\n                            for (x = start; x < dataMinLength; x = x + 1) {\r\n                                for (y = start; y < max; y = y + 1) {\r\n                                    if (dataA[x] === dataB[y] || dataB[x] === dataA[y]) {\r\n                                        store.push([x, y]);\r\n                                        if (dataA[y] === dataB[x] && dataA[y + 1] === dataB[x + 1] && whitetest.test(dataB[x - 1]) === true) {\r\n                                            wordtest = true;\r\n                                            store    = [\r\n                                                [x, y]\r\n                                            ];\r\n                                        }\r\n                                        if (dataA[x] === dataB[y] && dataA[x + 1] === dataB[y + 1] && whitetest.test(dataB[y - 1]) === true) {\r\n                                            wordtest = true;\r\n                                            store    = [\r\n                                                [x, y]\r\n                                            ];\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (wordtest === true) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            //if there are no character matches then quit out\r\n                            if (store.length === 0) {\r\n                                return [dataMinLength, max, 0, whitespace];\r\n                            }\r\n                            // take the list of matches and sort it first sort by size of change with\r\n                            // shortest up front second sort by sum of change start and end the second sort\r\n                            // results in the smallest change from the earliest point\r\n                            store.sort(sorta);\r\n                            if (dataMinLength - start < 5000) {\r\n                                store.sort(sortb);\r\n                            }\r\n                            //x should always be the shorter index (change start)\r\n                            if (store[0][0] < store[0][1]) {\r\n                                x = store[0][0];\r\n                                y = store[0][1];\r\n                            } else {\r\n                                y = store[0][0];\r\n                                x = store[0][1];\r\n                            }\r\n                            //package the output\r\n                            if (dataA[y] === dataB[x]) {\r\n                                if (dataA[y - 1] === dataB[x - 1] && x !== start) {\r\n                                    x = x - 1;\r\n                                    y = y - 1;\r\n                                }\r\n                                if (options.diffspaceignore === true && ((whitetest.test(dataA[y - 1]) === true && y - start > 0) || (whitetest.test(dataB[x - 1]) === true && x - start > 0))) {\r\n                                    whitespace = true;\r\n                                }\r\n                                return [x, y, 0, whitespace];\r\n                            }\r\n                            if (dataA[x] === dataB[y]) {\r\n                                if (dataA[x - 1] === dataB[y - 1] && x !== start) {\r\n                                    x = x - 1;\r\n                                    y = y - 1;\r\n                                }\r\n                                if (options.diffspaceignore === true && ((whitetest.test(dataA[x - 1]) === true && x - start > 0) || (whitetest.test(dataB[y - 1]) === true && y - start > 0))) {\r\n                                    whitespace = true;\r\n                                }\r\n                                return [x, y, 1, whitespace];\r\n                            }\r\n                        };\r\n                    //if same after accounting for character entities then exit\r\n                    if (cleanedA === cleanedB) {\r\n                        return [lineA, lineB];\r\n                    }\r\n                    //prevent extra error counting that occurred before entering this function\r\n                    errorout = errorout - 1;\r\n                    //diff for tabs\r\n                    if (tabFix !== "" && cleanedA.length !== cleanedB.length && cleanedA.replace(tabFix, "") === cleanedB.replace(tabFix, "") && options.diffspaceignore === false) {\r\n                        errorout = errorout + 1;\r\n                        if (options.diffcli === true) {\r\n                            tabdiff[0] = tabdiff[0] + tabdiff[2];\r\n                            tabdiff[0] = tabdiff[0]\r\n                                .replace(regStart, "<pd>")\r\n                                .replace(regEnd, "</pd>");\r\n                            tabdiff[1] = tabdiff[1] + tabdiff[3];\r\n                            tabdiff[1] = tabdiff[1]\r\n                                .replace(regStart, "<pd>")\r\n                                .replace(regEnd, "</pd>");\r\n                            return [\r\n                                tabdiff[0], tabdiff[1]\r\n                            ];\r\n                        }\r\n                        tabdiff[0] = tabdiff[0] + tabdiff[2];\r\n                        tabdiff[0] = tabdiff[0]\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;")\r\n                            .replace(regStart, "<em>")\r\n                            .replace(regEnd, "</em>");\r\n                        tabdiff[1] = tabdiff[1] + tabdiff[3];\r\n                        tabdiff[1] = tabdiff[1]\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;")\r\n                            .replace(regStart, "<em>")\r\n                            .replace(regEnd, "</em>");\r\n                        return [\r\n                            tabdiff[0], tabdiff[1]\r\n                        ];\r\n                    }\r\n                    //turn the pruned input into arrays\r\n                    dataA         = cleanedA.split("");\r\n                    dataB         = cleanedB.split("");\r\n                    //the length of the shortest array\r\n                    dataMinLength = Math.min(dataA.length, dataB.length);\r\n                    for (b = 0; b < dataMinLength; b = b + 1) {\r\n                        //if undefined break the loop\r\n                        if (dataA[b] === undefined || dataB[b] === undefined) {\r\n                            break;\r\n                        }\r\n                        //iterate until the arrays are not the same\r\n                        if (dataA[b] !== dataB[b]) {\r\n                            // fuzzy string comparison returns an array with these indexes 0 - shorter\r\n                            // ending index of difference 1 - longer ending index of difference 2 - 0 if\r\n                            // index 2 is for dataA or 1 for dataB 3 - whether the difference is only\r\n                            // whitespace\r\n                            currentdiff = compare(b);\r\n                            //supply the difference start indicator\r\n                            if (currentdiff[3] === false) {\r\n                                //count each difference\r\n                                errorout = errorout + 1;\r\n                                if (b > 0) {\r\n                                    dataA[b - 1] = dataA[b - 1] + strStart;\r\n                                    dataB[b - 1] = dataB[b - 1] + strStart;\r\n                                } else {\r\n                                    dataA[b] = strStart + dataA[b];\r\n                                    dataB[b] = strStart + dataB[b];\r\n                                }\r\n                                //complex decision tree on how to supply difference end indicator\r\n                                if (currentdiff[2] === 1) {\r\n                                    if (currentdiff[0] === 0) {\r\n                                        dataA[0] = dataA[0].replace(regStart, strStart + strEnd);\r\n                                    } else if (currentdiff[0] === dataMinLength) {\r\n                                        if (dataB.length === dataMinLength) {\r\n                                            dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;\r\n                                        } else {\r\n                                            dataA[currentdiff[0] - 1] = dataA[currentdiff[0] - 1] + strEnd;\r\n                                        }\r\n                                    } else {\r\n                                        if (dataA[currentdiff[0]].indexOf(strStart) > -1) {\r\n                                            dataA[currentdiff[0]] = dataA[currentdiff[0]] + strEnd;\r\n                                        } else if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {\r\n                                            dataA[b] = strEnd + dataA[b];\r\n                                        } else {\r\n                                            dataA[currentdiff[0]] = strEnd + dataA[currentdiff[0]];\r\n                                        }\r\n                                    }\r\n                                    if (currentdiff[1] > dataB.length - 1 || currentdiff[0] === dataMinLength) {\r\n                                        dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;\r\n                                    } else if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {\r\n                                        dataB[b + (currentdiff[1] - currentdiff[0])] = strEnd + dataB[b + (currentdiff[1] - currentdiff[0])];\r\n                                    } else {\r\n                                        dataB[currentdiff[1]] = strEnd + dataB[currentdiff[1]];\r\n                                    }\r\n                                } else {\r\n                                    if (currentdiff[0] === 0) {\r\n                                        dataB[0] = dataB[0].replace(regStart, strStart + strEnd);\r\n                                    } else if (currentdiff[0] === dataMinLength) {\r\n                                        if (dataA.length === dataMinLength) {\r\n                                            dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;\r\n                                        } else {\r\n                                            dataB[currentdiff[0] - 1] = dataB[currentdiff[0] - 1] + strEnd;\r\n                                        }\r\n                                    } else {\r\n                                        if (dataB[currentdiff[0]].indexOf(strStart) > -1) {\r\n                                            dataB[currentdiff[0]] = dataB[currentdiff[0]] + strEnd;\r\n                                        } else if (currentdiff[0] - currentdiff[1] === currentdiff[1]) {\r\n                                            dataB[b] = strEnd + dataB[b];\r\n                                        } else {\r\n                                            dataB[currentdiff[0]] = strEnd + dataB[currentdiff[0]];\r\n                                        }\r\n                                    }\r\n                                    if (currentdiff[1] > dataA.length - 1 || currentdiff[0] === dataMinLength) {\r\n                                        dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;\r\n                                    } else if (currentdiff[0] - currentdiff[1] === currentdiff[1]) {\r\n                                        dataA[b + (currentdiff[0] - currentdiff[1])] = strEnd + dataA[b + (currentdiff[0] - currentdiff[1])];\r\n                                    } else {\r\n                                        dataA[currentdiff[1]] = strEnd + dataA[currentdiff[1]];\r\n                                    }\r\n                                }\r\n                            }\r\n                            // we must rebase the array with the shorter difference so that the end of the\r\n                            // current difference is on the same index.  This provides a common baseline by\r\n                            // which to find the next unmatching index\r\n                            if (currentdiff[1] > currentdiff[0] && currentdiff[1] - currentdiff[0] < 1000) {\r\n                                if (currentdiff[2] === 1) {\r\n                                    do {\r\n                                        dataA.unshift("");\r\n                                        currentdiff[0] = currentdiff[0] + 1;\r\n                                    } while (currentdiff[1] > currentdiff[0]);\r\n                                } else {\r\n                                    do {\r\n                                        dataB.unshift("");\r\n                                        currentdiff[0] = currentdiff[0] + 1;\r\n                                    } while (currentdiff[1] > currentdiff[0]);\r\n                                }\r\n                            }\r\n                            // since the previous logic will grow the shorter array we have to redefine the\r\n                            // shortest length\r\n                            dataMinLength = Math.min(dataA.length, dataB.length);\r\n                            //assign the incrementer to the end of the longer difference\r\n                            b             = currentdiff[1];\r\n                        }\r\n                    }\r\n                    // if one array is longer than the other and not identified as different then\r\n                    // identify this difference in length\r\n                    if (dataA.length > dataB.length && dataB[dataB.length - 1] !== undefined && dataB[dataB.length - 1].indexOf(strEnd) < 1) {\r\n                        dataB.push(strStart + strEnd);\r\n                        dataA[dataB.length - 1] = strStart + dataA[dataB.length - 1];\r\n                        dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;\r\n                        errorout                = errorout + 1;\r\n                    }\r\n                    if (dataB.length > dataA.length && dataA[dataA.length - 1] !== undefined && dataA[dataA.length - 1].indexOf(strEnd) < 1) {\r\n                        dataA.push(strStart + strEnd);\r\n                        dataB[dataA.length - 1] = strStart + dataB[dataA.length - 1];\r\n                        dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;\r\n                        errorout                = errorout + 1;\r\n                    }\r\n                    // options.diffcli output doesn\'t need XML protected characters to be escaped\r\n                    // because its output is the command line\r\n                    if (options.diffcli === true) {\r\n                        return [\r\n                            dataA\r\n                                .join("")\r\n                                .replace(regStart, "<pd>")\r\n                                .replace(regEnd, "</pd>")\r\n                                .replace(/<pd>\\s+<\\/pd>/g, whiteout),\r\n                            dataB\r\n                                .join("")\r\n                                .replace(regStart, "<pd>")\r\n                                .replace(regEnd, "</pd>")\r\n                                .replace(/<pd>\\s+<\\/pd>/g, whiteout)\r\n                        ];\r\n                    }\r\n                    return [\r\n                        dataA\r\n                            .join("")\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;")\r\n                            .replace(regStart, "<em>")\r\n                            .replace(regEnd, "</em>")\r\n                            .replace(/<em>\\s+<\\/em>/g, whiteout),\r\n                        dataB\r\n                            .join("")\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;")\r\n                            .replace(regStart, "<em>")\r\n                            .replace(regEnd, "</em>")\r\n                            .replace(/<em>\\s+<\\/em>/g, whiteout)\r\n                    ];\r\n                };\r\n            if (options.diffcli === false) {\r\n                if (options.diffview === "inline") {\r\n                    node.push("<h3 class=\'texttitle\'>");\r\n                    node.push(options.sourcelabel);\r\n                    node.push(" vs. ");\r\n                    node.push(options.difflabel);\r\n                    node.push("</h3><ol class=\'count\'>");\r\n                } else {\r\n                    data[0].push("<div class=\'diff-left\'><h3 class=\'texttitle\'>");\r\n                    data[0].push(options.sourcelabel);\r\n                    data[0].push("</h3><ol class=\'count\'>");\r\n                    data[2].push("<div class=\'diff-right\'><h3 class=\'texttitle\'>");\r\n                    data[2].push(options.difflabel);\r\n                    data[2].push("</h3><ol class=\'count\' style=\'cursor:w-resize\'>");\r\n                }\r\n            } else {\r\n                foldstart = 0;\r\n            }\r\n            for (a = 0; a < opcodesLength; a = a + 1) {\r\n                code      = opcodes[a];\r\n                change    = code[0];\r\n                baseStart = code[1];\r\n                baseEnd   = code[2];\r\n                newStart  = code[3];\r\n                newEnd    = code[4];\r\n                rowcnt    = Math.max(baseEnd - baseStart, newEnd - newStart);\r\n                ctest     = true;\r\n\r\n                if (foldstart > -1 && options.diffcli === false) {\r\n                    data[0][foldstart] = data[0][foldstart].replace("xxx", foldcount);\r\n                }\r\n                if (options.diffcli === true) {\r\n                    if (foldstart > 49 && change === "equal") {\r\n                        break;\r\n                    }\r\n                    if (options.diffspaceignore === true && change === "replace" && baseTextArray[baseStart] !== undefined && newTextArray[newStart] !== undefined && baseTextArray[baseStart].replace(/\\s+/g, "") === newTextArray[newStart].replace(/\\s+/g, "")) {\r\n                        change = "equal";\r\n                    } else if (change !== "equal") {\r\n                        if (a > 0 && opcodes[a - 1][0] === "equal") {\r\n                            foldcount = options.context;\r\n                            if ((ntest === true || change === "insert") && (options.diffspaceignore === false || (/^(\\s+)$/g).test(newTextArray[newStart]) === false)) {\r\n                                foldstart = foldstart + 1;\r\n                                if (options.api === "dom") {\r\n                                    data.push("</li><li><h3>Line: ");\r\n                                    data.push(opcodes[a - 1][2] + 1);\r\n                                    data.push("</h3>");\r\n                                } else {\r\n                                    data.push("");\r\n                                    data.push("\\u001b[36mLine: " + (opcodes[a - 1][2] + 1) + "\\u001b[39m");\r\n                                }\r\n                                if (foldcount > 0) {\r\n                                    do {\r\n                                        if (newStart - foldcount > -1) {\r\n                                            if (options.api === "dom") {\r\n                                                data.push("<p>");\r\n                                                data.push(htmlfix(newTextArray[newStart - foldcount]));\r\n                                                data.push("</p>");\r\n                                            } else {\r\n                                                data.push(newTextArray[newStart - foldcount]);\r\n                                            }\r\n                                        }\r\n                                        foldcount = foldcount - 1;\r\n                                    } while (foldcount > 0);\r\n                                }\r\n                            } else {\r\n                                foldstart = foldstart + 1;\r\n                                if (options.api === "dom") {\r\n                                    data.push("</li><li><h3>Line: ");\r\n                                    data.push(baseStart + 1);\r\n                                    data.push("</h3>");\r\n                                } else {\r\n                                    data.push("");\r\n                                    data.push("\\u001b[36mLine: " + (baseStart + 1) + "\\u001b[39m");\r\n                                }\r\n                                if (foldcount > 0) {\r\n                                    do {\r\n                                        if (baseStart - foldcount > -1) {\r\n                                            if (options.api === "dom") {\r\n                                                data.push("<p>");\r\n                                                data.push(htmlfix(newTextArray[newStart - foldcount]));\r\n                                                data.push("</p>");\r\n                                            } else {\r\n                                                data.push(baseTextArray[baseStart - foldcount]);\r\n                                            }\r\n                                        }\r\n                                        foldcount = foldcount - 1;\r\n                                    } while (foldcount > 0);\r\n                                }\r\n                            }\r\n                        } else if (a < 1) {\r\n                            if (options.api === "dom") {\r\n                                data.push("</li><li><h3>Line: 1</h3>");\r\n                            } else {\r\n                                data.push("");\r\n                                data.push("\\u001b[36mLine: 1\\u001b[39m");\r\n                            }\r\n                            foldstart = foldstart + 1;\r\n                        }\r\n                        foldcount = 0;\r\n                        if ((ntest === true || change === "insert") && (options.diffspaceignore === false || (/^(\\s+)$/g).test(newTextArray[newStart]) === false)) {\r\n                            do {\r\n                                if (options.api === "dom") {\r\n                                    data.push("<ins>");\r\n                                    data.push(htmlfix(newTextArray[newStart + foldcount]));\r\n                                    data.push("</ins>");\r\n                                } else {\r\n                                    data.push("\\u001b[32m" + newTextArray[newStart + foldcount] + "\\u001b[39m");\r\n                                }\r\n                                foldcount = foldcount + 1;\r\n                            } while (foldcount < 7 && foldcount + newStart < newEnd);\r\n                        } else if (change === "delete" && (options.diffspaceignore === false || (/^(\\s+)$/g).test(baseTextArray[baseStart]) === false)) {\r\n                            do {\r\n                                if (options.api === "dom") {\r\n                                    data.push("<del>");\r\n                                    data.push(htmlfix(baseTextArray[baseStart + foldcount]))\r\n                                    data.push("</del>");\r\n                                } else {\r\n                                    data.push("\\u001b[31m" + baseTextArray[baseStart + foldcount] + "\\u001b[39m");\r\n                                }\r\n                                foldcount = foldcount + 1;\r\n                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);\r\n                        } else if (change === "replace" && (options.diffspaceignore === false || baseTextArray[baseStart].replace(/\\s+/g, "") !== newTextArray[newStart].replace(/\\s+/g, ""))) {\r\n                            do {\r\n                                charcompOutput = charcomp(\r\n                                    baseTextArray[baseStart + foldcount],\r\n                                    newTextArray[newStart + foldcount]\r\n                                );\r\n                                if (options.api === "dom") {\r\n                                    data.push("<del>");\r\n                                    data.push(htmlfix(charcompOutput[0]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\\/pd&gt;/g, "</em>"));\r\n                                    data.push("</del><ins>");\r\n                                    data.push(htmlfix(charcompOutput[1]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\\/pd&gt;/g, "</em>"));\r\n                                    data.push("</ins>");\r\n                                } else {\r\n                                    data.push("\\u001b[31m" + charcompOutput[0].replace(/<pd>/g, "\\u001b[1m").replace(/<\\/pd>/g, "\\u001b[22m") + "\\u001b[39m");\r\n                                    data.push("\\u001b[32m" + charcompOutput[1].replace(/<pd>/g, "\\u001b[1m").replace(/<\\/pd>/g, "\\u001b[22m") + "\\u001b[39m");\r\n                                }\r\n                                foldcount = foldcount + 1;\r\n                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);\r\n                        }\r\n                        if (((change === "insert" && foldcount + newStart === newEnd) || (change !== "insert" && foldcount + baseStart === baseEnd)) && baseTextArray[baseStart + foldcount] !== undefined && options.context > 0 && a < opcodesLength - 1 && opcodes[a + 1][0] === "equal") {\r\n                            foldcount = 0;\r\n                            baseStart = opcodes[a + 1][1];\r\n                            baseEnd   = opcodes[a + 1][2] - baseStart;\r\n                            do {\r\n                                if (options.api === "dom") {\r\n                                    data.push("<p>");\r\n                                    data.push(htmlfix(baseTextArray[baseStart + foldcount]));\r\n                                    data.push("</p>");\r\n                                } else {\r\n                                    data.push(baseTextArray[baseStart + foldcount]);\r\n                                }\r\n                                foldcount = foldcount + 1;\r\n                            } while (foldcount < options.context && foldcount < baseEnd);\r\n                        }\r\n                        if (btest === true) {\r\n                            baseStart = baseStart + 1;\r\n                            btest     = false;\r\n                        } else if (ntest === true) {\r\n                            newStart = newStart + 1;\r\n                            ntest    = false;\r\n                        } else {\r\n                            baseStart = baseStart + 1;\r\n                            newStart  = newStart + 1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (i = 0; i < rowcnt; i = i + 1) {\r\n                        //apply options.context collapsing for the output, if needed\r\n                        if (options.context > -1 && opcodes.length > 1 && ((a > 0 && i === options.context) || (a === 0 && i === 0)) && change === "equal") {\r\n                            ctest = false;\r\n                            jump  = rowcnt - ((a === 0\r\n                                ? 1\r\n                                : 2) * options.context);\r\n                            if (jump > 1) {\r\n                                baseStart = baseStart + jump;\r\n                                newStart  = newStart + jump;\r\n                                i         = i + (jump - 1);\r\n                                if (options.diffcli === true) {\r\n                                    data[5].push([baseStart, newStart]);\r\n                                } else {\r\n                                    data[0].push("<li>...</li>");\r\n                                    if (options.diffview !== "inline") {\r\n                                        data[1].push("<li class=\\"skip\\">&#10;</li>");\r\n                                    }\r\n                                    data[2].push("<li>...</li>");\r\n                                    data[3].push("<li class=\\"skip\\">&#10;</li>");\r\n                                }\r\n                                if (a + 1 === opcodes.length) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                        } else if (change !== "equal") {\r\n                            diffline = diffline + 1;\r\n                        }\r\n                        foldcount = foldcount + 1;\r\n                        // this is a check against false positives incurred by increasing or reducing of\r\n                        // nesting.  At this time it only checks one level deep.\r\n                        if (tab !== "") {\r\n                            if (btest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof baseTextArray[baseStart + 1] === "string" && typeof newTextArray[newStart] === "string" && baseTab[baseStart + 1] === newTab[newStart] && baseTab[baseStart] !== newTab[newStart] && (typeof newTextArray[newStart - 1] !== "string" || baseTab[baseStart] !== newTab[newStart - 1])) {\r\n                                btest = true;\r\n                            } else if (ntest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof newTextArray[newStart + 1] === "string" && typeof baseTextArray[baseStart] === "string" && newTab[newStart + 1] === baseTab[baseStart] && newTab[newStart] !== baseTab[baseStart] && (typeof baseTextArray[baseStart - 1] !== "string" || newTab[newStart] !== baseTab[baseStart - 1])) {\r\n                                ntest = true;\r\n                            }\r\n                        }\r\n                        if (options.diffview === "inline") {\r\n                            if (options.diffspaceignore === true && change === "replace" && baseTextArray[baseStart].replace(/\\s+/g, "") === newTextArray[newStart].replace(/\\s+/g, "")) {\r\n                                change   = "equal";\r\n                                errorout = errorout - 1;\r\n                            }\r\n                            if (options.context < 0 && rowItem < a) {\r\n                                rowItem = a;\r\n                                if (foldstart > -1) {\r\n                                    if (data[0][foldstart + 1] === foldcount - 1) {\r\n                                        data[0][foldstart] = "<li class=\\"" + data[0][foldstart].slice(\r\n                                            data[0][foldstart].indexOf(\r\n                                                "line xxx\\">- "\r\n                                            ) + 12\r\n                                        );\r\n                                    } else {\r\n                                        data[0][foldstart] = data[0][foldstart].replace(\r\n                                            "xxx",\r\n                                            (foldcount - 1 + rcount)\r\n                                        );\r\n                                    }\r\n                                }\r\n                                if (change !== "replace") {\r\n                                    if (baseEnd - baseStart > 1 || newEnd - newStart > 1) {\r\n                                        data[0].push("<li class=\\"fold\\" title=\\"folds from line " + (\r\n                                            foldcount + rcount\r\n                                        ) + " to line xxx\\">- ");\r\n                                        foldstart = data[0].length - 1;\r\n                                    } else {\r\n                                        data[0].push("<li>");\r\n                                    }\r\n                                    if (ntest === true || change === "insert") {\r\n                                        data[0].push("&#10;");\r\n                                    } else {\r\n                                        data[0].push(baseStart + 1);\r\n                                    }\r\n                                    data[0].push("</li>");\r\n                                } else {\r\n                                    rcount = rcount + 1;\r\n                                }\r\n                            } else if (change !== "replace") {\r\n                                data[0].push("<li>");\r\n                                if (ntest === true || change === "insert") {\r\n                                    data[0].push("&#10;");\r\n                                } else {\r\n                                    data[0].push(baseStart + 1);\r\n                                }\r\n                                data[0].push("</li>");\r\n                            } else if (change === "replace") {\r\n                                rcount = rcount + 1;\r\n                            }\r\n                            if (ntest === true || change === "insert") {\r\n                                data[2].push("<li>");\r\n                                data[2].push(newStart + 1);\r\n                                data[2].push("&#10;</li>");\r\n                                if (options.diffspaceignore === true && newTextArray[newStart].replace(/\\s+/g, "") === "") {\r\n                                    data[3].push("<li class=\\"equal\\">");\r\n                                    diffline = diffline - 1;\r\n                                } else {\r\n                                    data[3].push("<li class=\\"insert\\">");\r\n                                }\r\n                                data[3].push(newTextArray[newStart]);\r\n                                data[3].push("&#10;</li>");\r\n                            } else if (btest === true || change === "delete") {\r\n                                data[2].push("<li class=\\"empty\\">&#10;</li>");\r\n                                if (options.diffspaceignore === true && baseTextArray[baseStart].replace(/\\s+/g, "") === "") {\r\n                                    data[3].push("<li class=\\"equal\\">");\r\n                                    diffline = diffline - 1;\r\n                                } else {\r\n                                    data[3].push("<li class=\\"delete\\">");\r\n                                }\r\n                                data[3].push(baseTextArray[baseStart]);\r\n                                data[3].push("&#10;</li>");\r\n                            } else if (change === "replace") {\r\n                                if (baseTextArray[baseStart] !== newTextArray[newStart]) {\r\n                                    if (baseTextArray[baseStart] === "") {\r\n                                        charcompOutput = [\r\n                                            "", newTextArray[newStart]\r\n                                        ];\r\n                                    } else if (newTextArray[newStart] === "") {\r\n                                        charcompOutput = [baseTextArray[baseStart], ""];\r\n                                    } else if (baseStart < baseEnd && newStart < newEnd) {\r\n                                        charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);\r\n                                    }\r\n                                }\r\n                                if (baseStart < baseEnd) {\r\n                                    data[0].push("<li>" + (\r\n                                        baseStart + 1\r\n                                    ) + "</li>");\r\n                                    data[2].push("<li class=\\"empty\\">&#10;</li>");\r\n                                    if (options.diffspaceignore === true && baseTextArray[baseStart].replace(/\\s+/g, "") === "") {\r\n                                        data[3].push("<li class=\\"equal\\">");\r\n                                        diffline = diffline - 1;\r\n                                    } else {\r\n                                        data[3].push("<li class=\\"delete\\">");\r\n                                    }\r\n                                    if (newStart < newEnd) {\r\n                                        data[3].push(charcompOutput[0]);\r\n                                    } else {\r\n                                        data[3].push(baseTextArray[baseStart]);\r\n                                    }\r\n                                    data[3].push("&#10;</li>");\r\n                                }\r\n                                if (newStart < newEnd) {\r\n                                    data[0].push("<li class=\\"empty\\">&#10;</li>");\r\n                                    data[2].push("<li>");\r\n                                    data[2].push(newStart + 1);\r\n                                    data[2].push("</li>");\r\n                                    if (options.diffspaceignore === true && newTextArray[newStart].replace(/\\s+/g, "") === "") {\r\n                                        data[3].push("<li class=\\"equal\\">");\r\n                                        diffline = diffline - 1;\r\n                                    } else {\r\n                                        data[3].push("<li class=\\"insert\\">");\r\n                                    }\r\n                                    if (baseStart < baseEnd) {\r\n                                        data[3].push(charcompOutput[1]);\r\n                                    } else {\r\n                                        data[3].push(newTextArray[newStart]);\r\n                                    }\r\n                                    data[3].push("&#10;</li>");\r\n                                }\r\n                            } else if (baseStart < baseEnd || newStart < newEnd) {\r\n                                data[2].push("<li>");\r\n                                data[2].push(newStart + 1);\r\n                                data[2].push("</li>");\r\n                                data[3].push("<li class=\\"");\r\n                                data[3].push(change);\r\n                                data[3].push("\\">");\r\n                                data[3].push(baseTextArray[baseStart]);\r\n                                data[3].push("&#10;</li>");\r\n                            }\r\n                            if (btest === true) {\r\n                                baseStart = baseStart + 1;\r\n                                btest     = false;\r\n                            } else if (ntest === true) {\r\n                                newStart = newStart + 1;\r\n                                ntest    = false;\r\n                            } else {\r\n                                baseStart = baseStart + 1;\r\n                                newStart  = newStart + 1;\r\n                            }\r\n                        } else {\r\n                            if (btest === false && ntest === false && typeof baseTextArray[baseStart] === "string" && typeof newTextArray[newStart] === "string") {\r\n                                if (change === "replace" && baseStart < baseEnd && newStart < newEnd && baseTextArray[baseStart] !== newTextArray[newStart]) {\r\n                                    charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);\r\n                                } else {\r\n                                    charcompOutput = [\r\n                                        baseTextArray[baseStart], newTextArray[newStart]\r\n                                    ];\r\n                                }\r\n                                if (baseStart === Number(data[0][data[0].length - 1].substring(\r\n                                    data[0][data[0].length - 1].indexOf(">") + 1,\r\n                                    data[0][data[0].length - 1].lastIndexOf("<")\r\n                                )) - 1 || newStart === Number(data[2][data[2].length - 1].substring(\r\n                                    data[2][data[2].length - 1].indexOf(">") + 1,\r\n                                    data[2][data[2].length - 1].lastIndexOf("<")\r\n                                )) - 1) {\r\n                                    repeat = true;\r\n                                }\r\n                                if (repeat === false) {\r\n                                    if (baseStart < baseEnd) {\r\n                                        if (options.context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3] > 1)) {\r\n                                            rowItem = a;\r\n                                            data[0].push(\r\n                                                "<li class=\\"fold\\" title=\\"folds from line " + foldcount +\r\n                                                " to line xxx\\">- " + (\r\n                                                    baseStart + 1\r\n                                                ) + "</li>"\r\n                                            );\r\n                                            foldstart = data[0].length - 1;\r\n                                        } else {\r\n                                            data[0].push("<li>" + (\r\n                                                baseStart + 1\r\n                                            ) + "</li>");\r\n                                        }\r\n                                        data[1].push("<li class=\\"");\r\n                                        if (newStart >= newEnd) {\r\n                                            if (options.diffspaceignore === true && baseTextArray[baseStart].replace(/\\s+/g, "") === "") {\r\n                                                data[1].push("equal");\r\n                                                diffline = diffline - 1;\r\n                                            } else {\r\n                                                data[1].push("delete");\r\n                                            }\r\n                                        } else if (baseTextArray[baseStart] === "" && newTextArray[newStart] !== "" && (options.diffspaceignore === false || (baseTextArray[baseStart].replace(/\\s+/g, "") !== "" && newTextArray[newStart].replace(/\\s+/g, "") !== ""))) {\r\n                                            data[1].push("empty");\r\n                                        } else {\r\n                                            data[1].push(change);\r\n                                        }\r\n                                        data[1].push("\\">");\r\n                                        data[1].push(charcompOutput[0]);\r\n                                        data[1].push("&#10;</li>");\r\n                                    } else if (ctest === true) {\r\n                                        if (options.context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3])) {\r\n                                            rowItem = a;\r\n                                            if (foldstart > -1) {\r\n                                                data[0][foldstart] = data[0][foldstart].replace("xxx", (foldcount - 1));\r\n                                            }\r\n                                            data[0].push(\r\n                                                "<li class=\\"fold\\" title=\\"folds from line " + foldcount + " to line xxx\\">- &" +\r\n                                                "#10;</li>"\r\n                                            );\r\n                                            foldstart = data[0].length - 1;\r\n                                        } else {\r\n                                            data[0].push("<li class=\\"empty\\">&#10;</li>");\r\n                                        }\r\n                                        data[1].push("<li class=\\"empty\\"></li>");\r\n                                    }\r\n                                    if (newStart < newEnd) {\r\n                                        data[2].push("<li>" + (\r\n                                            newStart + 1\r\n                                        ) + "</li>");\r\n                                        data[3].push("<li class=\\"");\r\n                                        if (baseStart >= baseEnd) {\r\n                                            if (options.diffspaceignore === true && newTextArray[newStart].replace(/\\s+/g, "") === "") {\r\n                                                data[3].push("equal");\r\n                                                diffline = diffline - 1;\r\n                                            } else {\r\n                                                data[3].push("insert");\r\n                                            }\r\n                                        } else if (newTextArray[newStart] === "" && baseTextArray[baseStart] !== "" && (options.diffspaceignore === false || (baseTextArray[baseStart].replace(/\\s+/g, "") !== "" && newTextArray[newStart].replace(/\\s+/g, "") !== ""))) {\r\n                                            data[3].push("empty");\r\n                                        } else {\r\n                                            data[3].push(change);\r\n                                        }\r\n                                        data[3].push("\\">");\r\n                                        data[3].push(charcompOutput[1]);\r\n                                        data[3].push("&#10;</li>");\r\n                                    } else if (ctest === true) {\r\n                                        data[2].push("<li class=\\"empty\\">&#10;</li>");\r\n                                        data[3].push("<li class=\\"empty\\"></li>");\r\n                                    }\r\n                                } else {\r\n                                    repeat = false;\r\n                                }\r\n                                if (baseStart < baseEnd) {\r\n                                    baseStart = baseStart + 1;\r\n                                }\r\n                                if (newStart < newEnd) {\r\n                                    newStart = newStart + 1;\r\n                                }\r\n                            } else if (btest === true || (typeof baseTextArray[baseStart] === "string" && typeof newTextArray[newStart] !== "string")) {\r\n                                if (baseStart !== Number(data[0][data[0].length - 1].substring(\r\n                                    data[0][data[0].length - 1].indexOf(">") + 1,\r\n                                    data[0][data[0].length - 1].lastIndexOf("<")\r\n                                )) - 1) {\r\n                                    if (options.context < 0 && rowItem < a && opcodes[a][2] - opcodes[a][1] > 1) {\r\n                                        rowItem = a;\r\n                                        data[0].push(\r\n                                            "<li class=\\"fold\\" title=\\"folds from line " + foldcount +\r\n                                            " to line xxx\\">- " + (\r\n                                                baseStart + 1\r\n                                            ) + "</li>"\r\n                                        );\r\n                                        foldstart = data[0].length - 1;\r\n                                    } else {\r\n                                        data[0].push("<li>" + (\r\n                                            baseStart + 1\r\n                                        ) + "</li>");\r\n                                    }\r\n                                    data[1].push("<li class=\\"delete\\">");\r\n                                    data[1].push(baseTextArray[baseStart]);\r\n                                    data[1].push("&#10;</li>");\r\n                                    data[2].push("<li class=\\"empty\\">&#10;</li>");\r\n                                    data[3].push("<li class=\\"empty\\"></li>");\r\n                                }\r\n                                btest     = false;\r\n                                baseStart = baseStart + 1;\r\n                            } else if (ntest === true || (typeof baseTextArray[baseStart] !== "string" && typeof newTextArray[newStart] === "string")) {\r\n                                if (newStart !== Number(data[2][data[2].length - 1].substring(\r\n                                    data[2][data[2].length - 1].indexOf(">") + 1,\r\n                                    data[2][data[2].length - 1].lastIndexOf("<")\r\n                                )) - 1) {\r\n                                    if (options.context < 0 && rowItem < a && opcodes[a][4] - opcodes[a][3] > 1) {\r\n                                        rowItem = a;\r\n                                        data[0].push(\r\n                                            "<li class=\\"fold\\" title=\\"folds from line " + foldcount + " to line xxx\\">-</" +\r\n                                            "li>"\r\n                                        );\r\n                                        foldstart = data[0].length - 1;\r\n                                    } else {\r\n                                        data[0].push("<li class=\\"empty\\">&#10;</li>");\r\n                                    }\r\n                                    data[1].push("<li class=\\"empty\\"></li>");\r\n                                    data[2].push("<li>" + (\r\n                                        newStart + 1\r\n                                    ) + "</li>");\r\n                                    data[3].push("<li class=\\"insert\\">");\r\n                                    data[3].push(newTextArray[newStart]);\r\n                                    data[3].push("&#10;</li>");\r\n                                }\r\n                                ntest    = false;\r\n                                newStart = newStart + 1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (options.diffcli === true) {\r\n                if (a < opcodesLength && foldstart > 49) {\r\n                    diffline = -1;\r\n                }\r\n                if (options.api === "dom") {\r\n                    data.push("</li></ol>");\r\n                    return [data.join("").replace("</li>", "<ol class=\\"diffcli\\">"), foldstart, diffline];\r\n                }\r\n                return [data, foldstart, diffline];\r\n            }\r\n            if (foldstart > -1) {\r\n                data[0][foldstart] = data[0][foldstart].replace("xxx", foldcount + rcount);\r\n            }\r\n            node.push(data[0].join(""));\r\n            node.push("</ol><ol class=");\r\n            if (options.diffview === "inline") {\r\n                node.push("\\"count\\">");\r\n            } else {\r\n                node.push("\\"data\\" data-prettydiff-ignore=\\"true\\">");\r\n                node.push(data[1].join(""));\r\n                node.push("</ol></div>");\r\n            }\r\n            node.push(data[2].join(""));\r\n            node.push("</ol><ol class=\\"data\\" data-prettydiff-ignore=\\"true\\">");\r\n            node.push(data[3].join(""));\r\n            if (options.diffview === "inline") {\r\n                node.push("</ol>");\r\n            } else {\r\n                node.push("</ol></div>");\r\n            }\r\n            node.push(\r\n                "<p class=\\"author\\">Diff view written by <a href=\\"http://prettydiff.com/\\">Pr" +\r\n                "etty Diff</a>.</p></div>"\r\n            );\r\n            baseTab  = (errorout === 1)\r\n                ? ""\r\n                : "s";\r\n            newTab   = (diffline === 1)\r\n                ? ""\r\n                : "s";\r\n            finaldoc = "<p><strong>Number of differences:</strong> <em>" + (\r\n                errorout + diffline\r\n            ) + "</em> difference" + baseTab + " from <em>" + diffline + "</em> line" +\r\n                    newTab + " of code.</p>" + node.join("");\r\n            return [\r\n                finaldoc\r\n                    .replace(\r\n                        /li\\u0020class="equal"><\\/li/g,\r\n                        "li class=\\"equal\\">&#10;</li"\r\n                    )\r\n                    .replace(/\\$#gt;/g, "&gt;")\r\n                    .replace(/\\$#lt;/g, "&lt;")\r\n                    .replace(/%#lt;/g, "$#lt;")\r\n                    .replace(/%#gt;/g, "$#gt;"),\r\n                errorout,\r\n                diffline\r\n            ];\r\n        }());\r\n    };\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function diffview_requirejs() {\r\n            return function diffview_requirejs_wrapper(x) {\r\n                return diffview(x);\r\n            };\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = diffview;\r\n    } else {\r\n        global.prettydiff.diffview = diffview;\r\n    }\r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(44))},function(n,e){n.exports='/*prettydiff.com topcoms:true,insize:4,inchar:" ",vertical:true */\r\n/*jshint laxbreak: true*/\r\n/*global __dirname, ace, define, global, module, process, require*/\r\n/*\r\n Special thanks to Harry Whitfield for assistance in providing test\r\n cases.\r\n\r\n jspretty is written by Austin Cheney on 2 Nov 2012\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n -----------------------------------------------------------------------\r\n */\r\n(function jspretty_init() {\r\n    "use strict";\r\n    var jspretty = function jspretty_(options) {\r\n        var sourcemap    = [\r\n                0, ""\r\n            ],\r\n            json         = (options.lang === "json"),\r\n            globalerror  = "",\r\n            // all data that is created from the tokization process is stored in the\r\n            // following four arrays: token, types, level, and lines.  All of this data\r\n            // passes from the tokenization process to be analyzed by the algorithm\r\n            token        = [], //stores parsed tokens\r\n            types        = [], //parallel array that describes the tokens\r\n            level        = [], //parallel array that list indentation per token\r\n            lines        = [], //used to preserve empty lines\r\n            depth        = [], //describes the token\'s current container\r\n            begin        = [], //index where current container starts\r\n            globals      = [], //which variables are declared globals\r\n            // meta used to find scope and variables for jsscope these values are assigned in parallel to the other arrays\r\n            //* irrelevant tokens are represented with an empty string\r\n            // * first \'(\' following \'function\' is token index number of function\'s closing\r\n            // curly brace\r\n            //* variables are represented with the value \'v\'\r\n            //* the closing brace of a function is an array of variables\r\n            meta         = [],\r\n            // lists a number at the opening paren of a function that points to the token\r\n            // index of the function\'s closing curly brace.  At the closing curly brace\r\n            // index this array stores an array indicating the names of variables declared\r\n            // in the current function for coloring by function depth in jsscope.  This\r\n            // array is ignored if jsscope is false\r\n            varlist      = [],\r\n            // groups variables from a variable list into a child array as well as\r\n            // properties of objects.  This array for adding extra space so that the "="\r\n            // following declared variables of a variable list is vertically aligned and\r\n            // likewise of the ":" with object properties\r\n            markupvar = [],\r\n            // notes a token index of a JSX markup tag assigned to JavaScript variable. This\r\n            // is necessary for indentation apart from syntactical factors.\r\n            error        = [],\r\n            news         = 0,\r\n            scolon       = 0,\r\n            // counts uncessary use of \'new\' keyword variables j, k, l, m, n, o, p, q, and w\r\n            // are used as various counters for the reporting only.  These variables do not\r\n            // store any tokens and are not used in the algorithm j counts line comments\r\n            stats        = {\r\n                comma       : 0,\r\n                commentBlock: {\r\n                    chars: 0,\r\n                    token: 0\r\n                },\r\n                commentLine : {\r\n                    chars: 0,\r\n                    token: 0\r\n                },\r\n                container   : 0,\r\n                number      : {\r\n                    chars: 0,\r\n                    token: 0\r\n                },\r\n                operator    : {\r\n                    chars: 0,\r\n                    token: 0\r\n                },\r\n                regex       : {\r\n                    chars: 0,\r\n                    token: 0\r\n                },\r\n                semicolon   : 0,\r\n                server      : {\r\n                    chars: 0,\r\n                    token: 0\r\n                },\r\n                space       : {\r\n                    newline: 0,\r\n                    other  : 0,\r\n                    space  : 0,\r\n                    tab    : 0\r\n                },\r\n                string      : {\r\n                    chars: 0,\r\n                    quote: 0,\r\n                    token: 0\r\n                },\r\n                word        : {\r\n                    chars: 0,\r\n                    token: 0\r\n                }\r\n            },\r\n            result       = "",\r\n            objsortop    = false,\r\n            verticalop   = false,\r\n            originalSize = options.source.length,\r\n            lf           = (options.crlf === true || options.crlf === "true")\r\n                ? "\\r\\n"\r\n                : "\\n",\r\n            extlib       = function jspretty__extlib(ops) {\r\n                var item = (ops === undefined)\r\n                    ? global\r\n                        .prettydiff\r\n                        .markuppretty(ops)\r\n                    : global\r\n                        .prettydiff\r\n                        .markuppretty(options);\r\n                if (options.nodeasync === true) {\r\n                    if (globalerror === "") {\r\n                        globalerror = item[1];\r\n                    }\r\n                    return item[0];\r\n                }\r\n                return item;\r\n            };\r\n        (function jspretty__options() {\r\n            var styleguide  = {},\r\n                brace_style = {};\r\n            if (options.mode === "beautify" || options.mode === "diff" || options.mode === "minify") {\r\n                objsortop  = (\r\n                    options.objsort === true || options.objsort === "true" || options.objsort === "all" || options.objsort === "js" || options.objsort === "jsonly"\r\n                );\r\n                verticalop = (\r\n                    options.vertical === true || options.vertical === "true" || options.vertical === "all" || options.vertical === "js"\r\n                );\r\n            }\r\n            options.source                          = (\r\n                typeof options.source === "string" && options.source.length > 0\r\n            )\r\n                ? options\r\n                    .source\r\n                    .replace(/\\r\\n?/g, "\\n")\r\n                : "Error: no source code supplied to jspretty!";\r\n            if (options.mode !== "analysis" && options.source.indexOf("Error: no") < 0) {\r\n                options.source = options.source + " ";\r\n            }\r\n            options.titanium                        = (options.titanium === true || options.titanium === "true")\r\n                ? (function jspretty__options_titanium() {\r\n                    options.correct  = false;\r\n                    options.titanium = true;\r\n                    token.push("x{");\r\n                    types.push("start");\r\n                    lines.push(0);\r\n                    depth.push("global");\r\n                    begin.push(0);\r\n                    return true;\r\n                }())\r\n                : false;\r\n            styleguide.airbnb                       = function jspretty__options_styleairbnb() {\r\n                options.bracepadding = true;\r\n                options.correct      = true;\r\n                options.endcomma     = "always";\r\n                options.inchar       = " ";\r\n                options.insize       = 2;\r\n                options.preserve     = 1;\r\n                options.quoteConvert = "single";\r\n                options.varword      = "each";\r\n                options.wrap         = 80;\r\n            };\r\n            styleguide.crockford                    = function jspretty__options_stylecrockford() {\r\n                options.bracepadding  = false;\r\n                options.correct       = true;\r\n                options.elseline      = false;\r\n                options.endcomma      = "never";\r\n                options.inchar        = " ";\r\n                options.insize        = 4;\r\n                options.nocaseindent  = true;\r\n                options.nochainindent = false;\r\n                options.space         = true;\r\n                options.varword       = "each";\r\n                verticalop            = false;\r\n            };\r\n            styleguide.google                       = function jspretty__options_stylegoogle() {\r\n                options.correct      = true;\r\n                options.inchar       = " ";\r\n                options.insize       = 4;\r\n                options.preserve     = 1;\r\n                options.quoteConvert = "single";\r\n                verticalop           = false;\r\n                options.wrap         = -1;\r\n            };\r\n            styleguide.grunt                        = function jspretty__options_stylegrunt() {\r\n                options.inchar       = " ";\r\n                options.insize       = 2;\r\n                options.quoteConvert = "single";\r\n                options.varword      = "each";\r\n            };\r\n            styleguide.jquery                       = function jspretty__options_stylejquery() {\r\n                options.bracepadding = true;\r\n                options.correct      = true;\r\n                options.inchar       = "\\u0009";\r\n                options.insize       = 1;\r\n                options.quoteConvert = "double";\r\n                options.varword      = "each";\r\n                options.wrap         = 80;\r\n            };\r\n            styleguide.jslint                       = styleguide.crockford;\r\n            styleguide.mrdoobs                      = function jspretty__options_stylemrdoobs() {\r\n                options.braceline    = true;\r\n                options.bracepadding = true;\r\n                options.correct      = true;\r\n                options.inchar       = "\\u0009";\r\n                options.insize       = 1;\r\n                verticalop           = false;\r\n            };\r\n            styleguide.mediawiki                    = function jspretty__options_stylemediawiki() {\r\n                options.bracepadding = true;\r\n                options.correct      = true;\r\n                options.inchar       = "\\u0009";\r\n                options.insize       = 1;\r\n                options.preserve     = 1;\r\n                options.quoteConvert = "single";\r\n                options.space        = false;\r\n                options.wrap         = 80;\r\n            };\r\n            styleguide.meteor                       = function jspretty__options_stylemeteor() {\r\n                options.correct = true;\r\n                options.inchar  = " ";\r\n                options.insize  = 2;\r\n                options.wrap    = 80;\r\n            };\r\n            styleguide.yandex                       = function jspretty__options_styleyandex() {\r\n                options.bracepadding = false;\r\n                options.correct      = true;\r\n                options.quoteConvert = "single";\r\n                options.varword      = "each";\r\n                verticalop           = false;\r\n            };\r\n            brace_style.collapse                    = function jspretty__options_collapse() {\r\n                options.braceline    = false;\r\n                options.bracepadding = false;\r\n                options.braces       = false;\r\n                options.formatObject = "indent";\r\n                options.neverflatten = true;\r\n            };\r\n            brace_style["collapse-preserve-inline"] = function jspretty__options_collapseInline() {\r\n                options.braceline    = false;\r\n                options.bracepadding = true;\r\n                options.braces       = false;\r\n                options.formatObject = "inline";\r\n                options.neverflatten = false;\r\n            };\r\n            brace_style.expand                      = function jspretty__options_expand() {\r\n                options.braceline    = false;\r\n                options.bracepadding = false;\r\n                options.braces       = true;\r\n                options.formatObject = "indent";\r\n                options.neverflatten = true;\r\n            };\r\n            if (styleguide[options.styleguide] !== undefined) {\r\n                styleguide[options.styleguide]();\r\n            }\r\n            if (brace_style[options.brace_style] !== undefined) {\r\n                brace_style[options.brace_style]();\r\n            }\r\n            if (json === true) {\r\n                options.wrap = 0;\r\n            }\r\n        }());\r\n        if (options.source === "Error: no source code supplied to jspretty!") {\r\n            return options.source;\r\n        }\r\n\r\n        (function jspretty__tokenize() {\r\n            var a              = 0,\r\n                b              = options.source.length,\r\n                c              = options\r\n                    .source\r\n                    .split(""),\r\n                ltoke          = "",\r\n                ltype          = "",\r\n                lword          = [],\r\n                brace          = [],\r\n                pword          = [],\r\n                lengtha        = 0,\r\n                lengthb        = 0,\r\n                wordTest       = -1,\r\n                paren          = -1,\r\n                classy         = [],\r\n                depthlist      = [\r\n                    ["global", 0]\r\n                ],\r\n                tempstore      = [],\r\n                pdepth         = [],\r\n                //depth and status of templateStrings\r\n                templateString = [],\r\n                //identify variable declarations\r\n                vart           = {\r\n                    count: [],\r\n                    index: [],\r\n                    word : [],\r\n                    len  : -1\r\n                },\r\n                //operations for start types: (, [, {\r\n                start          = function jspretty__tokenize_startInit() {\r\n                    return;\r\n                },\r\n                //peek at whats up next\r\n                nextchar       = function jspretty__tokenize_nextchar(len, current) {\r\n                    var cc    = 0,\r\n                        dd    = "",\r\n                        front = (current === true)\r\n                            ? a\r\n                            : a + 1;\r\n                    if (typeof len !== "number" || len < 1) {\r\n                        len = 1;\r\n                    }\r\n                    if (c[a] === "/") {\r\n                        if (c[a + 1] === "/") {\r\n                            dd = "\\n";\r\n                        } else if (c[a + 1] === "*") {\r\n                            dd = "/";\r\n                        }\r\n                    }\r\n                    for (cc = front; cc < b; cc = cc + 1) {\r\n                        if ((/\\s/).test(c[cc]) === false) {\r\n                            if (c[cc] === "/") {\r\n                                if (dd === "") {\r\n                                    if (c[cc + 1] === "/") {\r\n                                        dd = "\\n";\r\n                                    } else if (c[cc + 1] === "*") {\r\n                                        dd = "/";\r\n                                    }\r\n                                } else if (dd === "/" && c[cc - 1] === "*") {\r\n                                    dd = "";\r\n                                }\r\n                            }\r\n                            if (dd === "" && c[cc - 1] + c[cc] !== "*/") {\r\n                                return c\r\n                                    .slice(cc, cc + len)\r\n                                    .join("");\r\n                            }\r\n                        } else if (dd === "\\n" && c[cc] === "\\n") {\r\n                            dd = "";\r\n                        }\r\n                    }\r\n                    return "";\r\n                },\r\n                //cleans up improperly applied ASI\r\n                asifix         = function jspretty__tokenize_asifix() {\r\n                    var len = types.length;\r\n                    do {\r\n                        len = len - 1;\r\n                    } while (\r\n                        len > 0 && (types[len] === "comment" || types[len] === "comment-inline")\r\n                    );\r\n                    if (token[len] === "from") {\r\n                        len = len - 2;\r\n                    }\r\n                    if (token[len] === "x;") {\r\n                        token.splice(len, 1);\r\n                        types.splice(len, 1);\r\n                        lines.splice(len, 1);\r\n                        depth.splice(len, 1);\r\n                        begin.splice(len, 1);\r\n                    }\r\n                },\r\n                //determine the definition of containment by depth\r\n                depthPush      = function jspretty__tokenize_depthPush() {\r\n                    // * block      : if, for, while, catch, function, class, map\r\n                    // * immediates : else, do, try, finally, switch\r\n                    // * paren based: method, expression, paren\r\n                    // * data       : array, object\r\n                    var last  = 0,\r\n                        aa    = 0,\r\n                        wordx = "",\r\n                        wordy = "",\r\n                        bpush = false;\r\n                    lengtha = token.length;\r\n                    last    = lengtha - 1;\r\n                    aa      = last - 1;\r\n                    wordx   = token[aa];\r\n                    wordy   = (depth[aa] === undefined)\r\n                        ? ""\r\n                        : token[begin[aa] - 1];\r\n                    if (types[aa] === "comment" || types[aa] === "comment-inline") {\r\n                        do {\r\n                            aa = aa - 1;\r\n                        } while (aa > 0 && (types[aa] === "comment" || types[aa] === "comment-inline"));\r\n                        wordx = token[aa];\r\n                    }\r\n                    if ((token[last] === "{" || token[last] === "x{") && ((wordx === "else" && token[last] !== "if") || wordx === "do" || wordx === "try" || wordx === "finally" || wordx === "switch")) {\r\n                        depth.push(wordx);\r\n                    } else if (token[last] === "{" || token[last] === "x{") {\r\n                        if (lengtha === 1 && options.jsx === true) {\r\n                            depth.push("global");\r\n                        } else if (classy[classy.length - 1] === 0 && wordx !== "return") {\r\n                            classy.pop();\r\n                            depth.push("class");\r\n                        } else if (token[aa - 1] === "class") {\r\n                            depth.push("class");\r\n                        } else if (token[aa] === "]" && token[aa - 1] === "[") {\r\n                            depth.push("array");\r\n                        } else if (types[aa] === "word" && (types[aa - 1] === "word" || (token[aa - 1] === "?" && types[aa - 2] === "word")) && token[aa] !== "in" && token[aa - 1] !== "export" && token[aa - 1] !== "import") {\r\n                            depth.push("map");\r\n                        } else if (depth[aa] === "method" && types[aa] === "end" && types[begin[aa] - 1] === "word" && token[begin[aa] - 2] === "new") {\r\n                            depth.push("initializer");\r\n                        } else if (token[last] === "{" && (wordx === ")" || wordx === "x)") && (types[begin[aa] - 1] === "word" || token[begin[aa] - 1] === "]")) {\r\n                            if (wordy === "if") {\r\n                                depth.push("if");\r\n                            } else if (wordy === "for") {\r\n                                depth.push("for");\r\n                            } else if (wordy === "while") {\r\n                                depth.push("while");\r\n                            } else if (wordy === "class") {\r\n                                depth.push("class");\r\n                            } else if (wordy === "switch" || token[begin[aa] - 1] === "switch") {\r\n                                depth.push("switch");\r\n                            } else if (wordy === "catch") {\r\n                                depth.push("catch");\r\n                            } else {\r\n                                depth.push("function");\r\n                            }\r\n                        } else if (token[last] === "{" && (wordx === ";" || wordx === "x;")) {\r\n                            //ES6 block\r\n                            depth.push("block");\r\n                        } else if (token[last] === "{" && token[aa] === ":" && depth[aa] === "switch") {\r\n                            //ES6 block\r\n                            depth.push("block");\r\n                        } else if (token[aa - 1] === "import" || token[aa - 2] === "import" || token[aa - 1] === "export" || token[aa - 2] === "export") {\r\n                            depth.push("object");\r\n                        } else if (wordx === ")" && (pword[0] === "function" || pword[0] === "if" || pword[0] === "for" || pword[0] === "class" || pword[0] === "while" || pword[0] === "switch" || pword[0] === "catch")) {\r\n                            // if preceeded by a paren the prior containment is preceeded by a keyword if\r\n                            // (...) {\r\n                            depth.push(pword[0]);\r\n                        } else if (depth[aa] === "notation") {\r\n                            //if following a TSX array type declaration\r\n                            depth.push("function");\r\n                        } else if ((types[aa] === "literal" || types[aa] === "word") && types[aa - 1] === "word" && token[begin[aa] - 1] !== "for") {\r\n                            //if preceed by a word and either string or word public class {\r\n                            depth.push("function");\r\n                        } else if (depthlist.length > 0 && token[aa] !== ":" && depthlist[depthlist.length - 1][0] === "object" && (\r\n                            token[begin[aa] - 2] === "{" || token[begin[aa] - 2] === ","\r\n                        )) {\r\n                            // if an object wrapped in some containment which is itself preceeded by a curly\r\n                            // brace or comma var a={({b:{cat:"meow"}})};\r\n                            depth.push("function");\r\n                        } else if (types[pword[1] - 1] === "markup" && token[pword[1] - 3] === "function") {\r\n                            //checking for TSX function using an angle brace name\r\n                            depth.push("function");\r\n                        } else if (wordx === "=>") {\r\n                            //checking for fat arrow assignment\r\n                            depth.push("function");\r\n                        } else if (wordx === ")" && depth[aa] === "method" && types[begin[aa] - 1] === "word") {\r\n                            depth.push("function");\r\n                        } else if (types[last - 1] === "word" && token[last] === "{" && token[last - 1] !== "return" && token[last - 1] !== "in" && token[last - 1] !== "import" && token[last - 1] !== "const" && token[last - 1] !== "let" && token[last - 1] !== "") {\r\n                            //ES6 block\r\n                            depth.push("block");\r\n                        } else {\r\n                            depth.push("object");\r\n                        }\r\n                    } else if (token[last] === "[") {\r\n                        if ((/\\s/).test(c[a - 1]) === true && types[aa] === "word" && wordx !== "return" && options.twig === false) {\r\n                            depth.push("notation");\r\n                        } else {\r\n                            depth.push("array");\r\n                        }\r\n                    } else if (token[last] === "(" || token[last] === "x(") {\r\n                        if (types[aa] === "generic") {\r\n                            depth.push("method");\r\n                        } else if (token[aa] === "}" && depth[aa] === "function") {\r\n                            depth.push("method");\r\n                        } else if (wordx === "if" || wordx === "for" || wordx === "function" || wordx === "class" || wordx === "while" || wordx === "catch" || wordx === "switch" || wordx === "with") {\r\n                            depth.push("expression");\r\n                        } else if ((types[aa] === "word" && wordx !== "return") || (wordx === "}" && (depth[aa] === "function" || depth[aa] === "class"))) {\r\n                            depth.push("method");\r\n                        } else {\r\n                            depth.push("paren");\r\n                        }\r\n                    } else if (ltoke === ":" && types[aa] === "word" && token[aa - 1] === "[") {\r\n                        depth[aa]     = "attribute";\r\n                        depth[aa - 1] = "attribute";\r\n                        depth.push("attribute");\r\n                        depthlist[depthlist.length - 1][0] = "attribute";\r\n                    } else if (depthlist.length === 0) {\r\n                        depth.push("global");\r\n                        begin.push(0);\r\n                        bpush = true;\r\n                    } else {\r\n                        depth.push(depthlist[depthlist.length - 1][0]);\r\n                        begin.push(depthlist[depthlist.length - 1][1]);\r\n                        bpush = true;\r\n                    }\r\n                    if (bpush === false) {\r\n                        begin.push(last);\r\n                    }\r\n                },\r\n                tokenpop       = function jspretty__tokenize_tokenpop() {\r\n                    lengtha   = lengtha - 1;\r\n                    lengthb   = lengthb - 1;\r\n                    tempstore = [token.pop(), types.pop(), lines.pop(), depth.pop(), begin.pop()];\r\n                },\r\n                //reinsert the prior popped token\r\n                temppush       = function jspretty__tokenize_temppush() {\r\n                    token.push(tempstore[0]);\r\n                    types.push(tempstore[1]);\r\n                    lines.push(tempstore[2]);\r\n                    depth.push(tempstore[3]);\r\n                    begin.push(tempstore[4]);\r\n                    lengtha = lengtha + 1;\r\n                },\r\n                //populate various parallel arrays\r\n                tokenpush      = function jspretty__tokenize_tokenpush(comma, lin) {\r\n                    if (comma === true) {\r\n                        token.push(",");\r\n                        types.push("separator");\r\n                    } else {\r\n                        token.push(ltoke);\r\n                        types.push(ltype);\r\n                    }\r\n                    lengtha = token.length;\r\n                    lines.push(lin);\r\n                    depthPush();\r\n                },\r\n                //inserts ending curly brace\r\n                blockinsert    = function jspretty__tokenize_blockinsert() {\r\n                    var next = nextchar(5, false),\r\n                        g    = lengtha - 1;\r\n                    if (json === true) {\r\n                        return;\r\n                    }\r\n                    if (depth[lengtha - 1] === "do" && next === "while" && token[lengtha - 1] === "}") {\r\n                        return;\r\n                    }\r\n                    next = next.slice(0, 4);\r\n                    if (ltoke === ";" && token[g - 1] === "x{") {\r\n                        //to prevent the semicolon from inserting between the braces --\x3e while (x) {};\r\n                        tokenpop();\r\n                        ltoke = "x}";\r\n                        ltype = "end";\r\n                        tokenpush(false, 0);\r\n                        brace.pop();\r\n                        pdepth = depthlist.pop();\r\n                        ltoke  = ";";\r\n                        ltype  = "end";\r\n                        temppush();\r\n                        return;\r\n                    }\r\n                    ltoke = "x}";\r\n                    ltype = "end";\r\n                    if (token[lengtha - 1] === "x}") {\r\n                        return;\r\n                    }\r\n                    if (depth[lengtha - 1] === "if" && (token[lengtha - 1] === ";" || token[lengtha - 1] === "x;") && next === "else") {\r\n                        tokenpush(false, 0);\r\n                        brace.pop();\r\n                        pdepth = depthlist.pop();\r\n                        return;\r\n                    }\r\n                    do {\r\n                        tokenpush(false, 0);\r\n                        brace.pop();\r\n                        pdepth = depthlist.pop();\r\n                    } while (brace[brace.length - 1] === "x{");\r\n                },\r\n                //remove "vart" object data\r\n                vartpop        = function jspretty__tokenize_vartpop() {\r\n                    vart\r\n                        .count\r\n                        .pop();\r\n                    vart\r\n                        .index\r\n                        .pop();\r\n                    vart\r\n                        .word\r\n                        .pop();\r\n                    vart.len = vart.len - 1;\r\n                },\r\n                logError       = function jspretty__tokenize_logError(message, start) {\r\n                    var f = a,\r\n                        g = types.length;\r\n                    if (error.length > 0) {\r\n                        return;\r\n                    }\r\n                    error.push(message);\r\n                    do {\r\n                        f = f - 1;\r\n                    } while (c[f] !== "\\n" && f > 0);\r\n                    error.push(c.slice(f, start).join(""));\r\n                    if (g > 1) {\r\n                        do {\r\n                            g = g - 1;\r\n                        } while (g > 0 && types[g] !== "comment");\r\n                    }\r\n                    if (g > -1 && g < token.length && token[g].indexOf("//") === 0 && error[1].replace(/^\\s+/, "").indexOf(token[g + 1]) === 0 && (token[g].split("\\"").length % 2 === 1 || token[g].split("\'").length % 2 === 1)) {\r\n                        error = [\r\n                            message, token[g] + error[1]\r\n                        ];\r\n                    } else {\r\n                        error = [\r\n                            message, error[1]\r\n                        ];\r\n                    }\r\n                    if (globalerror === "") {\r\n                        globalerror = message + ":" + error[1];\r\n                    }\r\n                },\r\n                //A tokenizer for keywords, reserved words, and variables\r\n                word           = function jspretty__tokenize_word() {\r\n                    var f        = wordTest,\r\n                        g        = 1,\r\n                        build    = [],\r\n                        output   = "",\r\n                        nextitem = "",\r\n                        elsefix  = function jspretty__tokenize_word_elsefix() {\r\n                            brace.push("x{");\r\n                            depthlist.push(["else", lengtha]);\r\n                            token.splice(lengtha - 3, 1);\r\n                            types.splice(lengtha - 3, 1);\r\n                            lines.splice(lengtha - 3, 1);\r\n                            depth.splice(lengtha - 3, 1);\r\n                            begin.splice(lengtha - 3, 1);\r\n                        };\r\n                    do {\r\n                        build.push(c[f]);\r\n                        if (c[f] === "\\\\") {\r\n                            logError("Illegal escape in JavaScript", a);\r\n                        }\r\n                        f = f + 1;\r\n                    } while (f < a);\r\n                    output   = build.join("");\r\n                    wordTest = -1;\r\n                    if (types.length > 1 && output === "function" && token[lengtha - 1] === "(" && (token[token.length - 2] === "{" || token[token.length - 2] === "x{")) {\r\n                        types[types.length - 1] = "start";\r\n                    }\r\n                    if (types.length > 2 && output === "function" && ltoke === "(" && (token[token.length - 2] === "}" || token[token.length - 2] === "x}")) {\r\n                        if (token[token.length - 2] === "}") {\r\n                            for (f = token.length - 3; f > -1; f = f - 1) {\r\n                                if (types[f] === "end") {\r\n                                    g = g + 1;\r\n                                } else if (types[f] === "start" || types[f] === "end") {\r\n                                    g = g - 1;\r\n                                }\r\n                                if (g === 0) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (token[f] === "{" && token[f - 1] === ")") {\r\n                                g = 1;\r\n                                for (f = f - 2; f > -1; f = f - 1) {\r\n                                    if (types[f] === "end") {\r\n                                        g = g + 1;\r\n                                    } else if (types[f] === "start" || types[f] === "end") {\r\n                                        g = g - 1;\r\n                                    }\r\n                                    if (g === 0) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (token[f - 1] !== "function" && token[f - 2] !== "function") {\r\n                                    types[types.length - 1] = "start";\r\n                                }\r\n                            }\r\n                        } else {\r\n                            types[types.length - 1] = "start";\r\n                        }\r\n                    }\r\n                    if (options.correct === true && (output === "Object" || output === "Array") && c[a + 1] === "(" && c[a + 2] === ")" && token[lengtha - 2] === "=" && token[lengtha - 1] === "new") {\r\n                        if (output === "Object") {\r\n                            token[lengtha - 1]                 = "{";\r\n                            ltoke                              = "}";\r\n                            depth[a - 1]                       = "object";\r\n                            depthlist[depthlist.length - 1][0] = "object";\r\n                        } else {\r\n                            token[lengtha - 1]                 = "[";\r\n                            ltoke                              = "]";\r\n                            depth[a - 1]                       = "array";\r\n                            depthlist[depthlist.length - 1][0] = "array";\r\n                        }\r\n                        types[lengtha - 1] = "start";\r\n                        ltype              = "end";\r\n                        c[a + 1]           = "";\r\n                        c[a + 2]           = "";\r\n                        stats.container    = stats.container + 2;\r\n                        a                  = a + 2;\r\n                    } else {\r\n                        g = types.length - 1;\r\n                        f = g;\r\n                        if (options.varword !== "none" && (output === "var" || output === "let" || output === "const")) {\r\n                            if (types[g] === "comment" || types[g] === "comment-inline") {\r\n                                do {\r\n                                    g = g - 1;\r\n                                } while (g > 0 && (types[g] === "comment" || types[g] === "comment-inline"));\r\n                            }\r\n                            if (options.varword === "list" && vart.len > -1 && vart.index[vart.len] === g && output === vart.word[vart.len]) {\r\n                                stats.word.token     = stats.word.token + 1;\r\n                                stats.word.chars     = stats.word.chars + output.length;\r\n                                ltoke                = ",";\r\n                                ltype                = "separator";\r\n                                token[g]             = ltoke;\r\n                                types[g]             = ltype;\r\n                                vart.count[vart.len] = 0;\r\n                                vart.index[vart.len] = g;\r\n                                vart.word[vart.len]  = output;\r\n                                return;\r\n                            }\r\n                            vart.len = vart.len + 1;\r\n                            vart\r\n                                .count\r\n                                .push(0);\r\n                            vart\r\n                                .index\r\n                                .push(g);\r\n                            vart\r\n                                .word\r\n                                .push(output);\r\n                            g = f;\r\n                        } else if (vart.len > -1 && output !== vart.word[vart.len] && token.length === vart.index[vart.len] + 1 && token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && options.varword === "list") {\r\n                            vartpop();\r\n                        }\r\n                        if (output === "else" && (types[g] === "comment" || types[g] === "comment-inline")) {\r\n                            do {\r\n                                f = f - 1;\r\n                            } while (f > -1 && (types[f] === "comment" || types[f] === "comment-inline"));\r\n                            if (token[f] === "x;" && (token[f - 1] === "}" || token[f - 1] === "x}")) {\r\n                                token.splice(f, 1);\r\n                                types.splice(f, 1);\r\n                                lines.splice(f, 1);\r\n                                depth.splice(f, 1);\r\n                                begin.splice(f, 1);\r\n                                g = g - 1;\r\n                                f = f - 1;\r\n                            }\r\n                            do {\r\n                                build = [\r\n                                    token[g], types[g], lines[g], depth[g], begin[g]\r\n                                ];\r\n                                tokenpop();\r\n                                token.splice(g - 3, 0, build[0]);\r\n                                types.splice(g - 3, 0, build[1]);\r\n                                lines.splice(g - 3, 0, build[2]);\r\n                                depth.splice(g - 3, 0, build[3]);\r\n                                begin.splice(g - 3, 0, build[4]);\r\n                                f = f + 1;\r\n                            } while (f < g);\r\n                        }\r\n                        if (output === "from" && token[lengtha - 1] === "x;" && token[lengtha - 2] === "}") {\r\n                            asifix();\r\n                        }\r\n                        if (output === "while" && token[lengtha - 1] === "x;" && token[lengtha - 2] === "}") {\r\n                            (function jspretty__tokenize_word_whilefix() {\r\n                                var d = 0,\r\n                                    e = 0;\r\n                                for (e = lengtha - 3; e > -1; e = e - 1) {\r\n                                    if (types[e] === "end") {\r\n                                        d = d + 1;\r\n                                    } else if (types[e] === "start") {\r\n                                        d = d - 1;\r\n                                    }\r\n                                    if (d < 0) {\r\n                                        if (token[e] === "{" && token[e - 1] === "do") {\r\n                                            asifix();\r\n                                        }\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }());\r\n                        }\r\n                        ltoke            = output;\r\n                        ltype            = "word";\r\n                        stats.word.token = stats.word.token + 1;\r\n                        stats.word.chars = stats.word.chars + output.length;\r\n                        if (output === "from" && token[lengtha - 1] === "}") {\r\n                            asifix();\r\n                        }\r\n                    }\r\n                    tokenpush(false, 0);\r\n                    if (output === "class") {\r\n                        classy.push(0);\r\n                    }\r\n                    if (output === "do") {\r\n                        nextitem = nextchar(1, true);\r\n                        if (nextitem !== "{") {\r\n                            ltoke = "x{";\r\n                            ltype = "start";\r\n                            brace.push("x{");\r\n                            tokenpush(false, 0);\r\n                            depthlist.push([\r\n                                "do", lengtha - 1\r\n                            ]);\r\n                        }\r\n                    }\r\n                    if (output === "else") {\r\n                        nextitem = nextchar(2, true);\r\n                        if (nextitem !== "if" && nextitem.charAt(0) !== "{") {\r\n                            ltoke = "x{";\r\n                            ltype = "start";\r\n                            brace.push("x{");\r\n                            tokenpush(false, 0);\r\n                            depthlist.push([\r\n                                "else", lengtha - 1\r\n                            ]);\r\n                        }\r\n                        if (token[lengtha - 3] === "x}") {\r\n                            if (token[lengtha - 2] === "else") {\r\n                                if (token[lengtha - 4] === "x}" && pdepth[0] !== "if" && depth[depth.length - 2] === "else") {\r\n                                    elsefix();\r\n                                } else if (token[lengtha - 4] === "}" && depth[lengtha - 4] === "if" && pdepth[0] === "if" && token[pdepth[1] - 1] !== "if" && token[begin[lengtha - 3]] === "x{") {\r\n                                    //fixes when "else" is following a block that isn\'t "if"\r\n                                    elsefix();\r\n                                }\r\n                            } else if (token[lengtha - 2] === "x}" && depth[depth.length - 2] === "if") {\r\n                                elsefix();\r\n                            }\r\n                        }\r\n                    }\r\n                    if ((output === "for" || output === "if" || output === "switch" || output === "catch") && options.twig === false && token[lengtha - 2] !== ".") {\r\n                        nextitem = nextchar(1, true);\r\n                        if (nextitem !== "(") {\r\n                            paren = lengtha - 1;\r\n                            start("x(");\r\n                        }\r\n                    }\r\n                },\r\n                //sort object properties\r\n                objSort        = function jspretty__tokenize_objSort() {\r\n                    var cc        = 0,\r\n                        dd        = 0,\r\n                        ee        = 0,\r\n                        startlen  = token.length - 1,\r\n                        behind    = startlen,\r\n                        keys      = [],\r\n                        keylen    = 0,\r\n                        keyend    = 0,\r\n                        front     = 0,\r\n                        sort      = function jspretty__tokenize_objSort_sort(x, y) {\r\n                            var xx = x[0],\r\n                                yy = y[0];\r\n                            if (types[xx] === "comment" || types[xx] === "comment-inline") {\r\n                                do {\r\n                                    xx = xx + 1;\r\n                                } while (\r\n                                    xx < startlen && (types[xx] === "comment" || types[xx] === "comment-inline")\r\n                                );\r\n                            }\r\n                            if (types[yy] === "comment" || types[yy] === "comment-inline") {\r\n                                do {\r\n                                    yy = yy + 1;\r\n                                } while (\r\n                                    yy < startlen && (types[yy] === "comment" || types[yy] === "comment-inline")\r\n                                );\r\n                            }\r\n                            if (token[xx].toLowerCase() > token[yy].toLowerCase()) {\r\n                                return 1;\r\n                            }\r\n                            return -1;\r\n                        },\r\n                        commaTest = true,\r\n                        pairToken = [],\r\n                        pairTypes = [],\r\n                        pairLines = [],\r\n                        pairDepth = [],\r\n                        pairBegin = [];\r\n                    if (token[behind] === "," || types[behind] === "comment") {\r\n                        do {\r\n                            behind = behind - 1;\r\n                        } while (behind > 0 && (token[behind] === "," || types[behind] === "comment"));\r\n                    }\r\n                    for (cc = behind; cc > -1; cc = cc - 1) {\r\n                        if (types[cc] === "end") {\r\n                            dd = dd + 1;\r\n                        }\r\n                        if (types[cc] === "start") {\r\n                            dd = dd - 1;\r\n                        }\r\n                        if (dd === 0) {\r\n                            if (types[cc].indexOf("template") > -1) {\r\n                                return;\r\n                            }\r\n                            if (token[cc] === ",") {\r\n                                commaTest = true;\r\n                                front     = cc + 1;\r\n                            }\r\n                            if (commaTest === true && token[cc] === "," && front < behind) {\r\n                                if (token[behind] !== ",") {\r\n                                    behind = behind + 1;\r\n                                }\r\n                                if (types[front] === "comment-inline") {\r\n                                    front = front + 1;\r\n                                }\r\n                                keys.push([front, behind]);\r\n                                behind = front - 1;\r\n                            }\r\n                        }\r\n                        if (dd < 0 && cc < startlen) {\r\n                            if (keys.length > 0 && keys[keys.length - 1][0] > cc + 1) {\r\n                                ee = keys[keys.length - 1][0];\r\n                                if (types[ee - 1] !== "comment-inline") {\r\n                                    ee = ee - 1;\r\n                                }\r\n                                keys.push([\r\n                                    cc + 1,\r\n                                    ee\r\n                                ]);\r\n                            }\r\n                            if (token[cc - 1] === "=" || token[cc - 1] === ":" || token[cc - 1] === "(" || token[cc - 1] === "[" || token[cc - 1] === "," || types[cc - 1] === "word" || cc === 0) {\r\n                                if (keys.length > 1) {\r\n                                    keys.sort(sort);\r\n                                    keylen    = keys.length;\r\n                                    commaTest = false;\r\n                                    for (dd = 0; dd < keylen; dd = dd + 1) {\r\n                                        keyend = keys[dd][1];\r\n                                        if (lines[keys[dd][0] - 1] > 1 && pairLines.length > 0) {\r\n                                            pairLines[pairLines.length - 1] = lines[keys[dd][0] - 1];\r\n                                        }\r\n                                        for (ee = keys[dd][0]; ee < keyend; ee = ee + 1) {\r\n                                            pairToken.push(token[ee]);\r\n                                            pairTypes.push(types[ee]);\r\n                                            pairLines.push(lines[ee]);\r\n                                            pairDepth.push(depth[ee]);\r\n                                            pairBegin.push(begin[ee]);\r\n\r\n                                            //remove extra commas\r\n                                            if (token[ee] === ",") {\r\n                                                commaTest = true;\r\n                                            } else if (token[ee] !== "," && types[ee] !== "comment" && types[ee] !== "comment-inline") {\r\n                                                commaTest = false;\r\n                                            }\r\n                                        }\r\n                                        if (commaTest === false) {\r\n                                            ee = pairTypes.length - 1;\r\n                                            if (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline") {\r\n                                                do {\r\n                                                    ee = ee - 1;\r\n                                                } while (\r\n                                                    ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\r\n                                                );\r\n                                            }\r\n                                            ee = ee + 1;\r\n                                            pairToken.splice(ee, 0, ",");\r\n                                            pairTypes.splice(ee, 0, "separator");\r\n                                            pairLines.splice(ee, 0, pairLines[ee - 1]);\r\n                                            pairDepth.splice(ee, 0, "object");\r\n                                            pairBegin.splice(ee, 0, cc);\r\n                                            pairLines[ee - 1] = 0;\r\n                                        }\r\n                                    }\r\n                                    ee = pairTypes.length;\r\n                                    do {\r\n                                        ee = ee - 1;\r\n                                    } while (\r\n                                        ee > 0 && (pairTypes[ee] === "comment" || pairTypes[ee] === "comment-inline")\r\n                                    );\r\n                                    if (options.endcomma === "never" || options.endcomma === "multiline") {\r\n                                        pairToken.splice(ee, 1);\r\n                                        pairTypes.splice(ee, 1);\r\n                                        pairLines.splice(ee, 1);\r\n                                        pairDepth.splice(ee, 1);\r\n                                        pairBegin.splice(ee, 1);\r\n                                    }\r\n                                    keylen = token.length - (cc + 1);\r\n                                    token.splice(cc + 1, keylen);\r\n                                    types.splice(cc + 1, keylen);\r\n                                    lines.splice(cc + 1, keylen);\r\n                                    depth.splice(cc + 1, keylen);\r\n                                    begin.splice(cc + 1, keylen);\r\n                                    token     = token.concat(pairToken);\r\n                                    types     = types.concat(pairTypes);\r\n                                    lines     = lines.concat(pairLines);\r\n                                    depth     = depth.concat(pairDepth);\r\n                                    begin     = begin.concat(pairBegin);\r\n                                    lengtha   = token.length;\r\n                                    pairToken = [cc];\r\n                                    for (cc = cc + 1; cc < lengtha; cc = cc + 1) {\r\n                                        if (types[cc] === "start") {\r\n                                            pairToken.push(cc);\r\n                                        }\r\n                                        begin[cc] = pairToken[pairToken.length - 1];\r\n                                        if (types[cc] === "end") {\r\n                                            pairToken.pop();\r\n                                        }\r\n                                    }\r\n                                } else if (options.endcomma === "always" && types[lengtha - 1] !== "start") {\r\n                                    tokenpush(true, 0);\r\n                                }\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                },\r\n                slashes        = function jspretty__tokenize_slashes(index) {\r\n                    var slashy = index;\r\n                    do {\r\n                        slashy = slashy - 1;\r\n                    } while (c[slashy] === "\\\\" && slashy > 0);\r\n                    if ((index - slashy) % 2 === 1) {\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                },\r\n                // commaComment ensures that commas immediately precede comments instead of\r\n                // immediately follow\r\n                commaComment   = function jspretty__tokenize_commacomment() {\r\n                    var x = types.length;\r\n                    if (depth[lengtha - 1] === "object" && objsortop === true) {\r\n                        ltoke = ",";\r\n                        ltype = "separator";\r\n                        asifix();\r\n                        tokenpush(false, 0);\r\n                    } else {\r\n                        do {\r\n                            x = x - 1;\r\n                        } while (\r\n                            x > 0 && (types[x - 1] === "comment" || types[x - 1] === "comment-inline")\r\n                        );\r\n                        token.splice(x, 0, ",");\r\n                        types.splice(x, 0, "separator");\r\n                        lines.splice(x, 0, 0);\r\n                        depthPush();\r\n                    }\r\n                },\r\n                //injects a comma into the end of arrays for use with endcomma option\r\n                endCommaArray  = function jspretty__tokenize_endCommaArray() {\r\n                    var d = 0,\r\n                        e = 0;\r\n                    for (d = lengtha; d > 0; d = d - 1) {\r\n                        if (types[d] === "end") {\r\n                            e = e + 1;\r\n                        } else if (types[d] === "start") {\r\n                            e = e - 1;\r\n                        }\r\n                        if (e < 0) {\r\n                            return;\r\n                        }\r\n                        if (e === 0 && token[d] === ",") {\r\n                            return tokenpush(true, 0);\r\n                        }\r\n                    }\r\n                },\r\n                //automatic semicolon insertion\r\n                asi            = function jspretty__tokenize_asi(isEnd) {\r\n                    var len   = token.length - 1,\r\n                        aa    = 0,\r\n                        next  = nextchar(1, false),\r\n                        tokel = token[len],\r\n                        typel = types[len],\r\n                        deepl = depth[len],\r\n                        begnl = begin[len],\r\n                        clist = (depthlist.length === 0)\r\n                            ? ""\r\n                            : depthlist[depthlist.length - 1][0];\r\n                    if (json === true || tokel === ";" || tokel === "," || next === "{" || deepl === "class" || deepl === "map" || deepl === "attribute" || clist === "initializer" || types[begnl - 1] === "generic") {\r\n                        return;\r\n                    }\r\n                    if (((deepl === "global" && typel !== "end") || (typel === "end" && depth[begnl - 1] === "global")) && (next === "" || next === "}") && deepl === depth[lengtha - 2] && options.jsx === true) {\r\n                        return;\r\n                    }\r\n                    if (deepl === "array" && tokel !== "]") {\r\n                        return;\r\n                    }\r\n                    if (typel !== undefined && typel.indexOf("template") > -1) {\r\n                        return;\r\n                    }\r\n                    if (next === ";" && isEnd === false) {\r\n                        return;\r\n                    }\r\n                    if (options.qml === true) {\r\n                        if (typel === "start") {\r\n                            return;\r\n                        }\r\n                        ltoke = "x;";\r\n                        ltype = "separator";\r\n                        tokenpush(false, 0);\r\n                        if (brace[brace.length - 1] === "x{" && nextchar !== "}") {\r\n                            blockinsert();\r\n                        }\r\n                        return;\r\n                    }\r\n                    if (tokel === "}" && (deepl === "function" || deepl === "if" || deepl === "else" || deepl === "for" || deepl === "do" || deepl === "while" || deepl === "switch" || deepl === "class" || deepl === "try" || deepl === "catch" || deepl === "finally" || deepl === "block")) {\r\n                        if (token[begnl - 1] === ")") {\r\n                            aa = begin[begnl - 1] - 1;\r\n                            if (token[aa - 1] === "function") {\r\n                                aa = aa - 1;\r\n                            }\r\n                            if (depth[aa - 1] === "object" || depth[aa - 1] === "switch") {\r\n                                return;\r\n                            }\r\n                            if (token[aa - 1] !== "=" && token[aa - 1] !== "return" && token[aa - 1] !== ":") {\r\n                                return;\r\n                            }\r\n                        } else {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (typel === "comment" || typel === "comment-inline" || clist === "method" || clist === "paren" || clist === "expression" || clist === "array" || clist === "object" || (clist === "switch" && deepl !== "method" && token[begin[lengtha - 1]] === "(")) {\r\n                        return;\r\n                    }\r\n                    if (depth[lengtha - 1] === "expression" && (token[begin[lengtha - 1] - 1] !== "while" || (token[begin[lengtha - 1] - 1] === "while" && depth[begin[lengtha - 1] - 2] !== "do"))) {\r\n                        return;\r\n                    }\r\n                    if (next !== "" && "=<>+*?|^:&%~,.()]".indexOf(next) > -1 && isEnd === false) {\r\n                        return;\r\n                    }\r\n                    if (typel === "comment" || typel === "comment-inline") {\r\n                        do {\r\n                            len = len - 1;\r\n                        } while (\r\n                            len > 0 && (types[len] === "comment" || types[len] === "comment-inline")\r\n                        );\r\n                        if (len < 1) {\r\n                            return;\r\n                        }\r\n                        tokel = token[len];\r\n                        typel = types[len];\r\n                        deepl = depth[len];\r\n                    }\r\n                    if (tokel === undefined || typel === "start" || typel === "separator" || (typel === "operator" && tokel !== "++" && tokel !== "--") || tokel === "x}" || tokel === "var" || tokel === "let" || tokel === "const" || tokel === "else" || tokel.indexOf("#!/") === 0 || tokel === "instanceof") {\r\n                        return;\r\n                    }\r\n                    if (deepl === "method" && (token[begnl - 1] === "function" || token[begnl - 2] === "function")) {\r\n                        return;\r\n                    }\r\n                    if (options.varword === "list") {\r\n                        vart.index[vart.len] = token.length;\r\n                    }\r\n                    ltoke = ";";\r\n                    ltype = "separator";\r\n                    token.splice(len + 1, 0, "x;");\r\n                    types.splice(len + 1, 0, "separator");\r\n                    lines.splice(len, 0, 0);\r\n                    depthPush();\r\n                    if (brace[brace.length - 1] === "x{" && nextchar !== "}") {\r\n                        blockinsert();\r\n                    }\r\n                },\r\n                //convert ++ and -- into "= x +"  and "= x -" in most cases\r\n                plusplus = function jspretty__tokenize_plusplus() {\r\n                    var store      = [],\r\n                        pre        = true,\r\n                        toke       = "+",\r\n                        tokea      = "",\r\n                        tokeb      = "",\r\n                        tokec      = "",\r\n                        inc        = 0,\r\n                        ind        = 0,\r\n                        walk       = 0,\r\n                        end        = function jspretty__tokenize_plusplus_endInit() {\r\n                            return;\r\n                        },\r\n                        period     = function jspretty__tokenize_plusplus_periodInit() {\r\n                            return;\r\n                        },\r\n                        applyStore = function jspretty__tokenize_plusplus_applyStore() {\r\n                            var x = 0,\r\n                                y = store[0].length;\r\n                            do {\r\n                                token.push(store[0][x]);\r\n                                types.push(store[1][x]);\r\n                                lines.push(store[2][x]);\r\n                                depth.push(store[3][x]);\r\n                                begin.push(store[4][x]);\r\n                                x = x + 1;\r\n                            } while (x < y);\r\n                        },\r\n                        next       = "";\r\n                    lengtha = token.length;\r\n                    tokea   = token[lengtha - 1];\r\n                    tokeb   = token[lengtha - 2];\r\n                    tokec   = token[lengtha - 3];\r\n                    end     = function jspretty__tokenize_plusplus_end() {\r\n                        walk = begin[walk] - 1;\r\n                        if (types[walk] === "end") {\r\n                            jspretty__tokenize_plusplus_end();\r\n                        } else if (token[walk - 1] === ".") {\r\n                            period();\r\n                        }\r\n                    };\r\n                    period  = function jspretty__tokenize_plusplus_period() {\r\n                        walk = walk - 2;\r\n                        if (types[walk] === "end") {\r\n                            end();\r\n                        } else if (token[walk - 1] === ".") {\r\n                            jspretty__tokenize_plusplus_period();\r\n                        }\r\n                    };\r\n                    if (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--") {\r\n                        walk = lengtha - 1;\r\n                        if (types[walk] === "end") {\r\n                            end();\r\n                        } else if (token[walk - 1] === ".") {\r\n                            period();\r\n                        }\r\n                    }\r\n                    if (token[walk - 1] === "++" || token[walk - 1] === "--") {\r\n                        if ("startendoperator".indexOf(types[walk - 2]) > -1) {\r\n                            return;\r\n                        }\r\n                        store.push(token.slice(walk));\r\n                        store.push(types.slice(walk));\r\n                        store.push(lines.slice(walk));\r\n                        store.push(depth.slice(walk));\r\n                        store.push(begin.slice(walk));\r\n                        token.splice(walk, lengtha - walk);\r\n                        types.splice(walk, lengtha - walk);\r\n                        lines.splice(walk, lengtha - walk);\r\n                        depth.splice(walk, lengtha - walk);\r\n                        begin.splice(walk, lengtha - walk);\r\n                    } else {\r\n                        if (options.correct === false || (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--")) {\r\n                            return;\r\n                        }\r\n                        next = nextchar(1, false);\r\n                        if ((tokea === "++" || tokea === "--") && (c[a] === ";" || next === ";" || c[a] === "}" || next === "}" || c[a] === ")" || next === ")")) {\r\n                            toke = depth[lengtha - 1];\r\n                            if (toke === "array" || toke === "method" || toke === "object" || toke === "paren" || toke === "notation" || (token[begin[lengtha - 1] - 1] === "while" && toke !== "while")) {\r\n                                return;\r\n                            }\r\n                            inc = lengtha - 1;\r\n                            do {\r\n                                inc = inc - 1;\r\n                                if (token[inc] === "return") {\r\n                                    return;\r\n                                }\r\n                                if (types[inc] === "end") {\r\n                                    do {\r\n                                        inc = begin[inc] - 1;\r\n                                    } while (types[inc] === "end" && inc > 0);\r\n                                }\r\n                            } while (\r\n                                inc > 0 && (token[inc] === "." || types[inc] === "word" || types[inc] === "end")\r\n                            );\r\n                            if (token[inc] === "," && c[a] !== ";" && next !== ";" && c[a] !== "}" && next !== "}" && c[a] !== ")" && next !== ")") {\r\n                                return;\r\n                            }\r\n                            if (types[inc] === "operator") {\r\n                                if (depth[inc] === "switch" && token[inc] === ":") {\r\n                                    do {\r\n                                        inc = inc - 1;\r\n                                        if (types[inc] === "start") {\r\n                                            ind = ind - 1;\r\n                                            if (ind < 0) {\r\n                                                break;\r\n                                            }\r\n                                        } else if (types[inc] === "end") {\r\n                                            ind = ind + 1;\r\n                                        }\r\n                                        if (token[inc] === "?" && ind === 0) {\r\n                                            return;\r\n                                        }\r\n                                    } while (inc > 0);\r\n                                } else {\r\n                                    return;\r\n                                }\r\n                            }\r\n                            pre = false;\r\n                            if (tokea === "--") {\r\n                                toke = "-";\r\n                            } else {\r\n                                toke = "+";\r\n                            }\r\n                        } else if (tokec === "[" || tokec === ";" || tokec === "x;" || tokec === "}" || tokec === "{" || tokec === "(" || tokec === ")" || tokec === "," || tokec === "return") {\r\n                            if (tokea === "++" || tokea === "--") {\r\n                                if (tokec === "[" || tokec === "(" || tokec === "," || tokec === "return") {\r\n                                    return;\r\n                                }\r\n                                if (tokea === "--") {\r\n                                    toke = "-";\r\n                                }\r\n                                pre = false;\r\n                            } else if (tokeb === "--" || tokea === "--") {\r\n                                toke = "-";\r\n                            }\r\n                        } else {\r\n                            return;\r\n                        }\r\n                        if (pre === false) {\r\n                            tokenpop();\r\n                        }\r\n                        walk = lengtha - 1;\r\n                        if (types[walk] === "end") {\r\n                            end();\r\n                        } else if (token[walk - 1] === ".") {\r\n                            period();\r\n                        }\r\n                        store.push(token.slice(walk));\r\n                        store.push(types.slice(walk));\r\n                        store.push(lines.slice(walk));\r\n                        store.push(depth.slice(walk));\r\n                        store.push(begin.slice(walk));\r\n                    }\r\n                    if (pre === true) {\r\n                        token.splice(walk - 1, 1);\r\n                        types.splice(walk - 1, 1);\r\n                        lines.splice(walk - 1, 1);\r\n                        depth.splice(walk - 1, 1);\r\n                        begin.splice(walk - 1, 1);\r\n                        ltoke = "=";\r\n                        ltype = "operator";\r\n                        tokenpush(false, 0);\r\n                        applyStore();\r\n                        ltoke = toke;\r\n                        ltype = "operator";\r\n                        tokenpush(false, 0);\r\n                        ltoke = "1";\r\n                        ltype = "literal";\r\n                        tokenpush(false, 0);\r\n                    } else {\r\n                        ltoke = "=";\r\n                        ltype = "operator";\r\n                        tokenpush(false, 0);\r\n                        applyStore();\r\n                        ltoke = toke;\r\n                        ltype = "operator";\r\n                        tokenpush(false, 0);\r\n                        ltoke = "1";\r\n                        ltype = "literal";\r\n                        tokenpush(false, 0);\r\n                    }\r\n                    ltoke = token[lengtha - 1];\r\n                    ltype = types[lengtha - 1];\r\n                    if (next === "}" && c[a] !== ";") {\r\n                        asi(false);\r\n                    }\r\n                },\r\n                //converts "+=" and "-=" to "x = x + 1"\r\n                plusequal = function jspretty__tokenize_plusequal(op) {\r\n                    var toke       = op.charAt(0),\r\n                        walk       = lengtha - 1,\r\n                        store      = [],\r\n                        end        = function jspretty__tokenize_plusequal_endInit() {\r\n                            return;\r\n                        },\r\n                        period     = function jspretty__tokenize_plusequal_periodInit() {\r\n                            return;\r\n                        },\r\n                        applyStore = function jspretty__tokenize_plusplus_applyStore() {\r\n                            var x = 0,\r\n                                y = store[0].length;\r\n                            do {\r\n                                token.push(store[0][x]);\r\n                                types.push(store[1][x]);\r\n                                lines.push(store[2][x]);\r\n                                depth.push(store[3][x]);\r\n                                begin.push(store[4][x]);\r\n                                x = x + 1;\r\n                            } while (x < y);\r\n                        };\r\n                    end    = function jspretty__tokenize_plusequal_end() {\r\n                        walk = begin[walk] - 1;\r\n                        if (types[walk] === "end") {\r\n                            jspretty__tokenize_plusequal_end();\r\n                        } else if (token[walk - 1] === ".") {\r\n                            period();\r\n                        }\r\n                    };\r\n                    period = function jspretty__tokenize_plusequal_period() {\r\n                        walk = walk - 2;\r\n                        if (types[walk] === "end") {\r\n                            end();\r\n                        } else if (token[walk - 1] === ".") {\r\n                            jspretty__tokenize_plusequal_period();\r\n                        }\r\n                    };\r\n                    if (types[walk] === "end") {\r\n                        end();\r\n                    } else if (token[walk - 1] === ".") {\r\n                        period();\r\n                    }\r\n                    store.push(token.slice(walk));\r\n                    store.push(types.slice(walk));\r\n                    store.push(lines.slice(walk));\r\n                    store.push(depth.slice(walk));\r\n                    store.push(begin.slice(walk));\r\n                    ltoke = "=";\r\n                    ltype = "operator";\r\n                    tokenpush(false, 0);\r\n                    applyStore();\r\n                    return toke;\r\n                },\r\n                //fixes asi location if inserted after an inserted brace\r\n                asibrace       = function jspretty__tokenize_asibrace() {\r\n                    var aa = token.length;\r\n                    do {\r\n                        aa = aa - 1;\r\n                    } while (aa > -1 && token[aa] === "x}");\r\n                    if (depth[aa] === "else") {\r\n                        return tokenpush(false, 0);\r\n                    }\r\n                    aa = aa + 1;\r\n                    token.splice(aa, 0, ltoke);\r\n                    types.splice(aa, 0, ltype);\r\n                    lines.push(0);\r\n                    depthPush();\r\n                },\r\n                //convert double quotes to single or the opposite\r\n                quoteConvert   = function jspretty__tokenize_quoteConvert(item) {\r\n                    var dub   = (options.quoteConvert === "double"),\r\n                        qchar = (dub === true)\r\n                            ? "\\""\r\n                            : "\'";\r\n                    item = item.slice(1, item.length - 1);\r\n                    if (dub === true) {\r\n                        item = item.replace(/"/g, "\'");\r\n                    } else {\r\n                        item = item.replace(/\'/g, "\\"");\r\n                    }\r\n                    return qchar + item + qchar;\r\n                },\r\n                //manage comment wrapping\r\n                commentwrap    = function jspretty__tokenize_commentwrap(comment, line) {\r\n                    var prior        = "",\r\n                        ptype        = "",\r\n                        xblock       = (function jspretty__tokenize_commentLine_xblock() {\r\n                            if (token[lengtha - 1] !== "x}" || (lines[lengtha - 1] > 0 && nextchar(4, false) !== "else") || (token[lengtha - 1] === "x}" && (token[lengtha - 2] === "}" || token[lengtha - 2] === "x}"))) {\r\n                                return false;\r\n                            }\r\n                            tokenpop();\r\n                            return true;\r\n                        }()),\r\n                        ind          = 0,\r\n                        vartest      = "",\r\n                        cstart       = (line === true)\r\n                            ? "// "\r\n                            : " * ",\r\n                        empty        = (/^(\\/\\/\\s*)$/),\r\n                        list         = (\r\n                            /^(\\/\\/\\s*(\\*|-|@|\\=|(\\d+(\\.|(\\s*-))))(?!(\\*|-|@|\\=|(\\d+(\\.|(\\s*-))))))/\r\n                        ),\r\n                        hrule        = (/^(\\/\\/\\s*---+\\s*)$/),\r\n                        remind       = (/^(\\/\\/\\s*((todo)|(note:)))/i),\r\n                        commentSplit = function jspretty__tokenize_commentLine_commentSplit() {\r\n                            var endi    = options.wrap - 3,\r\n                                starti  = 0,\r\n                                spacely = (comment.indexOf(" ") > 0),\r\n                                len     = 0,\r\n                                block   = [];\r\n                            if (line === true) {\r\n                                comment = comment.slice(2);\r\n                                if (spacely === true) {\r\n                                    do {\r\n                                        //split comments by word if possible\r\n                                        len    = comment.length;\r\n                                        starti = 0;\r\n                                        if ((/\\s/).test(comment.charAt(0)) === true) {\r\n                                            do {\r\n                                                starti = starti + 1;\r\n                                            } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\r\n                                        }\r\n                                        comment = comment.slice(starti);\r\n                                        len     = comment.length;\r\n                                        endi    = (options.wrap - 3);\r\n                                        if ((/\\s/).test(comment.slice(0, endi + 1)) === true && endi < len) {\r\n                                            endi = endi + 1;\r\n                                            do {\r\n                                                endi = endi - 1;\r\n                                            } while (endi > 0 && (/\\s/).test(comment.charAt(endi)) === false);\r\n                                        } else if ((/\\s/).test(comment) === true && endi < len) {\r\n                                            do {\r\n                                                endi = endi + 1;\r\n                                            } while (endi < len && (/\\s/).test(comment.charAt(endi)) === false);\r\n                                        } else {\r\n                                            endi = len;\r\n                                        }\r\n                                        ltoke = cstart + comment\r\n                                            .slice(0, endi)\r\n                                            .replace(/(\\s+)$/, "");\r\n                                        tokenpush(false, 0);\r\n                                        comment = comment.slice(endi);\r\n                                    } while (comment.length > endi);\r\n                                    if (comment !== "") {\r\n                                        len    = comment.length;\r\n                                        starti = 0;\r\n                                        if ((/\\s/).test(comment.charAt(0)) === true) {\r\n                                            do {\r\n                                                starti = starti + 1;\r\n                                            } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\r\n                                        }\r\n                                        ltoke = cstart + comment.slice(starti);\r\n                                        ltoke = ltoke.replace(/(\\s+)$/, "");\r\n                                        tokenpush(false, 0);\r\n                                    }\r\n                                } else {\r\n                                    if (prior.indexOf("//") === 0 && prior.length < endi && prior.indexOf(" ") === -1 && comment.indexOf(" ") === -1) {\r\n                                        endi               = endi - prior.length;\r\n                                        token[lengtha - 1] = prior + comment.slice(0, endi);\r\n                                        comment            = comment.slice(endi);\r\n                                        endi               = options.wrap;\r\n                                    }\r\n                                    endi = endi - 2;\r\n                                    do {\r\n                                        ltoke = cstart + comment.slice(0, endi);\r\n                                        ltoke = ltoke.replace(/(\\s+)$/, "");\r\n                                        tokenpush(false, 0);\r\n                                        comment = comment.slice(endi);\r\n                                    } while (comment.length > endi);\r\n                                    if (comment !== "") {\r\n                                        ltoke = cstart + comment.slice(0, endi);\r\n                                        ltoke = ltoke.replace(/(\\s+)$/, "");\r\n                                        tokenpush(false, 0);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                // the functionality for wrapping block comments is written here, but currently\r\n                                // disabled.  It demands a bit more finesse to prevent violation of JSLint and\r\n                                // some mutilation of white space styles\r\n                                if (spacely === true) {\r\n                                    len    = comment.length;\r\n                                    starti = 0;\r\n                                    if ((/\\s/).test(comment.charAt(0)) === true) {\r\n                                        do {\r\n                                            starti = starti + 1;\r\n                                        } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\r\n                                    }\r\n                                    endi = (options.wrap - 3) + starti;\r\n                                    if ((/\\s/).test(comment.charAt(endi)) === false && endi < len) {\r\n                                        do {\r\n                                            endi = endi - 1;\r\n                                        } while (endi > starti && (/\\s/).test(comment.charAt(endi)) === false);\r\n                                    }\r\n                                    if (endi > 0) {\r\n                                        block.push("/* " + comment.slice(starti, endi));\r\n                                        do {\r\n                                            starti = endi;\r\n                                            if ((/\\s/).test(comment.charAt(starti)) === true) {\r\n                                                do {\r\n                                                    starti = starti + 1;\r\n                                                } while (starti < len && (/\\s/).test(comment.charAt(starti)) === true);\r\n                                            }\r\n                                            endi = (options.wrap - 3) + starti;\r\n                                            if ((/\\s/).test(comment.charAt(endi)) === false && endi < len) {\r\n                                                do {\r\n                                                    endi = endi - 1;\r\n                                                } while (\r\n                                                    endi > 0 && endi > starti && (/\\s/).test(comment.charAt(endi)) === false\r\n                                                );\r\n                                            }\r\n                                            block.push(cstart + comment.slice(starti, endi).replace(/(\\s+)$/, ""));\r\n                                        } while (endi > 0 && endi < len);\r\n                                        block.push(" */");\r\n                                        ltoke = block.join(lf);\r\n                                    } else {\r\n                                        ltoke = "/* " + comment.replace(/(\\s+)$/, "") + " */";\r\n                                    }\r\n                                    tokenpush(false, 0);\r\n                                } else {\r\n                                    len  = comment.length;\r\n                                    endi = options.wrap - 3;\r\n                                    block.push("/* " + comment.slice(0, endi));\r\n                                    do {\r\n                                        starti = endi;\r\n                                        endi   = starti + (options.wrap - 3);\r\n                                        block.push(cstart + comment.slice(starti, endi));\r\n                                    } while (endi < len);\r\n                                    block.push(" */");\r\n                                    ltoke = block.join(lf);\r\n                                    tokenpush(false, 0);\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                    if (lines[lines.length - 1] === 0 && ltype !== "comment" && ltype !== "comment-inline" && options.styleguide !== "mrdoobs") {\r\n                        ltype = "comment-inline";\r\n                    } else {\r\n                        ltype = "comment";\r\n                    }\r\n                    if (options.preserveComment === true) {\r\n                        return tokenpush(false, 0);\r\n                    }\r\n                    if (hrule.test(comment) === true) {\r\n                        if (comment.charAt(2) !== " ") {\r\n                            comment = "// " + comment.slice(2);\r\n                        }\r\n                        ltoke = comment;\r\n                        return tokenpush(false, 0);\r\n                    }\r\n                    lengtha = token.length;\r\n                    if (comment.indexOf("/*global") === 0) {\r\n                        return tokenpush(false, 0);\r\n                    }\r\n                    if (line === true) {\r\n                        comment = comment\r\n                            .replace(/\\s\\/\\//g, " ")\r\n                            .replace(/(\\s+)$/, "");\r\n                    } else {\r\n                        if (comment.indexOf("/**") === 0) {\r\n                            return tokenpush(false, 0);\r\n                        }\r\n                        if (comment.indexOf("\\n") < 0 && comment.indexOf(":") > 0 && comment.indexOf(",") > 0) {\r\n                            return tokenpush(false, 0);\r\n                        }\r\n                        if ((/\\n(\\u0020|\\t)/).test(comment) === true && ((/\\n\\u0020\\*(\\u0020|\\/)/).test(comment) === false || (/\\n(?!(\\u0020\\*(\\u0020|\\/)))/).test(comment) === true)) {\r\n                            return tokenpush(false, 0);\r\n                        }\r\n                        if (comment.length < options.wrap - 3) {\r\n                            return tokenpush(false, 0);\r\n                        }\r\n                        if ((/^(\\/\\*\\u0020)/).test(comment) === true && (/\\n\\u0020\\*\\u0020/).test(comment) === true) {\r\n                            comment = comment.replace("/* ", "/*");\r\n                        }\r\n                        comment = comment\r\n                            .replace(/\\n\\u0020\\*\\u0020/g, " ")\r\n                            .replace(/\\n(\\u0020|\\t)+/g, "\\n");\r\n                        comment = comment.slice(2, comment.length - 2);\r\n                    }\r\n                    if (lengtha > 0) {\r\n                        prior = token[lengtha - 1];\r\n                        ptype = types[lengtha - 1];\r\n                    }\r\n                    if (ltype === "comment" && ptype !== "comment-inline" && options.wrap > 0 && empty.test(comment) === false && (comment.length > options.wrap || prior.indexOf("//") === 0)) {\r\n                        if (lengtha > 0 && token[lengtha - 1].indexOf("//") === 0 && empty.test(token[lengtha - 1]) === false && hrule.test(token[lengtha - 1]) === false && list.test(comment) === false && remind.test(comment) === false) {\r\n                            if (comment.charAt(2) !== " ") {\r\n                                comment = prior + " " + comment.slice(2);\r\n                            } else {\r\n                                comment = prior + comment.slice(2);\r\n                            }\r\n                            tokenpop();\r\n                        }\r\n                        if (token[lengtha - 1] === "var" || token[lengtha - 1] === "let" || token[lengtha - 1] === "const") {\r\n                            tokenpop();\r\n                            vartest = token[lengtha - 1];\r\n                        }\r\n                        if (comment.length > options.wrap - 2) {\r\n                            commentSplit();\r\n                        } else {\r\n                            if (line === true) {\r\n                                ltoke = comment;\r\n                            } else {\r\n                                ltoke = "/* " + comment\r\n                                    .replace(/^(\\s+)/, "")\r\n                                    .replace(/(\\s+)$/, "") + " */";\r\n                            }\r\n                            tokenpush(false, 0);\r\n                        }\r\n                        if (vartest !== "") {\r\n                            temppush();\r\n                            ind = lengtha - 1;\r\n                            do {\r\n                                ind = ind - 1;\r\n                            } while (types[ind] === "comment");\r\n                            lines[ind]         = lines[lengtha - 1];\r\n                            lines[lengtha - 1] = 0;\r\n                        }\r\n                    } else if (options.wrap < 0 && prior.indexOf("//") === 0) {\r\n                        if (comment.charAt(2) !== " ") {\r\n                            token[lengtha - 1] = prior + " " + comment.slice(2);\r\n                        } else {\r\n                            token[lengtha - 1] = prior + comment.slice(2);\r\n                        }\r\n                    } else {\r\n                        if (token[lengtha - 1] === "var" || token[lengtha - 1] === "let" || token[lengtha - 1] === "const") {\r\n                            tokenpop();\r\n                            vartest = token[lengtha - 1];\r\n                        }\r\n                        if (line === true) {\r\n                            ltoke = comment;\r\n                        } else {\r\n                            ltoke = "/* " + comment\r\n                                .replace(/^(\\s+)/, "")\r\n                                .replace(/(\\s+)$/, "") + " */";\r\n                        }\r\n                        tokenpush(false, 0);\r\n                        if (vartest !== "") {\r\n                            temppush();\r\n                            ind = lengtha - 1;\r\n                            do {\r\n                                ind = ind - 1;\r\n                            } while (types[ind] === "comment");\r\n                            lines[ind]         = lines[lengtha - 1];\r\n                            lines[lengtha - 1] = 0;\r\n                        }\r\n                    }\r\n                    if (xblock === true) {\r\n                        token.push("x}");\r\n                        types.push("end");\r\n                        lines.push(0);\r\n                        depth[lengtha - 1] = pdepth[0];\r\n                        begin[lengtha - 1] = pdepth[1];\r\n                        depth.push(pdepth[0]);\r\n                        begin.push(pdepth[1]);\r\n                    }\r\n                },\r\n                //merges strings separated by "+" if options.wrap is less than 0\r\n                strmerge       = function jspretty__tokenize_strmerge() {\r\n                    var aa   = 0,\r\n                        bb   = "",\r\n                        item = ltoke.slice(1, ltoke.length - 1);\r\n                    tokenpop();\r\n                    aa        = token.length - 1;\r\n                    bb        = token[aa];\r\n                    token[aa] = bb.slice(0, bb.length - 1) + item + bb.charAt(0);\r\n                },\r\n                // the generic function is a generic tokenizer start argument contains the\r\n                // token\'s starting syntax offset argument is length of start minus control\r\n                // chars end is how is to identify where the token ends\r\n                generic        = function jspretty__tokenize_genericBuilder(starting, ending) {\r\n                    var ee     = 0,\r\n                        ender  = ending.split(""),\r\n                        endlen = ender.length,\r\n                        jj     = b,\r\n                        build  = [starting],\r\n                        base   = a + starting.length,\r\n                        output = "",\r\n                        escape = false;\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    // this insanity is for JSON where all the required quote characters are\r\n                    // escaped.\r\n                    if (c[a - 1] === "\\\\" && slashes(a - 1) === true && (c[a] === "\\"" || c[a] === "\'")) {\r\n                        tokenpop();\r\n                        if (token[0] === "{") {\r\n                            if (c[a] === "\\"") {\r\n                                starting = "\\"";\r\n                                ending   = "\\\\\\"";\r\n                                build    = ["\\""];\r\n                            } else {\r\n                                starting = "\'";\r\n                                ending   = "\\\\\'";\r\n                                build    = ["\'"];\r\n                            }\r\n                            escape = true;\r\n                        } else {\r\n                            if (c[a] === "\\"") {\r\n                                return "\\\\\\"";\r\n                            }\r\n                            return "\\\\\'";\r\n                        }\r\n                    }\r\n                    for (ee = base; ee < jj; ee = ee + 1) {\r\n                        if (ee > a + 1) {\r\n                            if (c[ee] === "<" && c[ee + 1] === "?" && c[ee + 2] === "p" && c[ee + 3] === "h" && c[ee + 4] === "p" && c[ee + 5] !== starting && starting !== "//" && starting !== "/*") {\r\n                                a = ee;\r\n                                build.push(jspretty__tokenize_genericBuilder("<?php", "?>"));\r\n                                ee = ee + build[build.length - 1].length - 1;\r\n                            } else if (c[ee] === "<" && c[ee + 1] === "%" && c[ee + 2] !== starting && starting !== "//" && starting !== "/*") {\r\n                                a = ee;\r\n                                build.push(jspretty__tokenize_genericBuilder("<%", "%>"));\r\n                                ee = ee + build[build.length - 1].length - 1;\r\n                            } else if (c[ee] === "{" && c[ee + 1] === "%" && c[ee + 2] !== starting && starting !== "//" && starting !== "/*") {\r\n                                a = ee;\r\n                                build.push(jspretty__tokenize_genericBuilder("{%", "%}"));\r\n                                ee = ee + build[build.length - 1].length - 1;\r\n                            } else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] === "{" && c[ee + 3] !== starting && starting !== "//" && starting !== "/*") {\r\n                                a = ee;\r\n                                build.push(jspretty__tokenize_genericBuilder("{{{", "}}}"));\r\n                                ee = ee + build[build.length - 1].length - 1;\r\n                            } else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] !== starting && starting !== "//" && starting !== "/*") {\r\n                                a = ee;\r\n                                build.push(jspretty__tokenize_genericBuilder("{{", "}}"));\r\n                                ee = ee + build[build.length - 1].length - 1;\r\n                            } else if (c[ee] === "<" && c[ee + 1] === "!" && c[ee + 2] === "-" && c[ee + 3] === "-" && c[ee + 4] === "#" && c[ee + 5] !== starting && starting !== "//" && starting !== "/*") {\r\n                                a = ee;\r\n                                build.push(jspretty__tokenize_genericBuilder("\x3c!--#", "--\x3e"));\r\n                                ee = ee + build[build.length - 1].length - 1;\r\n                            } else {\r\n                                build.push(c[ee]);\r\n                            }\r\n                        } else {\r\n                            build.push(c[ee]);\r\n                        }\r\n                        if ((starting === "\\"" || starting === "\'") && json === false && c[ee - 1] !== "\\\\" && (c[ee] === "\\n" || ee === jj - 1)) {\r\n                            logError("Unterminated string in JavaScript", ee);\r\n                            break;\r\n                        }\r\n                        if (c[ee] === ender[endlen - 1] && (c[ee - 1] !== "\\\\" || slashes(ee - 1) === false)) {\r\n                            if (endlen === 1) {\r\n                                break;\r\n                            }\r\n                            // `ee - base` is a cheap means of computing length of build array the `ee -\r\n                            // base` and `endlen` are both length based values, so adding two (1 for each)\r\n                            // provides an index based number\r\n                            if (build[ee - base] === ender[0] && build.slice(ee - base - endlen + 2).join("") === ending) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (escape === true) {\r\n                        output = build[build.length - 1];\r\n                        build.pop();\r\n                        build.pop();\r\n                        build.push(output);\r\n                    }\r\n                    a = ee;\r\n                    if (starting === "//") {\r\n                        stats.space.newline = stats.space.newline + 1;\r\n                        build.pop();\r\n                    }\r\n                    output = build.join("");\r\n                    if (starting === "//") {\r\n                        output = output.replace(/(\\s+)$/, "");\r\n                    } else if (starting === "/*") {\r\n                        build = output.split(lf);\r\n                        for (ee = build.length - 1; ee > -1; ee = ee - 1) {\r\n                            build[ee] = build[ee].replace(/(\\s+)$/, "");\r\n                        }\r\n                        output = build.join(lf);\r\n                    }\r\n                    if (options.jsscope !== "none") {\r\n                        output = output\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;");\r\n                    }\r\n                    if (starting === "{%") {\r\n                        if (output.indexOf("{%-") < 0) {\r\n                            output = output\r\n                                .replace(/^(\\{%\\s*)/, "{% ")\r\n                                .replace(/(\\s*%\\})$/, " %}");\r\n                        } else {\r\n                            output = output\r\n                                .replace(/^(\\{%-\\s*)/, "{%- ")\r\n                                .replace(/(\\s*-%\\})$/, " -%}");\r\n                        }\r\n                    }\r\n                    if (output.indexOf("#region") === 0 || output.indexOf("#endregion") === 0) {\r\n                        output = output.replace(/(\\s+)$/, "");\r\n                    }\r\n                    return output;\r\n                },\r\n                //a tokenizer for regular expressions\r\n                regex          = function jspretty__tokenize_regex() {\r\n                    var ee     = 0,\r\n                        f      = b,\r\n                        h      = 0,\r\n                        i      = 0,\r\n                        build  = ["/"],\r\n                        output = "",\r\n                        square = false;\r\n                    for (ee = a + 1; ee < f; ee = ee + 1) {\r\n                        build.push(c[ee]);\r\n                        if (c[ee - 1] !== "\\\\" || c[ee - 2] === "\\\\") {\r\n                            if (c[ee] === "[") {\r\n                                square = true;\r\n                            }\r\n                            if (c[ee] === "]") {\r\n                                square = false;\r\n                            }\r\n                        }\r\n                        if (c[ee] === "/" && square === false) {\r\n                            if (c[ee - 1] === "\\\\") {\r\n                                i = 0;\r\n                                for (h = ee - 1; h > 0; h = h - 1) {\r\n                                    if (c[h] === "\\\\") {\r\n                                        i = i + 1;\r\n                                    } else {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (i % 2 === 0) {\r\n                                    break;\r\n                                }\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (c[ee + 1] === "g" || c[ee + 1] === "i" || c[ee + 1] === "m" || c[ee + 1] === "y" || c[ee + 1] === "u") {\r\n                        build.push(c[ee + 1]);\r\n                        if (c[ee + 2] !== c[ee + 1] && (c[ee + 2] === "g" || c[ee + 2] === "i" || c[ee + 2] === "m" || c[ee + 2] === "y" || c[ee + 2] === "u")) {\r\n                            build.push(c[ee + 2]);\r\n                            if (c[ee + 3] !== c[ee + 1] && c[ee + 3] !== c[ee + 2] && (c[ee + 3] === "g" || c[ee + 3] === "i" || c[ee + 3] === "m" || c[ee + 3] === "y" || c[ee + 3] === "u")) {\r\n                                build.push(c[ee + 3]);\r\n                                if (c[ee + 4] !== c[ee + 1] && c[ee + 4] !== c[ee + 2] && c[ee + 4] !== c[ee + 3] && (c[ee + 4] === "g" || c[ee + 4] === "i" || c[ee + 4] === "m" || c[ee + 4] === "y" || c[ee + 4] === "u")) {\r\n                                    build.push(c[ee + 4]);\r\n                                    if (c[ee + 5] !== c[ee + 1] && c[ee + 5] !== c[ee + 2] && c[ee + 5] !== c[ee + 3] && c[ee + 5] !== c[ee + 4] && (c[ee + 5] === "g" || c[ee + 5] === "i" || c[ee + 5] === "m" || c[ee + 5] === "y" || c[ee + 5] === "u")) {\r\n                                        build.push(c[ee + 4]);\r\n                                        a = ee + 5;\r\n                                    } else {\r\n                                        a = ee + 4;\r\n                                    }\r\n                                } else {\r\n                                    a = ee + 3;\r\n                                }\r\n                            } else {\r\n                                a = ee + 2;\r\n                            }\r\n                        } else {\r\n                            a = ee + 1;\r\n                        }\r\n                    } else {\r\n                        a = ee;\r\n                    }\r\n                    output = build.join("");\r\n                    if (options.jsscope !== "none") {\r\n                        output = output\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;");\r\n                    }\r\n                    return output;\r\n                },\r\n                //a unique tokenizer for operator characters\r\n                operator       = function jspretty__tokenize_operator() {\r\n                    var syntax = [\r\n                            "=",\r\n                            "<",\r\n                            ">",\r\n                            "+",\r\n                            "*",\r\n                            "?",\r\n                            "|",\r\n                            "^",\r\n                            ":",\r\n                            "&",\r\n                            "%",\r\n                            "~"\r\n                        ],\r\n                        g      = 0,\r\n                        h      = 0,\r\n                        jj     = b,\r\n                        build  = [c[a]],\r\n                        synlen = syntax.length,\r\n                        output = "";\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    if (c[a] === "/" && (lengtha > 0 && (ltype !== "word" || ltoke === "typeof" || ltoke === "return" || ltoke === "else") && ltype !== "literal" && ltype !== "end")) {\r\n                        if (ltoke === "return" || ltoke === "typeof" || ltoke === "else" || ltype !== "word") {\r\n                            ltoke             = regex();\r\n                            ltype             = "regex";\r\n                            stats.regex.token = stats.regex.token + 1;\r\n                            stats.regex.chars = stats.regex.chars + ltoke.length;\r\n                        } else {\r\n                            stats.operator.token = stats.operator.token + 1;\r\n                            stats.operator.chars = stats.operator.token + 1;\r\n                            ltoke                = "/";\r\n                            ltype                = "operator";\r\n                        }\r\n                        tokenpush(false, 0);\r\n                        return "regex";\r\n                    }\r\n                    if (c[a] === "?" && ("+-*/".indexOf(c[a + 1]) > -1 || (c[a + 1] === ":" && syntax.join("").indexOf(c[a + 2]) < 0))) {\r\n                        return "?";\r\n                    }\r\n                    if (c[a] === ":" && "+-*/".indexOf(c[a + 1]) > -1) {\r\n                        return ":";\r\n                    }\r\n                    if (a < b - 1) {\r\n                        if (c[a] !== "<" && c[a + 1] === "<") {\r\n                            return c[a];\r\n                        }\r\n                        if (c[a] === "!" && c[a + 1] === "/") {\r\n                            return "!";\r\n                        }\r\n                        if (c[a] === "-") {\r\n                            if (c[a + 1] === "-") {\r\n                                output = "--";\r\n                            } else if (c[a + 1] === "=") {\r\n                                output = "-=";\r\n                            } else if (c[a + 1] === ">") {\r\n                                output = "->";\r\n                            }\r\n                            if (output === "") {\r\n                                return "-";\r\n                            }\r\n                        }\r\n                        if (c[a] === "+") {\r\n                            if (c[a + 1] === "+") {\r\n                                output = "++";\r\n                            } else if (c[a + 1] === "=") {\r\n                                output = "+=";\r\n                            }\r\n                            if (output === "") {\r\n                                return "+";\r\n                            }\r\n                        }\r\n                        if (c[a] === "=" && c[a + 1] !== "=" && c[a + 1] !== "!" && c[a + 1] !== ">") {\r\n                            return "=";\r\n                        }\r\n                    }\r\n                    if (output === "") {\r\n                        if ((c[a + 1] === "+" && c[a + 2] === "+") || (c[a + 1] === "-" && c[a + 2] === "-")) {\r\n                            output = c[a];\r\n                        } else {\r\n                            for (g = a + 1; g < jj; g = g + 1) {\r\n                                if ((c[g] === "+" && c[g + 1] === "+") || (c[g] === "-" && c[g + 1] === "-")) {\r\n                                    break;\r\n                                }\r\n                                for (h = 0; h < synlen; h = h + 1) {\r\n                                    if (c[g] === syntax[h]) {\r\n                                        build.push(syntax[h]);\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (h === synlen) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            output = build.join("");\r\n                        }\r\n                    }\r\n                    a = a + (output.length - 1);\r\n                    if (options.jsscope !== "none") {\r\n                        output = output\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;");\r\n                    }\r\n                    if (output === "=>" && ltoke === ")") {\r\n                        g  = token.length - 1;\r\n                        jj = begin[g];\r\n                        do {\r\n                            if (begin[g] === jj) {\r\n                                depth[g] = "method";\r\n                            }\r\n                            g = g - 1;\r\n                        } while (g > jj - 1);\r\n                    }\r\n                    if (output.length === 2 && output.charAt(1) === "=" && "!=<>|&?".indexOf(output.charAt(0)) < 0 && options.correct === true) {\r\n                        return plusequal(output);\r\n                    }\r\n                    return output;\r\n                },\r\n                //ES6 template string support\r\n                tempstring     = function jspretty__tokenize_tempstring() {\r\n                    var output = [c[a]];\r\n                    for (a = a + 1; a < b; a = a + 1) {\r\n                        output.push(c[a]);\r\n                        if (c[a] === "`" && (c[a - 1] !== "\\\\" || slashes(a - 1) === false)) {\r\n                            templateString.pop();\r\n                            break;\r\n                        }\r\n                        if (c[a - 1] === "$" && c[a] === "{" && (c[a - 2] !== "\\\\" || slashes(a - 2) === false)) {\r\n                            templateString[templateString.length - 1] = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    return output.join("");\r\n                },\r\n                //a tokenizer for numbers\r\n                numb           = function jspretty__tokenize_number() {\r\n                    var ee    = 0,\r\n                        f     = b,\r\n                        build = [c[a]],\r\n                        test  = /zz/,\r\n                        dot   = (build[0] === ".");\r\n                    if (a < b - 2 && c[a] === "0") {\r\n                        if (c[a + 1] === "x") {\r\n                            test = /[0-9a-fA-F]/;\r\n                        } else if (c[a + 1] === "o") {\r\n                            test = /[0-9]/;\r\n                        } else if (c[a + 1] === "b") {\r\n                            test = /0|1/;\r\n                        }\r\n                        if (test.test(c[a + 2]) === true) {\r\n                            build.push(c[a + 1]);\r\n                            ee = a + 1;\r\n                            do {\r\n                                ee = ee + 1;\r\n                                build.push(c[ee]);\r\n                            } while (test.test(c[ee + 1]) === true);\r\n                            a = ee;\r\n                            return build.join("");\r\n                        }\r\n                    }\r\n                    for (ee = a + 1; ee < f; ee = ee + 1) {\r\n                        if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {\r\n                            build.push(c[ee]);\r\n                            if (c[ee] === ".") {\r\n                                dot = true;\r\n                            }\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (ee < f - 1 && ((/\\d/).test(c[ee - 1]) === true || ((/\\d/).test(c[ee - 2]) === true && (c[ee - 1] === "-" || c[ee - 1] === "+"))) && (c[ee] === "e" || c[ee] === "E")) {\r\n                        build.push(c[ee]);\r\n                        if (c[ee + 1] === "-" || c[ee + 1] === "+") {\r\n                            build.push(c[ee + 1]);\r\n                            ee = ee + 1;\r\n                        }\r\n                        dot = false;\r\n                        for (ee = ee + 1; ee < f; ee = ee + 1) {\r\n                            if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {\r\n                                build.push(c[ee]);\r\n                                if (c[ee] === ".") {\r\n                                    dot = true;\r\n                                }\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    a = ee - 1;\r\n                    return build.join("");\r\n                },\r\n                // Not a tokenizer.  This counts white space characters and determines if there\r\n                // are empty lines to be preserved\r\n                space          = function jspretty__tokenize_space() {\r\n                    var schars    = [],\r\n                        f         = 0,\r\n                        locallen  = b,\r\n                        emptyline = 1,\r\n                        output    = "",\r\n                        stest     = (/\\s/),\r\n                        asitest   = false;\r\n                    for (f = a; f < locallen; f = f + 1) {\r\n                        if (c[f] === "\\n") {\r\n                            stats.space.newline = stats.space.newline + 1;\r\n                            asitest             = true;\r\n                        } else if (c[f] === " ") {\r\n                            stats.space.space = stats.space.space + 1;\r\n                        } else if (c[f] === "\\t") {\r\n                            stats.space.tab = stats.space.tab + 1;\r\n                        } else if (stest.test(c[f]) === true) {\r\n                            stats.space.other = stats.space.other + 1;\r\n                        } else {\r\n                            break;\r\n                        }\r\n                        schars.push(c[f]);\r\n                    }\r\n                    a = f - 1;\r\n                    if (token.length === 0) {\r\n                        return;\r\n                    }\r\n                    output = schars.join("");\r\n                    if (output.indexOf("\\n") > -1 && token[token.length - 1].indexOf("#!/") !== 0) {\r\n                        schars = output.split("\\n");\r\n                        if (schars.length > 2) {\r\n                            emptyline = schars.length - 1;\r\n                            if (token[lengtha - 1].indexOf("//") === 0) {\r\n                                emptyline = emptyline + 1;\r\n                            }\r\n                            if (emptyline > options.preserve + 1) {\r\n                                emptyline = options.preserve + 1;\r\n                            }\r\n                        } else if (token[lengtha - 1] !== undefined && token[lengtha - 1].indexOf("//") === 0) {\r\n                            emptyline = 2;\r\n                        }\r\n                        if (ltype === "comment" && ltoke.charAt(1) !== "*" && emptyline < 2) {\r\n                            lines[lines.length - 1] = emptyline + 1;\r\n                        } else {\r\n                            lines[lines.length - 1] = emptyline;\r\n                        }\r\n                    }\r\n                    if (asitest === true && ltoke !== ";" && lengthb < token.length && c[a + 1] !== "}") {\r\n                        asi(false);\r\n                        lengthb = token.length;\r\n                    }\r\n                },\r\n                // Identifies blocks of markup embedded within JavaScript for language supersets\r\n                // like React JSX.\r\n                markup         = function jspretty__tokenize_markup() {\r\n                    var output     = [],\r\n                        curlytest  = false,\r\n                        endtag     = false,\r\n                        anglecount = 0,\r\n                        curlycount = 0,\r\n                        tagcount   = 0,\r\n                        d          = 0,\r\n                        next       = "",\r\n                        syntaxnum  = "0123456789=<>+-*?|^:&.,;%(){}[]~",\r\n                        syntax     = "=<>+-*?|^:&.,;%(){}[]~";\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    d = token.length - 1;\r\n                    if (types[d] === "comment" || types[d] === "comment-inline") {\r\n                        do {\r\n                            d = d - 1;\r\n                        } while (d > 0 && (types[d] === "comment" || types[d] === "comment-inline"));\r\n                    }\r\n                    if (c[a] === "<" && c[a + 1] === ">") {\r\n                        a     = a + 1;\r\n                        ltype = "generic";\r\n                        return "<>";\r\n                    }\r\n                    if ((c[a] !== "<" && syntaxnum.indexOf(c[a + 1]) > -1) || token[d] === "++" || token[d] === "--" || (/\\s/).test(c[a + 1]) === true || ((/\\d/).test(c[a + 1]) === true && (ltype === "operator" || ltype === "literal" || (ltype === "word" && ltoke !== "return")))) {\r\n                        ltype = "operator";\r\n                        return operator();\r\n                    }\r\n                    if (options.typescript === false && (token[d] === "return" || types[d] === "operator" || types[d] === "start" || types[d] === "separator" || (token[d] === "}" && depthlist[depthlist.length - 1][0] === "global"))) {\r\n                        ltype       = "markup";\r\n                        options.jsx = true;\r\n                    } else if (options.typescript === true || token[lengtha - 1] === "#include" || (((/\\s/).test(c[a - 1]) === false || ltoke === "public" || ltoke === "private" || ltoke === "static" || ltoke === "final" || ltoke === "implements" || ltoke === "class" || ltoke === "void" || ltoke === "Promise") && syntaxnum.indexOf(c[a + 1]) < 0)) {\r\n                        //Java type generics\r\n                        return (function jspretty__tokenize_markup_generic() {\r\n                            var generics = [\r\n                                    "<",\r\n                                    c[a + 1]\r\n                                ],\r\n                                comma    = false,\r\n                                e        = 1,\r\n                                f        = 0;\r\n                            if (c[a + 1] === "<") {\r\n                                e = 2;\r\n                            }\r\n                            for (d = a + 2; d < b; d = d + 1) {\r\n                                generics.push(c[d]);\r\n                                if (c[d] === "?" && c[d + 1] === ">") {\r\n                                    generics.push(">");\r\n                                    d = d + 1;\r\n                                }\r\n                                if (c[d] === ",") {\r\n                                    comma = true;\r\n                                    if ((/\\s/).test(c[d + 1]) === false) {\r\n                                        generics.push(" ");\r\n                                    }\r\n                                } else if (c[d] === "[") {\r\n                                    f = f + 1;\r\n                                } else if (c[d] === "]") {\r\n                                    f = f - 1;\r\n                                } else if (c[d] === "<") {\r\n                                    e = e + 1;\r\n                                } else if (c[d] === ">") {\r\n                                    e = e - 1;\r\n                                    if (e === 0 && f === 0) {\r\n                                        if ((/\\s/).test(c[d - 1]) === true) {\r\n                                            ltype = "operator";\r\n                                            return operator();\r\n                                        }\r\n                                        ltype = "generic";\r\n                                        a     = d;\r\n                                        return generics\r\n                                            .join("")\r\n                                            .replace(/\\s+/g, " ");\r\n                                    }\r\n                                }\r\n                                if ((syntax.indexOf(c[d]) > -1 && c[d] !== "," && c[d] !== "<" && c[d] !== ">" && c[d] !== "[" && c[d] !== "]") || (comma === false && (/\\s/).test(c[d]) === true)) {\r\n                                    ltype = "operator";\r\n                                    return operator();\r\n                                }\r\n                            }\r\n                        }());\r\n                    } else {\r\n                        ltype = "operator";\r\n                        return operator();\r\n                    }\r\n                    for (a = a; a < b; a = a + 1) {\r\n                        output.push(c[a]);\r\n                        if (c[a] === "{") {\r\n                            curlycount = curlycount + 1;\r\n                            curlytest  = true;\r\n                        } else if (c[a] === "}") {\r\n                            curlycount = curlycount - 1;\r\n                            if (curlycount === 0) {\r\n                                curlytest = false;\r\n                            }\r\n                        } else if (c[a] === "<" && curlytest === false) {\r\n                            if (c[a + 1] === "<") {\r\n                                do {\r\n                                    output.push(c[a]);\r\n                                    a = a + 1;\r\n                                } while (c[a + 1] === "<");\r\n                            }\r\n                            anglecount = anglecount + 1;\r\n                            if (c[a + 1] === "/") {\r\n                                endtag = true;\r\n                            }\r\n                        } else if (c[a] === ">" && curlytest === false) {\r\n                            if (c[a + 1] === ">") {\r\n                                do {\r\n                                    output.push(c[a]);\r\n                                    a = a + 1;\r\n                                } while (c[a + 1] === ">");\r\n                            }\r\n                            anglecount = anglecount - 1;\r\n                            if (endtag === true) {\r\n                                tagcount = tagcount - 1;\r\n                            } else if (c[a - 1] !== "/") {\r\n                                tagcount = tagcount + 1;\r\n                            }\r\n                            if (anglecount === 0 && curlycount === 0 && tagcount < 1) {\r\n                                ltype = "markup";\r\n                                next  = nextchar(2, false);\r\n                                if (next.charAt(0) !== "<") {\r\n                                    return output.join("");\r\n                                }\r\n                                // catch additional trailing tag sets\r\n                                if (next.charAt(0) === "<" && syntaxnum.indexOf(next.charAt(1)) < 0 && (/\\s/).test(next.charAt(1)) === false) {\r\n                                    // perform a minor safety test to verify if "<" is a tag start or a less than\r\n                                    // operator\r\n                                    d = a + 1;\r\n                                    do {\r\n                                        d = d + 1;\r\n                                        if (c[d] === ">" || ((/\\s/).test(c[d - 1]) === true && syntaxnum.indexOf(c[d]) < 0)) {\r\n                                            break;\r\n                                        }\r\n                                        if (syntaxnum.indexOf(c[d]) > -1) {\r\n                                            return output.join("");\r\n                                        }\r\n                                    } while (d < b);\r\n                                } else {\r\n                                    return output.join("");\r\n                                }\r\n                            }\r\n                            endtag = false;\r\n                        }\r\n                    }\r\n                    ltype = "markup";\r\n                    return output.join("");\r\n                },\r\n                //operations for end types: ), ], }\r\n                end            = function jspretty__tokenize_end(x) {\r\n                    var insert   = false,\r\n                        next     = nextchar(1, false),\r\n                        newarray = function jspretty__tokenize_end_newarray() {\r\n                            var aa       = begin[lengtha - 1],\r\n                                bb       = 0,\r\n                                cc       = 0,\r\n                                ar       = (token[begin[lengtha - 1] - 1] === "Array"),\r\n                                startar  = (ar === true)\r\n                                    ? "["\r\n                                    : "{",\r\n                                endar    = (ar === true)\r\n                                    ? "]"\r\n                                    : "}",\r\n                                namear   = (ar === true)\r\n                                    ? "array"\r\n                                    : "object",\r\n                                arraylen = 0;\r\n                            tokenpop();\r\n                            cc = lengtha - 1;\r\n                            if (ar === true && token[cc - 1] === "(" && types[cc] === "literal" && token[cc].charAt(0) !== "\\"" && token[cc].charAt(0) !== "\'") {\r\n                                arraylen = token[cc] - 1;\r\n                                tokenpop();\r\n                                tokenpop();\r\n                                tokenpop();\r\n                                token[token.length - 1]         = "[";\r\n                                lengtha                         = token.length;\r\n                                types[types.length - 1]         = "start";\r\n                                lines[lines.length - 1]         = 0;\r\n                                depth[depth.length - 1]         = "array";\r\n                                begin[begin.length - 1]         = lengtha - 1;\r\n                                depthlist[depthlist.length - 1] = [\r\n                                    "array", lengtha - 1\r\n                                ];\r\n                                do {\r\n                                    tokenpush(true, 0);\r\n                                    arraylen = arraylen - 1;\r\n                                } while (arraylen > 0);\r\n                            } else {\r\n                                token[aa] = startar;\r\n                                types[aa] = "start";\r\n                                cc        = begin[aa];\r\n                                token.splice(aa - 2, 2);\r\n                                types.splice(aa - 2, 2);\r\n                                lines.splice(aa - 2, 2);\r\n                                depth.splice(aa - 2, 2);\r\n                                begin.splice(aa - 2, 2);\r\n                                lengtha                         = lengtha - 2;\r\n                                depthlist[depthlist.length - 1] = [\r\n                                    namear, aa - 2\r\n                                ];\r\n                                pdepth                          = [namear, aa];\r\n                                bb                              = lengtha - 1;\r\n                                do {\r\n                                    if (begin[bb] === cc) {\r\n                                        depth[bb] = namear;\r\n                                        begin[bb] = begin[bb] - 2;\r\n                                    }\r\n                                    bb = bb - 1;\r\n                                } while (bb > aa - 3);\r\n                            }\r\n                            ltoke = endar;\r\n                            ltype = "end";\r\n                            tokenpush(false, 0);\r\n                        };\r\n                    stats.container = stats.container + 1;\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    if (classy.length > 0) {\r\n                        if (classy[classy.length - 1] === 0) {\r\n                            classy.pop();\r\n                        } else {\r\n                            classy[classy.length - 1] = classy[classy.length - 1] - 1;\r\n                        }\r\n                    }\r\n                    if (x === ")" || x === "x)" || x === "]") {\r\n                        plusplus();\r\n                        asifix();\r\n                    }\r\n                    if (x === ")" || x === "x)") {\r\n                        asi(false);\r\n                    }\r\n                    if (vart.len > -1) {\r\n                        if (x === "}" && ((options.varword === "list" && vart.count[vart.len] === 0) || (token[token.length - 1] === "x;" && options.varword === "each"))) {\r\n                            vartpop();\r\n                        }\r\n                        vart.count[vart.len] = vart.count[vart.len] - 1;\r\n                        if (vart.count[vart.len] < 0) {\r\n                            vartpop();\r\n                        }\r\n                    }\r\n                    if (ltoke === "," && depth[lengtha - 1] !== "initializer" && ((x === "]" && (options.endcomma === "never" || options.endcomma === "multiline" || token[lengtha - 2] === "[")) || x === "}")) {\r\n                        tokenpop();\r\n                    } else if ((x === "]" || x === "}") && options.endcomma === "always" && ltoke !== ",") {\r\n                        endCommaArray();\r\n                    }\r\n                    if (x === ")" || x === "x)") {\r\n                        ltoke = x;\r\n                        ltype = "end";\r\n                        if (lword.length > 0) {\r\n                            pword = lword[lword.length - 1];\r\n                            if (pword.length > 1 && next !== "{" && (pword[0] === "if" || pword[0] === "for" || (pword[0] === "while" && depth[pword[1] - 2] !== undefined && depth[pword[1] - 2] !== "do") || pword[0] === "with")) {\r\n                                insert = true;\r\n                            }\r\n                        }\r\n                    } else if (x === "]") {\r\n                        ltoke = "]";\r\n                        ltype = "end";\r\n                        pword = [];\r\n                    } else if (x === "}") {\r\n                        if (ltoke !== "," || options.endcomma === "always") {\r\n                            if (ltoke === ";" && options.mode === "minify") {\r\n                                token[token.length - 1] = "x;";\r\n                            }\r\n                            plusplus();\r\n                        }\r\n                        if (depthlist.length > 0 && depthlist[depthlist.length - 1][0] !== "object") {\r\n                            asi(true);\r\n                        } else if (objsortop === true) {\r\n                            objSort();\r\n                        }\r\n                        if (ltype === "comment" || ltype === "comment-inline") {\r\n                            lengtha = token.length;\r\n                            ltoke   = token[lengtha - 1];\r\n                            ltype   = types[lengtha - 1];\r\n                        }\r\n                        if (options.braceline === true) {\r\n                            lines[lines.length - 1] = 2;\r\n                        }\r\n                        ltoke = "}";\r\n                        ltype = "end";\r\n                        pword = [];\r\n                    }\r\n                    lword.pop();\r\n                    tokenpush(false, 0);\r\n                    if (x === ")" && options.correct === true && (token[begin[lengtha - 1] - 1] === "Array" || token[begin[lengtha - 1] - 1] === "Object") && token[begin[lengtha - 1] - 2] === "new") {\r\n                        newarray();\r\n                    }\r\n                    pdepth = depthlist.pop();\r\n                    if (brace[brace.length - 1] === "x{" && x === "}") {\r\n                        blockinsert();\r\n                    }\r\n                    brace.pop();\r\n                    if (brace[brace.length - 1] === "x{" && x === "}" && depth[lengtha - 1] !== "try") {\r\n                        if (next !== ":" && token[begin[a] - 1] !== "?") {\r\n                            blockinsert();\r\n                        }\r\n                    }\r\n                    if (insert === true) {\r\n                        ltoke = "x{";\r\n                        ltype = "start";\r\n                        tokenpush(false, 0);\r\n                        brace.push("x{");\r\n                        pword[1] = lengtha - 1;\r\n                        depthlist.push(pword);\r\n                    }\r\n                },\r\n                //determines tag names for {% %} based template tags and returns a type\r\n                tname          = function jspretty__tokenize_tname(x) {\r\n                    var sn       = 2,\r\n                        en       = 0,\r\n                        st       = x.slice(0, 2),\r\n                        len      = x.length,\r\n                        name     = "",\r\n                        namelist = [\r\n                            "autoescape",\r\n                            "block",\r\n                            "capture",\r\n                            "case",\r\n                            "comment",\r\n                            "embed",\r\n                            "filter",\r\n                            "for",\r\n                            "form",\r\n                            "if",\r\n                            "macro",\r\n                            "paginate",\r\n                            "raw",\r\n                            "sandbox",\r\n                            "spaceless",\r\n                            "tablerow",\r\n                            "unless",\r\n                            "verbatim"\r\n                        ];\r\n                    if (x.charAt(2) === "-") {\r\n                        sn = sn + 1;\r\n                    }\r\n                    if ((/\\s/).test(x.charAt(sn)) === true) {\r\n                        do {\r\n                            sn = sn + 1;\r\n                        } while ((/\\s/).test(x.charAt(sn)) === true && sn < len);\r\n                    }\r\n                    en = sn;\r\n                    do {\r\n                        en = en + 1;\r\n                    } while (\r\n                        (/\\s/).test(x.charAt(en)) === false && x.charAt(en) !== "(" && en < len\r\n                    );\r\n                    if (en === len) {\r\n                        en = x.length - 2;\r\n                    }\r\n                    name = x.slice(sn, en);\r\n                    if (name === "else" || (st === "{%" && (name === "elseif" || name === "when" || name === "elif"))) {\r\n                        return "template_else";\r\n                    }\r\n                    if (st === "{{") {\r\n                        if (name === "end") {\r\n                            return "template_end";\r\n                        }\r\n                        if (name === "block" || name === "define" || name === "form" || name === "if" || name === "range" || name === "with") {\r\n                            return "template_start";\r\n                        }\r\n                        return "template";\r\n                    }\r\n                    for (en = namelist.length - 1; en > -1; en = en - 1) {\r\n                        if (name === namelist[en]) {\r\n                            return "template_start";\r\n                        }\r\n                        if (name === "end" + namelist[en]) {\r\n                            return "template_end";\r\n                        }\r\n                    }\r\n                    return "template";\r\n                };\r\n            start = function jspretty__tokenize_start(x) {\r\n                brace.push(x);\r\n                stats.container = stats.container + 1;\r\n                if (wordTest > -1) {\r\n                    word();\r\n                }\r\n                if (vart.len > -1) {\r\n                    vart.count[vart.len] = vart.count[vart.len] + 1;\r\n                }\r\n                if (token[lengtha - 2] === "function") {\r\n                    lword.push(["function", lengtha]);\r\n                } else {\r\n                    lword.push([ltoke, lengtha]);\r\n                }\r\n                ltoke = x;\r\n                ltype = "start";\r\n                if (x === "(" || x === "x(") {\r\n                    asifix();\r\n                } else if (x === "{") {\r\n                    if (paren > -1) {\r\n                        if (begin[paren - 1] === begin[begin[lengtha - 1] - 1] || token[begin[lengtha - 1]] === "x(") {\r\n                            paren = -1;\r\n                            end("x)");\r\n                            asifix();\r\n                            ltoke = "{";\r\n                            ltype = "start";\r\n                        }\r\n                    } else if (ltoke === ")") {\r\n                        asifix();\r\n                    }\r\n                    if ((ltype === "comment" || ltype === "comment-inline") && token[lengtha - 2] === ")") {\r\n                        ltoke              = token[lengtha - 1];\r\n                        token[lengtha - 1] = "{";\r\n                        ltype              = types[lengtha - 1];\r\n                        types[lengtha - 1] = "start";\r\n                    }\r\n                }\r\n                if (options.braceline === true && x === "{") {\r\n                    tokenpush(false, 2);\r\n                } else {\r\n                    tokenpush(false, 0);\r\n                }\r\n                if (classy.length > 0) {\r\n                    classy[classy.length - 1] = classy[classy.length - 1] + 1;\r\n                }\r\n                depthlist.push([\r\n                    depth[depth.length - 1],\r\n                    begin[begin.length - 1]\r\n                ]);\r\n            };\r\n            for (a = 0; a < b; a = a + 1) {\r\n                if ((/\\s/).test(c[a])) {\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    space();\r\n                } else if (c[a] === "<" && c[a + 1] === "?" && c[a + 2] === "p" && c[a + 3] === "h" && c[a + 4] === "p") {\r\n                    //php\r\n                    ltoke              = generic("<?php", "?>");\r\n                    ltype              = "template";\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "<" && c[a + 1] === "%") {\r\n                    //asp\r\n                    ltoke              = generic("<%", "%>");\r\n                    ltype              = "template";\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "{" && c[a + 1] === "%") {\r\n                    //twig\r\n                    ltoke              = generic("{%", "%}");\r\n                    ltype              = tname(ltoke);\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "{" && c[a + 1] === "{" && c[a + 2] === "{") {\r\n                    //mustache\r\n                    ltoke              = generic("{{{", "}}}");\r\n                    ltype              = "template";\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "{" && c[a + 1] === "{") {\r\n                    //handlebars\r\n                    ltoke              = generic("{{", "}}");\r\n                    ltype              = tname(ltoke);\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-" && c[a + 4] === "#") {\r\n                    //ssi\r\n                    ltoke              = generic("\x3c!--#", "--\x3e");\r\n                    ltype              = "template";\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-") {\r\n                    //markup comment\r\n                    ltoke                    = generic("\x3c!--", "--\x3e");\r\n                    ltype                    = "comment";\r\n                    stats.commentBlock.token = stats.commentBlock.token + 1;\r\n                    stats.commentBlock.chars = stats.commentBlock.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "<") {\r\n                    //markup\r\n                    ltoke              = markup();\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "*")) {\r\n                    //comment block\r\n                    ltoke                    = generic("/*", "*\\/");\r\n                    stats.commentBlock.token = stats.commentBlock.token + 1;\r\n                    stats.commentBlock.chars = stats.commentBlock.chars + ltoke.length;\r\n                    if (ltoke.indexOf("# sourceMappingURL=") === 2) {\r\n                        sourcemap[0] = token.length;\r\n                        sourcemap[1] = ltoke;\r\n                    }\r\n                    if (options.comments !== "nocomment") {\r\n                        ltype = "comment";\r\n                        if (token[lengtha - 1] === "var" || token[lengtha - 1] === "let" || token[lengtha - 1] === "const") {\r\n                            tokenpop();\r\n                            commentwrap(ltoke, false);\r\n                            temppush();\r\n                            if (lines[lengtha - 3] === 0) {\r\n                                lines[lengtha - 3] = lines[lengtha - 1];\r\n                            }\r\n                            lines[lengtha - 1] = 0;\r\n                        } else {\r\n                            commentwrap(ltoke, false);\r\n                        }\r\n                    }\r\n                } else if ((lines.length === 0 || lines[lines.length - 1] > 0) && c[a] === "#" && c[a + 1] === "!" && (c[a + 2] === "/" || c[a + 2] === "[")) {\r\n                    //shebang\r\n                    ltoke              = generic("#!" + c[a + 2], "\\n");\r\n                    ltoke              = ltoke.slice(0, ltoke.length - 1);\r\n                    ltype              = "literal";\r\n                    stats.server.token = stats.server.token + 1;\r\n                    stats.server.chars = stats.server.chars + ltoke.length;\r\n                    tokenpush(false, 2);\r\n                } else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "/")) {\r\n                    //comment line\r\n                    asi(false);\r\n                    ltoke                   = generic("//", "\\n");\r\n                    stats.commentLine.token = stats.commentLine.token + 1;\r\n                    stats.commentLine.chars = stats.commentLine.chars + ltoke.length;\r\n                    if (ltoke.indexOf("# sourceMappingURL=") === 2) {\r\n                        sourcemap[0] = token.length;\r\n                        sourcemap[1] = ltoke;\r\n                    }\r\n                    if (options.comments !== "nocomment") {\r\n                        commentwrap(ltoke, true);\r\n                    }\r\n                } else if (c[a] === "#" && c[a + 1] === "r" && c[a + 2] === "e" && c[a + 3] === "g" && c[a + 4] === "i" && c[a + 5] === "o" && c[a + 6] === "n" && (/\\s/).test(c[a + 7]) === true) {\r\n                    //comment line\r\n                    asi(false);\r\n                    ltoke                   = generic("#region", "\\n");\r\n                    ltype                   = "comment";\r\n                    stats.commentLine.token = stats.commentLine.token + 1;\r\n                    stats.commentLine.chars = stats.commentLine.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "#" && c[a + 1] === "e" && c[a + 2] === "n" && c[a + 3] === "d" && c[a + 4] === "r" && c[a + 5] === "e" && c[a + 6] === "g" && c[a + 7] === "i" && c[a + 8] === "o" && c[a + 9] === "n") {\r\n                    //comment line\r\n                    asi(false);\r\n                    ltoke                   = generic("#endregion", "\\n");\r\n                    ltype                   = "comment";\r\n                    stats.commentLine.token = stats.commentLine.token + 1;\r\n                    stats.commentLine.chars = stats.commentLine.chars + ltoke.length;\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "`" || (c[a] === "}" && templateString[templateString.length - 1] === true)) {\r\n                    //template string\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    if (c[a] === "`") {\r\n                        templateString.push(false);\r\n                    } else {\r\n                        templateString[templateString.length - 1] = false;\r\n                    }\r\n                    ltoke              = tempstring();\r\n                    ltype              = "literal";\r\n                    stats.string.token = stats.string.token + 1;\r\n                    if (ltoke.charAt(ltoke.length - 1) === "{") {\r\n                        stats.string.quote = stats.string.quote + 3;\r\n                        stats.string.chars = stats.string.chars + ltoke.length - 3;\r\n                    } else {\r\n                        stats.string.quote = stats.string.quote + 2;\r\n                        stats.string.chars = ltoke.length - 2;\r\n                    }\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === "\\"" || c[a] === "\'") {\r\n                    //string\r\n                    ltoke = generic(c[a], c[a]);\r\n                    ltype = "literal";\r\n                    if ((ltoke.charAt(0) === "\\"" && options.quoteConvert === "single") || (ltoke.charAt(0) === "\'" && options.quoteConvert === "double")) {\r\n                        ltoke = quoteConvert(ltoke);\r\n                    }\r\n                    stats.string.token = stats.string.token + 1;\r\n                    if (ltoke.length > 1) {\r\n                        stats.string.chars = stats.string.chars + ltoke.length - 2;\r\n                    }\r\n                    stats.string.quote = stats.string.quote + 2;\r\n                    if (options.wrap !== 0 && token[lengtha - 1] === "+" && (token[lengtha - 2].charAt(0) === "\\"" || token[lengtha - 2].charAt(0) === "\'")) {\r\n                        strmerge();\r\n                    } else if (options.wrap > 0 && (types[lengtha] !== "operator" || token[lengtha] === "=" || token[lengtha] === ":" || (token[lengtha] === "+" && types[lengtha - 1] === "literal"))) {\r\n                        if ((token[0] === "[" && (/(\\]\\s*)$/).test(options.source) === true) || (token[0] === "{" && (/(\\}\\s*)$/).test(options.source) === true)) {\r\n                            tokenpush(false, 0);\r\n                        } else if (types[lengtha - 2] === "literal" && token[lengtha - 1] === "+" && (token[lengtha - 2].charAt(0) === "\\"" || token[lengtha - 2].charAt(0) === "\'") && token[lengtha - 2].length < options.wrap + 2) {\r\n                            strmerge();\r\n                        } else {\r\n                            tokenpush(false, 0);\r\n                        }\r\n                    } else {\r\n                        tokenpush(false, 0);\r\n                    }\r\n                } else if (c[a] === "-" && (a < b - 1 && c[a + 1] !== "=" && c[a + 1] !== "-") && (ltype === "literal" || ltype === "word") && ltoke !== "return" && (ltoke === ")" || ltoke === "]" || ltype === "word" || ltype === "literal")) {\r\n                    //subtraction\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    stats.operator.token = stats.operator.token + 1;\r\n                    stats.operator.chars = stats.operator.chars + 1;\r\n                    ltoke                = "-";\r\n                    ltype                = "operator";\r\n                    tokenpush(false, 0);\r\n                } else if (wordTest === -1 && (c[a] !== "0" || (c[a] === "0" && c[a + 1] !== "b")) && ((/\\d/).test(c[a]) || (a !== b - 2 && c[a] === "-" && c[a + 1] === "." && (/\\d/).test(c[a + 2])) || (a !== b - 1 && (c[a] === "-" || c[a] === ".") && (/\\d/).test(c[a + 1])))) {\r\n                    //number\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    if (ltype === "end" && c[a] === "-") {\r\n                        ltoke                = "-";\r\n                        ltype                = "operator";\r\n                        stats.operator.token = stats.operator.token + 1;\r\n                        stats.operator.chars = stats.operator.chars + 1;\r\n                    } else {\r\n                        ltoke              = numb();\r\n                        ltype              = "literal";\r\n                        stats.number.token = stats.number.token + 1;\r\n                        stats.number.chars = stats.number.chars + ltoke.length;\r\n                    }\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === ":" && c[a + 1] === ":") {\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    plusplus();\r\n                    asifix();\r\n                    a                    = a + 1;\r\n                    stats.operator.token = stats.operator.token + 1;\r\n                    stats.operator.chars = stats.operator.chars + 2;\r\n                    ltoke                = "::";\r\n                    ltype                = "separator";\r\n                    tokenpush(false, 0);\r\n                } else if (c[a] === ",") {\r\n                    //comma\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    plusplus();\r\n                    stats.comma = stats.comma + 1;\r\n                    if (ltype === "comment" || ltype === "comment-inline") {\r\n                        commaComment();\r\n                    } else if (vart.len > -1 && vart.count[vart.len] === 0 && options.varword === "each") {\r\n                        asifix();\r\n                        ltoke = ";";\r\n                        ltype = "separator";\r\n                        tokenpush(false, 0);\r\n                        ltoke = vart.word[vart.len];\r\n                        ltype = "word";\r\n                        tokenpush(false, 0);\r\n                        vart.index[vart.len] = token.length - 1;\r\n                    } else {\r\n                        ltoke = ",";\r\n                        ltype = "separator";\r\n                        asifix();\r\n                        tokenpush(false, 0);\r\n                    }\r\n                } else if (c[a] === ".") {\r\n                    //period\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    stats.operator.token = stats.operator.token + 1;\r\n                    if (c[a + 1] === "." && c[a + 2] === ".") {\r\n                        ltoke                = "...";\r\n                        ltype                = "operator";\r\n                        stats.operator.chars = stats.operator.chars + 3;\r\n                        a                    = a + 2;\r\n                    } else {\r\n                        asifix();\r\n                        ltoke                = ".";\r\n                        ltype                = "separator";\r\n                        stats.operator.chars = stats.operator.chars + 1;\r\n                    }\r\n                    if ((/\\s/).test(c[a - 1]) === true) {\r\n                        tokenpush(false, 1);\r\n                    } else {\r\n                        tokenpush(false, 0);\r\n                    }\r\n                } else if (c[a] === ";") {\r\n                    //semicolon\r\n                    if (wordTest > -1) {\r\n                        word();\r\n                    }\r\n                    if (options.qml === true) {\r\n                        ltoke = "x;";\r\n                        ltype = "separator";\r\n                        tokenpush(false, 0);\r\n                    } else {\r\n                        if (classy[classy.length - 1] === 0) {\r\n                            classy.pop();\r\n                        }\r\n                        if (vart.len > -1 && vart.count[vart.len] === 0) {\r\n                            if (options.varword === "each") {\r\n                                vartpop();\r\n                            } else {\r\n                                vart.index[vart.len] = token.length;\r\n                            }\r\n                        }\r\n                        stats.semicolon = stats.semicolon + 1;\r\n                        plusplus();\r\n                        ltoke = ";";\r\n                        ltype = "separator";\r\n                        if (token[token.length - 1] === "x}") {\r\n                            asibrace();\r\n                        } else {\r\n                            tokenpush(false, 0);\r\n                        }\r\n                    }\r\n                    if (brace[brace.length - 1] === "x{" && nextchar(1, false) !== "}") {\r\n                        blockinsert();\r\n                    }\r\n                } else if (c[a] === "(" || c[a] === "[" || c[a] === "{") {\r\n                    start(c[a]);\r\n                } else if (c[a] === ")" || c[a] === "]" || c[a] === "}") {\r\n                    end(c[a]);\r\n                } else if (c[a] === "*" && depth[lengtha - 1] === "object" && wordTest < 0 && (/\\s/).test(c[a + 1]) === false && c[a + 1] !== "=" && (/\\d/).test(c[a + 1]) === false) {\r\n                    wordTest = a;\r\n                } else if (c[a] === "=" || c[a] === "&" || c[a] === "<" || c[a] === ">" || c[a] === "+" || c[a] === "-" || c[a] === "*" || c[a] === "/" || c[a] === "!" || c[a] === "?" || c[a] === "|" || c[a] === "^" || c[a] === ":" || c[a] === "%" || c[a] === "~") {\r\n                    //operator\r\n                    ltoke = operator();\r\n                    if (ltoke === "regex") {\r\n                        ltoke = token[lengtha - 1];\r\n                    } else {\r\n                        ltype                = "operator";\r\n                        stats.operator.token = stats.operator.token + 1;\r\n                        stats.operator.chars = stats.operator.chars + ltoke.length;\r\n                        if (ltoke !== "!" && ltoke !== "++" && ltoke !== "--") {\r\n                            asifix();\r\n                        }\r\n                        tokenpush(false, 0);\r\n                    }\r\n                } else if (wordTest < 0 && c[a] !== "") {\r\n                    wordTest = a;\r\n                }\r\n                if (vart.len > -1 && token.length === vart.index[vart.len] + 2 && token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && ltype !== "comment" && ltype !== "comment-inline" && options.varword === "list") {\r\n                    vartpop();\r\n                }\r\n            }\r\n            if (options.jsx === false && ((token[token.length - 1] !== "}" && token[0] === "{") || token[0] !== "{") && ((token[token.length - 1] !== "]" && token[0] === "[") || token[0] !== "[")) {\r\n                asi(false);\r\n            }\r\n            if (sourcemap[0] === token.length - 1) {\r\n                ltoke = "\\n" + sourcemap[1];\r\n                ltype = "literal";\r\n                tokenpush(false, 0);\r\n            }\r\n            if (token[token.length - 1] === "x;" && (token[token.length - 2] === "}" || token[token.length - 2] === "]") && begin[begin.length - 2] === 0) {\r\n                tokenpop();\r\n            }\r\n        }());\r\n\r\n        if (options.correct === true) {\r\n            (function jspretty__correct() {\r\n                var a = 0,\r\n                    b = token.length;\r\n                for (a = 0; a < b; a = a + 1) {\r\n                    if (token[a] === "x;") {\r\n                        token[a] = ";";\r\n                        scolon   = scolon + 1;\r\n                    } else if (token[a] === "x{") {\r\n                        token[a] = "{";\r\n                    } else if (token[a] === "x}") {\r\n                        token[a] = "}";\r\n                    } else if (token[a] === "x(") {\r\n                        token[a] = "(";\r\n                    } else if (token[a] === "x)") {\r\n                        token[a] = ")";\r\n                    }\r\n                }\r\n            }());\r\n        }\r\n        if (options.nodeasync === false) {\r\n            if (global.prettydiff.meta === undefined) {\r\n                global.prettydiff.meta       = {};\r\n                global.prettydiff.meta.error = "";\r\n            }\r\n            if (global.prettydiff.meta.error === "") {\r\n                global.prettydiff.meta.error = globalerror;\r\n            }\r\n        }\r\n        if (options.mode === "parse") {\r\n            return (function jspretty__parse() {\r\n                var a      = 0,\r\n                    c      = token.length,\r\n                    record = [],\r\n                    def    = {\r\n                        begin: "number - The index where the current container starts",\r\n                        depth: "string - The name of the current container",\r\n                        lines: "number - Whether the token is preceeded any space and/or line breaks in the or" +\r\n                                "iginal code source",\r\n                        token: "string - The parsed code tokens",\r\n                        types: "string - Data types of the tokens: comment, comment-inline, end, literal, mark" +\r\n                                "up, operator, regex, separator, start, template, template_else, template_end, " +\r\n                                "template_start, word"\r\n                    };\r\n                for (a = 0; a < c; a = a + 1) {\r\n                    if (options.correct === false && (token[a] === "x;" || token[a] === "x{" || token[a] === "x}" || token[a] === "x(" || token[a] === "x)")) {\r\n                        c = c - 1;\r\n                        begin.splice(a, 1);\r\n                        depth.splice(a, 1);\r\n                        lines.splice(a, 1);\r\n                        token.splice(a, 1);\r\n                        types.splice(a, 1);\r\n                    }\r\n                    if (options.parseFormat !== "htmltable" && types[a] === "markup" && global.prettydiff.markuppretty !== undefined) {\r\n                        options.source = token[a];\r\n                        options.jsx    = true;\r\n                        token[a]       = global\r\n                            .prettydiff\r\n                            .markuppretty(options)\r\n                            .data;\r\n                    }\r\n                }\r\n                if (options.parseFormat === "sequential") {\r\n                    for (a = 0; a < c; a = a + 1) {\r\n                        record.push([\r\n                            token[a], types[a], depth[a], begin[a], lines[a]\r\n                        ]);\r\n                    }\r\n                    if (options.nodeasync === true) {\r\n                        return [\r\n                            {\r\n                                data      : record,\r\n                                definition: def\r\n                            },\r\n                            globalerror\r\n                        ];\r\n                    }\r\n                    return {data: record, definition: def};\r\n                }\r\n                if (options.parseFormat === "htmltable") {\r\n                    return (function jspretty__parse_html() {\r\n                        var output = [],\r\n                            header = "<tr class=\\"header\\"><th>index</th><th>token</th><th>types</th><th>depth</th><" +\r\n                                    "th>begin</th><th>lines</th></tr>",\r\n                            aa     = 0,\r\n                            len    = 0;\r\n                        output.push("<table summary=\'CSS parse table\'><thead>");\r\n                        output.push(header);\r\n                        output.push("</thead><tbody>");\r\n                        len = token.length;\r\n                        for (aa = 0; aa < len; aa = aa + 1) {\r\n                            if (types[aa] === "markup" && global.prettydiff.markuppretty !== undefined) {\r\n                                options.source = token[aa];\r\n                                options.jsx    = true;\r\n                                output.push("<tr><td colspan=\\"6\\" class=\\"nested\\">");\r\n                                output.push(global.prettydiff.markuppretty(options).data.replace(\r\n                                    "<thead>",\r\n                                    "<thead><tr><th colspan=\\"10\\" class=\\"nested\\">markup tokens</th></tr>"\r\n                                ));\r\n                                output.push("</td></tr>");\r\n                                output.push(\r\n                                    "<tr><th colspan=\\"6\\" class=\\"nested\\">JavaScript tokens</th></tr>"\r\n                                );\r\n                                output.push(header);\r\n                            } else {\r\n                                output.push("<tr><td>");\r\n                                output.push(aa);\r\n                                output.push("</td><td>");\r\n                                output.push(\r\n                                    token[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\r\n                                );\r\n                                output.push("</td><td>");\r\n                                output.push(types[aa]);\r\n                                output.push("</td><td>");\r\n                                output.push(depth[aa]);\r\n                                output.push("</td><td>");\r\n                                output.push(begin[aa]);\r\n                                output.push("</td><td>");\r\n                                output.push(lines[aa]);\r\n                                output.push("</td></tr>");\r\n                            }\r\n                        }\r\n                        output.push("</tbody></table>");\r\n                        if (options.nodeasync === true) {\r\n                            return [\r\n                                {\r\n                                    data      : output.join(""),\r\n                                    definition: def\r\n                                },\r\n                                globalerror\r\n                            ];\r\n                        }\r\n                        return {data: output.join(""), definition: def};\r\n                    }());\r\n                }\r\n                if (options.nodeasync === true) {\r\n                    return [\r\n                        {\r\n                            data      : {\r\n                                begin: begin,\r\n                                depth: depth,\r\n                                lines: lines,\r\n                                token: token,\r\n                                types: types\r\n                            },\r\n                            definition: def\r\n                        },\r\n                        globalerror\r\n                    ];\r\n                }\r\n                return {\r\n                    data      : {\r\n                        begin: begin,\r\n                        depth: depth,\r\n                        lines: lines,\r\n                        token: token,\r\n                        types: types\r\n                    },\r\n                    definition: def\r\n                };\r\n            }());\r\n        }\r\n\r\n        if (options.jsx === true && options.jsscope !== "none" && token[0] === "{") {\r\n            options.jsscope = "none";\r\n            (function jspretty__jsxScope() {\r\n                var a   = 0,\r\n                    len = token.length;\r\n                for (a = 0; a < len; a = a + 1) {\r\n                    if (types[a] === "word" && token[a - 1] !== ".") {\r\n                        token[a] = "[pdjsxscope]" + token[a] + "[/pdjsxscope]";\r\n                    }\r\n                }\r\n            }());\r\n        }\r\n        if (options.mode === "beautify" || options.mode === "diff") {\r\n            //this function is the pretty-print algorithm\r\n            (function jspretty__beautify() {\r\n                var a             = 0,\r\n                    b             = token.length,\r\n                    indent        = options.inlevel, //will store the current level of indentation\r\n                    list          = [], //stores comma status of current block\r\n                    wordlist      = [], //if the current list is word types preceeded by a word (Java type invocations)\r\n                    lastlist      = false, //remembers the list status of the most recently closed block\r\n                    ternary       = [], //used to identify ternary statments\r\n                    varline       = [], //determines if a current list of the given block is a list of variables following the "var" keyword\r\n                    ctype         = "", //ctype stands for "current type"\r\n                    ctoke         = "", //ctoke standa for "current token"\r\n                    ltype         = types[0], //ltype stands for "last type"\r\n                    ltoke         = token[0], //ltype stands for "last token"\r\n                    lettest       = -1,\r\n                    varlen        = [\r\n                        []\r\n                    ], //stores lists of variables, assignments, and object properties for white space padding\r\n                    extraindent   = [\r\n                        []\r\n                    ], //stores token indexes where extra indentation occurs from ternaries and broken method chains\r\n                    arrbreak      = [], //array where a method break has occurred\r\n                    destruct      = [], //attempt to identify object destructuring\r\n                    itemcount     = [], //counts items in destructured lists\r\n                    assignlist    = [false], //are you in a list right now?\r\n                    destructfix   = function jspretty__beautify_destructFix(listFix, override) {\r\n                        // listfix  - at the end of a list correct the containing list override - to\r\n                        // break arrays with more than 4 items into a vertical list\r\n                        var c          = 0,\r\n                            d          = (listFix === true)\r\n                                ? 0\r\n                                : 1,\r\n                            ei         = (extraindent[extraindent.length - 1] === undefined)\r\n                                ? []\r\n                                : extraindent[extraindent.length - 1],\r\n                            arrayCheck = (\r\n                                override === false && depth[a] === "array" && listFix === true && ctoke !== "["\r\n                            );\r\n                        if (destruct[destruct.length - 1] === false || (depth[a] === "array" && options.formatArray === "inline") || (depth[a] === "object" && options.formatObject === "inline")) {\r\n                            return;\r\n                        }\r\n                        destruct[destruct.length - 1] = false;\r\n                        for (c = a - 1; c > -1; c = c - 1) {\r\n                            if (types[c] === "end") {\r\n                                d = d + 1;\r\n                            } else if (types[c] === "start") {\r\n                                d = d - 1;\r\n                            }\r\n                            if (depth[c] === "global") {\r\n                                return;\r\n                            }\r\n                            if (d === 0) {\r\n                                if (depth[a] === "class" || depth[a] === "map" || (arrayCheck === false && ((listFix === false && token[c] !== "(" && token[c] !== "x(") || (listFix === true && token[c] === ",")))) {\r\n                                    if (types[c + 1] === "template_start") {\r\n                                        if (lines[c] < 1) {\r\n                                            level[c] = -20;\r\n                                        } else {\r\n                                            level[c] = indent - 1;\r\n                                        }\r\n                                    } else if (ei.length > 0 && ei[ei.length - 1] > -1) {\r\n                                        level[c] = indent - 1;\r\n                                    } else {\r\n                                        level[c] = indent;\r\n                                    }\r\n                                }\r\n                                if (listFix === false) {\r\n                                    return;\r\n                                }\r\n                            }\r\n                            if (d < 0) {\r\n                                if (types[c + 1] === "template_start") {\r\n                                    if (lines[c] < 1) {\r\n                                        level[c] = -20;\r\n                                    } else {\r\n                                        level[c] = indent - 1;\r\n                                    }\r\n                                } else if (ei.length > 0 && ei[ei.length - 1] > -1) {\r\n                                    level[c] = indent - 1;\r\n                                } else {\r\n                                    level[c] = indent;\r\n                                }\r\n                                return;\r\n                            }\r\n                        }\r\n                    },\r\n                    strwrap       = function jspretty__beautify_strwrap(offset) {\r\n                        var aa        = 0,\r\n                            bb        = 0,\r\n                            cc        = 0,\r\n                            dd        = 0,\r\n                            ee        = 0,\r\n                            ff        = 0,\r\n                            x         = 0,\r\n                            str       = "",\r\n                            off       = false,\r\n                            ei        = (extraindent[extraindent.length - 1] === undefined)\r\n                                ? []\r\n                                : extraindent[extraindent.length - 1],\r\n                            ind       = (token[begin[a]] === "(" && (list[list.length - 1] === true || ei.length > 0))\r\n                                ? indent + 3\r\n                                : indent + 2,\r\n                            bgn       = begin[a],\r\n                            dep       = depth[a],\r\n                            lin       = lines[a],\r\n                            wrap      = options.wrap - 2,\r\n                            paren     = token[a + 1] === ".",\r\n                            uchar     = (/u[0-9a-fA-F]{4}/),\r\n                            xchar     = (/x[0-9a-fA-F]{2}/),\r\n                            item      = token[a],\r\n                            qchar     = item.charAt(0),\r\n                            slash     = function jspretty__beautify_strwrap_slash(trim, entity) {\r\n                                var dist = 0;\r\n                                if (entity === true) {\r\n                                    ff = trim;\r\n                                }\r\n                                do {\r\n                                    dist = dist + 1;\r\n                                } while (item.charAt(cc - (trim + dist)) === "\\\\" && dist < cc);\r\n                                if (entity === false) {\r\n                                    cc = cc - dist;\r\n                                    ff = ff + dist;\r\n                                } else if (dist % 2 === 1) {\r\n                                    cc = cc - ff;\r\n                                } else {\r\n                                    ff = 0;\r\n                                }\r\n                            },\r\n                            parenpush = function jspretty_beautify_strwrap_parenpush() {\r\n                                token.splice(a, 0, "(");\r\n                                types.splice(a, 0, "start");\r\n                                lines.splice(a, 0, lin);\r\n                                depth.splice(a, 0, "paren");\r\n                                begin.splice(a, 0, a);\r\n                                level.push(indent + 1);\r\n                                bgn = a;\r\n                                dep = "paren";\r\n                                a   = a + 1;\r\n                                b   = b + 1;\r\n                                x   = x + 1;\r\n                            },\r\n                            tokenpush = function jspretty_beautify_strwrap_tokenpush(toke, type) {\r\n                                token.splice(a, 0, toke);\r\n                                types.splice(a, 0, type);\r\n                                lines.splice(a, 0, lin);\r\n                                depth.splice(a, 0, dep);\r\n                                begin.splice(a, 0, bgn);\r\n                                if (toke === "+") {\r\n                                    level.push(ind);\r\n                                } else if (toke === ")") {\r\n                                    level.push(indent);\r\n                                    level[a - 1] = indent;\r\n                                } else {\r\n                                    level.push(-10);\r\n                                }\r\n                                a = a + 1;\r\n                                b = b + 1;\r\n                                x = x + 1;\r\n                            };\r\n                        aa = a;\r\n                        do {\r\n                            aa = aa - 1;\r\n                            if (aa === begin[a] && token[aa] === "(") {\r\n                                break;\r\n                            }\r\n                        } while (aa > 0 && level[aa - 1] < -9);\r\n                        if (ltoke === "(") {\r\n                            level[a - 1] = indent + 1;\r\n                        }\r\n                        if (token[aa] === "." && token[begin[a]] !== "(") {\r\n                            ind = ind + 1;\r\n                        }\r\n                        if (token[begin[a]] === "(" && list[list.length - 1] === false && token[aa] !== "?" && token[aa] !== ":") {\r\n                            ind = indent + 1;\r\n                        }\r\n                        if (paren === true && token[aa] !== "?" && token[aa] !== ":") {\r\n                            ind = indent + 1;\r\n                        }\r\n                        if (offset > 1 && item.length > offset) {\r\n                            off = true;\r\n                            if (paren === true) {\r\n                                tokenpush("(");\r\n                            }\r\n                            if (item.charAt(offset - 5) === "\\\\" && uchar.test(item.slice(offset - 4, offset + 1)) === true) {\r\n                                str  = item.slice(0, offset - 5) + item.charAt(0);\r\n                                item = item.charAt(0) + item.slice(offset - 5);\r\n                            } else if (item.charAt(offset - 4) === "\\\\" && uchar.test(item.slice(offset - 3, offset + 2)) === true) {\r\n                                str  = item.slice(0, offset - 4) + item.charAt(0);\r\n                                item = item.charAt(0) + item.slice(offset - 4);\r\n                            } else if (item.charAt(offset - 3) === "\\\\" && (uchar.test(item.slice(offset - 2, offset + 3)) === true || xchar.test(item.slice(offset - 2, offset + 1)) === true)) {\r\n                                str  = item.slice(0, offset - 3) + item.charAt(0);\r\n                                item = item.charAt(0) + item.slice(offset - 3);\r\n                            } else if (item.charAt(offset - 2) === "\\\\" && (uchar.test(item.slice(offset - 1, offset + 4)) === true || xchar.test(item.slice(offset - 1, offset + 2)) === true)) {\r\n                                str  = item.slice(0, offset - 2) + item.charAt(0);\r\n                                item = item.charAt(0) + item.slice(offset - 2);\r\n                            } else if (item.charAt(offset - 1) === "\\\\") {\r\n                                str  = item.slice(0, offset - 1) + item.charAt(0);\r\n                                item = item.charAt(0) + item.slice(offset - 1);\r\n                            } else {\r\n                                str  = item.slice(0, offset) + item.charAt(0);\r\n                                item = item.charAt(0) + item.slice(offset);\r\n                            }\r\n                            if (str.charAt(str.length - 2) === "\\\\") {\r\n                                str = str + str.charAt(0);\r\n                            }\r\n                            tokenpush(str, "literal");\r\n                            tokenpush("+", "operator");\r\n                        }\r\n                        if (item.length > wrap) {\r\n                            if (depth[a] === "object" || depth[a] === "array") {\r\n                                destructfix(true, false);\r\n                            }\r\n                            if (off === false && paren === true) {\r\n                                parenpush();\r\n                            }\r\n                            token.splice(a, 1);\r\n                            types.splice(a, 1);\r\n                            lines.splice(a, 1);\r\n                            depth.splice(a, 1);\r\n                            begin.splice(a, 1);\r\n                            b    = b - 1;\r\n                            item = item.slice(1, item.length - 1);\r\n                            bb   = Math.floor(item.length / wrap) * wrap;\r\n                            for (aa = 0; aa < bb; aa = aa + wrap) {\r\n                                cc = aa + wrap + dd;\r\n                                if (item.charAt(cc - 5) === "\\\\" && uchar.test(item.slice(cc - 4, cc + 1)) === true) {\r\n                                    slash(5, true);\r\n                                } else if (item.charAt(cc - 4) === "\\\\" && uchar.test(item.slice(cc - 3, cc + 2)) === true) {\r\n                                    slash(4, true);\r\n                                } else if (item.charAt(cc - 3) === "\\\\" && (uchar.test(item.slice(cc - 2, cc + 3)) === true || xchar.test(item.slice(cc - 2, cc + 1)) === true)) {\r\n                                    slash(3, true);\r\n                                } else if (item.charAt(cc - 2) === "\\\\" && (uchar.test(item.slice(cc - 1, cc + 4)) === true || xchar.test(item.slice(cc - 1, cc + 2)) === true)) {\r\n                                    slash(2, true);\r\n                                } else if (item.charAt(cc - 1) === "\\\\") {\r\n                                    slash(1, true);\r\n                                } else {\r\n                                    ff = 0;\r\n                                }\r\n                                if (item.charAt(cc - 1) === "\\\\") {\r\n                                    slash(1, false);\r\n                                }\r\n                                if (aa > 0 && dd < 0) {\r\n                                    aa = aa - 1;\r\n                                    dd = 0;\r\n                                }\r\n                                if (item.charAt(cc - 1) === "\\\\") {\r\n                                    str = qchar + item.slice(ee, cc - 1) + qchar;\r\n                                    ee  = cc - 1;\r\n                                    aa  = aa - 1;\r\n                                } else {\r\n                                    str = qchar + item.slice(ee, cc) + qchar;\r\n                                    ee  = cc;\r\n                                }\r\n                                if (item.charAt(cc) === "\\\\") {\r\n                                    aa = aa - ff;\r\n                                }\r\n                                tokenpush(str, "literal");\r\n                                if (aa < item.length - wrap) {\r\n                                    tokenpush("+", "operator");\r\n                                }\r\n                            }\r\n                            if (aa < item.length) {\r\n                                tokenpush(qchar + item.slice(aa, aa + wrap) + qchar, "literal");\r\n                            }\r\n                            if (paren === true) {\r\n                                tokenpush(")", "end");\r\n                            }\r\n                            a  = a - 1;\r\n                            x  = x - 1;\r\n                            aa = a + 1;\r\n                            do {\r\n                                aa = aa + 1;\r\n                                if (types[aa - 1] === "start") {\r\n                                    begin[aa - 1] = (aa - 1);\r\n                                } else if (begin[aa - 1] > bgn) {\r\n                                    begin[aa - 1] = begin[aa - 1] + x;\r\n                                }\r\n                            } while (aa < b);\r\n                            ctoke = token[a];\r\n                            ctype = types[a];\r\n                            ltoke = token[a - 1];\r\n                            ltype = types[a - 1];\r\n                        } else {\r\n                            if (off === true) {\r\n                                aa = a;\r\n                                do {\r\n                                    aa = aa + 1;\r\n                                    if (types[aa - 1] === "start") {\r\n                                        begin[aa - 1] = (aa - 1);\r\n                                    } else if (begin[aa - 1] > bgn) {\r\n                                        begin[aa - 1] = begin[aa - 1] + x;\r\n                                    }\r\n                                } while (aa < b);\r\n                            }\r\n                            token[a] = item;\r\n                            level.push(-10);\r\n                        }\r\n                        ctoke = token[a];\r\n                        ctype = "string";\r\n                    },\r\n                    literal       = function jspretty__beautify_literal() {\r\n                        if (ctoke.indexOf("#!/") === 0) {\r\n                            level.push(indent);\r\n                        } else {\r\n                            if (ctoke.charAt(0) === "}") {\r\n                                level[a - 1] = -20;\r\n                            }\r\n                            if (options.bracepadding === true && ctoke.charAt(0) === "}" && ctoke.charAt(ctoke.length - 1) === "`") {\r\n                                level[a - 1] = -10;\r\n                            }\r\n                            if (options.wrap > 0 && ctoke.length > options.wrap && (ctoke.charAt(0) === "\\"" || ctoke.charAt(0) === "\'")) {\r\n                                strwrap(0);\r\n                            } else {\r\n                                level.push(-10);\r\n                            }\r\n                        }\r\n                        if ((ltoke === "," || ltype === "start") && (depth[a] === "object" || depth[a] === "array") && destruct[destruct.length - 1] === false && a > 0) {\r\n                            level[a - 1] = indent;\r\n                        }\r\n                    },\r\n                    endExtraInd   = function jspretty__beautify_endExtraInd() {\r\n                        var ei = extraindent[extraindent.length - 1],\r\n                            c  = 0;\r\n                        if (ei === undefined) {\r\n                            return;\r\n                        }\r\n                        c = ei.length - 1;\r\n                        if (c < 1 && ei[c] < 0 && (ctoke === ";" || ctoke === "x;" || ctoke === ")" || ctoke === "x)" || ctoke === "}" || ctoke === "x}")) {\r\n                            return ei.pop();\r\n                        }\r\n                        if (c < 0 || ei[c] < 0) {\r\n                            return;\r\n                        }\r\n                        if (ctoke === ":") {\r\n                            if (token[ei[c]] !== "?") {\r\n                                do {\r\n                                    ei.pop();\r\n                                    c      = c - 1;\r\n                                    indent = indent - 1;\r\n                                } while (c > -1 && ei[c] > -1 && token[ei[c]] !== "?");\r\n                            }\r\n                            ei[c]        = a;\r\n                            level[a - 1] = indent;\r\n                        } else {\r\n                            do {\r\n                                ei.pop();\r\n                                c      = c - 1;\r\n                                indent = indent - 1;\r\n                            } while (c > -1 && ei[c] > -1);\r\n                        }\r\n                        if ((depth[a] === "array" || ctoke === ",") && ei.length < 1) {\r\n                            ei.push(-1);\r\n                        }\r\n                    },\r\n                    comment       = function jspretty__beautify_comment() {\r\n                        destructfix(false, false);\r\n                        if (token[a - 1] === ",") {\r\n                            level[a - 1] = indent;\r\n                        } else if (lines[a - 1] === 0 && types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\r\n                            level[a - 1] = -20;\r\n                        } else if (ltoke === "=" && (/^(\\/\\*\\*\\s*@[a-z_]+\\s)/).test(ctoke) === true) {\r\n                            level[a - 1] = -10;\r\n                        } else {\r\n                            level[a - 1] = indent;\r\n                        }\r\n                        level.push(indent);\r\n                    },\r\n                    commentInline = function jspretty__beautify_commentInline() {\r\n                        destructfix(false, false);\r\n                        if (a < b - 1 && depth[a + 1] !== "block" && (token[a + 1] === "{" || token[a + 1] === "x{")) {\r\n                            token[a]     = token[a + 1];\r\n                            types[a]     = "start";\r\n                            depth[a]     = depth[a + 1];\r\n                            begin[a]     = begin[a + 1];\r\n                            lines[a]     = lines[a + 1];\r\n                            token[a + 1] = ctoke;\r\n                            types[a + 1] = ctype;\r\n                            a            = a - 1;\r\n                        } else {\r\n                            level[a - 1] = -10;\r\n                            if (depth[a] === "paren" || depth[a] === "method") {\r\n                                level.push(indent + 2);\r\n                            } else {\r\n                                level.push(indent);\r\n                            }\r\n                        }\r\n                    },\r\n                    template      = function jspretty__beautify_template() {\r\n                        if (ctype === "template_else") {\r\n                            level[a - 1] = indent - 1;\r\n                            level.push(indent);\r\n                        } else if (ctype === "template_start") {\r\n                            indent = indent + 1;\r\n                            if (lines[a - 1] < 1) {\r\n                                level[a - 1] = -20;\r\n                            }\r\n                            if (lines[a] > 0) {\r\n                                level.push(indent);\r\n                            } else {\r\n                                level.push(-20);\r\n                            }\r\n                        } else if (ctype === "template_end") {\r\n                            indent = indent - 1;\r\n                            if (ltype === "template_start" || lines[a - 1] < 1) {\r\n                                level[a - 1] = -20;\r\n                            } else {\r\n                                level[a - 1] = indent;\r\n                            }\r\n                            if (lines[a] > 0) {\r\n                                level.push(indent);\r\n                            } else {\r\n                                level.push(-20);\r\n                            }\r\n                        } else if (ctype === "template") {\r\n                            if (lines[a] > 0) {\r\n                                level.push(indent);\r\n                            } else {\r\n                                level.push(-20);\r\n                            }\r\n                        }\r\n                    },\r\n                    markup        = function jspretty__beautify_markup() {\r\n                        if ((token[a + 1] !== "," && ctoke.indexOf("/>") !== ctoke.length - 2) || (token[a + 1] === "," && token[begin[a] - 3] !== "React")) {\r\n                            destructfix(false, false);\r\n                        }\r\n                        if (ltoke === "return" || ltoke === "?" || ltoke === ":") {\r\n                            level[a - 1] = -10;\r\n                            level.push(-20);\r\n                        } else if (ltype === "start" || (token[a - 2] === "return" && depth[a - 1] === "method")) {\r\n                            level.push(indent);\r\n                        } else {\r\n                            level.push(-20);\r\n                        }\r\n                        if (varline[varline.length - 1] === true) {\r\n                            markupvar.push(a);\r\n                        }\r\n                    },\r\n                    separator     = function jspretty__beautify_separator() {\r\n                        var methtest      = false,\r\n                            ei            = (extraindent[extraindent.length - 1] === undefined)\r\n                                ? []\r\n                                : extraindent[extraindent.length - 1],\r\n                            propertybreak = function jspretty__beautify_separator_propertybreak() {\r\n                                var c = 0,\r\n                                    d = begin[a],\r\n                                    e = 1;\r\n                                if (ctoke === "." && ltype !== "end" && types[a + 2] !== "start") {\r\n                                    level[a - 1] = -20;\r\n                                    return;\r\n                                }\r\n                                for (c = a - 2; c > d; c = c - 1) {\r\n                                    if (begin[c] === d) {\r\n                                        if (token[c] === ".") {\r\n                                            e = e + 1;\r\n                                        }\r\n                                        if (token[c] === ";" || token[c] === "," || types[c] === "operator" || token[c] === "return" || token[c] === "break" || token[c] === "continue" || types[c] === "comment" || types[c] === "comment-inline") {\r\n                                            break;\r\n                                        }\r\n                                        if (types[c - 1] === "end") {\r\n                                            if (types[c] !== "start" && types[c] !== "operator" && token[c] !== ".") {\r\n                                                break;\r\n                                            }\r\n                                            c = begin[c - 1];\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (e < 2) {\r\n                                    level[a - 1] = -20;\r\n                                    return;\r\n                                }\r\n                                indent = indent + 1;\r\n                                if (token[c] !== ".") {\r\n                                    do {\r\n                                        c = c + 1;\r\n                                    } while (c < a && (token[c] !== "." || begin[c] !== d));\r\n                                }\r\n                                for (e = c; e < a; e = e + 1) {\r\n                                    if (token[e] === "." && begin[e] === d) {\r\n                                        level[e - 1] = indent;\r\n                                    } else if (level[e] > -9) {\r\n                                        level[e] = level[e] + 1;\r\n                                    }\r\n                                }\r\n                                level[a - 1] = indent;\r\n                                ei.push(a);\r\n                            };\r\n                        if (ctoke === "::") {\r\n                            level[a - 1] = -20;\r\n                            return level.push(-20);\r\n                        }\r\n                        if ((options.methodchain === "chain" || (options.methodchain === "none" && lines[a] < 1)) && types[a - 1] === "comment-inline" && a > 1) {\r\n                            return (function jspretty__beautify_separator_commentfix() {\r\n                                var c    = 0,\r\n                                    d    = b,\r\n                                    last = token[a - 1];\r\n                                level[a - 2] = -20;\r\n                                level[a - 1] = -20;\r\n                                for (c = a; c < d; c = c + 1) {\r\n                                    token[c - 1] = token[c];\r\n                                    types[c - 1] = types[c];\r\n                                    if (token[c] === ";" || token[c] === "x;" || token[c] === "{" || token[c] === "x{" || lines[c] > 0) {\r\n                                        token[c] = last;\r\n                                        types[c] = "comment-inline";\r\n                                        a        = a - 1;\r\n                                        return;\r\n                                    }\r\n                                }\r\n                                token[c - 1] = last;\r\n                                types[c - 1] = "comment-inline";\r\n                                a            = a - 1;\r\n                            }());\r\n                        }\r\n                        if (ctoke === ".") {\r\n                            if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && ei.length > 0) {\r\n                                if (depth[a] === "object" || depth[a] === "array") {\r\n                                    destructfix(true, false);\r\n                                } else {\r\n                                    destructfix(false, false);\r\n                                }\r\n                            }\r\n                            if ((options.methodchain === "chain" || (options.methodchain === "none" && lines[a] < 1)) && ltype !== "comment" && ltype !== "comment-inline") {\r\n                                level[a - 1] = -20;\r\n                            } else {\r\n                                if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && (types[a + 2] === "start" || ltoke === ")" || (token[ei[ei.length - 1]] !== "."))) {\r\n                                    if (token[ei[ei.length - 1]] !== "." && options.nochainindent === false) {\r\n                                        propertybreak();\r\n                                    } else {\r\n                                        level[a - 1] = indent;\r\n                                    }\r\n                                } else if (token[ei[ei.length - 1]] === ".") {\r\n                                    level[a - 1] = indent;\r\n                                } else {\r\n                                    level[a - 1] = -20;\r\n                                }\r\n                            }\r\n                            if (types[a - 1] === "comment" || types[a - 1] === "comment-inline") {\r\n                                if (ei > 0) {\r\n                                    level[a - 1] = indent;\r\n                                } else {\r\n                                    level[a - 1] = indent + 1;\r\n                                }\r\n                            }\r\n                            return level.push(-20);\r\n                        }\r\n                        if (ctoke === ",") {\r\n                            if (list[list.length - 1] === false && (depth[a] === "object" || depth[a] === "array" || depth[a] === "paren" || depth[a] === "expression" || depth[a] === "method")) {\r\n                                list[list.length - 1] = true;\r\n                                if (token[begin[a]] === "(") {\r\n                                    (function jspretty__beautify_separator_plusfix() {\r\n                                        var aa = a;\r\n                                        do {\r\n                                            aa = aa - 1;\r\n                                            if (begin[aa] === begin[a] && token[aa] === "+" && level[aa] > -9) {\r\n                                                level[aa] = level[aa] + 2;\r\n                                            }\r\n                                        } while (aa > begin[a]);\r\n                                    }());\r\n                                }\r\n                            }\r\n                            if (ei.length > 0) {\r\n                                if (ei[ei.length - 1] > -1) {\r\n                                    endExtraInd();\r\n                                }\r\n                                level[a - 1] = -20;\r\n                                return level.push(indent);\r\n                            }\r\n                            if (token[a - 2] === ":" && token[a - 4] === "where") {\r\n                                level[a - 1] = -20;\r\n                                return level.push(-10);\r\n                            }\r\n                            level[a - 1]                    = -20;\r\n                            itemcount[itemcount.length - 1] = itemcount[itemcount.length - 1] + 1;\r\n                            if ((token[begin[a]] === "(" || token[begin[a]] === "x(") && options.jsx === false && depth[a] !== "global" && (types[a - 1] !== "literal" || token[a - 2] !== "+" || (types[a - 1] === "literal" && token[a - 2] === "+" && types[a - 3] !== "literal"))) {\r\n                                return level.push(-10);\r\n                            }\r\n                            if (ltype === "word" && types[a - 2] === "word" && "var-let-const-from".indexOf(token[a - 2]) < 0 && (types[a - 3] === "end" || token[a - 3] === ";")) {\r\n                                wordlist[wordlist.length - 1] = true;\r\n                                return level.push(-10);\r\n                            }\r\n                            if (wordlist[wordlist.length - 1] === true || depth[a] === "notation") {\r\n                                return level.push(-10);\r\n                            }\r\n                            if (destruct[destruct.length - 1] === true && itemcount[itemcount.length - 1] > 4 && (depth[a] === "array" || depth[a] === "object")) {\r\n                                destructfix(true, true);\r\n                            }\r\n                            if (depth[a] === "object") {\r\n                                if (destruct[destruct.length - 1] === true && types[begin[a] - 1] !== "word" && token[begin[a] - 1] !== "(" && token[begin[a] - 1] !== "x(") {\r\n                                    (function jspretty__beautify_separator_objDestruct() {\r\n                                        var aa = 0,\r\n                                            bb = 0;\r\n                                        for (aa = a - 1; aa > -1; aa = aa - 1) {\r\n                                            if (types[aa] === "end") {\r\n                                                bb = bb + 1;\r\n                                            } else if (types[aa] === "start") {\r\n                                                bb = bb - 1;\r\n                                            }\r\n                                            if (bb < 0 || (bb === 0 && token[aa] === ",")) {\r\n                                                return;\r\n                                            }\r\n                                            if (bb === 0 && token[aa] === ":") {\r\n                                                return destructfix(true, false);\r\n                                            }\r\n                                        }\r\n                                    }());\r\n                                }\r\n                            }\r\n                            if (types[a - 1] === "word" && token[a - 2] === "for") {\r\n                                //This is for Volt templates\r\n                                return level.push(-10);\r\n                            }\r\n                            if (destruct[destruct.length - 1] === false || (token[a - 2] === "+" && ltype === "literal" && level[a - 2] > 0 && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'"))) {\r\n                                if (depth[a] === "method") {\r\n                                    if (token[a - 2] === "+" && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'") && (token[a - 3].charAt(0) === "\\"" || token[a - 3].charAt(0) === "\'")) {\r\n                                        return level.push(indent + 2);\r\n                                    }\r\n                                    if (token[a - 2] !== "+") {\r\n                                        return level.push(-10);\r\n                                    }\r\n                                }\r\n                                return level.push(indent);\r\n                            }\r\n                            if (list[list.length - 1] === true) {\r\n                                if (assignlist[assignlist.length - 1] === true && varline[varline.length - 1] === false) {\r\n                                    assignlist[assignlist.length - 1] = false;\r\n                                    varlen[varlen.length - 1]         = [];\r\n                                }\r\n                                return (function jspretty__beautify_separator_inList() {\r\n                                    var c = 0,\r\n                                        d = 0;\r\n                                    for (c = a - 1; c > -1; c = c - 1) {\r\n                                        if (types[c] === "end") {\r\n                                            d = d + 1;\r\n                                        }\r\n                                        if (types[c] === "start") {\r\n                                            d = d - 1;\r\n                                        }\r\n                                        if (d === -1) {\r\n                                            if (token[c] === "[" && token[c + 1] !== "]" && token[c + 2] !== "]") {\r\n                                                if (destruct[destruct.length - 1] === false || arrbreak[arrbreak.length - 1] === true) {\r\n                                                    level[c] = indent;\r\n                                                } else if (methtest === false && destruct[destruct.length - 1] === true) {\r\n                                                    level[c] = -20;\r\n                                                }\r\n                                                if (token[a - 2] === "+" && ltype === "literal" && level[a - 2] > 0 && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'")) {\r\n                                                    for (d = a - 2; d > c; d = d - 2) {\r\n                                                        if (token[d] !== "+") {\r\n                                                            return;\r\n                                                        }\r\n                                                        if (token[d - 1].charAt(0) !== "\\"" && token[d - 1].charAt(0) !== "\'") {\r\n                                                            level[d] = -10;\r\n                                                        }\r\n                                                    }\r\n                                                    return;\r\n                                                }\r\n                                            }\r\n                                            if (arrbreak[arrbreak.length - 1] === true) {\r\n                                                return level.push(indent);\r\n                                            }\r\n                                            return level.push(-10);\r\n                                        }\r\n                                    }\r\n                                    if (arrbreak[arrbreak.length - 1] === true) {\r\n                                        return level.push(indent);\r\n                                    }\r\n                                    return level.push(-10);\r\n                                }());\r\n                            }\r\n                            if (varline[varline.length - 1] === true && token[begin[a] - 1] !== "for") {\r\n                                if (ltoke !== "]") {\r\n                                    (function jspretty__beautify_separator_varline() {\r\n                                        var c     = 0,\r\n                                            brace = false;\r\n                                        for (c = a - 1; c > -1; c = c - 1) {\r\n                                            if (token[c] === "]") {\r\n                                                brace = true;\r\n                                            }\r\n                                            if (types[c] === "start") {\r\n                                                if (token[c] === "[" && token[c + 1] !== "]" && brace === false) {\r\n                                                    level[c] = indent;\r\n                                                }\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                    }());\r\n                                }\r\n                                if (ltype === "literal" && token[a - 2] === "+" && (ltoke.charAt(0) === "\\"" || ltoke.charAt(0) === "\'")) {\r\n                                    return level.push(indent);\r\n                                }\r\n                                return level.push(indent);\r\n                            }\r\n                            if (destruct[destruct.length - 1] === true && depth[a] !== "object") {\r\n                                return level.push(-10);\r\n                            }\r\n                            return level.push(indent);\r\n                        }\r\n                        if (ctoke === ";" || ctoke === "x;") {\r\n                            endExtraInd();\r\n                            if (token[begin[a] - 1] !== "for") {\r\n                                destructfix(false, false);\r\n                            }\r\n                            wordlist[wordlist.length - 1] = false;\r\n                            if (ctoke === "x;") {\r\n                                scolon = scolon + 1;\r\n                            }\r\n                            level[a - 1] = -20;\r\n                            if (varline[varline.length - 1] === true) {\r\n                                varline[varline.length - 1] = false;\r\n                                if (depth[a] !== "method" && varlen.length > 0 && varlen[varlen.length - 1].length > 1) {\r\n                                    varlist.push(varlen[varlen.length - 1]);\r\n                                }\r\n                                varlen[varlen.length - 1] = [];\r\n                                (function jspretty__beautify_separator_varlinefix() {\r\n                                    var c = 0,\r\n                                        d = 0;\r\n                                    for (c = a - 1; c > -1; c = c - 1) {\r\n                                        if (types[c] === "start") {\r\n                                            d = d + 1;\r\n                                        }\r\n                                        if (types[c] === "end") {\r\n                                            d = d - 1;\r\n                                        }\r\n                                        if (d > 0) {\r\n                                            return;\r\n                                        }\r\n                                        if (d === 0) {\r\n                                            if (token[c] === "var" || token[c] === "let" || token[c] === "const") {\r\n                                                return;\r\n                                            }\r\n                                            if (token[c] === ",") {\r\n                                                indent = indent - 1;\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }());\r\n                            }\r\n                            if (begin[a] > 0 && token[begin[a] - 1] === "for" && depth[a] !== "for") {\r\n                                return level.push(-10);\r\n                            }\r\n                            return level.push(indent);\r\n                        }\r\n                    },\r\n                    start         = function jspretty__beautify_start() {\r\n                        var deep   = depth[a],\r\n                            deeper = (a === 0)\r\n                                ? depth[a]\r\n                                : depth[a - 1];\r\n                        if (ltoke === ")" || ((deeper === "object" || deeper === "array") && ltoke !== "]")) {\r\n                            if (deep !== "method" || (deep === "method" && token[a + 1] !== ")" && token[a + 2] !== ")")) {\r\n                                if (ltoke === ")" && (deep !== "function" || token[begin[begin[a - 1] - 1]] === "(" || token[begin[begin[a - 1] - 1]] === "x(")) {\r\n                                    destructfix(false, false);\r\n                                } else if (types[a + 1] !== "end" && types[a + 2] !== "end") {\r\n                                    destructfix(true, false);\r\n                                }\r\n                            }\r\n                        }\r\n                        list.push(false);\r\n                        extraindent.push([]);\r\n                        assignlist.push(false);\r\n                        arrbreak.push(false);\r\n                        wordlist.push(false);\r\n                        itemcount.push(0);\r\n                        varlen.push([]);\r\n                        if (options.neverflatten === true || options.qml === true || deep === "attribute" || ltype === "generic" || (deep === "class" && ltoke !== "(" && ltoke !== "x(") || (ctoke === "[" && token[a + 1] === "function")) {\r\n                            destruct.push(false);\r\n                        } else {\r\n                            if (deep === "expression" || deep === "method") {\r\n                                destruct.push(true);\r\n                            } else if ((deep === "object" || deep === "class") && (ltoke === "(" || ltoke === "x(" || ltype === "word")) {\r\n                                //array or object literal following `return` or `(`\r\n                                destruct.push(true);\r\n                            } else if (deep === "array" || ctoke === "(" || ctoke === "x(") {\r\n                                //array, method, paren\r\n                                destruct.push(true);\r\n                            } else if (ctoke === "{" && deep === "object" && ltype !== "operator" && ltype !== "start" && ltype !== "literal" && deeper !== "object" && deeper !== "array" && a > 0) {\r\n                                //curly brace not in a list and not assigned\r\n                                destruct.push(true);\r\n                            } else {\r\n                                //not destructured (multiline)\r\n                                destruct.push(false);\r\n                            }\r\n                        }\r\n                        if (ctoke !== "(" && ctoke !== "x(" && depth[a] !== "attribute") {\r\n                            //if (ctoke !== "[" || (ctoke === "[" && token[a + 1] !== "(")) {\r\n                                indent = indent + 1;\r\n                            //}\r\n                        }\r\n                        if (ctoke === "{" || ctoke === "x{") {\r\n                            if (ctoke === "{") {\r\n                                varline.push(false);\r\n                            }\r\n                            if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\r\n                                if (ltype === "markup") {\r\n                                    level[a - 1] = indent;\r\n                                } else if (options.braces === true && ltype !== "operator" && ltoke !== "return") {\r\n                                    level[a - 1] = indent - 1;\r\n                                } else if (deep === "function" || ltoke === ")" || ltoke === "x)" || ltoke === "," || ltoke === "}" || ltype === "markup") {\r\n                                    level[a - 1] = -10;\r\n                                } else if (ltoke === "{" || ltoke === "x{" || ltoke === "[" || ltoke === "}" || ltoke === "x}") {\r\n                                    level[a - 1] = indent - 1;\r\n                                }\r\n                            }\r\n                            if (deep === "object") {\r\n                                if (options.formatObject === "indent") {\r\n                                    destruct[destruct.length - 1] = false;\r\n                                    return level.push(indent);\r\n                                }\r\n                                if (options.formatObject === "inline") {\r\n                                    destruct[destruct.length - 1] = true;\r\n                                    return level.push(-20);\r\n                                }\r\n                            }\r\n                            if (deep === "switch") {\r\n                                if (options.nocaseindent === true) {\r\n                                    return level.push(indent - 1);\r\n                                }\r\n                                indent = indent + 1;\r\n                                return level.push(indent);\r\n                            }\r\n                            if (destruct[destruct.length - 1] === true) {\r\n                                if (ltype !== "word") {\r\n                                    return level.push(-20);\r\n                                }\r\n                            }\r\n                            return level.push(indent);\r\n                        }\r\n                        if (ctoke === "(" || ctoke === "x(") {\r\n                            if (ltoke === "-" && (token[a - 2] === "(" || token[a - 2] === "x(")) {\r\n                                level[a - 2] = -20;\r\n                            }\r\n                            // the start of scope, at least for counting, is pushed back from the opening of\r\n                            // the block to the paranthesis containing arguments so that the arguments can\r\n                            // be tagged as variables of the coming scope\r\n                            if (options.jsscope !== "none" || options.mode === "minify") {\r\n                                // a 0 is pushed into the start of scope, but this number is updated in the\r\n                                // "end" function to indicate the index where the scope ends\r\n                                if (ltoke === "function" || token[a - 2] === "function") {\r\n                                    meta[meta.length - 1] = 0;\r\n                                }\r\n                            }\r\n                            if (ltype === "end" && deeper !== "if" && deeper !== "for" && deeper !== "catch" && deeper !== "else" && deeper !== "do" && deeper !== "try" && deeper !== "finally" && deeper !== "catch") {\r\n                                if (types[a - 1] === "comment" || types[a - 1] === "comment-inline") {\r\n                                    level[a - 1] = indent;\r\n                                } else {\r\n                                    level[a - 1] = -20;\r\n                                }\r\n                            }\r\n                            if (ltoke === "async") {\r\n                                level[a - 1] = -10;\r\n                            } else if (deep === "method" || (token[a - 2] === "function" && ltype === "word")) {\r\n                                if (ltoke === "import" || ltoke === "in" || options.functionname === true) {\r\n                                    level[a - 1] = -10;\r\n                                } else if ((ltoke === "}" && depth[a - 1] === "function") || ltype === "word") {\r\n                                    level[a - 1] = -20;\r\n                                } else if (deeper !== "method" && deep !== "method") {\r\n                                    level[a - 1] = indent;\r\n                                }\r\n                            }\r\n                            if (ltoke === "+" && (token[a - 2].charAt(0) === "\\"" || token[a - 2].charAt(0) === "\'")) {\r\n                                return level.push(indent);\r\n                            }\r\n                            if (ltoke === "}" || ltoke === "x}") {\r\n                                return level.push(-20);\r\n                            }\r\n                            if ((ltoke === "-" && (a < 2 || (token[a - 2] !== ")" && token[a - 2] !== "x)" && token[a - 2] !== "]" && types[a - 2] !== "word" && types[a - 2] !== "literal"))) || (options.space === false && ltoke === "function")) {\r\n                                level[a - 1] = -20;\r\n                            }\r\n                            return level.push(-20);\r\n                        }\r\n                        if (ctoke === "[") {\r\n                            if (ltoke === "[") {\r\n                                list[list.length - 2] = true;\r\n                            }\r\n                            if (ltoke === "return" || ltoke === "var" || ltoke === "let" || ltoke === "const") {\r\n                                level[a - 1] = -10;\r\n                            } else if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline" && depth[a - 1] !== "attribute" && (ltype === "end" || ltype === "word")) {\r\n                                level[a - 1] = -20;\r\n                            } else if (ltoke !== "{" && (ltoke === "[" || ltoke === "{" || ltoke === "x{")) {\r\n                                level[a - 1] = indent - 1;\r\n                            }\r\n                            if (depth[a] === "attribute") {\r\n                                return level.push(-20);\r\n                            }\r\n                            if (options.formatArray === "indent") {\r\n                                destruct[destruct.length - 1] = false;\r\n                                return level.push(indent);\r\n                            }\r\n                            if (options.formatArray === "inline") {\r\n                                destruct[destruct.length - 1] = true;\r\n                                return level.push(-20);\r\n                            }\r\n                            if (deep === "method" || destruct[destruct.length - 1] === true) {\r\n                                return level.push(-20);\r\n                            }\r\n                            return (function jspretty__beautify_start_squareBrace() {\r\n                                var c = 0;\r\n                                for (c = a + 1; c < b; c = c + 1) {\r\n                                    if (token[c] === "]") {\r\n                                        return level.push(-20);\r\n                                    }\r\n                                    if (token[c] === ",") {\r\n                                        return level.push(indent);\r\n                                    }\r\n                                }\r\n                                return level.push(-20);\r\n                            }());\r\n                        }\r\n                    },\r\n                    end           = function jspretty__beautify_end() {\r\n                        var ei = (extraindent[extraindent.length - 1] === undefined)\r\n                            ? []\r\n                            : extraindent[extraindent.length - 1];\r\n                        if (ctoke === ")" && token[a + 1] === "." && ei[ei.length - 1] > -1 && token[ei[0]] !== ":") {\r\n                            (function jspretty__beautify_end_brokenParen() {\r\n                                var c = begin[a],\r\n                                    d = false,\r\n                                    e = false;\r\n                                do {\r\n                                    c = c - 1;\r\n                                } while (c > 0 && level[c] < -9);\r\n                                d = (level[c] === indent);\r\n                                c = a + 1;\r\n                                do {\r\n                                    c = c + 1;\r\n                                    if (token[c] === "{") {\r\n                                        e = true;\r\n                                        break;\r\n                                    }\r\n                                    if (begin[c] === begin[a + 1] && (types[c] === "separator" || types[c] === "end")) {\r\n                                        break;\r\n                                    }\r\n                                } while (c < b);\r\n                                if (d === false && e === true && extraindent.length > 1) {\r\n                                    extraindent[extraindent.length - 2].push(begin[a]);\r\n                                    indent = indent + 1;\r\n                                }\r\n                            }());\r\n                        }\r\n                        if (token[a + 1] === "," && (depth[a] === "object" || depth[a] === "array")) {\r\n                            destructfix(true, false);\r\n                        }\r\n                        if ((token[a + 1] === "}" || token[a + 1] === "]") && (depth[a] === "object" || depth[a] === "array") && token[begin[a] - 1] === ",") {\r\n                            destructfix(true, false);\r\n                        }\r\n                        if (depth[a] !== "attribute") {\r\n                            if (ctoke !== ")" && ctoke !== "x)" && (ltype !== "markup" || (ltype === "markup" && token[a - 2] !== "return"))) {\r\n                                indent = indent - 1;\r\n                            }\r\n                            if (ctoke === "}" && depth[a] === "switch" && options.nocaseindent === false) {\r\n                                indent = indent - 1;\r\n                            }\r\n                        }\r\n                        if (ctoke === "}" || ctoke === "x}") {\r\n                            if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline" && ltoke !== "{" && ltoke !== "x{" && ltype !== "end" && ltype !== "literal" && ltype !== "separator" && ltoke !== "++" && ltoke !== "--" && varline[varline.length - 1] === false && (a < 2 || token[a - 2] !== ";" || token[a - 2] !== "x;" || ltoke === "break" || ltoke === "return")) {\r\n                                (function jspretty__beautify_end_curlyBrace() {\r\n                                    var c       = 0,\r\n                                        d       = 1,\r\n                                        assign  = false,\r\n                                        listlen = list.length;\r\n                                    for (c = a - 1; c > -1; c = c - 1) {\r\n                                        if (types[c] === "end") {\r\n                                            d = d + 1;\r\n                                        }\r\n                                        if (types[c] === "start") {\r\n                                            d = d - 1;\r\n                                        }\r\n                                        if (d === 1) {\r\n                                            if (token[c] === "=" || token[c] === ";" || token[c] === "x;") {\r\n                                                assign = true;\r\n                                            }\r\n                                            if (c > 0 && token[c] === "return" && (token[c - 1] === ")" || token[c - 1] === "x)" || token[c - 1] === "{" || token[c - 1] === "x{" || token[c - 1] === "}" || token[c - 1] === "x}" || token[c - 1] === ";" || token[c - 1] === "x;")) {\r\n                                                indent       = indent - 1;\r\n                                                level[a - 1] = indent;\r\n                                                return;\r\n                                            }\r\n                                            if ((token[c] === ":" && ternary.length === 0) || (token[c] === "," && assign === false && varline[varline.length - 1] === false)) {\r\n                                                return;\r\n                                            }\r\n                                            if ((c === 0 || token[c - 1] === "{" || token[c - 1] === "x{") || token[c] === "for" || token[c] === "if" || token[c] === "do" || token[c] === "function" || token[c] === "while" || token[c] === "var" || token[c] === "let" || token[c] === "const" || token[c] === "with") {\r\n                                                if (list[listlen - 1] === false && listlen > 1 && (a === b - 1 || (token[a + 1] !== ")" && token[a + 1] !== "x)")) && depth[a] !== "object") {\r\n                                                    indent = indent - 1;\r\n                                                }\r\n                                                if (varline[varline.length - 1] === true) {\r\n                                                    indent = indent - 1;\r\n                                                }\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }());\r\n                            }\r\n                            //this is the bulk of logic identifying scope start and end\r\n                            if (depth[a] === "function" && (options.jsscope !== "none" || options.mode === "minify")) {\r\n                                (function jspretty__beautify_end_jsscope() {\r\n                                    var c     = 0,\r\n                                        d     = 1,\r\n                                        build = [],\r\n                                        paren = false;\r\n                                    for (c = a - 1; c > -1; c = c - 1) {\r\n                                        if (types[c] === "end") {\r\n                                            d = d + 1;\r\n                                        } else if (types[c] === "start") {\r\n                                            d = d - 1;\r\n                                        }\r\n                                        if (d < 0) {\r\n                                            return;\r\n                                        }\r\n                                        if (meta[c] === "v" && token[c] !== build[build.length - 1]) {\r\n                                            build.push(token[c]);\r\n                                        } else if (d === 1 && token[c] === ")") {\r\n                                            paren = true;\r\n                                        } else if (d === 1 && paren === true && types[c] === "word" && token[c] !== build[build.length - 1]) {\r\n                                            build.push(token[c]);\r\n                                        }\r\n                                        if (c === lettest) {\r\n                                            meta[c] = a - 1;\r\n                                            if (token[c] === "let" || token[c] === "const") {\r\n                                                meta[meta.length - 2] = [build, true];\r\n                                            }\r\n                                            build   = [];\r\n                                            lettest = -1;\r\n                                        }\r\n                                        if (c > 0 && token[c - 1] === "function" && types[c] === "word" && token[c] !== build[build.length - 1]) {\r\n                                            build.push(token[c]);\r\n                                        }\r\n                                        if (d === 0) {\r\n                                            if (token[c] === "function") {\r\n                                                if (types[c + 1] === "word") {\r\n                                                    meta[c + 2] = a;\r\n                                                } else {\r\n                                                    meta[c + 1] = a;\r\n                                                }\r\n                                                meta[meta.length - 1] = [build, false];\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }());\r\n                            }\r\n                        }\r\n                        if (options.bracepadding === false && ctoke !== "}" && ltype !== "markup") {\r\n                            level[a - 1] = -20;\r\n                        }\r\n                        if (options.bracepadding === true && ltype !== "start" && ltoke !== ";" && (level[begin[a]] < -9 || destruct[destruct.length - 1] === true)) {\r\n                            level[begin[a]] = -10;\r\n                            level[a - 1]    = -10;\r\n                            level.push(-20);\r\n                        } else if (options.qml === true) {\r\n                            if (ltype === "start" || ctoke === ")" || ctoke === "x)") {\r\n                                level[a - 1] = -20;\r\n                            } else {\r\n                                level[a - 1] = indent;\r\n                            }\r\n                            level.push(indent);\r\n                        } else if (depth[a] === "attribute") {\r\n                            level[a - 1] = -20;\r\n                            level.push(indent);\r\n                        } else if (depth[a] === "array" && (ei.length > 0 || arrbreak[arrbreak.length - 1] === true)) {\r\n                            endExtraInd();\r\n                            destruct[destruct.length - 1] = false;\r\n                            level[begin[a]]               = indent + 1;\r\n                            level[a - 1]                  = indent;\r\n                            level.push(-20);\r\n                        } else if ((depth[a] === "object" || (begin[a] === 0 && ctoke === "}")) && ei.length > 0) {\r\n                            endExtraInd();\r\n                            destruct[destruct.length - 1] = false;\r\n                            level[begin[a]]               = indent + 1;\r\n                            level[a - 1]                  = indent;\r\n                            level.push(-20);\r\n                        } else if (ctoke === ")" || ctoke === "x)") {\r\n                            if (options.wrap > 0 && ctoke === ")") {\r\n                                (function jspretty__beautify_end_parenWrap() {\r\n                                    var len   = 0,\r\n                                        aa    = 0,\r\n                                        short = 0,\r\n                                        first = 0,\r\n                                        inc   = 0,\r\n                                        comma = false,\r\n                                        array = false,\r\n                                        wrap  = options.wrap,\r\n                                        open  = begin[a],\r\n                                        ind   = (indent + 1),\r\n                                        exl   = ei.length,\r\n                                        ready = false,\r\n                                        mark  = false,\r\n                                        tern  = false;\r\n                                    if (level[open] < -9) {\r\n                                        aa = open;\r\n                                        do {\r\n                                            aa = aa + 1;\r\n                                        } while (aa < a && level[aa] < -9);\r\n                                        first = aa;\r\n                                        do {\r\n                                            len = len + token[aa].length;\r\n                                            if (level[aa] === -10) {\r\n                                                len = len + 1;\r\n                                            }\r\n                                            if (token[aa] === "(" && short > 0 && short < wrap - 1 && first === a) {\r\n                                                short = -1;\r\n                                            }\r\n                                            if (token[aa] === ")") {\r\n                                                inc = inc - 1;\r\n                                            } else if (token[aa] === "(") {\r\n                                                inc = inc + 1;\r\n                                            }\r\n                                            if (aa === open && inc > 0) {\r\n                                                short = len;\r\n                                            }\r\n                                            aa = aa - 1;\r\n                                        } while (aa > 0 && level[aa] < -9);\r\n                                        if (token[aa + 1] === ".") {\r\n                                            ind = level[aa] + 1;\r\n                                        }\r\n                                        if (len > wrap - 1 && ltoke !== "(" && short !== -1 && destruct[destruct.length - 2] === false) {\r\n                                            if ((token[open - 1] === "if" && list[list.length - 1] === true) || token[open - 1] !== "if") {\r\n                                                level[open] = ind;\r\n                                                if (token[open - 1] === "for") {\r\n                                                    aa = open;\r\n                                                    do {\r\n                                                        aa = aa + 1;\r\n                                                        if (token[aa] === ";" && begin[aa] === open) {\r\n                                                            level[aa] = ind;\r\n                                                        }\r\n                                                    } while (aa < a);\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    aa  = a;\r\n                                    len = 0;\r\n                                    do {\r\n                                        aa = aa - 1;\r\n                                        if (depth[aa] === "function") {\r\n                                            aa = begin[aa];\r\n                                        } else if (begin[aa] === open) {\r\n                                            if (token[aa] === "?") {\r\n                                                tern = true;\r\n                                            } else if (token[aa] === "," && comma === false) {\r\n                                                comma = true;\r\n                                                if (len >= wrap) {\r\n                                                    ready = true;\r\n                                                }\r\n                                            } else if (types[aa] === "markup" && mark === false) {\r\n                                                mark = true;\r\n                                            }\r\n                                            if (level[aa] > -9 && token[aa] !== "," && types[aa] !== "markup") {\r\n                                                len = 0;\r\n                                            } else {\r\n                                                if (level[aa] === -10) {\r\n                                                    len = len + 1;\r\n                                                }\r\n                                                len = len + token[aa].length;\r\n                                                if (len >= wrap && (comma === true || mark === true)) {\r\n                                                    ready = true;\r\n                                                }\r\n                                            }\r\n                                        } else {\r\n                                            if (level[aa] > -9) {\r\n                                                len = 0;\r\n                                            } else {\r\n                                                len = len + token[aa].length;\r\n                                                if (len >= wrap && (comma === true || mark === true)) {\r\n                                                    ready = true;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    } while (aa > open && ready === false);\r\n                                    if (((comma === true || mark === true) && len >= wrap) || level[open] > -9) {\r\n                                        if (tern === true) {\r\n                                            ind = level[open];\r\n                                            if (token[open - 1] === "[") {\r\n                                                aa = a;\r\n                                                do {\r\n                                                    aa = aa + 1;\r\n                                                    if (types[aa] === "end" || token[aa] === "," || token[aa] === ";") {\r\n                                                        break;\r\n                                                    }\r\n                                                } while (aa < b);\r\n                                                if (token[aa] === "]") {\r\n                                                    ind = ind - 1;\r\n                                                    array = true;\r\n                                                }\r\n                                            }\r\n                                        } else if (exl > 0 && ei[exl - 1] > aa) {\r\n                                            ind = ind - exl;\r\n                                        }\r\n                                        destruct[destruct.length - 1] = false;\r\n                                        aa = a;\r\n                                        do {\r\n                                            aa = aa - 1;\r\n                                            if (begin[aa] === open) {\r\n                                                if (token[aa].indexOf("=") > -1 && types[aa] === "operator" && token[aa].indexOf("!") < 0 && token[aa].indexOf("==") < 0 && token[aa] !== "<=" && token[aa].indexOf(">") < 0) {\r\n                                                    len = aa;\r\n                                                    do {\r\n                                                        len = len - 1;\r\n                                                        if (begin[len] === open && (token[len] === ";" || token[len] === "," || len === open)) {\r\n                                                            break;\r\n                                                        }\r\n                                                    } while (len > open);\r\n                                                    if (token[len] !== ";" && varlen.length > 0) {\r\n                                                        varlen[varlen.length - 1].push(aa - 1);\r\n                                                    }\r\n                                                } else if (token[aa] === ",") {\r\n                                                    level[aa] = ind;\r\n                                                } else if (level[aa] > -9 && array === false && (token[open - 1] !== "for" || token[aa + 1] === "?" || token[aa + 1] === ":") && (token[begin[a]] !== "(" || token[aa] !== "+")) {\r\n                                                    level[aa] = level[aa] + 1;\r\n                                                }\r\n                                            } else if (level[aa] > -9 && array === false) {\r\n                                                level[aa] = level[aa] + 1;\r\n                                            }\r\n                                        } while (aa > open);\r\n                                        level[open]  = ind;\r\n                                        level[a - 1] = ind - 1;\r\n                                    } else {\r\n                                        level[a - 1] = -20;\r\n                                    }\r\n                                }());\r\n                                if (token[begin[a] - 1] === "+" && level[begin[a]] > -9) {\r\n                                    level[begin[a] - 1] = -10;\r\n                                }\r\n                            } else {\r\n                                level[a - 1] = -20;\r\n                            }\r\n                            level.push(-20);\r\n                        } else if (destruct[destruct.length - 1] === true) {\r\n                            if (ctoke === "]" && begin[a] - 1 > 0 && token[begin[begin[a] - 1]] === "[") {\r\n                                destruct[destruct.length - 2] = false;\r\n                            }\r\n                            if (begin[a] < level.length) {\r\n                                level[begin[a]] = -20;\r\n                            }\r\n                            level[a - 1] = -20;\r\n                            level.push(-20);\r\n                        } else if ((types[a - 1] === "comment" && token[a - 1].substr(0, 2) === "//") || types[a - 1] === "comment-inline") {\r\n                            if (token[a - 2] === "x}") {\r\n                                level[a - 3] = indent + 1;\r\n                            }\r\n                            level[a - 1] = indent;\r\n                            level.push(-20);\r\n                        } else if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline" && ((ltoke === "{" && ctoke === "}") || (ltoke === "[" && ctoke === "]"))) {\r\n                            level[a - 1] = -20;\r\n                            if (ctoke === "}" && options.titanium === true) {\r\n                                level.push(indent);\r\n                            } else {\r\n                                level.push(-20);\r\n                            }\r\n                        } else if (ctoke === "]") {\r\n                            if ((list[list.length - 1] === true && destruct[destruct.length - 1] === false) || (ltoke === "]" && level[a - 2] === indent + 1)) {\r\n                                level[a - 1]    = indent;\r\n                                level[begin[a]] = indent + 1;\r\n                            } else if (level[a - 1] === -10) {\r\n                                level[a - 1] = -20;\r\n                            }\r\n                            if (token[begin[a] + 1] === "function") {\r\n                                level[a - 1] = indent;\r\n                            } else if (list[list.length - 1] === false) {\r\n                                if (ltoke === "}" || ltoke === "x}") {\r\n                                    level[a - 1] = indent;\r\n                                }\r\n                                (function jspretty__beautify_end_squareBrace() {\r\n                                    var c = 0,\r\n                                        d = 1;\r\n                                    for (c = a - 1; c > -1; c = c - 1) {\r\n                                        if (token[c] === "]") {\r\n                                            d = d + 1;\r\n                                        }\r\n                                        if (token[c] === "[") {\r\n                                            d = d - 1;\r\n                                            if (d === 0) {\r\n                                                if (c > 0 && (token[c + 1] === "{" || token[c + 1] === "x{" || token[c + 1] === "[")) {\r\n                                                    level[c] = indent + 1;\r\n                                                    return;\r\n                                                }\r\n                                                if (token[c + 1] !== "[" || lastlist === false) {\r\n                                                    level[c] = -20;\r\n                                                    return;\r\n                                                }\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                        if (d === 1 && token[c] === "+" && level[c] > 1) {\r\n                                            level[c] = level[c] - 1;\r\n                                        }\r\n                                    }\r\n                                }());\r\n                            }\r\n                            level.push(-20);\r\n                        } else if (ctoke === "}" || ctoke === "x}" || list[list.length - 1] === true) {\r\n                            if (ctoke === "}" && ltoke === "x}" && token[a + 1] === "else") {\r\n                                level[a - 2] = indent + 2;\r\n                                level.push(-20);\r\n                            } else {\r\n                                level.push(indent);\r\n                            }\r\n                            level[a - 1] = indent;\r\n                        } else {\r\n                            level.push(-20);\r\n                        }\r\n                        endExtraInd();\r\n                        lastlist = list[list.length - 1];\r\n                        list.pop();\r\n                        extraindent.pop();\r\n                        arrbreak.pop();\r\n                        itemcount.pop();\r\n                        if (ctoke === "}" || (ctoke === ")" && level[a - 1] > -9)) {\r\n                            if (varline[varline.length - 1] === true || ltoke !== "{" || token[begin[a] - 2] === "interface") {\r\n                                if (varlen.length > 0 && varlen[varlen.length - 1].length > 1 && destruct[destruct.length - 1] === false) {\r\n                                    varlist.push(varlen[varlen.length - 1]);\r\n                                }\r\n                            }\r\n                            if (ctoke === "}") {\r\n                                varline.pop();\r\n                            }\r\n                        }\r\n                        wordlist.pop();\r\n                        varlen.pop();\r\n                        destruct.pop();\r\n                        assignlist.pop();\r\n                    },\r\n                    operator      = function jspretty__beautify_operator() {\r\n                        var ei = (extraindent[extraindent.length - 1] === undefined)\r\n                            ? []\r\n                            : extraindent[extraindent.length - 1];\r\n                        if (ei.length > 0 && ei[ei.length - 1] > -1 && depth[a] === "array") {\r\n                            arrbreak[arrbreak.length - 1] = true;\r\n                        }\r\n                        if (ctoke !== ":") {\r\n                            if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && destruct.length > 0) {\r\n                                destructfix(true, false);\r\n                            }\r\n                            if (ctoke !== "?" && token[ei[ei.length - 1]] === ".") {\r\n                                (function jspretty__beautify_operator_question() {\r\n                                    var c = a,\r\n                                        d = begin[c],\r\n                                        e = 0;\r\n                                    do {\r\n                                        if (begin[c] === d) {\r\n                                            if (token[c + 1] === "{" || token[c + 1] === "[" || token[c] === "function") {\r\n                                                return;\r\n                                            }\r\n                                            if (token[c] === "," || token[c] === ";" || types[c] === "end" || token[c] === ":") {\r\n                                                ei.pop();\r\n                                                indent = indent - 1;\r\n                                                return;\r\n                                            }\r\n                                            if (token[c] === "?" || token[c] === ":") {\r\n                                                if (token[ei[ei.length - 1]] === "." && e < 2) {\r\n                                                    ei[ei.length - 1] = d + 1;\r\n                                                }\r\n                                                return;\r\n                                            }\r\n                                            if (token[c] === ".") {\r\n                                                e = e + 1;\r\n                                            }\r\n                                        }\r\n                                        c = c + 1;\r\n                                    } while (c < b);\r\n                                }());\r\n                            }\r\n                        }\r\n                        if (ctoke === "!" || ctoke === "...") {\r\n                            if (ltoke === "}" || ltoke === "x}") {\r\n                                level[a - 1] = indent;\r\n                            }\r\n                            return level.push(-20);\r\n                        }\r\n                        if (ltoke === ";" || ltoke === "x;") {\r\n                            if (token[begin[a] - 1] !== "for") {\r\n                                level[a - 1] = indent;\r\n                            }\r\n                            return level.push(-20);\r\n                        }\r\n                        if (ctoke === "*") {\r\n                            if (ltoke === "function" || ltoke === "yield") {\r\n                                level[a - 1] = -20;\r\n                            } else {\r\n                                level[a - 1] = -10;\r\n                            }\r\n                            return level.push(-10);\r\n                        }\r\n                        if (ctoke === "?") {\r\n                            if (lines[a] === 0 && types[a - 2] === "word" && token[a - 2] !== "return" && token[a - 2] !== "in" && token[a - 2] !== "instanceof" && token[a - 2] !== "typeof" && ltype === "word") {\r\n                                if (types[a + 1] === "word" || ((token[a + 1] === "(" || token[a + 1] === "x(") && token[a - 2] === "new")) {\r\n                                    level[a - 1] = -20;\r\n                                    if (types[a + 1] === "word") {\r\n                                        return level.push(-10);\r\n                                    }\r\n                                    return level.push(-20);\r\n                                }\r\n                            }\r\n                            if (token[a + 1] === ":") {\r\n                                level[a - 1] = -20;\r\n                                return level.push(-20);\r\n                            }\r\n                            if (options.ternaryline === true) {\r\n                                level[a - 1] = -10;\r\n                            } else {\r\n                                (function jspretty__beautify_operator_ternObj() {\r\n                                    var c = a - 1;\r\n                                    do {\r\n                                        c = c - 1;\r\n                                    } while (c > -1 && level[c] < -9);\r\n                                    ei.push(a);\r\n                                    ternary.push(a);\r\n                                    indent = indent + 1;\r\n                                    if (level[c] === indent && token[c + 1] !== ":") {\r\n                                        indent = indent + 1;\r\n                                        ei.push(a);\r\n                                    }\r\n                                    level[a - 1] = indent;\r\n                                    if (token[begin[a]] === "(" && (ei.length < 2 || ei[0] === ei[1])) {\r\n                                        destruct[destruct.length - 1] = false;\r\n                                        if (a - 2 === begin[a]) {\r\n                                            level[begin[a]] = indent - 1;\r\n                                        } else {\r\n                                            level[begin[a]] = indent;\r\n                                        }\r\n                                        c = a - 2;\r\n                                        do {\r\n                                            if (types[c] === "end" && level[c - 1] > -1) {\r\n                                                break;\r\n                                            }\r\n                                            if (level[c] > -1) {\r\n                                                level[c] = level[c] + 1;\r\n                                            }\r\n                                            c = c - 1;\r\n                                        } while (c > begin[a]);\r\n                                    }\r\n                                }());\r\n                            }\r\n                        }\r\n                        if (ctoke === ":") {\r\n                            if (token[a - 2] === "where" && depth[a - 2] === depth[a]) {\r\n                                level[a - 1] = -10;\r\n                                return level.push(-10);\r\n                            }\r\n                            if ((token[a - 2] === "var" || token[a - 2] === "let" || token[a - 2] === "const" || token[a - 2] === "," || (depth[a] === "global" && options.jsx === true && ternary.length < 1)) && ltype === "word" && token[begin[a]] !== "(" && token[begin[a]] !== "x(") {\r\n                                level[a - 1] = -20;\r\n                                if (depth[a] === "object" || (varline[varline.length - 1] === true && token[begin[a]] !== "(" && token[begin[a]] !== "x(")) {\r\n                                    if (varlen.length > 0 && varlen[varlen.length - 1].length > 0 && token[varlen[varlen.length - 1][varlen[varlen.length - 1].length - 1] + 1] !== ctoke) {\r\n                                        if (varlen[varlen.length - 1].length > 1) {\r\n                                            varlist.push(varlen[varlen.length - 1]);\r\n                                        }\r\n                                        varlen[varlen.length - 1] = [];\r\n                                    }\r\n                                    varlen[varlen.length - 1].push(a - 1);\r\n                                }\r\n                                return level.push(-10);\r\n                            }\r\n                            if ((ltoke === ")" || ltoke === "x)") && token[begin[a - 1] - 2] === "function") {\r\n                                level[a - 1] = -20;\r\n                                return level.push(-10);\r\n                            }\r\n                            if (depth[a] === "attribute") {\r\n                                level[a - 1] = -20;\r\n                                return level.push(-10);\r\n                            }\r\n                            if (token[begin[a]] !== "(" && token[begin[a]] !== "x(" && (ltype === "word" || ltoke === ")" || ltoke === "]" || ltoke === "?") && (depth[a] === "map" || depth[a] === "class" || types[a + 1] === "word") && (ternary.length === 0 || ternary[ternary.length - 1] < begin[a]) && ("mapclassexpressionmethodglobalparen".indexOf(depth[a]) > -1 || (types[a - 2] === "word" && depth[a] !== "switch"))) {\r\n                                level[a - 1] = -20;\r\n                                varlen[varlen.length - 1].push(a - 1);\r\n                                return level.push(-10);\r\n                            }\r\n                            if (depth[a] === "switch" && (ternary.length < 1 || ternary[ternary.length - 1] < begin[a])) {\r\n                                level[a - 1] = -20;\r\n                                return level.push(indent);\r\n                            }\r\n                            if (ternary.length > 0 && ternary[ternary.length - 1] > begin[a]) {\r\n                                (function jspretty_beautify_operator_colon() {\r\n                                    var c = a,\r\n                                        d = begin[a];\r\n                                    do {\r\n                                        c = c - 1;\r\n                                        if (begin[c] === d) {\r\n                                            if (token[c] === "," || token[c] === ";") {\r\n                                                level[a - 1] = -20;\r\n                                                return;\r\n                                            }\r\n                                            if (token[c] === "?") {\r\n                                                ternary.pop();\r\n                                                return endExtraInd();\r\n                                            }\r\n                                        }\r\n                                    } while (c > d);\r\n                                }());\r\n                            } else if (depth[a] === "object") {\r\n                                level[a - 1] = -20;\r\n                                varlen[varlen.length - 1].push(a - 1);\r\n                            } else if (ternary.length > 0) {\r\n                                level[a - 1] = indent;\r\n                            } else {\r\n                                level[a - 1] = -10;\r\n                            }\r\n                            return level.push(-10);\r\n                        }\r\n                        if (ctoke === "++" || ctoke === "--") {\r\n                            if (ltype === "literal" || ltype === "word") {\r\n                                level[a - 1] = -20;\r\n                                level.push(-10);\r\n                            } else if (a < b - 1 && (types[a + 1] === "literal" || types[a + 1] === "word")) {\r\n                                level.push(-20);\r\n                            } else {\r\n                                level.push(-10);\r\n                            }\r\n                            return;\r\n                        }\r\n                        if (ctoke === "+") {\r\n                            if (ltype === "start") {\r\n                                level[a - 1] = -20;\r\n                            } else {\r\n                                level[a - 1] = -10;\r\n                            }\r\n                            if (options.wrap < 1 || token[begin[a]] === "x(") {\r\n                                return level.push(-10);\r\n                            }\r\n                            return (function jspretty__beautify_operator_plus() {\r\n                                var line = 0,\r\n                                    next = 0,\r\n                                    c    = a,\r\n                                    ind  = indent + 2,\r\n                                    aa   = token[a + 1],\r\n                                    meth = 0;\r\n                                if (aa === undefined) {\r\n                                    return level.push(-10);\r\n                                }\r\n                                if (types[a - 1] === "operator" || types[a - 1] === "start") {\r\n                                    if (types[a + 1] === "word" || aa === "(" || aa === "[") {\r\n                                        return level.push(-20);\r\n                                    }\r\n                                    if (isNaN(aa.slice(1, -1)) === false && ((/\\d/).test(aa.charAt(1)) === true || aa.charAt(1) === "." || aa.charAt(1) === "-" || aa.charAt(1) === "+")) {\r\n                                        return level.push(-20);\r\n                                    }\r\n                                }\r\n                                do {\r\n                                    c = c - 1;\r\n                                    if (token[begin[a]] === "(") {\r\n                                        if (c === begin[a]) {\r\n                                            meth = line;\r\n                                        }\r\n                                        if (token[c] === "," && begin[c] === begin[a] && list[list.length - 1] === true) {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (line > options.wrap - 1) {\r\n                                        break;\r\n                                    }\r\n                                    if (level[c] > -9) {\r\n                                        break;\r\n                                    }\r\n                                    if (types[c] === "operator" && token[c] !== "=" && token[c] !== "+" && begin[c] === begin[a]) {\r\n                                        break;\r\n                                    }\r\n                                    line = line + token[c].length;\r\n                                    if (c === begin[a] && token[c] === "[" && line < options.wrap - 1) {\r\n                                        break;\r\n                                    }\r\n                                    if (token[c] === "." && level[c] > -9) {\r\n                                        break;\r\n                                    }\r\n                                    if (level[c] === -10) {\r\n                                        line = line + 1;\r\n                                    }\r\n                                } while (c > 0);\r\n                                if (meth > 0) {\r\n                                    meth = meth + aa.length;\r\n                                }\r\n                                line = line + aa.length;\r\n                                next = c;\r\n                                if (line > options.wrap - 1 && level[c] < -9) {\r\n                                    do {\r\n                                        next = next - 1;\r\n                                    } while (next > 0 && level[next] < -9);\r\n                                }\r\n                                if (token[next + 1] === "." && begin[a] <= begin[next]) {\r\n                                    ind = ind + 1;\r\n                                } else if (token[next] === "+") {\r\n                                    ind = level[next];\r\n                                }\r\n                                next = aa.length;\r\n                                if (line + next < options.wrap) {\r\n                                    level.push(-10);\r\n                                } else {\r\n                                    if (token[begin[a]] === "(" && (token[ei[0]] === ":" || token[ei[0]] === "?")) {\r\n                                        ind = indent + 3;\r\n                                    } else if (depth[a] === "method") {\r\n                                        level[begin[a]] = indent;\r\n                                        if (list[list.length - 1] === true) {\r\n                                            ind = indent + 3;\r\n                                        } else {\r\n                                            ind = indent + 1;\r\n                                        }\r\n                                    } else if (depth[a] === "object" || depth[a] === "array") {\r\n                                        destructfix(true, false);\r\n                                    }\r\n                                    if (token[c] === "var" || token[c] === "let" || token[c] === "const") {\r\n                                        line = line - (options.insize * options.inchar.length * 2);\r\n                                    }\r\n                                    if (meth > 0) {\r\n                                        c = options.wrap - meth;\r\n                                    } else {\r\n                                        c = options.wrap - line;\r\n                                    }\r\n                                    if (c > 0 && c < 5) {\r\n                                        level.push(ind);\r\n                                        if (token[a].charAt(0) === "\\"" || token[a].charAt(0) === "\'") {\r\n                                            a = a + 1;\r\n                                            if (token[a].length > options.wrap) {\r\n                                                strwrap(0);\r\n                                            } else {\r\n                                                level.push(-10);\r\n                                            }\r\n                                        }\r\n                                    } else if (token[begin[a]] !== "(" || meth > options.wrap - 1 || meth === 0) {\r\n                                        if (meth > 0) {\r\n                                            line = meth;\r\n                                        }\r\n                                        if (line - aa.length < options.wrap - 1 && (aa.charAt(0) === "\\"" || aa.charAt(0) === "\'")) {\r\n                                            a = a + 1;\r\n                                            if (line - aa.length > options.wrap - 4) {\r\n                                                level.push(ind);\r\n                                            } else {\r\n                                                level.push(-10);\r\n                                            }\r\n                                            if (varline[varline.length - 1] === true && token[c] === "=") {\r\n                                                line = line + (options.inchar.length * options.insize) - 1;\r\n                                            } else {\r\n                                                line = line + 3;\r\n                                            }\r\n                                            strwrap(options.wrap - (line - aa.length));\r\n                                        } else {\r\n                                            level.push(ind);\r\n                                        }\r\n                                    } else {\r\n                                        level.push(-10);\r\n                                    }\r\n                                }\r\n                            }());\r\n                        }\r\n                        if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\r\n                            if (ltoke === "(") {\r\n                                level[a - 1] = -20;\r\n                            } else if (ctoke === "*" && depth[a] === "object" && types[a + 1] === "word" && (ltoke === "{" || ltoke === ",")) {\r\n                                level[a - 1] = indent;\r\n                            } else if (ctoke !== "?" || ternary.length === 0) {\r\n                                level[a - 1] = -10;\r\n                            }\r\n                        }\r\n                        if (ctoke.indexOf("=") > -1 && ctoke !== "==" && ctoke !== "===" && ctoke !== "!=" && ctoke !== "!==" && ctoke !== ">=" && ctoke !== "<=" && ctoke !== "=>" && depth[a] !== "method" && depth[a] !== "object") {\r\n                            if (assignlist[assignlist.length - 1] === true && token[begin[a] - 1] !== "for") {\r\n                                (function jspretty__beautify_operator_assignTest() {\r\n                                    var c = 0,\r\n                                        d = "",\r\n                                        e = begin[a];\r\n                                    if (depth[a] === "class") {\r\n                                        varlen[varlen.length - 1].push(a - 1);\r\n                                    } else {\r\n                                        for (c = a - 1; c > e; c = c - 1) {\r\n                                            d = token[c];\r\n                                            if (d === ";" || d === "x;" || d === "," || d === "?" || d === ":" || c === e + 1) {\r\n                                                return varlen[varlen.length - 1].push(a - 1);\r\n                                            }\r\n                                            if (d.indexOf("=") > -1 && d !== "==" && d !== "===" && d !== "!=" && d !== "!==" && d !== ">=" && d !== "<=") {\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }());\r\n                            }\r\n                            (function jspretty__beautify_operator_assignSpaces() {\r\n                                var c = 0,\r\n                                    d = 0,\r\n                                    e = false,\r\n                                    f = "";\r\n                                if ((token[begin[a]] === "(" || token[begin[a]] === "x(") && token[a + 1] !== "function") {\r\n                                    return;\r\n                                }\r\n                                for (c = a + 1; c < b; c = c + 1) {\r\n                                    if (types[c] === "start") {\r\n                                        if (e === true && token[c] !== "[") {\r\n                                            if (assignlist[assignlist.length - 1] === true) {\r\n                                                assignlist[assignlist.length - 1] = false;\r\n                                                if (varlen[varlen.length - 1].length > 1) {\r\n                                                    varlist.push(varlen[varlen.length - 1]);\r\n                                                }\r\n                                                varlen[varlen.length - 1] = [];\r\n                                            }\r\n                                            break;\r\n                                        }\r\n                                        d = d + 1;\r\n                                    }\r\n                                    if (types[c] === "end") {\r\n                                        d = d - 1;\r\n                                    }\r\n                                    if (d < 0) {\r\n                                        if (assignlist[assignlist.length - 1] === true) {\r\n                                            assignlist[assignlist.length - 1] = false;\r\n                                            if (varlen[varlen.length - 1].length > 1) {\r\n                                                varlist.push(varlen[varlen.length - 1]);\r\n                                            }\r\n                                            varlen[varlen.length - 1] = [];\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if (d === 0) {\r\n                                        f = token[c];\r\n                                        if (e === true) {\r\n                                            if (types[c] === "operator" || token[c] === ";" || token[c] === "x;" || token[c] === "?" || token[c] === "var" || token[c] === "let" || token[c] === "const") {\r\n                                                if (f !== undefined && (f === "?" || (f.indexOf("=") > -1 && f !== "==" && f !== "===" && f !== "!=" && f !== "!==" && f !== ">=" && f !== "<="))) {\r\n                                                    if (assignlist[assignlist.length - 1] === false && (varlen[varlen.length - 1].length === 0 || token[varlen[varlen.length - 1][varlen[varlen.length - 1].length - 1] + 1] === ctoke)) {\r\n                                                        varlen[varlen.length - 1].push(a - 1);\r\n                                                        assignlist[assignlist.length - 1] = true;\r\n                                                    }\r\n                                                }\r\n                                                if ((f === ";" || f === "x;" || f === "var" || f === "let" || f === "const") && assignlist[assignlist.length - 1] === true) {\r\n                                                    assignlist[assignlist.length - 1] = false;\r\n                                                    if (varlen[varlen.length - 1].length > 1) {\r\n                                                        varlist.push(varlen[varlen.length - 1]);\r\n                                                    }\r\n                                                    varlen[varlen.length - 1] = [];\r\n                                                }\r\n                                                break;\r\n                                            }\r\n                                            if (assignlist[assignlist.length - 1] === true && (f === "return" || f === "break" || f === "continue" || f === "throw")) {\r\n                                                assignlist[assignlist.length - 1] = false;\r\n                                                if (varlen[varlen.length - 1].length > 1) {\r\n                                                    varlist.push(varlen[varlen.length - 1]);\r\n                                                }\r\n                                                varlen[varlen.length - 1] = [];\r\n                                            }\r\n                                        }\r\n                                        if (f === ";" || f === "x;" || f === ",") {\r\n                                            e = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }());\r\n                        }\r\n                        if ((ctoke === "-" && ltoke === "return") || ltoke === "=") {\r\n                            return level.push(-20);\r\n                        }\r\n                        if (ltype === "operator" && types[a + 1] === "word" && ltoke !== "--" && ltoke !== "++" && ctoke !== "&&" && ctoke !== "||") {\r\n                            return level.push(-20);\r\n                        }\r\n                        level.push(-10);\r\n                    },\r\n                    word          = function jspretty__beautify_word() {\r\n                        var next    = token[a + 1],\r\n                            compare = (\r\n                                next !== undefined && next !== "==" && next !== "===" && next !== "!=" && next !== "!==" && next === ">=" && next !== "<=" && next.indexOf("=") > -1\r\n                            );\r\n                        if (varline[varline.length - 1] === true && (ltoke === "," || ltoke === "var" || ltoke === "let" || ltoke === "const")) {\r\n                            if (token[begin[a] - 1] !== "for" && depth[a] !== "method" && token[begin[a]] !== "(" && token[begin[a]] !== "x(") {\r\n                                if (types[a + 1] === "operator" && compare === true && token[varlen[varlen.length - 1][varlen[varlen.length - 1].length - 1] + 1] !== ":") {\r\n                                    varlen[varlen.length - 1].push(a);\r\n                                }\r\n                            }\r\n                            if (options.jsscope !== "none" || options.mode === "minify") {\r\n                                meta[meta.length - 1] = "v";\r\n                            }\r\n                        } else if ((options.jsscope !== "none" || options.mode === "minify") && ltoke === "function") {\r\n                            meta[meta.length - 1] = "v";\r\n                        }\r\n                        if ((ltoke === ")" || ltoke === "x)") && depth[a] === "class" && (token[begin[a - 1] - 1] === "static" || token[begin[a - 1] - 1] === "final" || token[begin[a - 1] - 1] === "void")) {\r\n                            level[a - 1]            = -10;\r\n                            level[begin[a - 1] - 1] = -10;\r\n                        }\r\n                        if (ltoke === "]") {\r\n                            level[a - 1] = -10;\r\n                        }\r\n                        if (ltoke === "}" || ltoke === "x}") {\r\n                            level[a - 1] = indent;\r\n                        }\r\n                        if (ctoke === "else" && ltoke === "}" && token[a - 2] === "x}") {\r\n                            level[a - 3] = level[a - 3] - 1;\r\n                        }\r\n                        if (varline.length === 1 && varline[0] === true && (ltoke === "var" || ltoke === "let" || ltoke === "const" || ltoke === "," || (ltoke === "function" && depth[a + 1] === "method"))) {\r\n                            globals.push(ctoke);\r\n                        }\r\n                        if ((ctoke === "let" || ctoke === "const") && lettest < 0) {\r\n                            lettest = a;\r\n                        }\r\n                        if (ctoke === "new") {\r\n                            (function jspretty__beautify_word_new() {\r\n                                var c       = 0,\r\n                                    nextish = (typeof next === "string")\r\n                                        ? next\r\n                                        : "",\r\n                                    apiword = (nextish === "")\r\n                                        ? []\r\n                                        : [\r\n                                            "ActiveXObject",\r\n                                            "ArrayBuffer",\r\n                                            "AudioContext",\r\n                                            "Canvas",\r\n                                            "CustomAnimation",\r\n                                            "DOMParser",\r\n                                            "DataView",\r\n                                            "Date",\r\n                                            "Error",\r\n                                            "EvalError",\r\n                                            "FadeAnimation",\r\n                                            "FileReader",\r\n                                            "Flash",\r\n                                            "Float32Array",\r\n                                            "Float64Array",\r\n                                            "FormField",\r\n                                            "Frame",\r\n                                            "Generator",\r\n                                            "HotKey",\r\n                                            "Image",\r\n                                            "Iterator",\r\n                                            "Intl",\r\n                                            "Int16Array",\r\n                                            "Int32Array",\r\n                                            "Int8Array",\r\n                                            "InternalError",\r\n                                            "Loader",\r\n                                            "Map",\r\n                                            "MenuItem",\r\n                                            "MoveAnimation",\r\n                                            "Notification",\r\n                                            "ParallelArray",\r\n                                            "Point",\r\n                                            "Promise",\r\n                                            "Proxy",\r\n                                            "RangeError",\r\n                                            "Rectangle",\r\n                                            "ReferenceError",\r\n                                            "Reflect",\r\n                                            "RegExp",\r\n                                            "ResizeAnimation",\r\n                                            "RotateAnimation",\r\n                                            "Set",\r\n                                            "SQLite",\r\n                                            "ScrollBar",\r\n                                            "Set",\r\n                                            "Shadow",\r\n                                            "StopIteration",\r\n                                            "Symbol",\r\n                                            "SyntaxError",\r\n                                            "Text",\r\n                                            "TextArea",\r\n                                            "Timer",\r\n                                            "TypeError",\r\n                                            "URL",\r\n                                            "Uint16Array",\r\n                                            "Uint32Array",\r\n                                            "Uint8Array",\r\n                                            "Uint8ClampedArray",\r\n                                            "URIError",\r\n                                            "WeakMap",\r\n                                            "WeakSet",\r\n                                            "Web",\r\n                                            "Window",\r\n                                            "XMLHttpRequest"\r\n                                        ],\r\n                                    apilen  = apiword.length;\r\n                                for (c = 0; c < apilen; c = c + 1) {\r\n                                    if (nextish === apiword[c]) {\r\n                                        return;\r\n                                    }\r\n                                }\r\n                                news = news + 1;\r\n                                if (options.jsscope !== "none") {\r\n                                    token[a] = "<strong class=\'new\'>new</strong>";\r\n                                }\r\n                            }());\r\n                        }\r\n                        if (ctoke === "from" && ltype === "end" && a > 0 && (token[begin[a - 1] - 1] === "import" || token[begin[a - 1] - 1] === ",")) {\r\n                            level[a - 1] = -10;\r\n                        }\r\n                        if (ctoke === "this" && options.jsscope !== "none") {\r\n                            token[a] = "<strong class=\'new\'>this</strong>";\r\n                        }\r\n                        if (ctoke === "function") {\r\n                            if (options.space === false && a < b - 1 && (token[a + 1] === "(" || token[a + 1] === "x(")) {\r\n                                return level.push(-20);\r\n                            }\r\n                            return level.push(-10);\r\n                        }\r\n                        if (ltype === "literal" && ltoke.charAt(ltoke.length - 1) === "{" && options.bracepadding === false) {\r\n                            level[a - 1] = -20;\r\n                        } else if (ltoke === "-" && a > 1) {\r\n                            if (types[a - 2] === "operator" || token[a - 2] === ",") {\r\n                                level[a - 1] = -20;\r\n                            } else if (types[a - 2] === "start") {\r\n                                level[a - 2] = -20;\r\n                                level[a - 1] = -20;\r\n                            }\r\n                        } else if (ctoke === "while" && (ltoke === "}" || ltoke === "x}")) {\r\n                            //verify if this is a do/while block\r\n                            (function jspretty__beautify_word_curlyBrace() {\r\n                                var c = 0,\r\n                                    d = 0;\r\n                                for (c = a - 1; c > -1; c = c - 1) {\r\n                                    if (token[c] === "}" || token[c] === "x}") {\r\n                                        d = d + 1;\r\n                                    }\r\n                                    if (token[c] === "{" || token[c] === "x{") {\r\n                                        d = d - 1;\r\n                                    }\r\n                                    if (d === 0) {\r\n                                        if (token[c - 1] === "do") {\r\n                                            level[a - 1] = -10;\r\n                                            return;\r\n                                        }\r\n                                        level[a - 1] = indent;\r\n                                        return;\r\n                                    }\r\n                                }\r\n                            }());\r\n                        } else if (ctoke === "in" || (((ctoke === "else" && options.elseline === false) || ctoke === "catch") && (ltoke === "}" || ltoke === "x}"))) {\r\n                            level[a - 1] = -10;\r\n                        } else if (ctoke === "var" || ctoke === "let" || ctoke === "const") {\r\n                            if (assignlist[assignlist.length - 1] === true && varlen.length > 0 && varlen[varlen.length - 1].length > 1) {\r\n                                assignlist[assignlist.length - 1] = false;\r\n                                varlist.push(varlen[varlen.length - 1]);\r\n                                varlen[varlen.length - 1] = [];\r\n                            } else if (depth[a] !== "method") {\r\n                                varlen[varlen.length - 1] = [];\r\n                            }\r\n                            if (ltype === "end") {\r\n                                level[a - 1] = indent;\r\n                            }\r\n                            if (token[begin[a] - 1] !== "for") {\r\n                                if (varline.length === 0) {\r\n                                    varline.push(true);\r\n                                } else {\r\n                                    varline[varline.length - 1] = true;\r\n                                }\r\n                                (function jspretty__beautify_word_varlisttest() {\r\n                                    var c = 0,\r\n                                        d = 0;\r\n                                    for (c = a + 1; c < b; c = c + 1) {\r\n                                        if (types[c] === "end") {\r\n                                            d = d - 1;\r\n                                        }\r\n                                        if (types[c] === "start") {\r\n                                            d = d + 1;\r\n                                        }\r\n                                        if (d < 0 || (d === 0 && (token[c] === ";" || token[c] === ","))) {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (token[c] === ",") {\r\n                                        indent = indent + 1;\r\n                                    }\r\n                                }());\r\n                            }\r\n                        } else if ((ctoke === "default" || ctoke === "case") && ltype !== "word" && depth[a] === "switch") {\r\n                            level[a - 1] = indent - 1;\r\n                            return level.push(-10);\r\n                        }\r\n                        if (ctoke === "catch" && ltoke === ".") {\r\n                            level[a - 1] = -20;\r\n                            return level.push(-20);\r\n                        }\r\n                        if (ctoke === "catch" || ctoke === "finally") {\r\n                            level[a - 1] = -10;\r\n                            return level.push(-10);\r\n                        }\r\n                        if (options.bracepadding === false && a < b - 1 && token[a + 1].charAt(0) === "}") {\r\n                            return level.push(-20);\r\n                        }\r\n                        if (depth[a] === "object" && (ltoke === "{" || ltoke === ",") && (token[a + 1] === "(" || token[a + 1] === "x(")) {\r\n                            return level.push(-20);\r\n                        }\r\n                        level.push(-10);\r\n                    };\r\n                if (options.titanium === true) {\r\n                    indent = indent - 1;\r\n                }\r\n                for (a = 0; a < b; a = a + 1) {\r\n                    if (options.jsscope !== "none" || options.mode === "minify") {\r\n                        meta.push("");\r\n                    }\r\n                    ctype = types[a];\r\n                    ctoke = token[a];\r\n                    if (ctype === "comment") {\r\n                        comment();\r\n                    } else if (ctype === "comment-inline") {\r\n                        commentInline();\r\n                    } else if (ctype === "regex") {\r\n                        level.push(-20);\r\n                    } else if (ctype === "literal") {\r\n                        literal();\r\n                    } else if (ctype === "separator") {\r\n                        separator();\r\n                    } else if (ctype === "start") {\r\n                        start();\r\n                    } else if (ctype === "end") {\r\n                        end();\r\n                    } else if (ctype === "operator") {\r\n                        operator();\r\n                    } else if (ctype === "word") {\r\n                        word();\r\n                    } else if (ctype === "markup") {\r\n                        markup();\r\n                    } else if (ctype.indexOf("template") === 0) {\r\n                        template();\r\n                    } else if (ctype === "generic") {\r\n                        if (ltoke !== "return" && ltoke.charAt(0) !== "#" && ltype !== "operator" && ltoke !== "public" && ltoke !== "private" && ltoke !== "static" && ltoke !== "final" && ltoke !== "implements" && ltoke !== "class" && ltoke !== "void") {\r\n                            level[a - 1] = -20;\r\n                        }\r\n                        if (token[a + 1] === "(" || token[a + 1] === "x(") {\r\n                            level.push(-20);\r\n                        } else {\r\n                            level.push(-10);\r\n                        }\r\n                    }\r\n                    if (ctype !== "comment" && ctype !== "comment-inline") {\r\n                        ltype = ctype;\r\n                        ltoke = ctoke;\r\n                    }\r\n                }\r\n                if (assignlist[assignlist.length - 1] === true && varlen[varlen.length - 1].length > 1 && ltoke === ";") {\r\n                    varlist.push(varlen[varlen.length - 1]);\r\n                }\r\n            }());\r\n        }\r\n        if (options.titanium === true) {\r\n            token[0] = "";\r\n            types[0] = "";\r\n            lines[0] = 0;\r\n        }\r\n        if (options.mode === "minify") {\r\n            result = (function jspretty__minify() {\r\n                var a        = 0,\r\n                    linelen  = 0,\r\n                    length   = token.length,\r\n                    comtest  = (options.topcoms === false),\r\n                    build    = [],\r\n                    lastsemi = function jspretty__minify_lastsemi() {\r\n                        var aa = 0,\r\n                            bb = 0;\r\n                        for (aa = a; aa > -1; aa = aa - 1) {\r\n                            if (types[aa] === "end") {\r\n                                bb = bb + 1;\r\n                            } else if (types[aa] === "start") {\r\n                                bb = bb - 1;\r\n                            }\r\n                            if (bb < 0) {\r\n                                if (token[aa - 1] === "for") {\r\n                                    build.push(";");\r\n                                }\r\n                                return;\r\n                            }\r\n                        }\r\n                    };\r\n                for (a = 0; a < length; a = a + 1) {\r\n                    if (types[a] !== "comment") {\r\n                        comtest = true;\r\n                    }\r\n                    if (types[a - 1] === "operator" && types[a] === "operator" && token[a] !== "!") {\r\n                        build.push(" ");\r\n                    }\r\n                    if (types[a] === "markup" && typeof global.prettydiff.markuppretty === "function") {\r\n                        build.push(extlib({jsx: true, mode: "minify", source: token[a]}));\r\n                    } else if (types[a] === "word" && (types[a + 1] === "word" || types[a + 1] === "literal" || token[a + 1] === "x{" || types[a + 1] === "comment" || types[a + 1] === "comment-inline")) {\r\n                        if (types[a - 1] === "literal" && token[a - 1].charAt(0) !== "\\"" && token[a - 1].charAt(0) !== "\'") {\r\n                            build.push(" ");\r\n                        }\r\n                        build.push(token[a]);\r\n                        build.push(" ");\r\n                    } else if (types[a] === "comment" && comtest === false) {\r\n                        build.push(token[a]);\r\n                        build.push(lf);\r\n                    } else if (token[a] === "x;" && token[a + 1] !== "}") {\r\n                        build.push(";");\r\n                    } else if (token[a] === ";" && token[a + 1] === "}") {\r\n                        lastsemi();\r\n                    } else if (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x)" && token[a] !== "x(" && types[a] !== "comment" && types[a] !== "comment-inline") {\r\n                        build.push(token[a]);\r\n                    }\r\n                    if (options.wrap > 0) {\r\n                        if (types[a] !== "comment" && types[a] !== "comment-inline") {\r\n                            linelen = linelen + token[a].length;\r\n                        }\r\n                        if ((types[a] === "operator" || types[a] === "separator" || types[a] === "start") && a < length - 1 && linelen + token[a + 1].length > options.wrap) {\r\n                            build.push(lf);\r\n                            linelen = 0;\r\n                        }\r\n                    }\r\n                }\r\n                if (options.newline === true) {\r\n                    if (options.crlf === true) {\r\n                        build.push("\\r\\n");\r\n                    } else {\r\n                        build.push("\\n");\r\n                    }\r\n                }\r\n                if (options.nodeasync === true) {\r\n                    return [build.join(""), globalerror];\r\n                }\r\n                return build.join("");\r\n            }());\r\n        } else {\r\n            //the result function generates the out\r\n            (function jspretty__result() {\r\n                var tab      = (function jspretty__result_tab() {\r\n                        var aa = options.inchar,\r\n                            bb = options.insize,\r\n                            cc = [];\r\n                        for (bb = bb; bb > 0; bb = bb - 1) {\r\n                            cc.push(aa);\r\n                        }\r\n                        return cc.join("");\r\n                    }()),\r\n                    vertical = function jspretty__result_vertical() {\r\n                        var aa          = 0,\r\n                            lastListLen = 0,\r\n                            cc          = 0,\r\n                            dd          = 0,\r\n                            longest     = 0,\r\n                            longTest    = 0,\r\n                            strlongest  = 0,\r\n                            isvar       = false,\r\n                            isvartoken  = 0,\r\n                            strspace    = "",\r\n                            tokenInList = "",\r\n                            longList    = [],\r\n                            joins       = function jspretty__result_vertical_joins(x) {\r\n                                var xlen = token[x].length,\r\n                                    y    = x;\r\n                                if (level[x] === 0) {\r\n                                    return xlen;\r\n                                }\r\n                                if (level[x] < -9) {\r\n                                    do {\r\n                                        y = y - 1;\r\n                                        if (level[y] > -9) {\r\n                                            break;\r\n                                        }\r\n                                        if (level[y] === -10) {\r\n                                            xlen = xlen + 1;\r\n                                        }\r\n                                        xlen = xlen + token[y].length;\r\n                                    } while (y > 0);\r\n                                    if (level[y] > 0) {\r\n                                        xlen = xlen + (options.inchar.length * options.insize * level[y]);\r\n                                    }\r\n                                } else {\r\n                                    xlen = xlen + (options.inchar.length * options.insize * level[x]);\r\n                                }\r\n                                if (depth[x] === "global" && varlist[0][0] === x && options.lang !== "javascript") {\r\n                                    y = x;\r\n                                    do {\r\n                                        y = y - 1;\r\n                                    } while (y > -1 && level[y] < -9);\r\n                                    if (y < 0) {\r\n                                        xlen = xlen + (options.inchar.length * options.insize * options.inlevel);\r\n                                    }\r\n                                }\r\n                                return xlen;\r\n                            };\r\n                        for (aa = varlist.length - 1; aa > -1; aa = aa - 1) {\r\n                            if (varlist[aa] !== undefined) {\r\n                                lastListLen = varlist[aa].length;\r\n                                longest     = 0;\r\n                                longList    = [];\r\n                                isvartoken  = token[varlist[aa][0] - 1];\r\n                                isvar       = (\r\n                                    isvartoken === "var" || isvartoken === "let" || isvartoken === "const"\r\n                                );\r\n                                for (cc = 0; cc < lastListLen; cc = cc + 1) {\r\n                                    longTest = joins(varlist[aa][cc], isvar);\r\n                                    if (longTest > longest) {\r\n                                        longest = longTest;\r\n                                    }\r\n                                    longList.push(longTest);\r\n                                }\r\n                                strspace = "";\r\n                                if (longest > options.insize) {\r\n                                    strlongest = longest - options.insize;\r\n                                } else if (longest < options.insize) {\r\n                                    strlongest = options.insize - longest;\r\n                                }\r\n                                if (token[varlist[aa][0] - 1] === "var" || token[varlist[aa][0] - 1] === "let" || token[varlist[aa][0] - 1] === "const") {\r\n                                    strlongest = strlongest - options.insize;\r\n                                } else if (token[varlist[aa][0] + 1] === "=") {\r\n                                    strlongest = strlongest + 1;\r\n                                }\r\n                                if (longest !== options.insize && strlongest > 0) {\r\n                                    do {\r\n                                        strspace   = strspace + " ";\r\n                                        strlongest = strlongest - 1;\r\n                                    } while (strlongest > -1);\r\n                                }\r\n                                for (cc = 0; cc < lastListLen; cc = cc + 1) {\r\n                                    tokenInList = token[varlist[aa][cc]];\r\n                                    if (longList[cc] < longest) {\r\n                                        do {\r\n                                            tokenInList  = tokenInList + " ";\r\n                                            longList[cc] = longList[cc] + 1;\r\n                                        } while (longList[cc] < longest);\r\n                                    }\r\n                                    token[varlist[aa][cc]] = tokenInList;\r\n                                    if (token[varlist[aa][cc] + 2] !== undefined && token[varlist[aa][cc] + 2].length === options.wrap + 2 && token[varlist[aa][cc] + 3] === "+" && token[varlist[aa][cc] + 4] !== undefined && options.styleguide !== "crockford" && options.styleguide !== "jslint" && (token[varlist[aa][cc] + 4].charAt(0) === "\\"" || token[varlist[aa][cc] + 4].charAt(0) === "\'")) {\r\n                                        if (longest <= options.insize) {\r\n                                            strspace = "";\r\n                                            dd       = 0;\r\n                                            do {\r\n                                                dd       = dd + 1;\r\n                                                strspace = strspace + " ";\r\n                                            } while (dd < longest + 1);\r\n                                            dd = varlist[aa][cc] + 4;\r\n                                            do {\r\n                                                token[dd]     = strspace + tab + tab + token[dd];\r\n                                                level[dd - 1] = level[dd - 1] - 1;\r\n                                                dd            = dd + 2;\r\n                                            } while (types[dd] === "literal" && types[dd - 1] !== "separator");\r\n                                        } else {\r\n                                            dd = varlist[aa][cc] + 4;\r\n                                            do {\r\n                                                token[dd]     = strspace + tab + tab + token[dd];\r\n                                                level[dd - 1] = 0;\r\n                                                dd            = dd + 2;\r\n                                            } while (types[dd] === "literal" && types[dd - 1] !== "separator");\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    };\r\n                if (options.jsscope !== "none") {\r\n                    result = (function jspretty__result_scope() {\r\n                        var a                  = 0,\r\n                            b                  = token.length,\r\n                            build              = [],\r\n                            linecount          = 2,\r\n                            last               = "",\r\n                            scope              = 1,\r\n                            buildlen           = 0,\r\n                            commentfix         = (function jspretty__result_scope_commentfix() {\r\n                                var aa = 1,\r\n                                    bb = 1;\r\n                                if (types[0] !== "comment" || (token[0].indexOf("//") === 0 && lines[0] > 0) || types[1] !== "comment") {\r\n                                    return 1;\r\n                                }\r\n                                do {\r\n                                    if (token[aa].indexOf("/*") === 0) {\r\n                                        bb = bb + 1;\r\n                                    }\r\n                                    aa = aa + 1;\r\n                                } while (types[aa] === "comment" && aa < b);\r\n                                return bb + 1;\r\n                            }()),\r\n                            folderItem         = [],\r\n                            comfold            = -1,\r\n                            //if current folding is for comment\r\n                            data               = [\r\n                                "<div class=\'beautify\' data-prettydiff-ignore=\'true\'><ol class=\'count\'>", "<li>", 1, "</li>"\r\n                            ],\r\n                            //applies folding to comments and functions\r\n                            //\r\n                            // Folder uses the i variable to determine how far back into the data array to\r\n                            // look.  i must be multiplied by 3 because each line number is three indexes in\r\n                            // the data array: <li>, line #, </li>.\r\n                            //\r\n                            //i is incremented for:\r\n                            // * block comments following one or more line  comments that follow one or more\r\n                            // block comments\r\n                            //* if last comment in a series is a block comment  and not the first token\r\n                            // * block comments with a new line that are either  the first token or not\r\n                            // followed by another block\r\n                            //* if a block comment is followed by another block  comment\r\n                            //\r\n                            //i is decremented for:\r\n                            //* line comment following a block comment\r\n                            //* block comment if "i" is greater than 1 and  inside a function fold\r\n                            // * if a line comment is not preceeded by another  comment and is followed by a\r\n                            // block comment\r\n                            //\r\n                            // If closing a fold and token is a comment and not token 0 then decrement by\r\n                            // commentfix.\r\n                            folder             = function jspretty__result_scope_folder() {\r\n                                var datalen = (data.length - (commentfix * 3) > 0)\r\n                                        ? data.length - (commentfix * 3)\r\n                                        : 1,\r\n                                    index   = a,\r\n                                    start   = data[datalen + 1] || 1,\r\n                                    assign  = true,\r\n                                    kk      = index;\r\n                                if (types[a] === "comment" && comfold === -1) {\r\n                                    comfold = a;\r\n                                } else if (types[a] !== "comment") {\r\n                                    index = meta[a];\r\n                                    do {\r\n                                        kk = kk - 1;\r\n                                    } while (token[kk] !== "function" && kk > -1);\r\n                                    kk = kk - 1;\r\n                                    if (token[kk] === "(" || token[kk] === "x(") {\r\n                                        do {\r\n                                            kk = kk - 1;\r\n                                        } while (kk > -1 && (token[kk] === "(" || token[kk] === "x("));\r\n                                    }\r\n                                    if (token[kk] === "=" || token[kk] === ":" || token[kk] === "," || token[kk + 1] === "(" || token[kk + 1] === "x(") {\r\n                                        assign = false;\r\n                                    }\r\n                                }\r\n                                if (types[a] === "comment" && lines[a] > 1) {\r\n                                    datalen = datalen - 3;\r\n                                    start   = start - 1;\r\n                                }\r\n                                data[datalen]     = "<li class=\'fold\' title=\'folds from line " + start + " to line " +\r\n                                        "xxx\'>";\r\n                                data[datalen + 1] = "- " + start;\r\n                                folderItem.push([datalen, index, assign]);\r\n                            },\r\n                            // determines where folding ends function assignments require one more line for\r\n                            // closing than everything else\r\n                            foldclose          = function jspretty__result_scope_foldclose() {\r\n                                var end  = (function jspretty__result_scope_foldclose_end() {\r\n                                        if (comfold > -1 || folderItem[folderItem.length - 1][2] === true) {\r\n                                            return linecount - commentfix - 1;\r\n                                        }\r\n                                        return linecount - commentfix;\r\n                                    }()),\r\n                                    semi = (/(>;<\\/em>)$/).test(token[a]),\r\n                                    gg   = 0,\r\n                                    lets = false;\r\n                                if (semi === true) {\r\n                                    end = end - 1;\r\n                                    for (gg = build.length - 1; gg > 0; gg = gg - 1) {\r\n                                        if (build[gg] === "let" || build[gg] === "const") {\r\n                                            lets = true;\r\n                                        }\r\n                                        if (build[gg].indexOf("><li") > 0) {\r\n                                            build[gg] = build[gg].replace(/class\\=\'l\\d+\'/, "class=\'l" + (\r\n                                                scope + 1\r\n                                            ) + "\'");\r\n                                            if (lets === true) {\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        if (build[gg].indexOf("<em class=\'l" + scope + "\'>" + tab) > -1) {\r\n                                            build[gg] = build[gg].replace(\r\n                                                "<em class=\'l" + scope + "\'>" + tab,\r\n                                                "<em class=\'l" + (\r\n                                                    scope + 1\r\n                                                ) + "\'>" + tab\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (a > 1 && token[a].indexOf("}</em>") === token[a].length - 6 && token[a - 1].indexOf("{</em>") === token[a - 1].length - 6) {\r\n                                    for (gg = data.length - 1; gg > 0; gg = gg - 1) {\r\n                                        if (typeof data[gg] === "string" && data[gg].charAt(0) === "-") {\r\n                                            data[gg - 1] = "<li>";\r\n                                            data[gg]     = Number(data[gg].substr(1));\r\n                                            folderItem.pop();\r\n                                            return;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (folderItem[folderItem.length - 1][1] === b - 1 && token[a].indexOf("<em ") === 0) {\r\n                                    end = end + 1;\r\n                                }\r\n                                data[folderItem[folderItem.length - 1][0]] = data[folderItem[folderItem.length - 1][0]].replace(\r\n                                    "xxx",\r\n                                    end\r\n                                );\r\n                                folderItem.pop();\r\n                            },\r\n                            // splits block comments, which are single tokens, into multiple lines of output\r\n                            blockline          = function jspretty__result_scope_blockline(x) {\r\n                                var commentLines = x.split(lf),\r\n                                    hh           = 0,\r\n                                    ii           = commentLines.length - 1;\r\n                                if (lines[a] > 0) {\r\n                                    data.push("<li>");\r\n                                    data.push(linecount);\r\n                                    data.push("</li>");\r\n                                    linecount = linecount + 1;\r\n                                }\r\n                                for (hh = 0; hh < ii; hh = hh + 1) {\r\n                                    data.push("<li>");\r\n                                    data.push(linecount);\r\n                                    data.push("</li>");\r\n                                    linecount        = linecount + 1;\r\n                                    commentLines[hh] = commentLines[hh] + "<em>&#xA;</em></li><li class=\'c0\'>";\r\n                                }\r\n                                return commentLines.join("");\r\n                            },\r\n                            //finds the variables if the jsscope option is true\r\n                            findvars           = function jspretty__result_scope_findvars(x) {\r\n                                var metax         = meta[x],\r\n                                    metameta      = meta[metax][0],\r\n                                    lettest       = false,\r\n                                    ee            = 0,\r\n                                    ff            = 0,\r\n                                    hh            = 0,\r\n                                    adjustment    = 1,\r\n                                    functionBlock = true,\r\n                                    varbuild      = [],\r\n                                    varbuildlen   = 0,\r\n                                    letcomma      = function jspretty__result_scope_findvars_letcomma() {\r\n                                        var aa = 0,\r\n                                            bb = 0;\r\n                                        for (aa = a; aa > -1; aa = aa - 1) {\r\n                                            if (types[aa] === "end") {\r\n                                                bb = bb - 1;\r\n                                            }\r\n                                            if (types[aa] === "start") {\r\n                                                bb = bb + 1;\r\n                                            }\r\n                                            if (bb > 0) {\r\n                                                return;\r\n                                            }\r\n                                            if (bb === 0) {\r\n                                                if (token[aa] === "var" || token[aa] === ";" || token[aa] === "x;") {\r\n                                                    return;\r\n                                                }\r\n                                                if (token[aa] === "let" || token[aa] === "const") {\r\n                                                    token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    };\r\n                                if (metameta === undefined) {\r\n                                    return;\r\n                                }\r\n                                lettest = meta[metax][1];\r\n                                hh      = metameta.length;\r\n                                if (types[a - 1] === "word" && token[a - 1] !== "function" && lettest === false) {\r\n                                    varbuild     = token[a - 1].split(" ");\r\n                                    token[a - 1] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\r\n                                    varbuildlen  = varbuild.length;\r\n                                    if (varbuildlen > 1) {\r\n                                        do {\r\n                                            token[ee]   = token[ee] + " ";\r\n                                            varbuildlen = varbuildlen - 1;\r\n                                        } while (varbuildlen > 1);\r\n                                    }\r\n                                }\r\n                                if (hh > 0) {\r\n                                    ee = metax - 1;\r\n                                    if (lettest === true) {\r\n                                        ee = ee - 1;\r\n                                    }\r\n                                    for (ee = ee; ee > a; ee = ee - 1) {\r\n                                        if (types[ee] === "word") {\r\n                                            varbuild = token[ee].split(" ");\r\n                                            for (ff = 0; ff < hh; ff = ff + 1) {\r\n                                                if (varbuild[0] === metameta[ff] && token[ee - 1] !== ".") {\r\n                                                    if (token[ee - 1] === "function" && token[ee + 1] === "(") {\r\n                                                        token[ee]   = "<em class=\'s" + (\r\n                                                            scope + 1\r\n                                                        ) + "\'>" + varbuild[0] + "</em>";\r\n                                                        varbuildlen = varbuild.length;\r\n                                                        if (varbuildlen > 1) {\r\n                                                            do {\r\n                                                                token[ee]   = token[ee] + " ";\r\n                                                                varbuildlen = varbuildlen - 1;\r\n                                                            } while (varbuildlen > 1);\r\n                                                        }\r\n                                                    } else if (token[ee - 1] === "case" || token[ee + 1] !== ":" || (token[ee + 1] === ":" && level[ee] > -20)) {\r\n                                                        if (lettest === true) {\r\n                                                            if (token[ee - 1] === "let" || token[ee - 1] === "const") {\r\n                                                                token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\r\n                                                            } else if (token[ee - 1] === ",") {\r\n                                                                letcomma();\r\n                                                            } else {\r\n                                                                token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\r\n                                                            }\r\n                                                        } else {\r\n                                                            token[ee] = "<em class=\'s" + scope + "\'>" + varbuild[0] + "</em>";\r\n                                                        }\r\n                                                        varbuildlen = varbuild.length;\r\n                                                        if (varbuildlen > 1) {\r\n                                                            do {\r\n                                                                token[ee]   = token[ee] + " ";\r\n                                                                varbuildlen = varbuildlen - 1;\r\n                                                            } while (varbuildlen > 1);\r\n                                                        }\r\n                                                    }\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        if (functionBlock === true) {\r\n                                            if (types[ee] === "end") {\r\n                                                adjustment = adjustment + 1;\r\n                                            } else if (types[ee] === "start") {\r\n                                                adjustment = adjustment - 1;\r\n                                            }\r\n                                            if (adjustment === 0 && token[ee] === "{") {\r\n                                                token[ee]     = "<em class=\'s" + scope + "\'>{</em>";\r\n                                                functionBlock = false;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    ee = a + 1;\r\n                                    if (lettest === true) {\r\n                                        ee = ee - 1;\r\n                                    }\r\n                                    for (ee = ee; ee < metax; ee = ee + 1) {\r\n                                        if (types[ee] === "end") {\r\n                                            adjustment = adjustment - 1;\r\n                                        } else if (types[ee] === "start") {\r\n                                            adjustment = adjustment + 1;\r\n                                        }\r\n                                        if (adjustment === 1 && token[ee] === "{") {\r\n                                            token[ee] = "<em class=\'s" + scope + "\'>{</em>";\r\n                                            return;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            },\r\n                            indent             = options.inlevel,\r\n                            //some prebuilt color coded tabs\r\n                            lscope             = [\r\n                                "<em class=\'l0\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\r\n                                        tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\r\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\r\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em><em class=\'l14\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\r\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em><em class=\'l14\'>" + tab + "</em><em" +\r\n                                        " class=\'l15\'>" + tab + "</em>",\r\n                                "<em class=\'l0\'>" + tab + "</em><em class=\'l1\'>" + tab +\r\n                                        "</em><em class=\'l2\'>" + tab + "</em><em class=\'l3\'>" + tab + "</em><em class=\'" +\r\n                                        "l4\'>" + tab + "</em><em class=\'l5\'>" + tab + "</em><em class=\'l6\'>" + tab + "<" +\r\n                                        "/em><em class=\'l7\'>" + tab + "</em><em class=\'l8\'>" + tab + "</em><em class=\'l" +\r\n                                        "9\'>" + tab + "</em><em class=\'l10\'>" + tab + "</em><em class=\'l11\'>" + tab + "</em><em class=\'l12\'>" +\r\n                                        tab + "</em><em class=\'l13\'>" + tab + "</em><em class=\'l14\'>" + tab + "</em><em" +\r\n                                        " class=\'l15\'>" + tab + "</em><em class=\'l16\'>" + tab + "</em>"\r\n                            ],\r\n                            //a function for calculating indentation after each new line\r\n                            nl                 = function jspretty__result_scope_nl(x, linetest) {\r\n                                var dd = 0;\r\n                                if (token[a] !== "x}" || (token[a] === "x}" && token[a + 1] !== "}")) {\r\n                                    data.push("<li>");\r\n                                    data.push(linecount);\r\n                                    data.push("</li>");\r\n                                    linecount = linecount + 1;\r\n                                    if (a < b - 1 && token[a + 1].indexOf("/*") === 0) {\r\n                                        build.push("<em>&#xA;</em></li><li class=\'c0\'>");\r\n                                    } else {\r\n                                        build.push("<em>&#xA;</em></li><li class=\'l" + scope + "\'>");\r\n                                        if (x > 0) {\r\n                                            dd = scope;\r\n                                            if (scope > 0) {\r\n                                                if (scope === x + 1 && x > 0 && linetest !== true) {\r\n                                                    dd = dd - 1;\r\n                                                }\r\n                                                build.push(lscope[dd - 1]);\r\n                                            }\r\n                                        } else if (linetest === true) {\r\n                                            build.push(lscope[0]);\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    if (x > 0) {\r\n                                        dd = scope;\r\n                                        if (scope > 0) {\r\n                                            if (scope === x + 1 && x > 0 && linetest !== true) {\r\n                                                dd = dd - 1;\r\n                                            }\r\n                                            build.push(lscope[dd - 1]);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                for (dd = dd; dd < x; dd = dd + 1) {\r\n                                    build.push(tab);\r\n                                }\r\n                            },\r\n                            rl                 = function jspretty__result_scope_rl(x) {\r\n                                var bb = token.length,\r\n                                    cc = 2,\r\n                                    dd = 0;\r\n                                for (dd = a + 2; dd < bb; dd = dd + 1) {\r\n                                    if (token[dd] === "x}") {\r\n                                        cc = cc + 1;\r\n                                    } else {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                nl(x - cc);\r\n                                a = a + 1;\r\n                            },\r\n                            markupBuild        = function jspretty__result_scope_markupBuild() {\r\n                                var mindent  = (function jspretty__result_scope_markupBuild_offset() {\r\n                                        var d = 0;\r\n                                        if (a === markupvar[0]) {\r\n                                            markupvar.splice(0, 1);\r\n                                            return 1;\r\n                                        }\r\n                                        if (token[d] === "return" || token[0] === "{") {\r\n                                            return 1;\r\n                                        }\r\n                                        if (level[a] < -9) {\r\n                                            return 0;\r\n                                        }\r\n                                        for (d = a - 1; d > -1; d = d - 1) {\r\n                                            if (token[d] !== "(" && token[d] !== "x(") {\r\n                                                if (token[d] === "=") {\r\n                                                    return 1;\r\n                                                }\r\n                                                return 0;\r\n                                            }\r\n                                        }\r\n                                        return 0;\r\n                                    }()),\r\n                                    markup   = (function jspretty__result_scope_markupBuild_varscope() {\r\n                                        var item    = "",\r\n                                            emscope = function jsscope__result_scope_markupBuild_varscope_emscope(x) {\r\n                                                return "<em class=\'s" + x\r\n                                                    .replace("[pdjsxem", "")\r\n                                                    .replace("]", "") + "\'>";\r\n                                            },\r\n                                            word    = "",\r\n                                            newword = "",\r\n                                            inca    = 0,\r\n                                            incb    = 0,\r\n                                            lena    = meta.length,\r\n                                            lenb    = 0,\r\n                                            vars    = [],\r\n                                            mode    = options.mode,\r\n                                            inle    = options.inlevel,\r\n                                            jsx     = options.jsx;\r\n                                        options.source  = token[a];\r\n                                        options.mode    = "beautify";\r\n                                        options.inlevel = mindent;\r\n                                        options.jsx     = true;\r\n                                        item            = extlib().replace(/return\\s+</g, "return <");\r\n                                        options.mode    = mode;\r\n                                        options.inlevel = inle;\r\n                                        options.jsx     = jsx;\r\n                                        if (item.indexOf("[pdjsxscope]") < 0) {\r\n                                            return item\r\n                                                .replace(/&/g, "&amp;")\r\n                                                .replace(/</g, "&lt;")\r\n                                                .replace(/>/g, "&gt;")\r\n                                                .split(lf);\r\n                                        }\r\n                                        do {\r\n                                            newword = "";\r\n                                            vars    = [];\r\n                                            word    = item.substring(\r\n                                                item.indexOf("[pdjsxscope]") + 12,\r\n                                                item.indexOf("[/pdjsxscope]")\r\n                                            );\r\n                                            for (inca = 0; inca < lena; inca = inca + 1) {\r\n                                                if (typeof meta[inca] === "number" && inca < a && a < meta[inca]) {\r\n                                                    vars.push(meta[inca]);\r\n                                                    lenb = meta[meta[inca]].length;\r\n                                                    for (incb = 0; incb < lenb; incb = incb + 1) {\r\n                                                        if (meta[meta[inca]][incb] === word) {\r\n                                                            newword = "[pdjsxem" + (\r\n                                                                vars.length + 1\r\n                                                            ) + "]" + word + "[/pdjsxem]";\r\n                                                        }\r\n                                                    }\r\n                                                    if (incb < lenb) {\r\n                                                        break;\r\n                                                    }\r\n                                                    vars.pop();\r\n                                                }\r\n                                            }\r\n                                            if (newword === "") {\r\n                                                lenb = globals.length;\r\n                                                for (incb = 0; incb < lenb; incb = incb + 1) {\r\n                                                    if (word === globals[incb]) {\r\n                                                        newword = "[pdjsxem0]" + word + "[/pdjsxem]";\r\n                                                    }\r\n                                                }\r\n                                                if (newword === "") {\r\n                                                    newword = word;\r\n                                                }\r\n                                            }\r\n                                            item = item.replace("[pdjsxscope]" + word + "[/pdjsxscope]", newword);\r\n                                        } while (item.indexOf("[pdjsxscope]") > -1);\r\n                                        return item\r\n                                            .replace(/&/g, "&amp;")\r\n                                            .replace(/</g, "&lt;")\r\n                                            .replace(/>/g, "&gt;")\r\n                                            .replace(/\\[pdjsxem\\d+\\]/g, emscope)\r\n                                            .replace(/\\[\\/pdjsxem\\]/g, "</em>")\r\n                                            .split(lf);\r\n                                    }()),\r\n                                    len      = 0,\r\n                                    c        = 0,\r\n                                    spaces   = 0,\r\n                                    synthtab = "\\\\" + tab.charAt(0),\r\n                                    tabreg   = {};\r\n                                len = tab.length;\r\n                                for (c = 1; c < len; c = c + 1) {\r\n                                    synthtab = synthtab + "\\\\" + tab.charAt(c);\r\n                                }\r\n                                tabreg  = new RegExp("^(" + synthtab + "+)");\r\n                                mindent = indent + 2;\r\n                                if (level[a] < -9) {\r\n                                    markup[0] = markup[0].replace(tabreg, "");\r\n                                    mindent   = mindent - 1;\r\n                                }\r\n                                len = markup.length;\r\n                                for (c = 0; c < len - 1; c = c + 1) {\r\n                                    if (markup[c].indexOf(tab) !== 0 && c > 0) {\r\n                                        spaces = markup[c - 1]\r\n                                            .split(tab)\r\n                                            .length - 1;\r\n                                        do {\r\n                                            spaces    = spaces - 1;\r\n                                            markup[c] = tab + markup[c];\r\n                                        } while (spaces > 0);\r\n                                    }\r\n                                    build.push(markup[c]);\r\n                                    nl(mindent - 1);\r\n                                }\r\n                                build.push(markup[markup.length - 1]);\r\n                            },\r\n                            multiline          = function jspretty__result_scope_multiline(x) {\r\n                                var temparray = x.split(lf),\r\n                                    c         = 0,\r\n                                    d         = temparray.length;\r\n                                build.push(temparray[0]);\r\n                                for (c = 1; c < d; c = c + 1) {\r\n                                    nl(indent);\r\n                                    build.push(temparray[c]);\r\n                                }\r\n                            },\r\n                            endcomma_multiline = function jspretty__result_scope_endcommaMultiline() {\r\n                                var c = a;\r\n                                if (types[c] === "comment" || types[c] === "comment-inline") {\r\n                                    do {\r\n                                        c = c - 1;\r\n                                    } while (c > 0 && (types[c] === "comment" || types[c] === "comment-inline"));\r\n                                }\r\n                                token[c] = token[c] + ",";\r\n                            };\r\n                        if (verticalop === true) {\r\n                            vertical();\r\n                        }\r\n                        if (types[a] === "comment" && token[a].indexOf("/*") === 0) {\r\n                            build.push("<ol class=\'data\'><li class=\'c0\'>");\r\n                        } else {\r\n                            build.push("<ol class=\'data\'><li>");\r\n                        }\r\n                        for (a = 0; a < indent; a = a + 1) {\r\n                            build.push(tab);\r\n                        }\r\n                        // its important to find the variables separately from building the output so\r\n                        // that recursive flows in the loop incrementation do not present simple\r\n                        // counting collisions as to what gets modified versus what gets included\r\n                        for (a = b - 1; a > -1; a = a - 1) {\r\n                            if (typeof meta[a] === "number") {\r\n                                scope = scope - 1;\r\n                                findvars(a);\r\n                            } else if (meta[a] !== undefined && typeof meta[a] !== "string" && typeof meta[a] !== "number" && a > 0 && token[a] !== "x;" && token[a] !== "x}" && token[a] !== "x{" && token[a] !== "x(" && token[a] !== "x)") {\r\n                                token[a] = "<em class=\'s" + scope + "\'>" + token[a] + "</em>";\r\n                                scope    = scope + 1;\r\n                                if (scope > 16) {\r\n                                    scope = 16;\r\n                                }\r\n                            }\r\n                        }\r\n                        (function jspretty__result_scope_globals() {\r\n                            var aa          = 0,\r\n                                bb          = token.length,\r\n                                globalLocal = globals,\r\n                                dd          = globalLocal.length,\r\n                                ee          = 0,\r\n                                word        = [],\r\n                                wordlen     = 0;\r\n                            for (aa = bb - 1; aa > 0; aa = aa - 1) {\r\n                                if (types[aa] === "word" && (token[aa + 1] !== ":" || (token[aa + 1] === ":" && level[aa + 1] === -20)) && token[aa].indexOf("<em ") < 0) {\r\n                                    word = token[aa].split(" ");\r\n                                    for (ee = dd - 1; ee > -1; ee = ee - 1) {\r\n                                        if (word[0] === globalLocal[ee] && token[aa - 1] !== ".") {\r\n                                            if (token[aa - 1] === "function" && depth[aa + 1] === "method") {\r\n                                                token[aa] = "<em class=\'s1\'>" + word[0] + "</em>";\r\n                                                wordlen   = word.length;\r\n                                                if (wordlen > 1) {\r\n                                                    do {\r\n                                                        token[aa] = token[aa] + " ";\r\n                                                        wordlen   = wordlen - 1;\r\n                                                    } while (wordlen > 1);\r\n                                                }\r\n                                            } else {\r\n                                                token[aa] = "<em class=\'s0\'>" + word[0] + "</em>";\r\n                                                wordlen   = word.length;\r\n                                                if (wordlen > 1) {\r\n                                                    do {\r\n                                                        token[aa] = token[aa] + " ";\r\n                                                        wordlen   = wordlen - 1;\r\n                                                    } while (wordlen > 1);\r\n                                                }\r\n                                            }\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }());\r\n                        scope = 0;\r\n                        // this loops combines the white space as determined from the algorithm with the\r\n                        // tokens to create the output\r\n                        for (a = 0; a < b; a = a + 1) {\r\n                            if (typeof meta[a] === "number") {\r\n                                folder();\r\n                            }\r\n                            if (comfold === -1 && types[a] === "comment" && ((token[a].indexOf("/*") === 0 && token[a].indexOf("\\n") > 0) || types[a + 1] === "comment" || lines[a] > 1)) {\r\n                                folder();\r\n                                comfold = a;\r\n                            }\r\n                            if (comfold > -1 && types[a] !== "comment") {\r\n                                foldclose();\r\n                                comfold = -1;\r\n                            }\r\n                            if (options.endcomma === "multiline" && (token[a + 1] === "]" || token[a + 1] === "}") && level[a] !== -20) {\r\n                                endcomma_multiline();\r\n                            }\r\n                            if (types[a] === "comment" && token[a].indexOf("/*") === 0) {\r\n                                build.push(blockline(token[a]));\r\n                            } else if (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x(" && token[a] !== "x)") {\r\n                                if (typeof meta[a] === "number") {\r\n                                    scope = scope + 1;\r\n                                    if (scope > 16) {\r\n                                        scope = 16;\r\n                                    }\r\n                                    build.push(token[a]);\r\n                                } else if (typeof meta[a] !== "string" && typeof meta[a] !== "number") {\r\n                                    build.push(token[a]);\r\n                                    scope    = scope - 1;\r\n                                    buildlen = build.length - 1;\r\n                                    do {\r\n                                        buildlen = buildlen - 1;\r\n                                    } while (buildlen > 0 && build[buildlen].indexOf("</li><li") < 0);\r\n                                    build[buildlen] = build[buildlen].replace(\r\n                                        /class\\=\'l\\d+\'/,\r\n                                        "class=\'l" + scope + "\'"\r\n                                    );\r\n                                } else if (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x(" && token[a] !== "x)") {\r\n                                    if (types[a] === "markup") {\r\n                                        if (level[a] > -9) {\r\n                                            if (types[a - 1] === "operator") {\r\n                                                nl(indent);\r\n                                            } else if (token[a - 1] !== "return") {\r\n                                                nl(indent + 1);\r\n                                            }\r\n                                        }\r\n                                        if (typeof global.prettydiff.markuppretty === "function") {\r\n                                            markupBuild();\r\n                                        } else {\r\n                                            build.push(token[a].replace(/\\r?\\n(\\s*)/g, " "));\r\n                                        }\r\n                                    } else if (types[a] === "comment") {\r\n                                        if (types[a - 1] !== "comment" && types[a - 1] !== "comment-inline") {\r\n                                            nl(indent);\r\n                                        }\r\n                                        if (a === 0) {\r\n                                            build[0] = "<ol class=\'data\'><li class=\'c0\'>";\r\n                                        } else {\r\n                                            buildlen = build.length - 1;\r\n                                            if (build[buildlen].indexOf("<li") < 0) {\r\n                                                do {\r\n                                                    build[buildlen] = build[buildlen]\r\n                                                        .replace(/<em\\u0020class\\=\'[a-z]\\d+\'>/g, "")\r\n                                                        .replace(/<\\/em>/g, "");\r\n                                                    buildlen        = buildlen - 1;\r\n                                                    if (buildlen > 0 && build[buildlen] === undefined) {\r\n                                                        buildlen = buildlen - 1;\r\n                                                    }\r\n                                                } while (\r\n                                                    buildlen > 0 && build[buildlen - 1] !== undefined && build[buildlen].indexOf("<li") < 0\r\n                                                );\r\n                                            }\r\n                                            if ((/^(<em>&#xA;<\\/em><\\/li><li\\u0020class=\'l\\d+\'>)$/).test(build[buildlen - 1]) === true) {\r\n                                                build[buildlen - 1] = build[buildlen - 1].replace(\r\n                                                    /class\\=\'l\\d+\'/,\r\n                                                    "class=\'c0\'"\r\n                                                );\r\n                                            }\r\n                                            build[buildlen] = build[buildlen].replace(/class\\=\'l\\d+\'/, "class=\'c0\'");\r\n                                        }\r\n                                        build.push(token[a]);\r\n                                    } else {\r\n                                        if (types[a] === "literal" && token[a].indexOf("\\n") > 0) {\r\n                                            multiline(token[a]);\r\n                                        } else {\r\n                                            build.push(token[a]);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            // this condition performs additional calculations for options.preserve.\r\n                            // options.preserve determines whether empty lines should be preserved from the\r\n                            // code input\r\n                            if (options.preserve > 0 && lines[a] > 0 && level[a] > -9 && token[a] !== "+") {\r\n                                //special treatment for math operators\r\n                                if (token[a] === "+" || token[a] === "-" || token[a] === "*" || token[a] === "/") {\r\n                                    //comments get special treatment\r\n                                    if (a < b - 1 && types[a + 1] !== "comment" && types[a + 1] !== "comment-inline") {\r\n                                        nl(level[a]);\r\n                                        build.push(tab);\r\n                                        level[a] = -20;\r\n                                    } else {\r\n                                        indent = level[a];\r\n                                        if (lines[a] > 1) {\r\n                                            do {\r\n                                                build.push(lf);\r\n                                                lines[a] = lines[a] - 1;\r\n                                            } while (lines[a] > 1);\r\n                                        }\r\n                                        nl(indent);\r\n                                        build.push(tab);\r\n                                        build.push(token[a + 1]);\r\n                                        nl(indent);\r\n                                        build.push(tab);\r\n                                        level[a + 1] = -20;\r\n                                        a            = a + 1;\r\n                                    }\r\n                                } else if (lines[a] > 1 && token[a].charAt(0) !== "=" && token[a].charAt(0) !== "!" && (types[a] !== "start" || (a < b - 1 && types[a + 1] !== "end"))) {\r\n                                    if ((token[a] !== "x}" || isNaN(level[a]) === true) && (a < b - 1 && (types[a + 1] === "comment" || types[a + 1] === "comment-inline" || (token[a] !== "." && types[a + 1] !== "separator")))) {\r\n                                        do {\r\n                                            nl(0, true);\r\n                                            lines[a] = lines[a] - 1;\r\n                                        } while (lines[a] > 1);\r\n                                        if (types[a] === "comment") {\r\n                                            build.push("<em>&#xA;</em></li><li class=\'c0\'>");\r\n                                        } else {\r\n                                            commentfix = commentfix + 1;\r\n                                            nl(level[a], true);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            if ((token[a] === ";" || token[a] === "x;") && token[a + 1] === "x}" && ((/<em\\u0020class=\'s\\d+\'>\\}<\\/em>/).test(token[a + 2]) === true || token[a + 2] === "x}")) {\r\n                                rl(indent);\r\n                            } else if (token[a] === "x{" && level[a] === -10 && level[a - 1] === -10) {\r\n                                build.push("");\r\n                            } else if (a < b - 1 && types[a + 1] === "comment" && options.comments === "noindent") {\r\n                                nl(options.inlevel);\r\n                            } else if (level[a] === -10 && token[a] !== "x}") {\r\n                                build.push(" ");\r\n                            } else if (token[a] !== "" && level[a] !== -20 && (token[a] !== "x}" || (token[a] === "x}" && (token[a - 1] === "x;" || token[a - 1] === ";") && types[a + 1] !== "word") || lines[a] > 1)) {\r\n                                indent = level[a];\r\n                                nl(indent);\r\n                            }\r\n                            if (folderItem.length > 0) {\r\n                                if (a === folderItem[folderItem.length - 1][1] && comfold === -1) {\r\n                                    foldclose();\r\n                                }\r\n                            }\r\n                        }\r\n                        for (a = build.length - 1; a > -1; a = a - 1) {\r\n                            if (build[a] === tab) {\r\n                                build.pop();\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        //this logic is necessary to some line counting corrections to the HTML output\r\n                        last = build[build.length - 1];\r\n                        if (last.indexOf("<li") > 0) {\r\n                            build[build.length - 1] = "<em>&#xA;</em></li>";\r\n                        } else if (last.indexOf("</li>") < 0) {\r\n                            build.push("<em>&#xA;</em></li>");\r\n                        }\r\n                        build.push("</ol></div>");\r\n                        last = build.join("");\r\n                        if (last.match(/<li/g) !== null) {\r\n                            scope = last\r\n                                .match(/<li/g)\r\n                                .length;\r\n                            if (linecount - 1 > scope) {\r\n                                linecount = linecount - 1;\r\n                                do {\r\n                                    data.pop();\r\n                                    data.pop();\r\n                                    data.pop();\r\n                                    linecount = linecount - 1;\r\n                                } while (linecount > scope);\r\n                            }\r\n                        }\r\n                        data.push("</ol>");\r\n                        if (options.jsscope === "html") {\r\n                            data.push(last);\r\n                            if (options.newline === true) {\r\n                                if (options.crlf === true) {\r\n                                    data.push("\\r\\n");\r\n                                } else {\r\n                                    data.push("\\n");\r\n                                }\r\n                            }\r\n                            return data.join("");\r\n                        }\r\n                        build = [\r\n                            "<p>Scope analysis does not provide support for undeclared variables.</p>",\r\n                            "<p><em>",\r\n                            scolon,\r\n                            "</em> instances of <strong>missing semicolons</strong> counted.</p>",\r\n                            "<p><em>",\r\n                            news,\r\n                            "</em> unnecessary instances of the keyword <strong>new</strong> counted.</p>",\r\n                            data.join(""),\r\n                            last\r\n                        ];\r\n                        if (options.newline === true) {\r\n                            if (options.crlf === true) {\r\n                                build.push("\\r\\n");\r\n                            } else {\r\n                                build.push("\\n");\r\n                            }\r\n                        }\r\n                        if (options.nodeasync === true) {\r\n                            return [build.join(""), globalerror];\r\n                        }\r\n                        return build.join("");\r\n                    }())\r\n                        .replace(/(\\s+)$/, "")\r\n                        .replace(options.functions.binaryCheck, "");\r\n                } else {\r\n                    result = (function jspretty__result_standard() {\r\n                        var a                  = 0,\r\n                            b                  = token.length,\r\n                            build              = [],\r\n                            indent             = options.inlevel,\r\n                            //a function for calculating indentation after each new line\r\n                            nl                 = function jspretty__result_standard_nl(x) {\r\n                                var dd = 0;\r\n                                build.push(lf);\r\n                                for (dd = 0; dd < x; dd = dd + 1) {\r\n                                    build.push(tab);\r\n                                }\r\n                            },\r\n                            rl                 = function jspretty__result_standard_rl(x) {\r\n                                var bb = token.length,\r\n                                    cc = 2,\r\n                                    dd = 0;\r\n                                for (dd = a + 2; dd < bb; dd = dd + 1) {\r\n                                    if (token[dd] === "x}") {\r\n                                        cc = cc + 1;\r\n                                    } else {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                nl(x - cc);\r\n                                a = a + 1;\r\n                            },\r\n                            markupwrapper      = function jspretty__result_standard_markupwrapper() {\r\n                                var inle = options.inlevel,\r\n                                    mode = options.mode,\r\n                                    jsx  = options.jsx,\r\n                                    nel  = options.newline;\r\n                                options.source  = token[a];\r\n                                options.jsx     = true;\r\n                                options.mode    = "beautify";\r\n                                options.newline = false;\r\n                                if (level[a] < -9 || depth[a] === "array" || token[begin[a]] === "(") {\r\n                                    options.inlevel = indent;\r\n                                } else {\r\n                                    options.inlevel = indent + 1;\r\n                                }\r\n                                build.push(extlib(options));\r\n                                options.jsx     = jsx;\r\n                                options.mode    = mode;\r\n                                options.inlevel = inle;\r\n                                options.newline = nel;\r\n                            },\r\n                            endcomma_multiline = function jspretty__result_standard_endcommaMultiline() {\r\n                                var c = a;\r\n                                if (types[c] === "comment" || types[c] === "comment-inline") {\r\n                                    do {\r\n                                        c = c - 1;\r\n                                    } while (c > 0 && (types[c] === "comment" || types[c] === "comment-inline"));\r\n                                }\r\n                                token[c] = token[c] + ",";\r\n                            };\r\n                        if (verticalop === true) {\r\n                            vertical();\r\n                        }\r\n                        for (a = 0; a < indent; a = a + 1) {\r\n                            build.push(tab);\r\n                        }\r\n                        // this loops combines the white space as determined from the algorithm with the\r\n                        // tokens to create the output\r\n                        for (a = 0; a < b; a = a + 1) {\r\n                            if (options.endcomma === "multiline" && (token[a + 1] === "]" || token[a + 1] === "}") && level[a] > -20) {\r\n                                endcomma_multiline();\r\n                            }\r\n                            if (types[a] === "comment" || (token[a] !== "x;" && token[a] !== "x{" && token[a] !== "x}" && token[a] !== "x(" && token[a] !== "x)")) {\r\n                                if (types[a] === "markup") {\r\n                                    if (level[a - 1] > -9 && token[a - 1] !== "return" && depth[a] !== "global" && depth[a] !== "array" && types[a] !== "markup") {\r\n                                        build.push(tab);\r\n                                    }\r\n                                    if (typeof global.prettydiff.markuppretty === "function") {\r\n                                        markupwrapper();\r\n                                    } else {\r\n                                        build.push(token[a].replace(/\\r?\\n(\\s*)/g, " "));\r\n                                    }\r\n                                } else {\r\n                                    build.push(token[a]);\r\n                                }\r\n                            }\r\n                            // this condition performs additional calculations if options.preserve === true.\r\n                            // options.preserve determines whether empty lines should be preserved from the\r\n                            // code input\r\n                            if (options.preserve > 0 && ((lines[a] > 0 && level[a] > -9 && token[a] !== "+" && options.qml === false) || (options.qml === true && lines[a] > 1))) {\r\n                                if (options.qml === true) {\r\n                                    do {\r\n                                        build.push(lf);\r\n                                        lines[a] = lines[a] - 1;\r\n                                    } while (lines[a] > 1);\r\n                                    //special treatment for math operators\r\n                                } else if (token[a] === "+" || token[a] === "-" || token[a] === "*" || token[a] === "/") {\r\n                                    //comments get special treatment\r\n                                    if (a < b - 1 && types[a + 1] !== "comment" && types[a + 1] !== "comment-inline") {\r\n                                        nl(level[a]);\r\n                                        build.push(tab);\r\n                                        level[a] = -20;\r\n                                    } else {\r\n                                        indent = level[a];\r\n                                        if (lines[a] > 1) {\r\n                                            do {\r\n                                                build.push(lf);\r\n                                                lines[a] = lines[a] - 1;\r\n                                            } while (lines[a] > 1);\r\n                                        }\r\n                                        nl(indent);\r\n                                        build.push(tab);\r\n                                        build.push(token[a + 1]);\r\n                                        nl(indent);\r\n                                        build.push(tab);\r\n                                        level[a + 1] = -20;\r\n                                        a            = a + 1;\r\n                                    }\r\n                                } else if (lines[a] > 1 && token[a].charAt(0) !== "=" && token[a].charAt(0) !== "!" && (types[a] !== "start" || (a < b - 1 && types[a + 1] !== "end"))) {\r\n                                    if (a < b - 1 && (types[a + 1] === "comment" || types[a + 1] === "comment-inline" || (token[a] !== "." && types[a + 1] !== "separator"))) {\r\n                                        if (token[a] !== "x}" || isNaN(level[a]) === true || level[a] === -20) {\r\n                                            do {\r\n                                                build.push(lf);\r\n                                                lines[a] = lines[a] - 1;\r\n                                            } while (lines[a] > 1);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            if ((token[a] === ";" || token[a] === "x;") && token[a + 1] === "x}" && (token[a + 2] === "}" || token[a + 2] === "x}")) {\r\n                                rl(indent);\r\n                            } else if (token[a] === "x{" && level[a] === -10 && level[a - 1] === -10) {\r\n                                build.push("");\r\n                                //adds a new line and no indentation\r\n                            } else if (a < b - 1 && types[a + 1] === "comment" && options.comments === "noindent") {\r\n                                nl(options.inlevel);\r\n                            } else if (level[a] === -10 && token[a] !== "x}") {\r\n                                build.push(" ");\r\n                                //adds a new line and indentation\r\n                            } else if (token[a] !== "" && level[a] !== -20 && (token[a] !== "x}" || (token[a] === "x}" && (token[a - 1] === "x;" || token[a - 1] === ";") && types[a + 1] !== "word") || lines[a] > 1)) {\r\n                                indent = level[a];\r\n                                nl(indent);\r\n                            }\r\n                        }\r\n                        for (a = build.length - 1; a > -1; a = a - 1) {\r\n                            if (build[a] === tab) {\r\n                                build.pop();\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (options.preserve > 0 && lines[lines.length - 1] > 0) {\r\n                            if (options.nodeasync === true) {\r\n                                return [\r\n                                    build\r\n                                        .join("")\r\n                                        .replace(/(\\s+)$/, lf),\r\n                                    globalerror\r\n                                ];\r\n                            }\r\n                            return build\r\n                                .join("")\r\n                                .replace(/(\\s+)$/, lf);\r\n                        }\r\n                        if (options.newline === true) {\r\n                            if (options.crlf === true) {\r\n                                build.push("\\r\\n");\r\n                            } else {\r\n                                build.push("\\n");\r\n                            }\r\n                        }\r\n                        if (options.nodeasync === true) {\r\n                            return [\r\n                                build\r\n                                    .join("")\r\n                                    .replace(/(\\s+)$/, ""),\r\n                                globalerror\r\n                            ];\r\n                        }\r\n                        return build\r\n                            .join("")\r\n                            .replace(/(\\s+)$/, "");\r\n                    }());\r\n                }\r\n            }());\r\n            //the analysis report is generated in this function\r\n            if (options.mode === "analysis") {\r\n                return (function jspretty__report() {\r\n                    var noOfLines = result\r\n                            .split(lf)\r\n                            .length,\r\n                        newlines  = stats.space.newline,\r\n                        percent   = 0,\r\n                        total     = {\r\n                            chars  : 0,\r\n                            comment: {\r\n                                chars: stats.commentBlock.chars + stats.commentLine.chars,\r\n                                token: stats.commentBlock.token + stats.commentLine.token\r\n                            },\r\n                            literal: {\r\n                                chars: stats.number.chars + stats.regex.chars + stats.string.chars,\r\n                                token: stats.number.token + stats.regex.token + stats.string.token\r\n                            },\r\n                            space  : stats.space.newline + stats.space.other + stats.space.space + stats.space.tab,\r\n                            syntax : {\r\n                                chars: 0,\r\n                                token: stats.string.quote + stats.comma + stats.semicolon + stats.container\r\n                            },\r\n                            token  : 0\r\n                        },\r\n                        output    = [],\r\n                        zero      = function jspretty__report_zero(x, y) {\r\n                            var ratio = 0;\r\n                            if (y === 0) {\r\n                                return "0.00%";\r\n                            }\r\n                            ratio = ((x / y) * 100);\r\n                            return ratio.toFixed(2) + "%";\r\n                        };\r\n                    total.syntax.chars = total.syntax.token + stats.operator.chars;\r\n                    total.syntax.token = total.syntax.token + stats.operator.token;\r\n                    total.token        = stats.server.token + stats.word.token + total.comment.token +\r\n                            total.literal.token + total.space + total.syntax.token;\r\n                    total.chars        = stats.server.chars + stats.word.chars + total.comment.chars +\r\n                            total.literal.chars + total.space + total.syntax.chars;\r\n                    if (newlines === 0) {\r\n                        newlines = 1;\r\n                    }\r\n                    output.push("<div class=\'report\'>");\r\n                    if (error.length > 0) {\r\n                        output.push("<p id=\'jserror\'><strong>Error: ");\r\n                        output.push(\r\n                            error[0].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(options.functions.binaryCheck, "")\r\n                        );\r\n                        output.push("</strong> <code><span>");\r\n                        error[1] = error[1]\r\n                            .replace(/&/g, "&amp;")\r\n                            .replace(/</g, "&lt;")\r\n                            .replace(/>/g, "&gt;")\r\n                            .replace(options.functions.binaryCheck, "")\r\n                            .replace(/^(\\s+)/, "");\r\n                        if (error.indexOf("\\n") > 0) {\r\n                            output.push(error[1].replace(lf, "</span>"));\r\n                        } else {\r\n                            output.push(error[1]);\r\n                            output.push("</span>");\r\n                        }\r\n                        output.push("</code></p>");\r\n                    }\r\n                    output.push("<p><em>");\r\n                    output.push(scolon);\r\n                    output.push("</em> instance");\r\n                    if (scolon !== 1) {\r\n                        output.push("s");\r\n                    }\r\n                    output.push(" of <strong>missing semicolons</strong> counted.</p>");\r\n                    output.push("<p><em>");\r\n                    output.push(news);\r\n                    output.push("</em> unnessary instance");\r\n                    if (news !== 1) {\r\n                        output.push("s");\r\n                    }\r\n                    output.push(" of the keyword <strong>new</strong> counted.</p>");\r\n                    output.push(\r\n                        "<table class=\'analysis\' summary=\'JavaScript character size comparison\'><captio" +\r\n                        "n>JavaScript data report</caption><thead><tr><th>Data Label</th><th>Input</th>" +\r\n                        "<th>Output</th><th>Literal Increase</th><th>Percentage Increase</th></tr>"\r\n                    );\r\n                    output.push("</thead><tbody><tr><th>Total Character Size</th><td>");\r\n                    output.push(originalSize);\r\n                    output.push("</td><td>");\r\n                    output.push(result.length);\r\n                    output.push("</td><td>");\r\n                    output.push(result.length - originalSize);\r\n                    output.push("</td><td>");\r\n                    percent = (((result.length - originalSize) / originalSize) * 100);\r\n                    output.push(percent.toFixed(2));\r\n                    output.push("%</td></tr><tr><th>Total Lines of Code</th><td>");\r\n                    output.push(newlines);\r\n                    output.push("</td><td>");\r\n                    output.push(noOfLines);\r\n                    output.push("</td><td>");\r\n                    output.push(noOfLines - newlines);\r\n                    output.push("</td><td>");\r\n                    percent = (((noOfLines - newlines) / newlines) * 100);\r\n                    output.push(percent.toFixed(2));\r\n                    output.push("%</td></tr></tbody></table>");\r\n                    output.push(\r\n                        "<table class=\'analysis\' summary=\'JavaScript component analysis\'><caption>JavaS" +\r\n                        "cript component analysis</caption><thead><tr><th>JavaScript Component</th><th>" +\r\n                        "Component Quantity</th><th>Percentage Quantity from Section</th>"\r\n                    );\r\n                    output.push(\r\n                        "<th>Percentage Qauntity from Total</th><th>Character Length</th><th>Percentage" +\r\n                        " Length from Section</th><th>Percentage Length from Total</th></tr></thead><tb" +\r\n                        "ody>"\r\n                    );\r\n                    output.push("<tr><th>Total Accounted</th><td>");\r\n                    output.push(total.token);\r\n                    output.push("</td><td>100.00%</td><td>100.00%</td><td>");\r\n                    output.push(total.chars);\r\n                    output.push(\r\n                        "</td><td>100.00%</td><td>100.00%</td></tr><tr><th colspan=\'7\'>Comments</th></t" +\r\n                        "r><tr><th>Block Comments</th><td>"\r\n                    );\r\n                    output.push(stats.commentBlock.token);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentBlock.token, total.comment.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentBlock.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.commentBlock.chars);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentBlock.chars, total.comment.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentBlock.chars, total.chars));\r\n                    output.push("</td></tr><tr><th>Inline Comments</th><td>");\r\n                    output.push(stats.commentLine.token);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentLine.token, total.comment.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentLine.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.commentLine.chars);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentLine.chars, total.comment.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.commentLine.chars, total.chars));\r\n                    output.push("</td></tr><tr><th>Comment Total</th><td>");\r\n                    output.push(total.comment.token);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.comment.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(total.comment.chars);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.comment.chars, total.chars));\r\n                    output.push(\r\n                        "</td></tr><tr><th colspan=\'7\'>Whitespace Outside of Strings and Comments</th><" +\r\n                        "/tr><tr><th>New Lines</th><td>"\r\n                    );\r\n                    output.push(stats.space.newline);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.newline, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.newline, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.space.newline);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.newline, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.newline, total.chars));\r\n                    output.push("</td></tr><tr><th>Spaces</th><td>");\r\n                    output.push(stats.space.space);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.space, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.space, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.space.space);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.space, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.space, total.chars));\r\n                    output.push("</td></tr><tr><th>Tabs</th><td>");\r\n                    output.push(stats.space.tab);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.tab, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.tab, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.space.tab);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.tab, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.tab, total.chars));\r\n                    output.push("</td></tr><tr><th>Other Whitespace</th><td>");\r\n                    output.push(stats.space.other);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.other, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.other, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.space.other);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.other, total.space));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.space.other, total.chars));\r\n                    output.push("</td></tr><tr><th>Total Whitespace</th><td>");\r\n                    output.push(total.space);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.space, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(total.space);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.space, total.chars));\r\n                    output.push(\r\n                        "</td></tr><tr><th colspan=\'7\'>Literals</th></tr><tr><th>Strings</th><td>"\r\n                    );\r\n                    output.push(stats.string.token);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.token, total.literal.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.string.chars);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.chars, total.literal.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.chars, total.chars));\r\n                    output.push("</td></tr><tr><th>Numbers</th><td>");\r\n                    output.push(stats.number.token);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.number.token, total.literal.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.number.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.number.chars);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.number.chars, total.literal.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.number.chars, total.chars));\r\n                    output.push("</td></tr><tr><th>Regular Expressions</th><td>");\r\n                    output.push(stats.regex.token);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.regex.token, total.literal.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.regex.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.regex.chars);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.regex.chars, total.literal.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.regex.chars, total.chars));\r\n                    output.push("</td></tr><tr><th>Total Literals</th><td>");\r\n                    output.push(total.literal.token);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.literal.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(total.literal.chars);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.literal.chars, total.chars));\r\n                    output.push(\r\n                        "</td></tr><tr><th colspan=\'7\'>Syntax Characters</th></tr><tr><th>Quote Charact" +\r\n                        "ers</th><td>"\r\n                    );\r\n                    output.push(stats.string.quote);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.quote, total.syntax.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.quote, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.string.quote);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.quote, total.syntax.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.string.quote, total.chars));\r\n                    output.push("</td></tr><tr><th>Commas</th><td>");\r\n                    output.push(stats.comma);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.comma, total.syntax.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.comma, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.comma);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.comma, total.syntax.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.comma, total.chars));\r\n                    output.push("</td></tr><tr><th>Containment Characters</th><td>");\r\n                    output.push(stats.container);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.container, total.syntax.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.container, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.container);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.container, total.syntax.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.container, total.chars));\r\n                    output.push("</td></tr><tr><th>Semicolons</th><td>");\r\n                    output.push(stats.semicolon);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.semicolon, total.syntax.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.semicolon, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.semicolon);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.semicolon, total.syntax.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.semicolon, total.chars));\r\n                    output.push("</td></tr><tr><th>Operators</th><td>");\r\n                    output.push(stats.operator.token);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.operator.token, total.syntax.token));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.operator.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.operator.chars);\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.operator.chars, total.syntax.chars));\r\n                    output.push("</td><td>");\r\n                    output.push(zero(stats.operator.chars, total.chars));\r\n                    output.push("</td></tr><tr><th>Total Syntax Characters</th><td>");\r\n                    output.push(total.syntax.token);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.syntax.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(total.syntax.chars);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(total.syntax.chars, total.chars));\r\n                    output.push("</td></tr>");\r\n                    output.push(\r\n                        "<tr><th colspan=\'7\'>Keywords and Variables</th></tr><tr><th>Words</th><td>"\r\n                    );\r\n                    output.push(stats.word.token);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(stats.word.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.word.chars);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(stats.word.chars, total.chars));\r\n                    output.push("</td></tr>");\r\n                    output.push(\r\n                        "<tr><th colspan=\'7\'>Server-side Tags</th></tr><tr><th>Server Tags</th><td>"\r\n                    );\r\n                    output.push(stats.server.token);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(stats.server.token, total.token));\r\n                    output.push("</td><td>");\r\n                    output.push(stats.server.chars);\r\n                    output.push("</td><td>100.00%</td><td>");\r\n                    output.push(zero(stats.server.chars, total.chars));\r\n                    output.push("</td></tr></tbody></table></div>");\r\n                    if (options.nodeasync === true) {\r\n                        return [output.join(""), globalerror];\r\n                    }\r\n                    return output.join("");\r\n                }());\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function jspretty_requirejs() {\r\n            return function jspretty_requirejs_wrapper(x) {\r\n                return jspretty(x);\r\n            };\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = jspretty;\r\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n            (function glib_jspretty() {\r\n                var localPath = (\r\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\r\n                )\r\n                    ? __dirname\r\n                    : ".";\r\n                if (global.prettydiff.markuppretty === undefined) {\r\n                    global.prettydiff.markuppretty = require(\r\n                        localPath + "/markuppretty.js"\r\n                    );\r\n                }\r\n            }());\r\n        }\r\n    } else {\r\n        global.prettydiff.jspretty = jspretty;\r\n    }\r\n}());\r\n'},function(n,e,r){"use strict";r(1)(r(46))},function(n,e){n.exports='/*prettydiff.com api.topcoms:true,api.insize:4,api.inchar:" ",api.vertical:true */\r\n/*jshint laxbreak: true*/\r\n/*global __dirname, ace, define, global, module, process, require*/\r\n/***********************************************************************\r\n markuppretty is written by Austin Cheney on 20 Jun 2015.\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n **********************************************************************/\r\n/* A simple parser for XML, HTML, and a variety of template schemes. It\r\n beautifies, minifies, and peforms a series of analysis*/\r\n(function markuppretty_init() {\r\n    "use strict";\r\n    var markuppretty = function markuppretty_(options) {\r\n        var safeSort    = global.prettydiff.safeSort,\r\n            output      = "",\r\n            stats       = {\r\n                cdata      : [\r\n                    0, 0\r\n                ],\r\n                comment    : [\r\n                    0, 0\r\n                ],\r\n                conditional: [\r\n                    0, 0\r\n                ],\r\n                content    : [\r\n                    0, 0\r\n                ],\r\n                end        : [\r\n                    0, 0\r\n                ],\r\n                ignore     : [\r\n                    0, 0\r\n                ],\r\n                script     : [\r\n                    0, 0\r\n                ],\r\n                sgml       : [\r\n                    0, 0\r\n                ],\r\n                singleton  : [\r\n                    0, 0\r\n                ],\r\n                space      : 0,\r\n                start      : [\r\n                    0, 0\r\n                ],\r\n                style      : [\r\n                    0, 0\r\n                ],\r\n                template   : [\r\n                    0, 0\r\n                ],\r\n                text       : [\r\n                    0, 0\r\n                ],\r\n                xml        : [0, 0]\r\n            },\r\n\r\n            //parallel arrays\r\n            // * attrs is a list of arrays, each of which contains (if any) parsed\r\n            // attributes\r\n            // * begin stores the index of the current token\'s parent element\r\n            // * daddy stores the tag name of the parent element\r\n            // * jscom stores true/false if the current token is a JS comment from JSX\r\n            // format\r\n            // * level describes the indentation of a given token level is only used in\r\n            // beautify and diff modes\r\n            // * linen stores the input line number on which the token occurs\r\n            // * lines describes the preceeding space using: 2, 1, or 0 lines is populated\r\n            // in markuppretty__tokenize_spacer\r\n            // * presv whether a given token should be preserved as provided\r\n            // * token stores parsed tokens\r\n            // * types segments tokens into named groups\r\n            // * value attribute value if current type is attribute and\r\n            // options.attributetoken is true\r\n            attrs       = [],\r\n            jscom       = [],\r\n            level       = [],\r\n            linen       = [],\r\n            lines       = [],\r\n            token       = [],\r\n            types       = [],\r\n            presv       = [],\r\n            daddy       = [],\r\n            begin       = [],\r\n            value       = [],\r\n            reqs        = [],\r\n            ids         = [],\r\n            parseError  = [],\r\n            parent      = [\r\n                ["none", -1]\r\n            ],\r\n            line        = 1,\r\n            wrap        = options.wrap,\r\n            objsortop   = false,\r\n            globalerror = "",\r\n            lf          = (options.crlf === true || options.crlf === "true")\r\n                ? "\\r\\n"\r\n                : "\\n",\r\n            sourceSize  = options.source.length,\r\n            extlib      = function markuppretty__extlib(type) {\r\n                var result = "",\r\n                    newline = options.newline;\r\n                if (type === "script" && typeof global.prettydiff.jspretty !== "function") {\r\n                    return options.source;\r\n                }\r\n                if (type === "style" && typeof global.prettydiff.csspretty !== "function") {\r\n                    return options.source;\r\n                }\r\n                options.newline = false;\r\n                result = (type === "script")\r\n                    ? global\r\n                        .prettydiff\r\n                        .jspretty(options)\r\n                    : global\r\n                        .prettydiff\r\n                        .csspretty(options);\r\n                options.newline = newline;\r\n                if (options.nodeasync === true) {\r\n                    if (globalerror === "") {\r\n                        globalerror = result[1];\r\n                    }\r\n                    if (options.mode === "parse") {\r\n                        if (options.parseFormat === "htmltable") {\r\n                            if (type === "script") {\r\n                                return result[0]\r\n                                    .data\r\n                                    .replace(\r\n                                        "<thead>",\r\n                                        "<thead><tr><th colspan=\\"6\\" class=\\"nested\\">JavaScript tokens</th></tr>"\r\n                                    );\r\n                            }\r\n                            return result[0]\r\n                                .data\r\n                                .replace(\r\n                                    "<thead>",\r\n                                    "<thead><tr><th colspan=\\"4\\" class=\\"nested\\">CSS tokens</th></tr>"\r\n                                );\r\n                        }\r\n                        return result[0].data;\r\n                    }\r\n                    return result[0];\r\n                }\r\n                if (options.mode === "parse") {\r\n                    if (options.parseFormat === "htmltable") {\r\n                        if (type === "script") {\r\n                            return result\r\n                                .data\r\n                                .replace(\r\n                                    "<thead>",\r\n                                    "<thead><tr><th colspan=\\"6\\" class=\\"nested\\">JavaScript tokens</th></tr>"\r\n                                );\r\n                        }\r\n                        return result\r\n                            .data\r\n                            .replace(\r\n                                "<thead>",\r\n                                "<thead><tr><th colspan=\\"4\\" class=\\"nested\\">CSS tokens</th></tr>"\r\n                            );\r\n                    }\r\n                    return result.data;\r\n                }\r\n                return result;\r\n            },\r\n            //What is the lowercase tag name of the provided token?\r\n            tagName     = function markuppretty__tagName(el) {\r\n                var space = el\r\n                        .replace(/^(\\{((%-?)|\\{-?)\\s*)/, "%")\r\n                        .replace(/\\s+/, " ")\r\n                        .indexOf(" "),\r\n                    name  = (space < 0)\r\n                        ? el\r\n                            .replace(/^(\\{((%-?)|\\{-?)\\s*)/, " ")\r\n                            .slice(1, el.length - 1)\r\n                            .toLowerCase()\r\n                        : el\r\n                            .replace(/^(\\{((%-?)|\\{-?)\\s*)/, " ")\r\n                            .slice(1, space)\r\n                            .toLowerCase();\r\n                name = name.replace(/(\\}\\})$/, "");\r\n                if (name.indexOf("(") > 0) {\r\n                    name = name.slice(0, name.indexOf("("));\r\n                }\r\n                return name;\r\n            };\r\n\r\n        (function markuppretty__options() {\r\n            objsortop      = (\r\n                options.objsort === true || options.objsort === "true" || options.objsort === "all" || options.objsort === "markup"\r\n            );\r\n            options.source = (\r\n                typeof options.source === "string" && options.source.length > 0\r\n            )\r\n                ? options\r\n                    .source\r\n                    .replace(/\\r\\n?/g, "\\n")\r\n                : "Error: no source code supplied to markuppretty!";\r\n            if (options.mode === "analysis") {\r\n                options.accessibility = true;\r\n            }\r\n        }());\r\n        //type definitions:\r\n        // * start      end     type\r\n        // * <![CDATA[   ]]>    cdata\r\n        // * \x3c!--       --\x3e     comment\r\n        // * <#--       --\x3e     comment\r\n        // * <%--       --%>    comment\r\n        // * {!         !}      comment\r\n        // * \x3c!--[if    --\x3e     conditional\r\n        // * text       text    content\r\n        // * </         >       end\r\n        // * <pre       </pre>  ignore (html only)\r\n        // * text       text    script\r\n        // * <!         >       sgml\r\n        // * <          />      singleton\r\n        // * <          >       start\r\n        // * text       text    style\r\n        // * \x3c!--#      --\x3e     template\r\n        // * <%         %>      template\r\n        // * {{{        }}}     template\r\n        // * {{         }}      template\r\n        // * {%         %}      template\r\n        // * [%         %]      template\r\n        // * {@         @}      template\r\n        // * {#         #}      template\r\n        // * {#         /}      template\r\n        // * {?         /}      template\r\n        // * {^         /}      template\r\n        // * {@         /}      template\r\n        // * {<         /}      template\r\n        // * {+         /}      template\r\n        // * {~         }       template\r\n        // * <?         ?>      template\r\n        // * {:else}            template_else\r\n        // * <#else     >       template_else\r\n        // * {@}else{@}         template_else\r\n        // * <%}else{%>         template_else\r\n        // * {{         }}      template_end\r\n        // * <%\\s*}     %>      template_end\r\n        // * [%\\s*}     %]      template_end\r\n        // * {@\\s*}     @}      template_end\r\n        // * {          }       template_end\r\n        // * {{#        }}      template_start\r\n        // * <%         {\\s*%>  template_start\r\n        // * [%         {\\s*%]  template_start\r\n        // * {@         {\\s*@}  template_start\r\n        // * {#         }       template_start\r\n        // * {?         }       template_start\r\n        // * {^         }       template_start\r\n        // * {@         }       template_start\r\n        // * {<         }       template_start\r\n        // * {+         }       template_start\r\n        // * <?xml      ?>      xml\r\n        if (options.mode !== "diff") {\r\n            options.content = false;\r\n        }\r\n        if (options.jsx === true) {\r\n            options.dustjs = false;\r\n        }\r\n        (function markuppretty__tokenize() {\r\n            var a             = 0,\r\n                b             = options\r\n                    .source\r\n                    .split(""),\r\n                c             = b.length,\r\n                minspace      = "",\r\n                space         = "",\r\n                list          = 0,\r\n                litag         = 0,\r\n                linepreserve  = 0,\r\n                cftransaction = false,\r\n                sgmlflag      = 0,\r\n                ext           = false,\r\n                //cftags is a list of supported coldfusion tags\r\n                //* required - means must have a separate matching end tag\r\n                // * optional - means the tag could have a separate end tag, but is probably a\r\n                // singleton\r\n                //* prohibited - means there is not corresponding end tag\r\n                cftags        = {\r\n                    cfabort               : "prohibited",\r\n                    cfajaximport          : "optional",\r\n                    cfajaxproxy           : "optional",\r\n                    cfapplet              : "prohibited",\r\n                    cfapplication         : "prohibited",\r\n                    cfargument            : "prohibited",\r\n                    cfassociate           : "prohibited",\r\n                    cfauthenticate        : "prohibited",\r\n                    cfbreak               : "prohibited",\r\n                    cfcache               : "optional",\r\n                    cfcalendar            : "optional",\r\n                    cfcase                : "required",\r\n                    cfcatch               : "required",\r\n                    cfchart               : "optional",\r\n                    cfchartdata           : "prohibited",\r\n                    cfchartseries         : "optional",\r\n                    cfclient              : "required",\r\n                    cfclientsettings      : "optional",\r\n                    cfcol                 : "prohibited",\r\n                    cfcollection          : "prohibited",\r\n                    cfcomponent           : "required",\r\n                    cfcontent             : "optional",\r\n                    cfcontinue            : "prohibited",\r\n                    cfcookie              : "prohibited",\r\n                    cfdbinfo              : "prohibited",\r\n                    cfdefaultcase         : "required",\r\n                    cfdirectory           : "prohibited",\r\n                    cfdiv                 : "optional",\r\n                    cfdocument            : "optional",\r\n                    cfdocumentitem        : "optional",\r\n                    cfdocumentsection     : "optional",\r\n                    cfdump                : "optional",\r\n                    cfelse                : "prohibited",\r\n                    cfelseif              : "prohibited",\r\n                    cferror               : "prohibited",\r\n                    cfexchangecalendar    : "optional",\r\n                    cfexchangeconnection  : "optional",\r\n                    cfexchangecontact     : "optional",\r\n                    cfexchangeconversation: "optional",\r\n                    cfexchangefilter      : "optional",\r\n                    cfexchangefolder      : "optional",\r\n                    cfexchangemail        : "optional",\r\n                    cfexchangetask        : "optional",\r\n                    cfexecute             : "required",\r\n                    cfexit                : "prohibited",\r\n                    cffeed                : "prohibited",\r\n                    cffile                : "optional",\r\n                    cffileupload          : "optional",\r\n                    cffinally             : "required",\r\n                    cfflush               : "prohibited",\r\n                    cfform                : "required",\r\n                    cfformgroup           : "required",\r\n                    cfformitem            : "optional",\r\n                    cfforward             : "prohibited",\r\n                    cfftp                 : "prohibited",\r\n                    cffunction            : "required",\r\n                    cfgraph               : "required",\r\n                    cfgraphdata           : "prohibited",\r\n                    cfgrid                : "required",\r\n                    cfgridcolumn          : "optional",\r\n                    cfgridrow             : "optional",\r\n                    cfgridupdate          : "optional",\r\n                    cfheader              : "prohibited",\r\n                    cfhtmlbody            : "optional",\r\n                    cfhtmlhead            : "optional",\r\n                    cfhtmltopdf           : "optional",\r\n                    cfhtmltopdfitem       : "optional",\r\n                    cfhttp                : "optional",\r\n                    cfhttpparam           : "prohibited",\r\n                    cfif                  : "required",\r\n                    cfimage               : "prohibited",\r\n                    cfimap                : "prohibited",\r\n                    cfimapfilter          : "optional",\r\n                    cfimport              : "prohibited",\r\n                    cfinclude             : "prohibited",\r\n                    cfindex               : "prohibited",\r\n                    cfinput               : "prohibited",\r\n                    cfinsert              : "prohibited",\r\n                    cfinterface           : "required",\r\n                    cfinvoke              : "optional",\r\n                    cfinvokeargument      : "prohibited",\r\n                    cflayout              : "optional",\r\n                    cflayoutarea          : "optional",\r\n                    cfldap                : "prohibited",\r\n                    cflocation            : "prohibited",\r\n                    cflock                : "required",\r\n                    cflog                 : "prohibited",\r\n                    cflogic               : "required",\r\n                    cfloginuser           : "prohibited",\r\n                    cflogout              : "prohibited",\r\n                    cfloop                : "required",\r\n                    cfmail                : "required",\r\n                    cfmailparam           : "prohibited",\r\n                    cfmailpart            : "required",\r\n                    cfmap                 : "optional",\r\n                    cfmapitem             : "optional",\r\n                    cfmediaplayer         : "optional",\r\n                    cfmenu                : "required",\r\n                    cfmenuitem            : "optional",\r\n                    cfmessagebox          : "optional",\r\n                    cfmodule              : "optional",\r\n                    cfNTauthenticate      : "optional",\r\n                    cfoauth               : "optional",\r\n                    cfobject              : "prohibited",\r\n                    cfobjectcache         : "prohibited",\r\n                    cfoutput              : "required",\r\n                    cfpageencoding        : "optional",\r\n                    cfparam               : "prohibited",\r\n                    cfpdf                 : "optional",\r\n                    cfpdfform             : "optional",\r\n                    cfpdfformparam        : "optional",\r\n                    cfpdfparam            : "prohibited",\r\n                    cfpdfsubform          : "required",\r\n                    cfpod                 : "optional",\r\n                    cfpop                 : "prohibited",\r\n                    cfpresentation        : "required",\r\n                    cfpresentationslide   : "optional",\r\n                    cfpresenter           : "optional",\r\n                    cfprint               : "optional",\r\n                    cfprocessingdirective : "optional",\r\n                    cfprocparam           : "prohibited",\r\n                    cfprocresult          : "prohibited",\r\n                    cfprogressbar         : "optional",\r\n                    cfproperty            : "prohibited",\r\n                    cfquery               : "required",\r\n                    cfqueryparam          : "prohibited",\r\n                    cfregistry            : "prohibited",\r\n                    cfreport              : "optional",\r\n                    cfreportparam         : "optional",\r\n                    cfrethrow             : "prohibited",\r\n                    cfretry               : "prohibited",\r\n                    cfreturn              : "prohibited",\r\n                    cfsavecontent         : "required",\r\n                    cfschedule            : "prohibited",\r\n                    cfscript              : "required",\r\n                    cfsearch              : "prohibited",\r\n                    cfselect              : "required",\r\n                    cfservlet             : "prohibited",\r\n                    cfservletparam        : "prohibited",\r\n                    cfset                 : "prohibited",\r\n                    cfsetting             : "optional",\r\n                    cfsharepoint          : "optional",\r\n                    cfsilent              : "required",\r\n                    cfsleep               : "prohibited",\r\n                    cfslider              : "prohibited",\r\n                    cfspreadsheet         : "optional",\r\n                    cfsprydataset         : "optional",\r\n                    cfstatic              : "required",\r\n                    cfstopwatch           : "required",\r\n                    cfstoredproc          : "optional",\r\n                    cfswitch              : "required",\r\n                    cftable               : "required",\r\n                    cftextarea            : "optional",\r\n                    cfthread              : "optional",\r\n                    cfthrow               : "prohibited",\r\n                    cftimer               : "required",\r\n                    cftooltip             : "required",\r\n                    cftrace               : "optional",\r\n                    cftransaction         : "required",\r\n                    cftree                : "required",\r\n                    cftreeitem            : "optional",\r\n                    cftry                 : "required",\r\n                    cfupdate              : "prohibited",\r\n                    cfvideo               : "prohibited",\r\n                    cfvideoplayer         : "optional",\r\n                    cfwddx                : "prohibited",\r\n                    cfwebsocket           : "optional",\r\n                    cfwhile               : "required",\r\n                    cfwindow              : "optional",\r\n                    cfx_                  : "prohibited",\r\n                    cfxml                 : "required",\r\n                    cfzip                 : "optional",\r\n                    cfzipparam            : "prohibited"\r\n                },\r\n                // determine if spaces between nodes are absent, multiline, or merely there 2 -\r\n                // multiline 1 - space present 0 - no space present\r\n                spacer        = function markuppretty__tokenize_spacer() {\r\n                    var linea = 0;\r\n                    if (space.length > 0) {\r\n                        stats.space = stats.space + space.length;\r\n                        linea       = space\r\n                            .split("\\n")\r\n                            .length - 1;\r\n                        if (options.preserve > 0 && linea > 1) {\r\n                            if (linea > options.preserve + 1) {\r\n                                lines.push(options.preserve + 1);\r\n                            } else {\r\n                                lines.push(linea);\r\n                            }\r\n                        } else {\r\n                            lines.push(1);\r\n                        }\r\n                    } else {\r\n                        lines.push(0);\r\n                    }\r\n                    minspace = space;\r\n                    space    = "";\r\n                },\r\n                //parses tags, attributes, and template elements\r\n                tag           = function markuppretty__tokenize_tag(end) {\r\n                    var lexer     = [],\r\n                        bcount    = 0,\r\n                        e         = 0,\r\n                        f         = 0,\r\n                        igcount   = 0,\r\n                        jsxcount  = 0,\r\n                        braccount = 0,\r\n                        parncount = 0,\r\n                        quote     = "",\r\n                        element   = "",\r\n                        lastchar  = "",\r\n                        jsxquote  = "",\r\n                        tname     = "",\r\n                        comment   = false,\r\n                        cheat     = false,\r\n                        endtag    = false,\r\n                        nopush    = false,\r\n                        nosort    = false,\r\n                        simple    = false,\r\n                        preserve  = false,\r\n                        stest     = false,\r\n                        liend     = false,\r\n                        ignoreme  = false,\r\n                        quotetest = false,\r\n                        parseFail = false,\r\n                        singleton = false,\r\n                        earlyexit = false,\r\n                        attribute = [],\r\n                        attstore  = [],\r\n                        presend   = {\r\n                            cfquery: true\r\n                        },\r\n                        arname    = function markuppretty__tokenize_tag_name(x) {\r\n                            var eq = x.indexOf("=");\r\n                            if (eq > 0 && ((eq < x.indexOf("\\"") && x.indexOf("\\"") > 0) || (eq < x.indexOf("\'") && x.indexOf("\'") > 0))) {\r\n                                return x.slice(0, eq);\r\n                            }\r\n                            return x;\r\n                        },\r\n                        slashy    = function markuppretty__tokenize_tag_slashy() {\r\n                            var x = a;\r\n                            do {\r\n                                x = x - 1;\r\n                            } while (b[x] === "\\\\");\r\n                            x = a - x;\r\n                            if (x % 2 === 1) {\r\n                                return false;\r\n                            }\r\n                            return true;\r\n                        },\r\n                        attrpush  = function markuppretty__tokenize_tag_attrpush(quotes) {\r\n                            var atty = "",\r\n                                name = "",\r\n                                aa   = 0,\r\n                                bb   = 0;\r\n                            if (quotes === true) {\r\n                                if (quote === "\\"" && options.quoteConvert === "single") {\r\n                                    atty = attribute\r\n                                        .slice(0, attribute.length - 1)\r\n                                        .join("")\r\n                                        .replace(/\'/g, "\\"")\r\n                                        .replace(/"/, "\'") + "\'";\r\n                                } else if (quote === "\'" && options.quoteConvert === "double") {\r\n                                    atty = attribute\r\n                                        .slice(0, attribute.length - 1)\r\n                                        .join("")\r\n                                        .replace(/"/g, "\'")\r\n                                        .replace(/\'/, "\\"") + "\\"";\r\n                                } else {\r\n                                    atty = attribute.join("");\r\n                                }\r\n                                name = arname(atty);\r\n                                if (name === "data-prettydiff-ignore") {\r\n                                    ignoreme = true;\r\n                                } else if (name === "id") {\r\n                                    ids.push(atty.slice(name.length + 2, atty.length - 1));\r\n                                } else if (name === "schemaLocation") {\r\n                                    reqs.push(atty.slice(name.length + 2, atty.length - 1));\r\n                                }\r\n                                quote = "";\r\n                            } else {\r\n                                atty = attribute\r\n                                    .join("")\r\n                                    .replace(/\\s+/g, " ");\r\n                                name = arname(atty);\r\n                                if (name === "data-prettydiff-ignore") {\r\n                                    ignoreme = true;\r\n                                } else if (name === "id") {\r\n                                    ids.push(element.slice(name.length + 1, atty.length));\r\n                                }\r\n                                if (options.jsx === true && attribute[0] === "{" && attribute[attribute.length - 1] === "}") {\r\n                                    jsxcount = 0;\r\n                                }\r\n                            }\r\n                            if (atty.slice(0, 3) === "<%=" || atty.slice(0, 2) === "{%") {\r\n                                nosort = true;\r\n                            }\r\n                            atty      = atty\r\n                                .replace(/^\\u0020/, "")\r\n                                .replace(/\\u0020$/, "");\r\n                            attribute = atty\r\n                                .replace(/\\r\\n/g, "\\n")\r\n                                .split("\\n");\r\n                            bb        = attribute.length;\r\n                            for (aa = 0; aa < bb; aa = aa + 1) {\r\n                                attribute[aa] = attribute[aa].replace(/(\\s+)$/, "");\r\n                            }\r\n                            atty = attribute.join(lf);\r\n                            if (atty === "=") {\r\n                                attstore[attstore.length - 1] = attstore[attstore.length - 1] + "=";\r\n                            } else if (atty.charAt(0) === "=" && attstore.length > 0 && attstore[attstore.length - 1].indexOf("=") < 0) {\r\n                                //if an attribute starts with a `=` then adjoin it to the last attribute\r\n                                attstore[attstore.length - 1] = attstore[attstore.length - 1] + atty;\r\n                            } else if (atty.charAt(0) !== "=" && attstore.length > 0 && attstore[attstore.length - 1].indexOf("=") === attstore[attstore.length - 1].length - 1) {\r\n                                // if an attribute follows an attribute ending with `=` then adjoin it to the\r\n                                // last attribute\r\n                                attstore[attstore.length - 1] = attstore[attstore.length - 1] + atty;\r\n                            } else if (atty !== "" && atty !== " ") {\r\n                                attstore.push(atty);\r\n                            }\r\n                            attribute = [];\r\n                        };\r\n                    spacer();\r\n                    jscom.push(false);\r\n                    linen.push(line);\r\n                    value.push("");\r\n                    ext = false;\r\n                    // this complex series of conditions determines an elements delimiters look to\r\n                    // the types being pushed to quickly reason about the logic no type is pushed\r\n                    // for start tags or singleton tags just yet some types set the `preserve` flag,\r\n                    // which means to preserve internal white space The `nopush` flag is set when\r\n                    // parsed tags are to be ignored and forgotten\r\n                    (function markuppretty__tokenize_types() {\r\n                        if (end === "]>") {\r\n                            end      = ">";\r\n                            sgmlflag = sgmlflag - 1;\r\n                            types.push("template_end");\r\n                        } else if (end === "---") {\r\n                            preserve = true;\r\n                            types.push("comment");\r\n                        } else if (b[a] === "<") {\r\n                            if (b[a + 1] === "/") {\r\n                                if (b[a + 2] === "#") {\r\n                                    types.push("template_end");\r\n                                } else {\r\n                                    types.push("end");\r\n                                }\r\n                                end = ">";\r\n                            } else if (b[a + 1] === "!") {\r\n                                if (b[a + 2] === "-" && b[a + 3] === "-") {\r\n                                    if (b[a + 4] === "#") {\r\n                                        end = "--\x3e";\r\n                                        types.push("template");\r\n                                    } else if (b[a + 4] === "[" && b[a + 5] === "i" && b[a + 6] === "f" && options.conditional === true) {\r\n                                        end = "--\x3e";\r\n                                        types.push("conditional");\r\n                                    } else if (b[a + 4] === "-" && (/<cf[a-z]/i).test(options.source) === true) {\r\n                                        preserve = true;\r\n                                        comment  = true;\r\n                                        end      = "---\x3e";\r\n                                        types.push("comment");\r\n                                    } else {\r\n                                        end = "--\x3e";\r\n                                        if (options.mode === "minify" || options.comments === "nocomment") {\r\n                                            nopush  = true;\r\n                                            comment = true;\r\n                                        } else {\r\n                                            if (options.preserveComment === true) {\r\n                                                preserve = true;\r\n                                            }\r\n                                            comment  = true;\r\n                                            if (options.commline === true) {\r\n                                                lines[lines.length - 1] = 2;\r\n                                            }\r\n                                            types.push("comment");\r\n                                        }\r\n                                    }\r\n                                } else if (b[a + 2] === "[" && b[a + 3] === "C" && b[a + 4] === "D" && b[a + 5] === "A" && b[a + 6] === "T" && b[a + 7] === "A" && b[a + 8] === "[") {\r\n                                    end      = "]]>";\r\n                                    preserve = true;\r\n                                    comment  = true;\r\n                                    types.push("cdata");\r\n                                } else {\r\n                                    end      = ">";\r\n                                    sgmlflag = sgmlflag + 1;\r\n                                    types.push("sgml");\r\n                                }\r\n                            } else if (b[a + 1] === "?") {\r\n                                end = "?>";\r\n                                if (b[a + 2] === "x" && b[a + 3] === "m" && b[a + 4] === "l") {\r\n                                    types.push("xml");\r\n                                } else {\r\n                                    preserve = true;\r\n                                    types.push("template");\r\n                                }\r\n                            } else if (b[a + 1] === "%") {\r\n                                if (b[a + 2] !== "=") {\r\n                                    preserve = true;\r\n                                }\r\n                                if (b[a + 2] === "-" && b[a + 3] === "-") {\r\n                                    end     = "--%>";\r\n                                    comment = true;\r\n                                    if (options.commline === true) {\r\n                                        line[line.length - 1] = 2;\r\n                                    }\r\n                                    types.push("comment");\r\n                                } else if (b[a + 2] === "#") {\r\n                                    end     = "%>";\r\n                                    comment = true;\r\n                                    if (options.commline === true) {\r\n                                        line[line.length - 1] = 2;\r\n                                    }\r\n                                    types.push("comment");\r\n                                } else {\r\n                                    end = "%>";\r\n                                    types.push("template");\r\n                                }\r\n                            } else if (b[a + 4] !== undefined && b[a + 1].toLowerCase() === "p" && b[a + 2].toLowerCase() === "r" && b[a + 3].toLowerCase() === "e" && (b[a + 4] === ">" || (/\\s/).test(b[a + 4]) === true)) {\r\n                                end      = "</pre>";\r\n                                preserve = true;\r\n                                types.push("ignore");\r\n                            } else if (b[a + 4] !== undefined && b[a + 1].toLowerCase() === "x" && b[a + 2].toLowerCase() === "s" && b[a + 3].toLowerCase() === "l" && b[a + 4].toLowerCase() === ":" && b[a + 5].toLowerCase() === "t" && b[a + 6].toLowerCase() === "e" && b[a + 7].toLowerCase() === "x" && b[a + 8].toLowerCase() === "t" && (b[a + 9] === ">" || (/\\s/).test(b[a + 9]) === true)) {\r\n                                end      = "</xsl:text>";\r\n                                preserve = true;\r\n                                types.push("ignore");\r\n                            } else if (b[a + 8] !== undefined && b[a + 1].toLowerCase() === "c" && b[a + 2].toLowerCase() === "f" && b[a + 3].toLowerCase() === "q" && b[a + 4].toLowerCase() === "u" && b[a + 5].toLowerCase() === "e" && b[a + 6].toLowerCase() === "r" && b[a + 7].toLowerCase() === "y" && (b[a + 8] === ">" || (/\\s/).test(b[a + 8]))) {\r\n                                end          = ">";\r\n                                linepreserve = linepreserve + 1;\r\n                                types.push("linepreserve");\r\n                            } else if (b[a + 1] === "<") {\r\n                                if (b[a + 2] === "<") {\r\n                                    end = ">>>";\r\n                                } else {\r\n                                    end = ">>";\r\n                                }\r\n                                types.push("template");\r\n                            } else if (b[a + 1] === "#") {\r\n                                if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {\r\n                                    end = ">";\r\n                                    types.push("template_else");\r\n                                } else if (b[a + 2] === "-" && b[a + 3] === "-") {\r\n                                    end = "--\x3e";\r\n                                    types.push("comment");\r\n                                    preserve = true;\r\n                                } else {\r\n                                    end = ">";\r\n                                    types.push("template_start");\r\n                                }\r\n                            } else {\r\n                                simple = true;\r\n                                end    = ">";\r\n                            }\r\n                        } else if (b[a] === "{") {\r\n                            preserve = true;\r\n                            if (options.jsx === true) {\r\n                                end = "}";\r\n                                types.push("script");\r\n                            } else if (options.dustjs === true) {\r\n                                if (b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {\r\n                                    a = a + 6;\r\n                                    token.push("{:else}");\r\n                                    presv.push(true);\r\n                                    daddy.push(parent[parent.length - 1][0]);\r\n                                    begin.push(parent[parent.length - 1][1]);\r\n                                    attrs.push({});\r\n                                    stats.template[0] = stats.template[0] + 1;\r\n                                    stats.template[1] = stats.template[1] + 7;\r\n                                    earlyexit         = true;\r\n                                    return types.push("template_else");\r\n                                }\r\n                                if (b[a + 1] === "!") {\r\n                                    end     = "!}";\r\n                                    comment = true;\r\n                                    types.push("comment");\r\n                                } else if (b[a + 1] === "/") {\r\n                                    end = "}";\r\n                                    types.push("template_end");\r\n                                } else if (b[a + 1] === "~") {\r\n                                    end = "}";\r\n                                    types.push("singleton");\r\n                                } else if (b[a + 1] === ">") {\r\n                                    end = "/}";\r\n                                    types.push("singleton");\r\n                                } else if (b[a + 1] === "#" || b[a + 1] === "?" || b[a + 1] === "^" || b[a + 1] === "@" || b[a + 1] === "<" || b[a + 1] === "+") {\r\n                                    end = "}";\r\n                                    types.push("template_start");\r\n                                } else {\r\n                                    end = "}";\r\n                                    types.push("template");\r\n                                }\r\n                            } else if (b[a + 1] === "{") {\r\n                                if (b[a + 2] === "{") {\r\n                                    end = "}}}";\r\n                                    types.push("template");\r\n                                } else if (b[a + 2] === "#") {\r\n                                    end = "}}";\r\n                                    types.push("template_start");\r\n                                } else if (b[a + 2] === "/") {\r\n                                    end = "}}";\r\n                                    types.push("template_end");\r\n                                } else if (b[a + 2] === "e" && b[a + 3] === "n" && b[a + 4] === "d") {\r\n                                    end = "}}";\r\n                                    types.push("template_end");\r\n                                } else if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {\r\n                                    end = "}}";\r\n                                    types.push("template_else");\r\n                                } else {\r\n                                    end = "}}";\r\n                                    types.push("template");\r\n                                }\r\n                            } else if (b[a + 1] === "%") {\r\n                                end = "%}";\r\n                                types.push("template");\r\n                            } else if (b[a + 1] === "#") {\r\n                                end = "#}";\r\n                                types.push("comment");\r\n                                preserve = true;\r\n                                comment  = true;\r\n                            } else {\r\n                                end = b[a + 1] + "}";\r\n                                types.push("template");\r\n                            }\r\n                            if (b[a + 1] === "@" && b[a + 2] === "}" && b[a + 3] === "e" && b[a + 4] === "l" && b[a + 5] === "s" && b[a + 6] === "e" && b[a + 7] === "{" && b[a + 8] === "@" && b[a + 9] === "}") {\r\n                                a                       = a + 9;\r\n                                types[types.length - 1] = "template_else";\r\n                                presv.push(true);\r\n                                daddy.push(parent[parent.length - 1][0]);\r\n                                begin.push(parent[parent.length - 1][1]);\r\n                                attrs.push({});\r\n                                stats.template[0] = stats.template[0] + 1;\r\n                                stats.template[1] = stats.template[1] + 10;\r\n                                earlyexit         = true;\r\n                                return token.push("{@}else{@}");\r\n                            }\r\n                        } else if (b[a] === "[" && b[a + 1] === "%") {\r\n                            end = "%]";\r\n                            types.push("template");\r\n                        } else if (b[a] === "#" && options.apacheVelocity === true) {\r\n                            if (b[a + 1] === "*") {\r\n                                preserve = true;\r\n                                comment  = true;\r\n                                end      = "*#";\r\n                                types.push("comment");\r\n                            } else if (b[a + 1] === "[" && b[a + 2] === "[") {\r\n                                preserve = true;\r\n                                comment  = true;\r\n                                end      = "]]#";\r\n                                types.push("comment");\r\n                            } else if (b[a + 1] === "#") {\r\n                                preserve = true;\r\n                                comment  = true;\r\n                                end      = "\\n";\r\n                                types.push("comment");\r\n                            } else if (b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (/\\s/).test(b[a + 5]) === true) {\r\n                                end = "\\n";\r\n                                types.push("template_else");\r\n                            } else if (b[a + 1] === "i" && b[a + 2] === "f") {\r\n                                end = "\\n";\r\n                                types.push("template_start");\r\n                            } else if (b[a + 1] === "f" && b[a + 2] === "o" && b[a + 3] === "r" && b[a + 4] === "e" && b[a + 5] === "a" && b[a + 6] === "c" && b[a + 7] === "h") {\r\n                                end = "\\n";\r\n                                types.push("template_start");\r\n                            } else if (b[a + 1] === "e" && b[a + 2] === "n" && b[a + 3] === "d") {\r\n                                end = "\\n";\r\n                                types.push("template_end");\r\n                            } else {\r\n                                end = "\\n";\r\n                                types.push("template");\r\n                            }\r\n                        } else if (b[a] === "$" && options.apacheVelocity === true) {\r\n                            end = "\\n";\r\n                            types.push("template");\r\n                        }\r\n                        if (options.unformatted === true) {\r\n                            preserve = true;\r\n                        }\r\n                    }());\r\n                    if (earlyexit === true) {\r\n                        return;\r\n                    }\r\n                    // This loop is the logic that parses tags and attributes If the attribute\r\n                    // data-prettydiff-ignore is present the `ignore` flag is set The ignore flag is\r\n                    // identical to the preserve flag\r\n                    lastchar = end.charAt(end.length - 1);\r\n                    for (a = a; a < c; a = a + 1) {\r\n                        if (b[a] === "\\n") {\r\n                            line = line + 1;\r\n                        }\r\n                        if (preserve === true || (/\\s/).test(b[a]) === false) {\r\n                            lexer.push(b[a]);\r\n                        } else if (lexer[lexer.length - 1] !== " ") {\r\n                            lexer.push(" ");\r\n                        }\r\n                        if (comment === true) {\r\n                            quote = "";\r\n                            //comments must ignore fancy encapsulations and attribute parsing\r\n                            if (b[a] === lastchar && lexer.length > end.length + 1) {\r\n                                //if current character matches the last character of the tag ending sequence\r\n                                f = lexer.length;\r\n                                for (e = end.length - 1; e > -1; e = e - 1) {\r\n                                    f = f - 1;\r\n                                    if (lexer[f] !== end.charAt(e)) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (e < 0) {\r\n                                    if (end === "endcomment") {\r\n                                        f = f - 1;\r\n                                        if ((/\\s/).test(lexer[f]) === true) {\r\n                                            do {\r\n                                                f = f - 1;\r\n                                            } while ((/\\s/).test(lexer[f]) === true);\r\n                                        }\r\n                                        if (lexer[f - 1] === "{" && lexer[f] === "%") {\r\n                                            end      = "%}";\r\n                                            lastchar = "}";\r\n                                        }\r\n                                    } else {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (quote === "") {\r\n                                if (options.jsx === true) {\r\n                                    if (b[a] === "{") {\r\n                                        jsxcount = jsxcount + 1;\r\n                                    } else if (b[a] === "}") {\r\n                                        jsxcount = jsxcount - 1;\r\n                                    }\r\n                                }\r\n                                if (types[types.length - 1] === "sgml" && b[a] === "[" && lexer.length > 4) {\r\n                                    types[types.length - 1] = "template_start";\r\n                                    break;\r\n                                }\r\n                                if (b[a] === "<" && preserve === false && lexer.length > 1 && end !== ">>" && end !== ">>>" && simple === true) {\r\n                                    parseError.push("Parse error on line " + line + " on element: ");\r\n                                    parseFail = true;\r\n                                }\r\n                                if (stest === true && (/\\s/).test(b[a]) === false && b[a] !== lastchar) {\r\n                                    //attribute start\r\n                                    stest   = false;\r\n                                    quote   = jsxquote;\r\n                                    igcount = 0;\r\n                                    lexer.pop();\r\n                                    for (a = a; a < c; a = a + 1) {\r\n                                        if (b[a] === "\\n") {\r\n                                            line = line + 1;\r\n                                        }\r\n                                        if (options.unformatted === true) {\r\n                                            lexer.push(b[a]);\r\n                                        }\r\n                                        attribute.push(b[a]);\r\n\r\n                                        if ((b[a] === "<" || b[a] === ">") && (quote === "" || quote === ">") && options.jsx === false) {\r\n                                            if (quote === "" && b[a] === "<") {\r\n                                                quote     = ">";\r\n                                                braccount = 1;\r\n                                            } else if (quote === ">") {\r\n                                                if (b[a] === "<") {\r\n                                                    braccount = braccount + 1;\r\n                                                } else if (b[a] === ">") {\r\n                                                    braccount = braccount - 1;\r\n                                                    if (braccount === 0) {\r\n                                                        // the following detects if a coldfusion tag is embedded within another markup\r\n                                                        // tag\r\n                                                        tname = tagName(attribute.join(""));\r\n                                                        if (cftags[tname] === "required") {\r\n                                                            quote = "</" + tname + ">";\r\n                                                        } else {\r\n                                                            quote   = "";\r\n                                                            igcount = 0;\r\n                                                            attrpush(false);\r\n                                                            break;\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        } else if (quote === "") {\r\n                                            if (b[a + 1] === lastchar) {\r\n                                                //if at end of tag\r\n                                                if (attribute[attribute.length - 1] === "/") {\r\n                                                    attribute.pop();\r\n                                                    if (preserve === true) {\r\n                                                        lexer.pop();\r\n                                                    }\r\n                                                    a = a - 1;\r\n                                                }\r\n                                                if (attribute.length > 0) {\r\n                                                    attrpush(false);\r\n                                                }\r\n                                                break;\r\n                                            }\r\n                                            if (b[a] === "{" && b[a - 1] === "=" && options.jsx === false) {\r\n                                                quote = "}";\r\n                                            } else if (b[a] === "\\"" || b[a] === "\'") {\r\n                                                quote = b[a];\r\n                                                if (b[a - 1] === "=" && (b[a + 1] === "<" || (b[a + 1] === "{" && b[a + 2] === "%") || (/\\s/).test(b[a + 1]) === true)) {\r\n                                                    igcount = a;\r\n                                                }\r\n                                            } else if (b[a] === "(") {\r\n                                                quote     = ")";\r\n                                                parncount = 1;\r\n                                            } else if (options.jsx === true) {\r\n                                                //jsx variable attribute\r\n                                                if ((b[a - 1] === "=" || (/\\s/).test(b[a - 1]) === true) && b[a] === "{") {\r\n                                                    quote  = "}";\r\n                                                    bcount = 1;\r\n                                                } else if (b[a] === "/") {\r\n                                                    //jsx comments\r\n                                                    if (b[a + 1] === "*") {\r\n                                                        quote = "*/";\r\n                                                    } else if (b[a + 1] === "/") {\r\n                                                        quote = "\\n";\r\n                                                    }\r\n                                                }\r\n                                            } else if (lexer[0] !== "{" && b[a] === "{" && (options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\r\n                                                //opening embedded template expression\r\n                                                if (b[a + 1] === "{") {\r\n                                                    if (b[a + 2] === "{") {\r\n                                                        quote = "}}}";\r\n                                                    } else {\r\n                                                        quote = "}}";\r\n                                                    }\r\n                                                } else if (options.dustjs === true) {\r\n                                                    quote = "}";\r\n                                                } else {\r\n                                                    quote = b[a + 1] + "}";\r\n                                                }\r\n                                            }\r\n                                            if ((/\\s/).test(b[a]) === true && quote === "") {\r\n                                                // testing for a run of spaces between an attribute\'s = and a quoted value.\r\n                                                // Unquoted values separated by space are separate attributes\r\n                                                if (attribute[attribute.length - 2] === "=") {\r\n                                                    for (e = a + 1; e < c; e = e + 1) {\r\n                                                        if ((/\\s/).test(b[e]) === false) {\r\n                                                            if (b[e] === "\\"" || b[e] === "\'") {\r\n                                                                a         = e - 1;\r\n                                                                quotetest = true;\r\n                                                                attribute.pop();\r\n                                                            }\r\n                                                            break;\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                if (quotetest === true) {\r\n                                                    quotetest = false;\r\n                                                } else if (jsxcount === 0 || (jsxcount === 1 && attribute[0] === "{")) {\r\n                                                    //if there is an unquoted space attribute is complete\r\n                                                    attribute.pop();\r\n                                                    attrpush(false);\r\n                                                    stest = true;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        } else if (b[a] === "(" && quote === ")") {\r\n                                            parncount = parncount + 1;\r\n                                        } else if (b[a] === ")" && quote === ")") {\r\n                                            parncount = parncount - 1;\r\n                                            if (parncount === 0) {\r\n                                                quote = "";\r\n                                                if (b[a + 1] === end.charAt(0)) {\r\n                                                    attrpush(false);\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        } else if (options.jsx === true && (quote === "}" || (quote === "\\n" && b[a] === "\\n") || (quote === "*/" && b[a - 1] === "*" && b[a] === "/"))) {\r\n                                            //jsx attributes\r\n                                            if (quote === "}") {\r\n                                                if (b[a] === "{") {\r\n                                                    bcount = bcount + 1;\r\n                                                } else if (b[a] === quote) {\r\n                                                    bcount = bcount - 1;\r\n                                                    if (bcount === 0) {\r\n                                                        jsxcount = 0;\r\n                                                        quote    = "";\r\n                                                        element  = attribute.join("");\r\n                                                        if (options.unformatted === false) {\r\n                                                            if (options.jsx === true) {\r\n                                                                if ((/^(\\s*)$/).test(element) === false) {\r\n                                                                    attstore.push(element);\r\n                                                                }\r\n                                                            } else {\r\n                                                                element = element.replace(/\\s+/g, " ");\r\n                                                                if (element !== " ") {\r\n                                                                    attstore.push(element);\r\n                                                                }\r\n                                                            }\r\n                                                        } else if ((/^(\\s+)$/).test(element) === false) {\r\n                                                            attstore.push(element);\r\n                                                        }\r\n                                                        attribute = [];\r\n                                                        break;\r\n                                                    }\r\n                                                }\r\n                                            } else {\r\n                                                quote                   = "";\r\n                                                jsxquote                = "";\r\n                                                jscom[jscom.length - 1] = true;\r\n                                                element                 = attribute.join("");\r\n                                                if (element.charAt(1) === "*") {\r\n                                                    element = element + "\\n";\r\n                                                }\r\n                                                attribute = [];\r\n                                                if (element !== " ") {\r\n                                                    attstore.push(element);\r\n                                                }\r\n                                                break;\r\n                                            }\r\n                                        } else if (b[a] === "{" && b[a + 1] === "%" && b[igcount - 1] === "=" && (quote === "\\"" || quote === "\'")) {\r\n                                            quote   = quote + "{%";\r\n                                            igcount = 0;\r\n                                        } else if (b[a - 1] === "%" && b[a] === "}" && (quote === "\\"{%" || quote === "\'{%")) {\r\n                                            quote   = quote.charAt(0);\r\n                                            igcount = 0;\r\n                                        } else if (b[a] === "<" && end === ">" && b[igcount - 1] === "=" && (quote === "\\"" || quote === "\'")) {\r\n                                            quote   = quote + "<";\r\n                                            igcount = 0;\r\n                                        } else if (b[a] === ">" && (quote === "\\"<" || quote === "\'<")) {\r\n                                            quote   = quote.charAt(0);\r\n                                            igcount = 0;\r\n                                        } else if (igcount === 0 && quote !== ">" && (quote.length < 2 || (quote.charAt(0) !== "\\"" && quote.charAt(0) !== "\'"))) {\r\n                                            //terminate attribute at the conclusion of a quote pair\r\n                                            f     = 0;\r\n                                            tname = lexer[1] + lexer[2];\r\n                                            tname = tname.toLowerCase();\r\n                                            // in coldfusion quotes are escaped in a string with double the characters:\r\n                                            // "cat"" and dog"\r\n                                            if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\\"" || b[a] === "\'")) {\r\n                                                attribute.push(b[a + 1]);\r\n                                                a = a + 1;\r\n                                            } else {\r\n                                                for (e = quote.length - 1; e > -1; e = e - 1) {\r\n                                                    if (b[a - f] !== quote.charAt(e)) {\r\n                                                        break;\r\n                                                    }\r\n                                                    f = f + 1;\r\n                                                }\r\n                                                if (e < 0) {\r\n                                                    attrpush(true);\r\n                                                    if (b[a + 1] === lastchar) {\r\n                                                        break;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        } else if (igcount > 0 && (/\\s/).test(b[a]) === false) {\r\n                                            igcount = 0;\r\n                                        }\r\n                                    }\r\n                                } else if (end !== "%>" && end !== "\\n" && (b[a] === "\\"" || b[a] === "\'")) {\r\n                                    //opening quote\r\n                                    quote = b[a];\r\n                                } else if (comment === false && end !== "\\n" && b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] !== "#" && types[types.length - 1] !== "conditional") {\r\n                                    quote = "--\x3e";\r\n                                } else if (lexer[0] !== "{" && end !== "\\n" && b[a] === "{" && end !== "%>" && end !== "%]" && (options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\r\n                                    //opening embedded template expression\r\n                                    if (b[a + 1] === "{") {\r\n                                        if (b[a + 2] === "{") {\r\n                                            quote = "}}}";\r\n                                        } else {\r\n                                            quote = "}}";\r\n                                        }\r\n                                    } else if (options.dustjs === true) {\r\n                                        quote = "}";\r\n                                    } else {\r\n                                        quote = b[a + 1] + "}";\r\n                                    }\r\n                                    if (quote === end) {\r\n                                        quote = "";\r\n                                    }\r\n                                } else if (simple === true && end !== "\\n" && (/\\s/).test(b[a]) === true && b[a - 1] !== "<") {\r\n                                    //identify a space in a regular start or singleton tag\r\n                                    stest = true;\r\n                                } else if (simple === true && options.jsx === true && b[a] === "/" && (b[a + 1] === "*" || b[a + 1] === "/")) {\r\n                                    //jsx comment immediately following tag name\r\n                                    stest                   = true;\r\n                                    lexer[lexer.length - 1] = " ";\r\n                                    attribute.push(b[a]);\r\n                                    if (b[a + 1] === "*") {\r\n                                        jsxquote = "*/";\r\n                                    } else {\r\n                                        jsxquote = "\\n";\r\n                                    }\r\n                                } else if ((b[a] === lastchar || (end === "\\n" && b[a + 1] === "<")) && (lexer.length > end.length + 1 || lexer[0] === "]") && (options.jsx === false || jsxcount === 0)) {\r\n                                    if (end === "\\n") {\r\n                                        if ((/\\s/).test(lexer[lexer.length - 1]) === true) {\r\n                                            do {\r\n                                                lexer.pop();\r\n                                                a = a - 1;\r\n                                            } while ((/\\s/).test(lexer[lexer.length - 1]) === true);\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if (lexer[0] === "{" && lexer[1] === "%" && lexer.join("").replace(/\\s+/g, "") === "{%comment%}") {\r\n                                        end                     = "endcomment";\r\n                                        lastchar                = "t";\r\n                                        preserve                = true;\r\n                                        comment                 = true;\r\n                                        types[types.length - 1] = "comment";\r\n                                    } else {\r\n                                        //if current character matches the last character of the tag ending sequence\r\n                                        f = lexer.length;\r\n                                        for (e = end.length - 1; e > -1; e = e - 1) {\r\n                                            f = f - 1;\r\n                                            if (lexer[f] !== end.charAt(e)) {\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        if (e < 0) {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else if (b[a] === quote.charAt(quote.length - 1) && ((options.jsx === true && end === "}" && (b[a - 1] !== "\\\\" || slashy() === false)) || options.jsx === false || end !== "}")) {\r\n                                //find the closing quote or embedded template expression\r\n                                f     = 0;\r\n                                tname = lexer[1] + lexer[2];\r\n                                tname = tname.toLowerCase();\r\n                                // in coldfusion quotes are escaped in a string with double the characters:\r\n                                // "cat"" and dog"\r\n                                if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\\"" || b[a] === "\'")) {\r\n                                    attribute.push(b[a + 1]);\r\n                                    a = a + 1;\r\n                                } else {\r\n                                    for (e = quote.length - 1; e > -1; e = e - 1) {\r\n                                        if (b[a - f] !== quote.charAt(e)) {\r\n                                            break;\r\n                                        }\r\n                                        f = f + 1;\r\n                                    }\r\n                                    if (e < 0) {\r\n                                        quote = "";\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    //nopush flags mean an early exit\r\n                    if (nopush === true) {\r\n                        jscom.pop();\r\n                        linen.pop();\r\n                        lines.pop();\r\n                        value.pop();\r\n                        space = minspace;\r\n                        return;\r\n                    }\r\n\r\n                    if (preserve === true) {\r\n                        presv.push(true);\r\n                    } else {\r\n                        presv.push(false);\r\n                    }\r\n\r\n                    if (options.correct === true) {\r\n                        if (b[a + 1] === ">" && lexer[0] === "<" && lexer[1] !== "<") {\r\n                            do {\r\n                                a = a + 1;\r\n                            } while (b[a + 1] === ">");\r\n                        } else if (lexer[0] === "<" && lexer[1] === "<" && b[a + 1] !== ">" && lexer[lexer.length - 2] !== ">") {\r\n                            do {\r\n                                lexer.splice(1, 1);\r\n                            } while (lexer[1] === "<");\r\n                        }\r\n                    }\r\n                    igcount = 0;\r\n                    element = lexer.join("");\r\n                    if (element.indexOf("{{") === 0 && element.slice(element.length - 2) === "}}") {\r\n                        if (tagName(element) === "end") {\r\n                            types[types.length - 1] = "template_end";\r\n                        } else if (tagName(element) === "else") {\r\n                            types[types.length - 1] = "template_else";\r\n                        }\r\n                    } else if (element.slice(0, 2) === "<%" && element.slice(element.length - 2) === "%>") {\r\n                        if ((/^(<%\\s*end\\s*-?%>)$/).test(element) === true || (/^(<%\\s*\\}\\s*%>)$/).test(element) === true) {\r\n                            types[types.length - 1] = "template_end";\r\n                        } else if ((/^(<%\\s*\\}?\\s*else\\s*\\{?\\s*-?%>)$/).test(element) === true) {\r\n                            types[types.length - 1] = "template_else";\r\n                        } else if (element.indexOf("<%=") !== 0) {\r\n                            types[types.length - 1] = "template_start";\r\n                        }\r\n                    }\r\n                    tname = tagName(element);\r\n                    if (options.html === true && element.charAt(0) === "<" && element.charAt(1) !== "!" && element.charAt(1) !== "?" && (types.length === 0 || types[types.length - 1].indexOf("template") < 0) && options.jsx === false && cftags[tname] === undefined && cftags[tname.slice(1)] === undefined && tname.slice(0, 3) !== "cf_") {\r\n                        element = element.toLowerCase();\r\n                    }\r\n                    if (tname === "comment" && element.slice(0, 2) === "{%") {\r\n                        element = element\r\n                            .replace(/^(\\{%\\s*comment\\s*%\\}\\s*)/, "")\r\n                            .replace(/(\\s*\\{%\\s*endcomment\\s*%\\})$/, "");\r\n\r\n                        attrs.push({});\r\n                        attrs.push({});\r\n                        value.push("");\r\n                        value.push("");\r\n                        jscom.push(false);\r\n                        jscom.push(false);\r\n                        e = linen[linen.length - 1];\r\n                        linen.push(e);\r\n                        linen.push(e);\r\n                        types[types.length - 1] = "template_start";\r\n                        token.push("{% comment %}");\r\n                        types.push("comment");\r\n                        daddy.push(parent[parent.length - 1][0]);\r\n                        begin.push(parent[parent.length - 1][1]);\r\n                        stats.template[0] = stats.template[0] + 1;\r\n                        stats.template[1] = stats.template[1] + 13;\r\n                        token.push(element);\r\n                        types.push("template_end");\r\n                        daddy.push(parent[parent.length - 1][0]);\r\n                        begin.push(parent[parent.length - 1][1]);\r\n                        stats.template[0] = stats.template[0] + 1;\r\n                        stats.template[1] = stats.template[1] + element.length;\r\n                        return token.push("{% endcomment %}");\r\n                    }\r\n\r\n                    if (end !== "]>" && sgmlflag > 0 && element.charAt(element.length - 1) !== "[" && (element.slice(element.length - 2) === "]>" || (/^(<!((doctype)|(notation))\\s)/i).test(element) === true)) {\r\n                        sgmlflag = sgmlflag - 1;\r\n                    }\r\n\r\n                    //fix singleton tags and sort attributes\r\n                    if (attstore.length > 0) {\r\n                        if (attstore[attstore.length - 1] === "/") {\r\n                            attstore.pop();\r\n                            lexer.splice(lexer.length - 1, 0, "/");\r\n                        }\r\n                        f = attstore.length;\r\n                        for (e = 1; e < f; e = e + 1) {\r\n                            quote = attstore[e - 1];\r\n                            if (quote.charAt(quote.length - 1) === "=" && attstore[e].indexOf("=") < 0) {\r\n                                attstore[e - 1] = quote + attstore[e];\r\n                                attstore.splice(e, 1);\r\n                                f = f - 1;\r\n                                e = e - 1;\r\n                            }\r\n                        }\r\n                        if (objsortop === true && jscom[jscom.length - 1] === false && options.jsx === false && nosort === false && tname !== "cfif" && tname !== "cfelseif" && tname !== "cfset") {\r\n                            attstore = safeSort(attstore);\r\n                        }\r\n                    }\r\n                    attrs.push(function markuppretty__tokenize_attribute() {\r\n                        var ind    = 0,\r\n                            len    = attstore.length,\r\n                            obj    = {},\r\n                            eq     = 0,\r\n                            dq     = 0,\r\n                            sq     = 0,\r\n                            syntax = "<{\\"\'=/",\r\n                            slice  = "",\r\n                            store  = [],\r\n                            name   = "",\r\n                            cft    = cftags[tname];\r\n                        if (tname.slice(0, 3) === "cf_") {\r\n                            cft = "required";\r\n                        }\r\n                        if (objsortop === true && options.jsx === false && cft === undefined) {\r\n                            attstore = safeSort(attstore);\r\n                        }\r\n                        for (ind = 0; ind < len; ind = ind + 1) {\r\n                            eq = attstore[ind].indexOf("=");\r\n                            dq = attstore[ind].indexOf("\\"");\r\n                            sq = attstore[ind].indexOf("\'");\r\n                            if (eq > -1 && store.length > 0) {\r\n                                obj[store.join(" ")] = "";\r\n                                store                = [];\r\n                                obj[attstore[ind]]   = "";\r\n                            } else if (cft !== undefined && eq < 0 && attstore[ind].indexOf("=") < 0) {\r\n                                store.push(attstore[ind]);\r\n                            } else if ((cft !== undefined && eq < 0) || (dq > 0 && dq < eq) || (sq > 0 && sq < eq) || syntax.indexOf(attstore[ind].charAt(0)) > -1) {\r\n                                obj[attstore[ind]] = "";\r\n                            } else if (eq < 0 && cft === undefined) {\r\n                                name = attstore[ind];\r\n                                if (options.html === true && options.jsx === false && cft === undefined) {\r\n                                    name = name.toLowerCase();\r\n                                }\r\n                                if (options.quoteConvert === "single") {\r\n                                    obj[name] = "\'" + attstore[ind] + "\'";\r\n                                } else {\r\n                                    obj[name] = "\\"" + attstore[ind] + "\\"";\r\n                                }\r\n                            } else {\r\n                                slice = attstore[ind].slice(eq + 1);\r\n                                if (syntax.indexOf(slice.charAt(0)) < 0 && cft === undefined) {\r\n                                    if (options.quoteConvert === "single") {\r\n                                        slice = "\'" + slice + "\'";\r\n                                    } else {\r\n                                        slice = "\\"" + slice + "\\"";\r\n                                    }\r\n                                }\r\n                                name = attstore[ind].slice(0, eq);\r\n                                if (options.html === true && options.jsx === false && cft === undefined) {\r\n                                    name = name.toLowerCase();\r\n                                }\r\n                                obj[name] = slice;\r\n                            }\r\n                        }\r\n                        if (store.length > 0) {\r\n                            obj[store.join(" ")] = "";\r\n                        }\r\n                        return obj;\r\n                    }());\r\n\r\n                    if (parseFail === true) {\r\n                        if (element.indexOf("\x3c!--<![") === 0) {\r\n                            parseError.pop();\r\n                        } else {\r\n                            parseError[parseError.length - 1] = parseError[parseError.length - 1] +\r\n                                    element;\r\n                            if (element.indexOf("</") > 0) {\r\n                                token.push(element);\r\n                                daddy.push(parent[parent.length - 1][0]);\r\n                                begin.push(parent[parent.length - 1][1]);\r\n                                stats.end[0] = stats.end[0] + 1;\r\n                                stats.end[1] = stats.end[1] + token[token.length - 1].length;\r\n                                return types.push("end");\r\n                            }\r\n                        }\r\n                    }\r\n                    // cheat identifies HTML singleton elements as singletons even if formatted as\r\n                    // start tags\r\n                    cheat = (function markuppretty__tokenize_tag_cheat() {\r\n                        var atty         = [],\r\n                            attn         = token[token.length - 1],\r\n                            atval        = "",\r\n                            type         = "",\r\n                            d            = 0,\r\n                            ee           = 1,\r\n                            cfval        = "",\r\n                            ender        = (/(\\/>)$/),\r\n                            htmlsings    = {\r\n                                area       : "singleton",\r\n                                base       : "singleton",\r\n                                basefont   : "singleton",\r\n                                br         : "singleton",\r\n                                col        : "singleton",\r\n                                embed      : "singleton",\r\n                                eventsource: "singleton",\r\n                                frame      : "singleton",\r\n                                hr         : "singleton",\r\n                                img        : "singleton",\r\n                                input      : "singleton",\r\n                                keygen     : "singleton",\r\n                                link       : "singleton",\r\n                                meta       : "singleton",\r\n                                param      : "singleton",\r\n                                progress   : "singleton",\r\n                                source     : "singleton",\r\n                                wbr        : "singleton"\r\n                            },\r\n                            fixsingleton = function markuppretty__tokenize_tag_cheat_fixsingleton() {\r\n                                var aa    = 0,\r\n                                    bb    = 0,\r\n                                    vname = tname.slice(1);\r\n                                for (aa = token.length - 1; aa > -1; aa = aa - 1) {\r\n                                    if (types[aa] === "end") {\r\n                                        bb = bb + 1;\r\n                                    } else if (types[aa] === "start") {\r\n                                        bb = bb - 1;\r\n                                        if (bb < 0) {\r\n                                            return false;\r\n                                        }\r\n                                    }\r\n                                    if (bb === 0 && token[aa].toLowerCase().indexOf(vname) === 1) {\r\n                                        if (cftags[tagName(token[aa])] !== undefined) {\r\n                                            types[aa] = "template_start";\r\n                                        } else {\r\n                                            types[aa]          = "start";\r\n                                            stats.singleton[0] = stats.singleton[0] - 1;\r\n                                            stats.singleton[1] = stats.singleton[1] - token[token.length - 1].length;\r\n                                            stats.start[0]     = stats.start[0] + 1;\r\n                                            stats.start[1]     = stats.start[1] + token[token.length - 1].length;\r\n                                        }\r\n                                        if (Object.keys(attrs[aa]).length > 0) {\r\n                                            token[aa] = token[aa].replace(/(\\s*\\/>)$/, " >");\r\n                                        } else {\r\n                                            token[aa] = token[aa].replace(/(\\s*\\/>)$/, ">");\r\n                                        }\r\n                                        return false;\r\n                                    }\r\n                                }\r\n                            };\r\n                        if (presend["/" + tname] === true) {\r\n                            linepreserve = linepreserve - 1;\r\n                        }\r\n                        if (types[types.length - 1] === "end" && tname.slice(0, 3) !== "/cf") {\r\n                            if (types[types.length - 2] === "singleton" && attn.charAt(attn.length - 2) !== "/" && "/" + tagName(attn) === tname) {\r\n                                types[types.length - 2] = "start";\r\n                            } else if ((types[types.length - 2] === "start" || htmlsings[tname.slice(1)] === "singleton") && tname !== "/span" && tname !== "/div" && tname !== "/script" && (options.html === false || (options.html === true && tname !== "/li")) && tname === "/" + tagName(token[token.length - 1]) && options.tagmerge === true) {\r\n                                types.pop();\r\n                                attrs.pop();\r\n                                jscom.pop();\r\n                                linen.pop();\r\n                                lines.pop();\r\n                                presv.pop();\r\n                                value.pop();\r\n                                if (types[types.length - 1] === "start") {\r\n                                    token[token.length - 1] = token[token.length - 1].replace(/>$/, "/>");\r\n                                }\r\n                                types[types.length - 1] = "singleton";\r\n                                singleton               = true;\r\n                                return;\r\n                            }\r\n                        }\r\n                        for (d = attstore.length - 1; d > -1; d = d - 1) {\r\n                            atty = arname(attstore[d]);\r\n                            if (atty[0] === "type") {\r\n                                type = atty[1];\r\n                                if (type.charAt(0) === "\\"" || type.charAt(0) === "\'") {\r\n                                    type = type.slice(1, type.length - 1);\r\n                                }\r\n                            } else if (atty[0] === "src" && (tname === "embed" || tname === "img" || tname === "script" || tname === "iframe")) {\r\n                                atval = atty[1];\r\n                                if (atval.charAt(0) === "\\"" || atval.charAt(0) === "\'") {\r\n                                    atval = atval.slice(1, atval.length - 1);\r\n                                }\r\n                                reqs.push(atval);\r\n                            } else if (tname === "link" && atty === "href") {\r\n                                atval = atty[1];\r\n                                if (atval.charAt(0) === "\\"" || atval.charAt(0) === "\'") {\r\n                                    atval = atval.slice(1, atval.length - 1);\r\n                                }\r\n                                reqs.push(atval);\r\n                            }\r\n                        }\r\n\r\n                        if ((tname === "script" || tname === "style" || tname === "cfscript") && element.slice(element.length - 2) !== "/>") {\r\n                            //identify if there is embedded code requiring an external parser\r\n                            if (tname === "script" && (type === "" || type === "text/javascript" || type === "babel" || type === "module" || type === "application/javascript" || type === "application/x-javascript" || type === "text/ecmascript" || type === "application/ecmascript" || type === "text/jsx" || type === "application/jsx" || type === "text/cjs")) {\r\n                                ext = true;\r\n                            } else if (tname === "style" && (type === "" || type === "text/css")) {\r\n                                ext = true;\r\n                            } else if (tname === "cfscript") {\r\n                                ext = true;\r\n                            }\r\n                            if (ext === true) {\r\n                                for (d = a + 1; d < c; d = d + 1) {\r\n                                    if ((/\\s/).test(b[d]) === false) {\r\n                                        if (b[d] === "<") {\r\n                                            if (b.slice(d + 1, d + 4).join("") === "!--") {\r\n                                                for (d = d + 4; d < c; d = d + 1) {\r\n                                                    if ((/\\s/).test(b[d]) === false) {\r\n                                                        ext = false;\r\n                                                        break;\r\n                                                    }\r\n                                                    if (b[d] === "\\n" || b[d] === "\\r") {\r\n                                                        break;\r\n                                                    }\r\n                                                }\r\n                                            } else if (b.slice(d + 1, d + 9).join("") !== "![CDATA[") {\r\n                                                ext = false;\r\n                                            }\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        if (tname === "/#assign" || tname === "/#global") {\r\n                            for (d = types.length - 2; d > -1; d = d - 1) {\r\n                                if (types[d] === "start" || types[d] === "template_start") {\r\n                                    ee = ee - 1;\r\n                                } else if (types[d] === "end" || types[d] === "template_end") {\r\n                                    ee = ee + 1;\r\n                                }\r\n                                if (ee === 1) {\r\n                                    if ((token[d].indexOf("<#assign") === 0 && tname === "/#assign") || (token[d].indexOf("<#global") === 0 && tname === "/#global")) {\r\n                                        types[d] = "template_start";\r\n                                        return false;\r\n                                    }\r\n                                }\r\n                                if (ee === 0) {\r\n                                    return false;\r\n                                }\r\n                            }\r\n                            return false;\r\n                        }\r\n                        if (tname.charAt(0) === "#" && types[types.length - 1] === "start" && (tname === "#assign" || tname === "#break" || tname === "#case" || tname === "#default" || tname === "#fallback" || tname === "#flush" || tname === "#ftl" || tname === "#global" || tname === "#import" || tname === "#include" || tname === "#local" || tname === "#t" || tname === "#lt" || tname === "#rt" || tname === "#nested" || tname === "#nt" || tname === "#recover" || tname === "#recurse" || tname === "#return" || tname === "#sep" || tname === "#setting" || tname === "#stop" || tname === "#visit")) {\r\n                            simple = true;\r\n                            return true;\r\n                        }\r\n                        if (options.html === true) {\r\n                            //simple means of looking for missing li end tags\r\n                            if (options.jsx === false) {\r\n                                if (tname === "li") {\r\n                                    if (litag === list && (list !== 0 || (list === 0 && types.length > 0 && types[types.length - 1].indexOf("template") < 0))) {\r\n                                        for (d = types.length - 1; d > -1; d = d - 1) {\r\n                                            if (types[d] === "start" || types[d] === "template_start") {\r\n                                                ee = ee - 1;\r\n                                            } else if (types[d] === "end" || types[d] === "template_end") {\r\n                                                ee = ee + 1;\r\n                                            }\r\n                                            if (ee === -1 && (tagName(token[d]) === "li" || (tagName(token[d + 1]) === "li" && (tagName(token[d]) === "ul" || tagName(token[d]) === "ol")))) {\r\n                                                liend = true;\r\n                                                break;\r\n                                            }\r\n                                            if (ee < 0) {\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                    } else {\r\n                                        litag = litag + 1;\r\n                                    }\r\n                                } else if (tname === "/li" && litag === list) {\r\n                                    litag = litag - 1;\r\n                                } else if (tname === "ul" || tname === "ol") {\r\n                                    list = list + 1;\r\n                                } else if (tname === "/ul" || tname === "/ol") {\r\n                                    if (litag === list) {\r\n                                        liend = true;\r\n                                        litag = litag - 1;\r\n\r\n                                    }\r\n                                    list = list - 1;\r\n                                }\r\n                            }\r\n                            if (types[types.length - 1] === "end" && htmlsings[tname.slice(1)] === "singleton" && tname !== "/cftransaction") {\r\n                                return fixsingleton();\r\n                            }\r\n                            if (htmlsings[tname] === "singleton") {\r\n                                if (options.correct === true && ender.test(element) === false) {\r\n                                    lexer.pop();\r\n                                    lexer.push(" ");\r\n                                    lexer.push("/");\r\n                                    lexer.push(">");\r\n                                    element = lexer.join("");\r\n                                }\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (types[types.length - 1] === "end" && tname.slice(0, 3) === "/cf" && cftags[tname.slice(1)] !== undefined) {\r\n                            cfval = cftags[tname.slice(1)];\r\n                            if (tname === "/cftransaction") {\r\n                                cftransaction = false;\r\n                            }\r\n                            if (cfval !== undefined) {\r\n                                types[types.length - 1] = "template_end";\r\n                            }\r\n                            if ((cfval === "optional" || cfval === "prohibited") && tname !== "/cftransaction") {\r\n                                return fixsingleton();\r\n                            }\r\n                            return false;\r\n                        }\r\n                        if (tname.slice(0, 2) === "cf") {\r\n                            if (tname === "cfelse" || tname === "cfelseif") {\r\n                                types.push("template_else");\r\n                                token.push(lexer.join(""));\r\n                                daddy.push(parent[parent.length - 1][0]);\r\n                                begin.push(parent[parent.length - 1][1]);\r\n                                stats.template[0] = stats.template[0] + 1;\r\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\r\n                                singleton         = true;\r\n                                return false;\r\n                            }\r\n                            if (tname === "cftransaction" && cftransaction === true) {\r\n                                cfval = "prohibited";\r\n                            } else {\r\n                                cfval = cftags[tname];\r\n                            }\r\n                            if (cfval === "optional" || cfval === "prohibited" || tname.slice(0, 3) === "cf_") {\r\n                                if (options.correct === true && ender.test(element) === false) {\r\n                                    lexer.pop();\r\n                                    lexer.push(" ");\r\n                                    lexer.push("/");\r\n                                    lexer.push(">");\r\n                                }\r\n                                types.push("template");\r\n                                token.push(lexer.join("").replace(/\\s+/, " "));\r\n                                daddy.push(parent[parent.length - 1][0]);\r\n                                begin.push(parent[parent.length - 1][1]);\r\n                                stats.template[0] = stats.template[0] + 1;\r\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\r\n                                singleton         = true;\r\n                                return false;\r\n                            }\r\n                            if (cfval === "required" && tname !== "cfquery") {\r\n                                if (tname === "cftransaction" && cftransaction === false) {\r\n                                    cftransaction = true;\r\n                                }\r\n                                types.push("template_start");\r\n                                token.push(lexer.join(""));\r\n                                daddy.push(parent[parent.length - 1][0]);\r\n                                if (parent[parent.length - 1][1] === -1) {\r\n                                    begin.push(token.length - 1);\r\n                                } else {\r\n                                    begin.push(parent[parent.length - 1][1]);\r\n                                }\r\n                                stats.template[0] = stats.template[0] + 1;\r\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\r\n                                singleton         = true;\r\n                            }\r\n                            return false;\r\n                        }\r\n                        if (options.dustjs === true && types[types.length - 1] === "template_start") {\r\n                            type  = element.charAt(1);\r\n                            atval = element.slice(element.length - 2);\r\n                            if ((atval === "/}" || atval.charAt(0) === type) && (type === "#" || type === "?" || type === "^" || type === "@" || type === "<" || type === "+")) {\r\n                                types[types.length - 1] = "template";\r\n                            }\r\n                        }\r\n                        return false;\r\n                    }());\r\n\r\n                    if (singleton === true) {\r\n                        return;\r\n                    }\r\n                    //am I a singleton or a start type?\r\n                    if (simple === true && ignoreme === false) {\r\n                        if (cheat === true || (lexer[lexer.length - 2] === "/" && lexer[lexer.length - 1] === ">")) {\r\n                            types.push("singleton");\r\n                        } else {\r\n                            types.push("start");\r\n                        }\r\n                    }\r\n                    // additional logic is required to find the end of a tag with the attribute\r\n                    // data-prettydiff-ignore\r\n                    if (simple === true && preserve === false && ignoreme === true && end === ">" && element.slice(element.length - 2) !== "/>") {\r\n                        if (cheat === true) {\r\n                            types.push("singleton");\r\n                        } else {\r\n                            preserve                = true;\r\n                            presv[presv.length - 1] = true;\r\n                            types.push("ignore");\r\n                            a     = a + 1;\r\n                            quote = "";\r\n                            for (a = a; a < c; a = a + 1) {\r\n                                if (b[a] === "\\n") {\r\n                                    line = line + 1;\r\n                                }\r\n                                lexer.push(b[a]);\r\n                                if (quote === "") {\r\n                                    if (b[a] === "\\"") {\r\n                                        quote = "\\"";\r\n                                    } else if (b[a] === "\'") {\r\n                                        quote = "\'";\r\n                                    } else if (lexer[0] !== "{" && b[a] === "{" && (options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\r\n                                        if (b[a + 1] === "{") {\r\n                                            if (b[a + 2] === "{") {\r\n                                                quote = "}}}";\r\n                                            } else {\r\n                                                quote = "}}";\r\n                                            }\r\n                                        } else if (options.dustjs === true) {\r\n                                            quote = "}";\r\n                                        } else {\r\n                                            quote = b[a + 1] + "}";\r\n                                        }\r\n                                    } else if (b[a] === "<" && simple === true) {\r\n                                        if (b[a + 1] === "/") {\r\n                                            endtag = true;\r\n                                        } else {\r\n                                            endtag = false;\r\n                                        }\r\n                                    } else if (b[a] === lastchar) {\r\n                                        if (b[a - 1] !== "/") {\r\n                                            if (b[a - 1] !== "/") {\r\n                                                if (endtag === true) {\r\n                                                    igcount = igcount - 1;\r\n                                                    if (igcount < 0) {\r\n                                                        break;\r\n                                                    }\r\n                                                } else {\r\n                                                    igcount = igcount + 1;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } else if (b[a] === quote.charAt(quote.length - 1)) {\r\n                                    f = 0;\r\n                                    for (e = quote.length - 1; e > -1; e = e - 1) {\r\n                                        if (b[a - f] !== quote.charAt(e)) {\r\n                                            break;\r\n                                        }\r\n                                        f = f + 1;\r\n                                    }\r\n                                    if (e < 0) {\r\n                                        quote = "";\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        element = lexer.join("");\r\n                        if (options.mode === "diff") {\r\n                            element = element.replace(" >", " />");\r\n                            element = element.slice(0, element.indexOf(" />") + 3);\r\n                            if (options.quotes === "single") {\r\n                                attstore = ["data-prettydiff-ignore=\'true\'"];\r\n                            } else {\r\n                                attstore = ["data-prettydiff-ignore=\\"true\\""];\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //some template tags can be evaluated as a block start/end based on syntax alone\r\n                    e = types.length - 1;\r\n                    if (types[e].indexOf("template") > -1) {\r\n                        if (element.slice(0, 2) === "{%") {\r\n                            lexer = [\r\n                                "autoescape",\r\n                                "block",\r\n                                "capture",\r\n                                "case",\r\n                                "comment",\r\n                                "embed",\r\n                                "filter",\r\n                                "for",\r\n                                "form",\r\n                                "if",\r\n                                "macro",\r\n                                "paginate",\r\n                                "raw",\r\n                                "sandbox",\r\n                                "spaceless",\r\n                                "tablerow",\r\n                                "unless",\r\n                                "verbatim"\r\n                            ];\r\n                            if (tname === "else" || tname === "elseif" || tname === "when" || tname === "elif") {\r\n                                types[e] = "template_else";\r\n                            } else {\r\n                                for (f = lexer.length - 1; f > -1; f = f - 1) {\r\n                                    if (tname === lexer[f]) {\r\n                                        types[e] = "template_start";\r\n                                        break;\r\n                                    }\r\n                                    if (tname === "end" + lexer[f]) {\r\n                                        types[e] = "template_end";\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else if (element.slice(0, 2) === "{{" && element.charAt(3) !== "{") {\r\n                            if ((/^(\\{\\{\\s*end\\s*\\}\\})$/).test(element) === true) {\r\n                                types[e] = "template_end";\r\n                            } else if (tname === "block" || tname === "define" || tname === "form" || tname === "if" || tname === "range" || tname === "with") {\r\n                                if (tname !== "block" || (/\\{%\\s*\\w/).test(options.source) === false) {\r\n                                    types[e] = "template_start";\r\n                                }\r\n                            }\r\n                        } else if (types[e] === "template") {\r\n                            if (element.indexOf("else") > 2) {\r\n                                types[e] = "template_else";\r\n                            } else if ((/^(<%\\s*\\})/).test(element) === true || (/^(\\[%\\s*\\})/).test(element) === true || (/^(\\{@\\s*\\})/).test(element) === true) {\r\n                                types[e] = "template_end";\r\n                            } else if ((/(\\{\\s*%>)$/).test(element) === true || (/(\\{\\s*%\\])$/).test(element) === true || (/(\\{\\s*@\\})$/).test(element) === true) {\r\n                                types[e] = "template_start";\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // HTML5 does not require an end tag for an opening list item <li> this logic\r\n                    // temprorarily creates a pseudo end tag\r\n                    if (liend === true && (options.mode === "beautify" || options.mode === "diff" || options.mode === "parse")) {\r\n                        token.push("</prettydiffli>");\r\n                        daddy.push(parent[parent.length - 1][0]);\r\n                        begin.push(parent[parent.length - 1][1]);\r\n                        lines.push(lines[lines.length - 1]);\r\n                        linen.push(line);\r\n                        lines[lines.length - 2] = 0;\r\n                        attrs.push({});\r\n                        if (types[types.length - 1] === "start") {\r\n                            types.splice(types.length - 1, 0, "end");\r\n                        } else {\r\n                            types.push("end");\r\n                        }\r\n                        presv.push(false);\r\n                        jscom.push(false);\r\n                        value.push("");\r\n                        if (parent.length > 1) {\r\n                            parent.pop();\r\n                        }\r\n                        stats.end[0] = stats.end[0] + 1;\r\n                        stats.end[1] = stats.end[1] + 5;\r\n                    }\r\n                    if (parent[parent.length - 1][1] === -1) {\r\n                        parent[parent.length - 1] = ["root", token.length];\r\n                    }\r\n                    if (preserve === true) {\r\n                        token.push(element);\r\n                        daddy.push(parent[parent.length - 1][0]);\r\n                        begin.push(parent[parent.length - 1][1]);\r\n                        stats.ignore[0] = stats.ignore[0] + 1;\r\n                        stats.ignore[1] = stats.ignore[1] + token[token.length - 1].length;\r\n                    } else {\r\n                        if (options.jsx === true) {\r\n                            token.push(element);\r\n                        } else {\r\n                            token.push(element.replace(/\\s+/g, " "));\r\n                        }\r\n                        daddy.push(parent[parent.length - 1][0]);\r\n                        begin.push(parent[parent.length - 1][1]);\r\n                        if (types[types.length - 1].indexOf("template") > -1) {\r\n                            stats.template[0] = stats.template[0] + 1;\r\n                            stats.template[1] = stats.template[1] + token[token.length - 1].length;\r\n                        } else if (types[types.length - 1].indexOf("linepreserve") > -1) {\r\n                            stats.ignore[0] = stats.ignore[0] + 1;\r\n                            stats.ignore[1] = stats.ignore[1] + token[token.length - 1].length;\r\n                        } else {\r\n                            stats[types[types.length - 1]][0] = stats[types[types.length - 1]][0] + 1;\r\n                            stats[types[types.length - 1]][1] = stats[types[types.length - 1]][1] +\r\n                                    token[token.length - 1].length;\r\n                        }\r\n                    }\r\n                    if (options.tagsort === true && types[types.length - 1] === "end" && types[types.length - 2] !== "start") {\r\n                        (function markuppretty__tokenize_tag_sorttag() {\r\n                            var children   = [],\r\n                                bb         = 0,\r\n                                d          = 0,\r\n                                endStore   = 0,\r\n                                startStore = 0,\r\n                                endData    = {},\r\n                                store      = {\r\n                                    attrs: [],\r\n                                    begin: [],\r\n                                    daddy: [],\r\n                                    jscom: [],\r\n                                    linen: [],\r\n                                    lines: [],\r\n                                    presv: [],\r\n                                    token: [],\r\n                                    types: [],\r\n                                    value: []\r\n                                },\r\n                                sortName   = function markuppretty__tokenize_tag_sorttag_sortName(x, y) {\r\n                                    if (token[x[0]] < token[y[0]]) {\r\n                                        return 1;\r\n                                    }\r\n                                    return -1;\r\n                                },\r\n                                pushy      = function markuppretty__tokenize_tag_sorttag_pushy(index) {\r\n                                    store\r\n                                        .attrs\r\n                                        .push(attrs[index]);\r\n                                    store\r\n                                        .begin\r\n                                        .push(begin[index]);\r\n                                    store\r\n                                        .daddy\r\n                                        .push(daddy[index]);\r\n                                    store\r\n                                        .jscom\r\n                                        .push(jscom[index]);\r\n                                    store\r\n                                        .linen\r\n                                        .push(linen[index]);\r\n                                    store\r\n                                        .lines\r\n                                        .push(lines[index]);\r\n                                    store\r\n                                        .presv\r\n                                        .push(presv[index]);\r\n                                    store\r\n                                        .token\r\n                                        .push(token[index]);\r\n                                    store\r\n                                        .types\r\n                                        .push(types[index]);\r\n                                    store\r\n                                        .value\r\n                                        .push(value[index]);\r\n                                };\r\n                            for (bb = token.length - 2; bb > -1; bb = bb - 1) {\r\n                                if (types[bb] === "start") {\r\n                                    d = d - 1;\r\n                                    if (d < 0) {\r\n                                        startStore = bb + 1;\r\n                                        break;\r\n                                    }\r\n                                } else if (types[bb] === "end") {\r\n                                    d = d + 1;\r\n                                    if (d === 1) {\r\n                                        endStore = bb;\r\n                                    }\r\n                                }\r\n                                if (d === 0) {\r\n                                    if (types[bb] === "start") {\r\n                                        children.push([bb, endStore]);\r\n                                    } else {\r\n                                        children.push([bb, bb]);\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (children.length < 2) {\r\n                                return;\r\n                            }\r\n                            children.sort(sortName);\r\n                            for (bb = children.length - 1; bb > -1; bb = bb - 1) {\r\n                                pushy(children[bb][0]);\r\n                                if (children[bb][0] !== children[bb][1]) {\r\n                                    for (d = children[bb][0] + 1; d < children[bb][1]; d = d + 1) {\r\n                                        pushy(d);\r\n                                    }\r\n                                    pushy(children[bb][1]);\r\n                                }\r\n                            }\r\n                            endData.attrs = attrs.pop();\r\n                            endData.begin = begin.pop();\r\n                            endData.daddy = daddy.pop();\r\n                            endData.jscom = jscom.pop();\r\n                            endData.linen = linen.pop();\r\n                            endData.lines = lines.pop();\r\n                            endData.presv = presv.pop();\r\n                            endData.token = token.pop();\r\n                            endData.types = types.pop();\r\n                            endData.value = value.pop();\r\n                            attrs         = attrs\r\n                                .slice(0, startStore)\r\n                                .concat(store.attrs);\r\n                            begin         = begin\r\n                                .slice(0, startStore)\r\n                                .concat(store.begin);\r\n                            daddy         = daddy\r\n                                .slice(0, startStore)\r\n                                .concat(store.daddy);\r\n                            jscom         = jscom\r\n                                .slice(0, startStore)\r\n                                .concat(store.jscom);\r\n                            linen         = linen\r\n                                .slice(0, startStore)\r\n                                .concat(store.linen);\r\n                            lines         = lines\r\n                                .slice(0, startStore)\r\n                                .concat(store.lines);\r\n                            presv         = presv\r\n                                .slice(0, startStore)\r\n                                .concat(store.presv);\r\n                            token         = token\r\n                                .slice(0, startStore)\r\n                                .concat(store.token);\r\n                            types         = types\r\n                                .slice(0, startStore)\r\n                                .concat(store.types);\r\n                            value         = value\r\n                                .slice(0, startStore)\r\n                                .concat(store.value);\r\n                            attrs.push(endData.attrs);\r\n                            begin.push(endData.begin);\r\n                            daddy.push(endData.daddy);\r\n                            jscom.push(endData.jscom);\r\n                            linen.push(endData.linen);\r\n                            lines.push(endData.lines);\r\n                            presv.push(endData.presv);\r\n                            token.push(endData.token);\r\n                            types.push(endData.types);\r\n                            value.push(endData.value);\r\n                        }());\r\n                    }\r\n                    e = token.length - 1;\r\n                    if (types[e] === "start") {\r\n                        parent.push([tname, e]);\r\n                    } else if (types[e] === "end" && parent.length > 1) {\r\n                        parent.pop();\r\n                    }\r\n                    if (options.attributetoken === true && options.mode === "parse") {\r\n                        attribute = Object.keys(attrs[e]);\r\n                        bcount    = attribute.length;\r\n                        if ((types[e] === "start" || types[e] === "singleton") && bcount > 0) {\r\n                            for (f = 0; f < bcount; f = f + 1) {\r\n                                attrs.push({});\r\n                                begin.push(begin[e]);\r\n                                if (daddy[e] === "root") {\r\n                                    daddy.push(tname);\r\n                                } else {\r\n                                    daddy.push(daddy[e]);\r\n                                }\r\n                                jscom.push(false);\r\n                                linen.push(linen[e]);\r\n                                lines.push(0);\r\n                                presv.push(presv[e]);\r\n                                token.push(attribute[f]);\r\n                                if (attribute[f] === "") {\r\n                                    types.push("template_attribute");\r\n                                    value.push("");\r\n                                } else {\r\n                                    types.push("attribute");\r\n                                    value.push(attrs[e][attribute[f]]);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                content       = function markuppretty__tokenize_content() {\r\n                    var lexer     = [],\r\n                        quote     = "",\r\n                        end       = "",\r\n                        square    = (\r\n                            types[types.length - 1] === "template_start" && token[token.length - 1].indexOf("<!") === 0 && token[token.length - 1].indexOf("<![") < 0 && token[token.length - 1].charAt(token[token.length - 1].length - 1) === "["\r\n                        ),\r\n                        tailSpace = function markuppretty__tokenize_content_tailSpace(spacey) {\r\n                            if (linepreserve > 0 && spacey.indexOf("\\n") < 0 && spacey.indexOf("\\r") < 0) {\r\n                                spacey = "";\r\n                            }\r\n                            space = spacey;\r\n                            return "";\r\n                        },\r\n                        esctest   = function markuppretty__tokenize_content_esctest() {\r\n                            var aa = 0,\r\n                                bb = 0;\r\n                            if (b[a - 1] !== "\\\\") {\r\n                                return false;\r\n                            }\r\n                            for (aa = a - 1; aa > -1; aa = aa - 1) {\r\n                                if (b[aa] !== "\\\\") {\r\n                                    break;\r\n                                }\r\n                                bb = bb + 1;\r\n                            }\r\n                            if (bb % 2 === 1) {\r\n                                return true;\r\n                            }\r\n                            return false;\r\n                        },\r\n                        name      = "";\r\n                    spacer();\r\n                    attrs.push({});\r\n                    jscom.push(false);\r\n                    linen.push(line);\r\n                    value.push("");\r\n                    if (linepreserve > 0) {\r\n                        presv.push(true);\r\n                    } else {\r\n                        presv.push(false);\r\n                    }\r\n                    if (ext === true) {\r\n                        name = tagName(token[token.length - 1]);\r\n                    }\r\n                    for (a = a; a < c; a = a + 1) {\r\n                        if (b[a] === "\\n") {\r\n                            line = line + 1;\r\n                        }\r\n                        // external code requires additional parsing to look for the appropriate end\r\n                        // tag, but that end tag cannot be quoted or commented\r\n                        if (ext === true) {\r\n                            if (quote === "") {\r\n                                if (b[a] === "/") {\r\n                                    if (b[a + 1] === "*") {\r\n                                        quote = "*";\r\n                                    } else if (b[a + 1] === "/") {\r\n                                        quote = "/";\r\n                                    } else if (name === "script" && "([{!=,;.?:&<>".indexOf(b[a - 1]) > -1) {\r\n                                        quote = "reg";\r\n                                    }\r\n                                } else if ((b[a] === "\\"" || b[a] === "\'" || b[a] === "`") && esctest() === false) {\r\n                                    quote = b[a];\r\n                                }\r\n                                end = b\r\n                                    .slice(a, a + 10)\r\n                                    .join("")\r\n                                    .toLowerCase();\r\n                                if (name === "cfscript" && end === "</cfscript") {\r\n                                    a   = a - 1;\r\n                                    ext = false;\r\n                                    if (lexer.length < 1) {\r\n                                        attrs.pop();\r\n                                        jscom.pop();\r\n                                        linen.pop();\r\n                                        presv.pop();\r\n                                        value.pop();\r\n                                        return lines.pop();\r\n                                    }\r\n                                    token.push(lexer.join("").replace(/^(\\s+)/, "").replace(/(\\s+)$/, ""));\r\n                                    daddy.push(parent[parent.length - 1][0]);\r\n                                    begin.push(parent[parent.length - 1][1]);\r\n                                    stats.script[0] = stats.script[0] + 1;\r\n                                    stats.script[1] = stats.script[1] + token[token.length - 1].length;\r\n                                    if (typeof global.prettydiff.jspretty === "function") {\r\n                                        return types.push(name);\r\n                                    }\r\n                                    return types.push("content");\r\n                                }\r\n                                if (name === "script") {\r\n                                    if (a === c - 9) {\r\n                                        end = end.slice(0, end.length - 1);\r\n                                    } else {\r\n                                        end = end.slice(0, end.length - 2);\r\n                                    }\r\n                                    if (end === "</script") {\r\n                                        a   = a - 1;\r\n                                        ext = false;\r\n                                        if (lexer.length < 1) {\r\n                                            attrs.pop();\r\n                                            jscom.pop();\r\n                                            linen.pop();\r\n                                            presv.pop();\r\n                                            value.pop();\r\n                                            return lines.pop();\r\n                                        }\r\n                                        token.push(lexer.join("").replace(/^(\\s+)/, "").replace(/(\\s+)$/, ""));\r\n                                        daddy.push(parent[parent.length - 1][0]);\r\n                                        begin.push(parent[parent.length - 1][1]);\r\n                                        stats.script[0] = stats.script[0] + 1;\r\n                                        stats.script[1] = stats.script[1] + token[token.length - 1].length;\r\n                                        if (typeof global.prettydiff.jspretty === "function") {\r\n                                            return types.push(name);\r\n                                        }\r\n                                        return types.push("content");\r\n                                    }\r\n                                }\r\n                                if (name === "style") {\r\n                                    if (a === c - 8) {\r\n                                        end = end.slice(0, end.length - 1);\r\n                                    } else if (a === c - 9) {\r\n                                        end = end.slice(0, end.length - 2);\r\n                                    } else {\r\n                                        end = end.slice(0, end.length - 3);\r\n                                    }\r\n                                    if (end === "</style") {\r\n                                        a   = a - 1;\r\n                                        ext = false;\r\n                                        if (lexer.length < 1) {\r\n                                            attrs.pop();\r\n                                            jscom.pop();\r\n                                            linen.pop();\r\n                                            presv.pop();\r\n                                            value.pop();\r\n                                            return lines.pop();\r\n                                        }\r\n                                        token.push(lexer.join("").replace(/^(\\s+)/, "").replace(/(\\s+)$/, ""));\r\n                                        daddy.push(parent[parent.length - 1][0]);\r\n                                        begin.push(parent[parent.length - 1][1]);\r\n                                        stats.style[0] = stats.style[0] + 1;\r\n                                        stats.style[1] = stats.style[1] + token[token.length - 1].length;\r\n                                        if (typeof global.prettydiff.csspretty === "function") {\r\n                                            return types.push(name);\r\n                                        }\r\n                                        return types.push("content");\r\n                                    }\r\n                                }\r\n                            } else if (quote === b[a] && (quote === "\\"" || quote === "\'" || quote === "`" || (quote === "*" && b[a + 1] === "/")) && esctest() === false) {\r\n                                quote = "";\r\n                            } else if (quote === "`" && b[a] === "$" && b[a + 1] === "{" && esctest() === false) {\r\n                                quote = "}";\r\n                            } else if (quote === "}" && b[a] === "}" && esctest() === false) {\r\n                                quote = "`";\r\n                            } else if (quote === "/" && (b[a] === "\\n" || b[a] === "\\r")) {\r\n                                quote = "";\r\n                            } else if (quote === "reg" && b[a] === "/" && esctest() === false) {\r\n                                quote = "";\r\n                            } else if (quote === "/" && b[a] === ">" && b[a - 1] === "-" && b[a - 2] === "-") {\r\n                                end = b\r\n                                    .slice(a + 1, a + 11)\r\n                                    .join("")\r\n                                    .toLowerCase();\r\n                                if (name === "cfscript" && end === "</cfscript") {\r\n                                    quote = "";\r\n                                }\r\n                                end = end.slice(0, end.length - 2);\r\n                                if (name === "script" && end === "</script") {\r\n                                    quote = "";\r\n                                }\r\n                                end = end.slice(0, end.length - 1);\r\n                                if (name === "style" && end === "</style") {\r\n                                    quote = "";\r\n                                }\r\n                            }\r\n                        }\r\n                        if (square === true && b[a] === "]") {\r\n                            a = a - 1;\r\n                            spacer();\r\n                            if (options.content === true) {\r\n                                token.push("text");\r\n                            } else if (options.textpreserve === true) {\r\n                                token.push(minspace + lexer.join(""));\r\n                                lines[lines.length - 1] = 0;\r\n                            } else if (linepreserve > 0) {\r\n                                token.push(minspace + lexer.join("").replace(/(\\s+)$/, tailSpace));\r\n                                lines[lines.length - 1] = 0;\r\n                            } else {\r\n                                token.push(lexer.join("").replace(/(\\s+)$/, tailSpace).replace(/\\s+/g, " "));\r\n                            }\r\n                            stats.content[0] = stats.content[0] + 1;\r\n                            stats.content[1] = stats.content[1] + token[token.length - 1].length;\r\n                            daddy.push(parent[parent.length - 1][0]);\r\n                            begin.push(parent[parent.length - 1][1]);\r\n                            return types.push("content");\r\n                        }\r\n\r\n                        if (ext === false && lexer.length > 0 && ((b[a] === "<" && b[a + 1] !== "=" && (/\\s|\\d/).test(b[a + 1]) === false) || (b[a] === "[" && b[a + 1] === "%") || (b[a] === "{" && (options.jsx === true || options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")))) {\r\n                            if (options.dustjs === true && b[a] === "{" && b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {\r\n                                a = a + 6;\r\n                                if (options.content === true) {\r\n                                    token.push("text");\r\n                                } else if (options.textpreserve === true) {\r\n                                    token.push(minspace + lexer.join(""));\r\n                                    lines[lines.length - 1] = 0;\r\n                                } else {\r\n                                    token.push(lexer.join("").replace(/(\\s+)$/, tailSpace).replace(/\\s+/g, " "));\r\n                                }\r\n                                stats.content[0] = stats.content[0] + 1;\r\n                                stats.content[1] = stats.content[1] + token[token.length - 1].length;\r\n                                types.push("content");\r\n                                spacer();\r\n                                attrs.push({});\r\n                                jscom.push(false);\r\n                                linen.push(line);\r\n                                presv.push(false);\r\n                                token.push("{:else}");\r\n                                value.push("");\r\n                                stats.template[0] = stats.template[0] + 1;\r\n                                stats.template[1] = stats.template[1] + token[token.length - 1].length;\r\n                                daddy.push(parent[parent.length - 1][0]);\r\n                                begin.push(parent[parent.length - 1][1]);\r\n                                return types.push("template_else");\r\n                            }\r\n                            a = a - 1;\r\n                            if (options.content === true) {\r\n                                token.push("text");\r\n                            } else if (options.textpreserve === true) {\r\n                                token.push(minspace + lexer.join(""));\r\n                                lines[lines.length - 1] = 0;\r\n                            } else if (linepreserve > 0) {\r\n                                token.push(minspace + lexer.join("").replace(/(\\s+)$/, tailSpace));\r\n                                lines[lines.length - 1] = 0;\r\n                            } else {\r\n                                token.push(lexer.join("").replace(/(\\s+)$/, tailSpace).replace(/\\s+/g, " "));\r\n                            }\r\n                            stats.content[0] = stats.content[0] + 1;\r\n                            stats.content[1] = stats.content[1] + token[token.length - 1].length;\r\n                            daddy.push(parent[parent.length - 1][0]);\r\n                            begin.push(parent[parent.length - 1][1]);\r\n                            return types.push("content");\r\n                        }\r\n                        lexer.push(b[a]);\r\n                    }\r\n                    spacer();\r\n                    if (options.content === true) {\r\n                        token.push("text");\r\n                    } else if (options.textpreserve === true) {\r\n                        token.push(minspace + lexer.join(""));\r\n                        lines[lines.length - 1] = 0;\r\n                    } else {\r\n                        token.push(lexer.join("").replace(/(\\s+)$/, tailSpace));\r\n                    }\r\n                    stats.content[0] = stats.content[0] + 1;\r\n                    stats.content[1] = stats.content[1] + token[token.length - 1].length;\r\n                    daddy.push(parent[parent.length - 1][0]);\r\n                    begin.push(parent[parent.length - 1][1]);\r\n                    return types.push("content");\r\n                };\r\n\r\n            for (a = 0; a < c; a = a + 1) {\r\n                if ((/\\s/).test(b[a]) === true) {\r\n                    space = space + b[a];\r\n                    if (b[a] === "\\n") {\r\n                        line = line + 1;\r\n                    }\r\n                } else if (ext === true) {\r\n                    content();\r\n                } else if (b[a] === "<") {\r\n                    tag("");\r\n                } else if (b[a] === "[" && b[a + 1] === "%") {\r\n                    tag("%]");\r\n                } else if (b[a] === "{" && (options.jsx === true || options.dustjs === true || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {\r\n                    tag("");\r\n                } else if (b[a] === "]" && sgmlflag > 0) {\r\n                    tag("]>");\r\n                } else if (b[a] === "-" && b[a + 1] === "-" && b[a + 2] === "-" && options.jekyll === true) {\r\n                    tag("---");\r\n                } else if (b[a] === "#" && options.apacheVelocity === true && (/\\d/).test(b[a + 1]) === false && (/\\s/).test(b[a + 1]) === false && ((/\\w/).test(b[a + 1]) === true || b[a + 1] === "*" || b[a + 1] === "#" || (b[a + 1] === "[" && b[a + 2] === "["))) {\r\n                    tag("");\r\n                } else if (b[a] === "$" && options.apacheVelocity === true && (/\\d/).test(b[a + 1]) === false && (/\\s/).test(b[a + 1]) === false && b[a + 1] !== "$" && b[a + 1] !== "=" && b[a + 1] !== "[") {\r\n                    tag("");\r\n                } else {\r\n                    content();\r\n                }\r\n            }\r\n            lines[0] = 0;\r\n        }());\r\n\r\n        if (token.length === 0) {\r\n            if (options.nodeasync === true) {\r\n                return [options.source, "Error: source does not appear to be markup."];\r\n            }\r\n            if (global.prettydiff.meta === undefined) {\r\n                global.prettydiff.meta = {};\r\n            }\r\n            global.prettydiff.meta.error = "Error: source does not appear to be markup.";\r\n            return options.source;\r\n        }\r\n\r\n        globalerror = (function markuppretty__globalerror() {\r\n            var startend = stats.start[0] - stats.end[0],\r\n                error    = "";\r\n            if (startend > 0) {\r\n                error = startend + " more start tag";\r\n                if (startend > 1) {\r\n                    error = error + "s";\r\n                }\r\n                error = error + " than start tag";\r\n                if (startend > 1) {\r\n                    error = error + "s";\r\n                }\r\n                error = error + "!";\r\n                return error;\r\n            } else if (startend < 0) {\r\n                startend = startend * -1;\r\n                error    = startend + " more end tag";\r\n                if (startend > 1) {\r\n                    error = error + "s";\r\n                }\r\n                error = error + " than start tag";\r\n                if (startend > 1) {\r\n                    error = error + "s";\r\n                }\r\n                error = error + "!";\r\n                return error;\r\n            } else {\r\n                return "";\r\n            }\r\n        }());\r\n\r\n        if (options.nodeasync === false) {\r\n            if (global.prettydiff.meta === undefined) {\r\n                global.prettydiff.meta       = {};\r\n                global.prettydiff.meta.error = "";\r\n            }\r\n            if (global.prettydiff.meta.error === "") {\r\n                global.prettydiff.meta.error = globalerror;\r\n            }\r\n        }\r\n\r\n        if (options.mode === "parse") {\r\n            return (function markuppretty__parse() {\r\n                var a        = 0,\r\n                    c        = token.length,\r\n                    record   = [],\r\n                    wspace   = "",\r\n                    data     = {},\r\n                    def      = {\r\n                        attrs: "array - List of attributes (if any) for the given token.",\r\n                        begin: "number - Index where the parent element occurs.",\r\n                        daddy: "string - Tag name of the parent element. Tokens of type \'template_start\' are n" +\r\n                                "ot considered as parent elements.  End tags reflect their matching start tag.",\r\n                        jscom: "boolean - Whether the token is a JavaScript comment if in JSX format.",\r\n                        linen: "number - The line number in the original source where the token started, which" +\r\n                                " is used for reporting and analysis.",\r\n                        lines: "number - Whether the token is preceeded any space and/or line breaks in the or" +\r\n                                "iginal code source.",\r\n                        presv: "boolean - Whether the token is preserved verbatim as found.  Useful for commen" +\r\n                                "ts and HTML \'pre\' tags.",\r\n                        token: "string - The parsed code tokens.",\r\n                        types: "string - Data types of the tokens: cdata, comment, conditional, content, end, " +\r\n                                "ignore, linepreserve, script, sgml, singleton, start, template, template_else," +\r\n                                " template_end, template_start, xml",\r\n                        value: "string - The attribute\'s value if the current type is attribute"\r\n                    },\r\n                    //white space token to insertion logic\r\n                    insert   = function markuppretty__parse_insert(string) {\r\n                        if (types[a] === "content") {\r\n                            token[a] = string + token[a];\r\n                            return;\r\n                        }\r\n                        if (types[a - 1] === "content" && token[a] !== "content") {\r\n                            token[a - 1] = token[a - 1] + string;\r\n                            return;\r\n                        }\r\n                        attrs.splice(a, 0, {});\r\n                        begin.splice(a, 0, begin[a]);\r\n                        daddy.splice(a, 0, daddy[a]);\r\n                        jscom.splice(a, 0, false);\r\n                        linen.splice(a, 0, linen[a]);\r\n                        lines.splice(a, 0, 1);\r\n                        presv.splice(a, 0, false);\r\n                        token.splice(a, 0, string);\r\n                        types.splice(a, 0, "content");\r\n                        value.splice(a, 0, "");\r\n                        c = c + 1;\r\n                        a = a + 1;\r\n                    },\r\n                    attApply = function markuppretty__parse_attApply(atty) {\r\n                        var string = "",\r\n                            xlen   = atty.length,\r\n                            xind   = 0,\r\n                            toke   = token[a],\r\n                            atts   = "";\r\n                        for (xind = 0; xind < xlen; xind = xind + 1) {\r\n                            if (attrs[a][atty[xind]] === "") {\r\n                                atts = atts + " " + atty[xind];\r\n                            } else {\r\n                                atts = atts + " " + atty[xind] + "=" + attrs[a][atty[xind]];\r\n                            }\r\n                        }\r\n                        if (presv[a] === true) {\r\n                            token[a] = toke.replace(" ", atts);\r\n                        } else {\r\n                            string   = ((/(\\/>)$/).test(toke) === true)\r\n                                ? "/>"\r\n                                : ">";\r\n                            xlen     = (string === "/>")\r\n                                ? 3\r\n                                : 2;\r\n                            token[a] = (toke.slice(0, toke.length - xlen) + atts + string);\r\n                        }\r\n                    };\r\n                if (options.attributetoken === true) {\r\n                    delete def.attrs;\r\n                } else {\r\n                    delete def.value;\r\n                }\r\n                for (a = 0; a < c; a = a + 1) {\r\n                    wspace = "";\r\n                    record = Object.keys(attrs[a]);\r\n                    if (record.length > 0 && options.unformatted === false) {\r\n                        attApply(record);\r\n                    }\r\n                    if (token[a] === "</prettydiffli>") {\r\n                        if (options.correct === true) {\r\n                            token[a] = "</li>";\r\n                        } else {\r\n                            attrs.splice(a, 1);\r\n                            begin.splice(a, 1);\r\n                            daddy.splice(a, 1);\r\n                            jscom.splice(a, 1);\r\n                            linen.splice(a, 1);\r\n                            lines.splice(a, 1);\r\n                            presv.splice(a, 1);\r\n                            token.splice(a, 1);\r\n                            types.splice(a, 1);\r\n                            value.splice(a, 1);\r\n                            a = a - 1;\r\n                            c = c - 1;\r\n                        }\r\n                    }\r\n                    if (options.parseFormat !== "htmltable") {\r\n                        if (types[a] === "script") {\r\n                            options.source = token[a];\r\n                            token[a]       = extlib("script");\r\n                        } else if (types[a] === "style") {\r\n                            options.source = token[a];\r\n                            token[a]       = extlib("style");\r\n                        }\r\n                    }\r\n                    if (options.parseSpace === true) {\r\n                        if (lines[a] > 1) {\r\n                            if (options.preserve > 1) {\r\n                                if (options.parseFormat === "htmltable") {\r\n                                    wspace = "(empty line)";\r\n                                } else {\r\n                                    wspace = lf + lf;\r\n                                }\r\n                            } else if (types[a] === "singleton" || types[a] === "content" || types[a] === "template") {\r\n                                wspace = " ";\r\n                            }\r\n                        } else if (lines[a] === 1) {\r\n                            if (types[a] === "singleton" || types[a] === "content" || types[a] === "template") {\r\n                                wspace = " ";\r\n                            } else if (types[a] !== types[a - 1] && (types[a - 1] === "singleton" || types[a - 1] === "content" || types[a - 1] === "template")) {\r\n                                wspace = " ";\r\n                            }\r\n                        }\r\n                        if (wspace !== "") {\r\n                            if (wspace === " " && options.parseFormat === "htmltable") {\r\n                                wspace = "(space)";\r\n                            }\r\n                            insert(wspace);\r\n                        }\r\n                    }\r\n                }\r\n                if (options.parseFormat === "sequential") {\r\n                    if (options.attributetoken === true) {\r\n                        def.order = "[token, types, value, lines, linen, jscom, presv, daddy, begin]";\r\n                    } else {\r\n                        def.order = "[token, types, attrs, lines, linen, jscom, presv, daddy, begin]";\r\n                    }\r\n                    for (a = 0; a < c; a = a + 1) {\r\n                        if (options.attributetoken === true) {\r\n                            record.push([\r\n                                token[a],\r\n                                types[a],\r\n                                value[a],\r\n                                lines[a],\r\n                                linen[a],\r\n                                jscom[a],\r\n                                presv[a],\r\n                                daddy[a],\r\n                                begin[a]\r\n                            ]);\r\n                        } else {\r\n                            record.push([\r\n                                token[a],\r\n                                types[a],\r\n                                attrs[a],\r\n                                lines[a],\r\n                                linen[a],\r\n                                jscom[a],\r\n                                presv[a],\r\n                                daddy[a],\r\n                                begin[a]\r\n                            ]);\r\n                        }\r\n                    }\r\n                    if (options.nodeasync === true) {\r\n                        return [\r\n                            {\r\n                                data      : record,\r\n                                definition: def\r\n                            },\r\n                            globalerror\r\n                        ];\r\n                    }\r\n                    return {data: record, definition: def};\r\n                }\r\n                if (options.parseFormat === "htmltable") {\r\n                    return (function markuppretty__parse_html() {\r\n                        var report = [],\r\n                            header = "<tr class=\\"header\\"><th>index</th><th>token</th><th>types</th>",\r\n                            aa     = 0,\r\n                            len    = 0;\r\n                        if (options.attributetoken === true) {\r\n                            header = header + "<th>value</th>";\r\n                        } else {\r\n                            header = header + "<th>attrs</th>";\r\n                        }\r\n                        header = header + "<th>linen</th><th>jscom</th><th>presv</th><th>daddy</th><th>" +\r\n                                "begin</th><th>lines</th></tr>";\r\n                        report.push("<table summary=\'markup parse table\'><thead>");\r\n                        report.push(header);\r\n                        report.push("</thead><tbody>");\r\n                        len = token.length;\r\n                        for (aa = 0; aa < len; aa = aa + 1) {\r\n                            if (types[aa] === "script") {\r\n                                options.source = token[aa];\r\n                                report.push("<tr><td colspan=\\"10\\" class=\\"nested\\">");\r\n                                report.push(extlib("script"));\r\n                                report.push("</td></tr>");\r\n                                report.push("<tr><th colspan=\\"10\\" class=\\"nested\\">Markup tokens</th></tr>");\r\n                                report.push(header);\r\n                            } else if (types[aa] === "style") {\r\n                                options.source = token[aa];\r\n                                report.push("<tr><td colspan=\\"10\\" class=\\"nested\\">");\r\n                                report.push(extlib("style"));\r\n                                report.push("</td></tr>");\r\n                                report.push("<tr><th colspan=\\"10\\" class=\\"nested\\">Markup tokens</th></tr>");\r\n                                report.push(header);\r\n                            } else {\r\n                                report.push("<tr><td>");\r\n                                report.push(aa);\r\n                                report.push("</td><td style=\\"white-space:pre\\">");\r\n                                report.push(\r\n                                    token[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\r\n                                );\r\n                                report.push("</td><td>");\r\n                                report.push(types[aa]);\r\n                                report.push("</td>");\r\n                                if (options.attributetoken === true) {\r\n                                    report.push("<td style=\\"white-space:pre\\">");\r\n                                    report.push(\r\n                                        value[aa].replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\r\n                                    );\r\n                                    report.push("</td><td>");\r\n                                } else {\r\n                                    report.push("<td style=\\"white-space:pre\\">");\r\n                                    report.push(\r\n                                        JSON.stringify(attrs[aa]).replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;")\r\n                                    );\r\n                                    report.push("</td><td>");\r\n                                }\r\n                                report.push(linen[aa]);\r\n                                report.push("</td><td>");\r\n                                report.push(jscom[aa]);\r\n                                report.push("</td><td>");\r\n                                report.push(presv[aa]);\r\n                                report.push("</td><td>");\r\n                                report.push(daddy[aa]);\r\n                                report.push("</td><td>");\r\n                                report.push(begin[aa]);\r\n                                report.push("</td><td>");\r\n                                report.push(lines[aa]);\r\n                                report.push("</td></tr>");\r\n                            }\r\n                        }\r\n                        report.push("</tbody></table>");\r\n                        if (options.nodeasync === true) {\r\n                            return [\r\n                                {\r\n                                    data      : report.join(""),\r\n                                    definition: def\r\n                                },\r\n                                globalerror\r\n                            ];\r\n                        }\r\n                        return {data: report.join(""), definition: def};\r\n                    }());\r\n                }\r\n                if (options.attributetoken === true) {\r\n                    data.value = value;\r\n                } else {\r\n                    data.attrs = attrs;\r\n                }\r\n                data.begin = begin;\r\n                data.daddy = daddy;\r\n                data.jscom = jscom;\r\n                data.linen = linen;\r\n                data.lines = lines;\r\n                data.presv = presv;\r\n                data.token = token;\r\n                data.types = types;\r\n                if (options.nodeasync === true) {\r\n                    return [\r\n                        {\r\n                            data      : data,\r\n                            definition: def\r\n                        },\r\n                        globalerror\r\n                    ];\r\n                }\r\n                return {data: data, definition: def};\r\n            }());\r\n        }\r\n\r\n        if (options.mode === "minify") {\r\n            (function markuppretty__minify() {\r\n                var a      = 0,\r\n                    c      = token.length,\r\n                    script = function markuppretty__minify_script() {\r\n                        options.source = token[a];\r\n                        token[a]       = extlib("script");\r\n                        level.push(-20);\r\n                    },\r\n                    style  = function markuppretty__minify_style() {\r\n                        options.source = token[a];\r\n                        token[a]       = extlib("style");\r\n                        level.push(-20);\r\n                    };\r\n                for (a = 0; a < c; a = a + 1) {\r\n                    if (types[a] === "script") {\r\n                        script();\r\n                    } else if (types[a] === "style") {\r\n                        style();\r\n                    } else if (lines[a] > 0) {\r\n                        if (types[a] === "singleton" || types[a] === "content" || types[a] === "template") {\r\n                            level.push(0);\r\n                        } else if (types[a - 1] === "singleton" || types[a - 1] === "content" || types[a] === "template") {\r\n                            level.push(0);\r\n                        } else {\r\n                            level.push(-20);\r\n                        }\r\n                    } else {\r\n                        level.push(-20);\r\n                    }\r\n                }\r\n            }());\r\n        }\r\n\r\n        output = (function markuppretty__beautify() {\r\n            var a            = 0,\r\n                c            = token.length,\r\n                lprescount   = [],\r\n                ltype        = "",\r\n                lline        = 0,\r\n                indent       = options.inlevel,\r\n                cdataS       = "",\r\n                cdataE       = "",\r\n                commentS     = "",\r\n                commentE     = "",\r\n                cdataStart   = (/^(\\s*(\\/)*<!?\\[+[A-Z]+\\[+)/),\r\n                cdataEnd     = (/((\\/)*\\]+>\\s*)$/),\r\n                commentStart = (/^(\\s*\x3c!--)/),\r\n                commentEnd   = (/((\\/\\/)?--\x3e\\s*)$/),\r\n                tabs         = "",\r\n                twigStart    = (/^(\\{%\\s+)/),\r\n                twigEnd      = (/(\\s%\\})$/),\r\n                xslline      = function markuppretty__beautify_xslline() {\r\n                    var tname = false;\r\n                    if (lines[a] > 1 || (types[a] !== "start" && types[a] !== "singleton") || (types[a - 1] === "comment" && lines[a - 1] > 1)) {\r\n                        return;\r\n                    }\r\n                    tname = (tagName(token[a]).indexOf("xsl:") === 0);\r\n                    if (tname === false) {\r\n                        return;\r\n                    }\r\n                    if (types[a] === "start") {\r\n                        lines[a] = 2;\r\n                    } else if (types[a - 1] !== "start" || types[a + 1] !== "end" || (types[a - 1] !== "start" && types[a + 1] !== "end")) {\r\n                        lines[a] = 2;\r\n                    }\r\n                },\r\n                tab          = (function markuppretty__beautify_tab() {\r\n                    var b   = options.insize,\r\n                        ind = [];\r\n                    for (b = b; b > 0; b = b - 1) {\r\n                        ind.push(options.inchar);\r\n                    }\r\n                    return new RegExp("^(" + ind.join("") + "+)");\r\n                }()),\r\n                end          = function markuppretty__beautify_end() {\r\n                    var b = 0;\r\n                    indent = indent - 1;\r\n                    if ((types[a] === "end" && ltype === "start") || (types[a] === "template_end" && ltype === "template_start") || (options.jsx === true && (/^\\s+\\{/).test(token[a - 1]) === true && lines[a] === 0)) {\r\n                        return level.push(-20);\r\n                    }\r\n                    if (lines[a] < 1 && options.html === true && a > 0 && tagName(token[a - 1]) === "/span") {\r\n                        b = a;\r\n                        do {\r\n                            b = b - 1;\r\n                        } while (lines[b] < 1);\r\n                        if (types[b] === "content" || types[b] === "singleton" || types[b] === "start" || types[b] === "comment" || types[b].indexOf("template") > -1) {\r\n                            level[a - 1] = -20;\r\n                            return level.push(-20);\r\n                        }\r\n                    }\r\n                    if (options.force_indent === false) {\r\n                        if (lines[a] === 0 && (ltype === "singleton" || ltype === "content" || (ltype === "template" && types[a] !== "template_end"))) {\r\n                            return level.push(-20);\r\n                        }\r\n                        if (ltype === "comment") {\r\n                            for (b = a - 1; b > -1; b = b - 1) {\r\n                                if (types[b] !== "comment") {\r\n                                    if (lines[b + 1] === 0 && (types[b] === "singleton" || types[b] === "content" || ltype === "template")) {\r\n                                        for (b = b + 1; b < a; b = b + 1) {\r\n                                            level[b] = -20;\r\n                                        }\r\n                                        return level.push(-20);\r\n                                    }\r\n                                    return level.push(indent);\r\n                                }\r\n                            }\r\n                        }\r\n                        return level.push(indent);\r\n                    }\r\n                    level.push(indent);\r\n                },\r\n                content      = function markuppretty__beautify_content() {\r\n                    var b       = 0,\r\n                        spanfix = function markuppretty__beautify_content_spanfix() {\r\n                            b = b - 1;\r\n                            if (types[b] === "comment") {\r\n                                do {\r\n                                    b = b - 1;\r\n                                } while (b > 0 && types[b] === "comment" && lines[b] < 1);\r\n                            }\r\n                            if (lines[b] === 0 && tagName(token[b]) === "span" && (tagName(token[b - 1]) === "span" || tagName(token[b - 1]) === "/span")) {\r\n                                do {\r\n                                    level[b] = -20;\r\n                                    b        = b - 1;\r\n                                } while (\r\n                                    b > 0 && lines[b] < 1 && (tagName(token[b]) === "span" || types[b] === "comment")\r\n                                );\r\n                            }\r\n                        };\r\n                    if (lines[a] === 0 && options.force_indent === false && (presv[a] === false || types[a] !== "content")) {\r\n                        if (ltype === "comment" && lline === 0) {\r\n                            for (b = a - 1; b > -1; b = b - 1) {\r\n                                if (types[b - 1] !== "comment" && types[b] === "comment") {\r\n                                    if (lines[b] === 0) {\r\n                                        for (b = b; b < a; b = b + 1) {\r\n                                            level[b] = -20;\r\n                                        }\r\n                                        if (options.html === true && tagName(token[begin[a]]) === "span") {\r\n                                            spanfix();\r\n                                        }\r\n                                        return level.push(-20);\r\n                                    }\r\n                                    return level.push(indent);\r\n                                }\r\n                                if (lines[b] > 0) {\r\n                                    return level.push(indent);\r\n                                }\r\n                            }\r\n                            return level.push(indent);\r\n                        }\r\n                        level.push(-20);\r\n                        if (options.html === true && begin[a] > -1 && tagName(token[begin[a]]) === "span") {\r\n                            b = a;\r\n                            spanfix();\r\n                        }\r\n                    } else {\r\n                        level.push(indent);\r\n                    }\r\n                },\r\n                script       = function markuppretty__beautify_script(twig) {\r\n                    var list    = [],\r\n                        source  = "",\r\n                        twigfix = function markuppretty__beautify_script_twigfix(item) {\r\n                            var fixnumb = function markupretty__beautify_script_twigfix_fixnumb(xx) {\r\n                                return xx.replace(". .", "..");\r\n                            };\r\n                            item = item\r\n                                .replace(tab, "")\r\n                                .replace(/\\)\\s*and\\s*\\(/g, ") and (")\r\n                                .replace(/in\\u0020?\\(?\\d+\\.\\u0020\\.\\d\\(?/g, fixnumb);\r\n                            if (options.correct === true) {\r\n                                item = item.replace(/;$/, "") + " %}";\r\n                            } else {\r\n                                item = item + " %}";\r\n                            }\r\n                            return "{% " + item;\r\n                        },\r\n                        inle    = options.inlevel,\r\n                        mode    = options.mode;\r\n                    if (twig === true) {\r\n                        options.twig = true;\r\n                        token[a]     = token[a]\r\n                            .replace(twigStart, "")\r\n                            .replace(twigEnd, "");\r\n                    }\r\n                    stats.script[0] = stats.script[0] + 1;\r\n                    stats.script[1] = stats.script[1] + token[a]\r\n                        .replace(/\\s+/g, " ")\r\n                        .length;\r\n                    if (cdataStart.test(token[a]) === true) {\r\n                        cdataS   = cdataStart\r\n                            .exec(token[a])[0]\r\n                            .replace(/^\\s+/, "") + lf;\r\n                        token[a] = token[a].replace(cdataStart, "");\r\n                    } else if (commentStart.test(token[a]) === true) {\r\n                        commentS = commentStart\r\n                            .exec(token[a])[0]\r\n                            .replace(/^\\s+/, "") + lf;\r\n                        token[a] = token[a].replace(commentStart, "");\r\n                    }\r\n                    if (cdataEnd.test(token[a]) === true) {\r\n                        cdataE   = cdataEnd.exec(token[a])[0];\r\n                        token[a] = token[a].replace(cdataEnd, "");\r\n                    } else if (commentEnd.test(token[a]) === true) {\r\n                        commentE = commentEnd.exec(token[a])[0];\r\n                        token[a] = token[a].replace(commentEnd, "");\r\n                    }\r\n                    source          = token[a].replace(/^(\\s+)/, "");\r\n                    options.source  = source;\r\n                    options.inlevel = (options.style === "noinde")\r\n                        ? 0\r\n                        : indent;\r\n                    options.mode    = "beautify";\r\n                    token[a]        = extlib("script");\r\n                    options.inlevel = inle;\r\n                    options.mode    = mode;\r\n                    options.twig    = false;\r\n                    list            = tab.exec(token[a]);\r\n                    if (list !== null) {\r\n                        tabs = list[0];\r\n                    }\r\n                    if (cdataS !== "") {\r\n                        token[a] = tabs + cdataS + token[a];\r\n                        cdataS   = "";\r\n                    } else if (commentS !== "") {\r\n                        token[a] = tabs + commentS + token[a];\r\n                        commentS = "";\r\n                    }\r\n                    if (cdataE !== "") {\r\n                        token[a] = token[a] + lf + tabs + cdataE;\r\n                        cdataE   = "";\r\n                    } else if (commentE !== "") {\r\n                        token[a] = token[a] + lf + tabs + commentE;\r\n                        commentE = "";\r\n                    }\r\n                    if ((/^(\\s+\\{)/).test(token[a]) === true && options.jsx === true) {\r\n                        if (ltype === "content" || ltype === "singleton" || ltype === "template") {\r\n                            token[a] = token[a].replace(/^(\\s+)/, "");\r\n                            if (lines[a] < 1) {\r\n                                level.push(-20);\r\n                            } else {\r\n                                level.push(-10);\r\n                            }\r\n                        } else {\r\n                            token[a] = token[a].replace(/^(\\s+)/, "");\r\n                            if (lines[a] === 0) {\r\n                                level.push(-20);\r\n                            } else {\r\n                                level.push(indent);\r\n                                token[a] = token[a].replace(/(\\r?\\n\\})$/, lf + tabs + "}");\r\n                            }\r\n                        }\r\n                        if (token[a].indexOf(";") < 0 && token[a].replace(/^(\\{\\s+)/, "").replace(/(\\s+\\})$/, "").indexOf("\\n") < 0) {\r\n                            token[a] = token[a]\r\n                                .replace(/^(\\{\\s+)/, "{")\r\n                                .replace(/(\\s+\\})$/, "}");\r\n                        }\r\n                    } else if (twig === true) {\r\n                        token[a] = twigfix(token[a]);\r\n                    } else if (twig === true && lines[a] === 0) {\r\n                        level.push(-20);\r\n                        types[a] = "singleton";\r\n                    } else {\r\n                        level.push(0);\r\n                    }\r\n                },\r\n                style        = function markuppretty__beautify_style() {\r\n                    var list = [],\r\n                        inle = options.inlevel,\r\n                        mode = options.mode;\r\n                    stats.style[0] = stats.style[0] + 1;\r\n                    stats.style[1] = stats.style[1] + token[a]\r\n                        .replace(/\\s+/g, " ")\r\n                        .length;\r\n                    if (cdataStart.test(token[a]) === true) {\r\n                        cdataS   = cdataStart\r\n                            .exec(token[a])[0]\r\n                            .replace(/^\\s+/, "") + lf;\r\n                        token[a] = token[a].replace(cdataStart, "");\r\n                    } else if (commentStart.test(token[a]) === true) {\r\n                        commentS = commentStart\r\n                            .exec(token[a])[0]\r\n                            .replace(/^\\s+/, "") + lf;\r\n                        token[a] = token[a].replace(commentStart, "");\r\n                    }\r\n                    if (cdataEnd.test(token[a]) === true) {\r\n                        cdataE   = cdataEnd.exec(token[a])[0];\r\n                        token[a] = token[a].replace(cdataEnd, "");\r\n                    } else if (commentEnd.test(token[a]) === true) {\r\n                        commentE = commentEnd.exec(token[a])[0];\r\n                        token[a] = token[a].replace(commentEnd, "");\r\n                    }\r\n                    options.inlevel = (options.style === "noindent")\r\n                        ? 0\r\n                        : indent;\r\n                    options.mode    = "beautify";\r\n                    options.source  = token[a].replace(/^(\\s+)/, "");\r\n                    token[a]        = extlib("style");\r\n                    options.inlevel = inle;\r\n                    options.mode    = mode;\r\n                    list            = tab.exec(token[a]);\r\n                    if (list !== null) {\r\n                        tabs = list[0];\r\n                    }\r\n                    if (cdataS !== "") {\r\n                        token[a] = tabs + cdataS + token[a];\r\n                        cdataS   = "";\r\n                    } else if (commentS !== "") {\r\n                        token[a] = tabs + commentS + token[a];\r\n                        commentS = "";\r\n                    }\r\n                    if (cdataE !== "") {\r\n                        token[a] = token[a] + lf + tabs + cdataE;\r\n                        cdataE   = "";\r\n                    } else if (commentE !== "") {\r\n                        token[a] = token[a] + lf + tabs + commentE;\r\n                        commentE = "";\r\n                    }\r\n                    token[a] = token[a].replace(/(\\s+)$/, "");\r\n                    level.push(0);\r\n                },\r\n                apply        = function markuppretty__beautify_apply() {\r\n                    var x            = 0,\r\n                        y            = level.length,\r\n                        build        = [],\r\n                        attrib       = [],\r\n                        //tab builds out the character sequence for one step of indentation\r\n                        ind          = (function markuppretty__beautify_apply_tab() {\r\n                            var aa   = 0,\r\n                                indy = [options.inchar],\r\n                                size = options.insize - 1;\r\n                            for (aa = 0; aa < size; aa = aa + 1) {\r\n                                indy.push(options.inchar);\r\n                            }\r\n                            return indy.join("");\r\n                        }()),\r\n                        // a new line character plus the correct amount of identation for the given line\r\n                        // of code\r\n                        nl           = function markuppretty__beautify_apply_nl(indy, item) {\r\n                            var aa          = 0,\r\n                                indentation = [lf];\r\n                            if (options.mode === "minify") {\r\n                                return build.push(lf);\r\n                            }\r\n                            if (indy === -10) {\r\n                                item.push(" ");\r\n                            } else if (indy > -9) {\r\n                                if (lines[x] > 1 && item === build) {\r\n                                    do {\r\n                                        lines[x] = lines[x] - 1;\r\n                                        indentation.push(lf);\r\n                                    } while (lines[x] > 1);\r\n                                }\r\n                                for (aa = 0; aa < indy; aa = aa + 1) {\r\n                                    indentation.push(ind);\r\n                                }\r\n                                item.push(indentation.join(""));\r\n                            }\r\n                        },\r\n                        // populates attributes onto start and singleton tags it also checks to see if a\r\n                        // tag or content should wrap\r\n                        wrapper      = function markuppretty__beautify_apply_wrapper() {\r\n                            var b      = 0,\r\n                                len    = 0,\r\n                                xlen   = 0,\r\n                                list   = attrib,\r\n                                lev    = level[x],\r\n                                atty   = "",\r\n                                string = "",\r\n                                indy   = "",\r\n                                name   = "",\r\n                                text   = [],\r\n                                tname  = tagName(token[x]);\r\n                            if (lev === -20) {\r\n                                b = x;\r\n                                do {\r\n                                    b    = b - 1;\r\n                                    lev  = level[b];\r\n                                    xlen = xlen + token[b].length;\r\n                                } while (lev === -20 && b > -1);\r\n                                if (lev === -20) {\r\n                                    lev = 1;\r\n                                }\r\n                            }\r\n                            if (lev === 0) {\r\n                                lev = lev + options.inlevel;\r\n                            }\r\n                            if (list.length > 0) {\r\n                                if (options.force_attribute === true) {\r\n                                    len = list.length;\r\n                                    text.push(list[0]);\r\n                                    if (len > 1) {\r\n                                        b = 1;\r\n                                        do {\r\n                                            nl(lev + 1, text);\r\n                                            text.push(list[b]);\r\n                                            b = b + 1;\r\n                                        } while (b < len);\r\n                                        b = 0;\r\n                                    }\r\n                                    atty = text.join("");\r\n                                    text = [];\r\n                                } else {\r\n                                    atty = list.join(" ");\r\n                                }\r\n                                if ((types[x] === "template_start" || types[x] === "template" || types[x] === "template_else") && options.jsx === false) {\r\n                                    len = list.length;\r\n                                    for (b = 0; b < len; b = b + 1) {\r\n                                        xlen = list[b].indexOf("{");\r\n                                        if (list[b].indexOf("}") > xlen && xlen > 0) {\r\n                                            options.source  = list[b].slice(xlen, list[b].indexOf("}") + 1);\r\n                                            options.inlevel = lev;\r\n                                            list[b]         = list[b].slice(0, xlen) + extlib("script").replace(/^(\\s+)/, "") +\r\n                                                    list[b].slice(list[b].indexOf("}") + 1);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                indy   = (function markuppretty__beautify_apply_wrapper_indy() {\r\n                                    var atline = lf,\r\n                                        atnum  = lev + 1;\r\n                                    do {\r\n                                        atline = atline + ind;\r\n                                        atnum  = atnum - 1;\r\n                                    } while (atnum > 0);\r\n                                    return atline;\r\n                                }());\r\n                                string = tagName(token[x]);\r\n                                len    = string.length + 3 + atty.length;\r\n                                if (token[x].charAt(token[x].length - 2) === "/") {\r\n                                    len = len + 1;\r\n                                }\r\n                                if (wrap === 0 || len <= wrap || tname === "cfset" || tname === "cfreturn" || tname === "cfif" || tname === "cfelseif") {\r\n                                    if (presv[x] === true) {\r\n                                        token[x] = token[x].replace(" ", " " + atty);\r\n                                    } else {\r\n                                        string = ((/(\\/>)$/).test(token[x]) === true)\r\n                                            ? "/>"\r\n                                            : ">";\r\n                                        xlen   = (string === "/>")\r\n                                            ? 3\r\n                                            : 2;\r\n                                        name   = token[x].slice(1, token[x].length - xlen);\r\n                                        if (options.force_attribute === true) {\r\n                                            token[x] = "<" + name + indy + atty + string;\r\n                                        } else {\r\n                                            token[x] = "<" + name + " " + atty + string;\r\n                                        }\r\n                                    }\r\n                                    if (types[x] === "singleton" || types[x] === "template") {\r\n                                        if (options.spaceclose === true) {\r\n                                            token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\r\n                                        } else {\r\n                                            token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\r\n                                        }\r\n                                    }\r\n                                    return;\r\n                                }\r\n                                text.push(token[x].slice(0, token[x].indexOf(" ")));\r\n                                len = list.length;\r\n                                for (b = 0; b < len; b = b + 1) {\r\n                                    nl(lev + 1, text);\r\n                                    text.push(list[b]);\r\n                                }\r\n                                text.push(token[x].slice(token[x].indexOf(" ") + 1));\r\n                                token[x] = text.join("");\r\n                                if (types[x] === "singleton" || types[x] === "template") {\r\n                                    if ((/(>\\}+\\/>)$/).test(token[x]) === true) {\r\n                                        b    = 0;\r\n                                        atty = lf;\r\n                                        if (lev > 1) {\r\n                                            do {\r\n                                                atty = atty + ind;\r\n                                                b    = b + 1;\r\n                                            } while (b < lev);\r\n                                            atty = atty + ind + "}" + atty + "/>";\r\n                                        } else {\r\n                                            atty = atty + "}/>";\r\n                                        }\r\n                                        token[x] = token[x].replace(/(\\u0020*\\}\\u0020*\\/>)$/, atty);\r\n                                    } else if (options.spaceclose === true) {\r\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\r\n                                    } else {\r\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                list = token[x]\r\n                                    .replace(/\\s+/g, " ")\r\n                                    .split(" ");\r\n                                len  = list.length;\r\n                                if (level[x] === -20 && types[x - 1] === "end") {\r\n                                    b   = x - 1;\r\n                                    lev = 1;\r\n                                    do {\r\n                                        b = b - 1;\r\n                                        if (types[b] === "start") {\r\n                                            lev = lev - 1;\r\n                                        } else if (types[b] === "end") {\r\n                                            lev = lev + 1;\r\n                                        }\r\n                                    } while (lev > 0 && b > 0);\r\n                                    lev = level[b];\r\n                                }\r\n                                for (b = 0; b < len; b = b + 1) {\r\n                                    string = string + list[b];\r\n                                    if (list[b + 1] !== undefined && string.length + list[b + 1].length + 1 > wrap - xlen) {\r\n                                        text.push(string);\r\n                                        xlen = 0;\r\n                                        if (level[x] === -20 && types[x - 1] !== "end") {\r\n                                            nl(lev + 1, text);\r\n                                        } else {\r\n                                            nl(lev, text);\r\n                                        }\r\n                                        string = "";\r\n                                    } else {\r\n                                        string = string + " ";\r\n                                    }\r\n                                }\r\n                                text.push(string.replace(/\\s$/, ""));\r\n                                token[x] = text.join("");\r\n                                if (types[x] === "singleton") {\r\n                                    if (options.spaceclose === true) {\r\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\r\n                                    } else {\r\n                                        token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\r\n                                    }\r\n                                }\r\n                            }\r\n                        },\r\n                        // JSX tags may contain comments, which are captured as attributes in this\r\n                        // parser.  These attributes demand unique care to be correctly applied.\r\n                        attrcom      = function markuppretty__beautify_apply_attrcom() {\r\n                            var toke  = token[x].split(" "),\r\n                                attr  = attrib,\r\n                                len   = attr.length,\r\n                                ilen  = 0,\r\n                                item  = [toke[0]],\r\n                                temp  = [],\r\n                                tempx = [],\r\n                                index = 0,\r\n                                b     = 0,\r\n                                xx    = 0,\r\n                                yy    = 0;\r\n                            nl(level[x], build);\r\n                            for (b = 0; b < len; b = b + 1) {\r\n                                index = attr[b].indexOf("\\n");\r\n                                if (index > 0 && index !== attr[b].length - 1 && attr[b].indexOf("/*") === 0) {\r\n                                    temp = (lf === "\\r\\n")\r\n                                        ? attr[b].split("\\r\\n")\r\n                                        : attr[b].split("\\n");\r\n                                    yy   = temp.length;\r\n                                    for (xx = 0; xx < yy; xx = xx + 1) {\r\n                                        if (temp[xx] === "") {\r\n                                            temp[xx] = lf;\r\n                                        } else {\r\n                                            nl(level[x] + 1, tempx);\r\n                                            tempx.push(temp[xx].replace(/^(\\s+)/, ""));\r\n                                        }\r\n                                    }\r\n                                    tempx.push(lf);\r\n                                    attr[b] = tempx.join("");\r\n                                }\r\n                                if (b > 0 && attr[b - 1].charAt(attr[b - 1].length - 1) === "\\n" && (/^(\\s*\\/\\/)/).test(attr[b]) === false) {\r\n                                    nl(level[x] + 1, item);\r\n                                    ilen       = item.length - 1;\r\n                                    item[ilen] = item[ilen].slice(1);\r\n                                } else if ((/^\\s/).test(attr[b]) === false && (/^(\\s*\\/\\/)/).test(attr[b - 1]) === false) {\r\n                                    item.push(" ");\r\n                                }\r\n                                item.push(attr[b]);\r\n                            }\r\n                            if (attr[len - 1].charAt(attr[len - 1].length - 1) === "\\n") {\r\n                                nl(level[x], item);\r\n                                ilen       = item.length - 1;\r\n                                item[ilen] = item[ilen].slice(1);\r\n                            }\r\n                            item.push(toke[1]);\r\n                            build.push(item.join(""));\r\n                        },\r\n                        jsxattribute = function markuppretty__beautify_apply_jsxattribute() {\r\n                            var attr     = Object.keys(attrs[x]),\r\n                                b        = 0,\r\n                                yy       = 0,\r\n                                xx       = attr.length,\r\n                                inlevel  = (level[x] < 1)\r\n                                    ? options.inlevel + 1\r\n                                    : level[x] + 1,\r\n                                builder  = "",\r\n                                inle     = options.inlevel,\r\n                                mode     = options.mode,\r\n                                vertical = options.vertical;\r\n                            for (b = 0; b < xx; b = b + 1) {\r\n                                if (attrs[x][attr[b]].charAt(0) === "{") {\r\n                                    options.mode      = "beautify";\r\n                                    options.inlevel   = inlevel;\r\n                                    options.source    = attrs[x][attr[b]].slice(1, attrs[x][attr[b]].length - 1);\r\n                                    options.vertical  = (\r\n                                        options.vertical === "jsonly" || options.vertical === true || options.vertical === "true"\r\n                                    );\r\n                                    attrs[x][attr[b]] = extlib("script");\r\n                                    options.mode      = mode;\r\n                                    options.inlevel   = inle;\r\n                                    options.vertical  = vertical;\r\n                                    attrib[b]         = attr[b] + "={" + attrs[x][attr[b]].replace(/^\\s+/, "") + "}";\r\n                                } else if (attr[b].charAt(0) === "/" && attr[b].charAt(1) === "/" && attr[b].charAt(attr[b].length - 1) === "\\n") {\r\n                                    builder = "";\r\n                                    yy      = inlevel;\r\n                                    do {\r\n                                        builder = builder + ind;\r\n                                        yy      = yy - 1;\r\n                                    } while (yy > 0);\r\n                                    if (b < attrib.length - 1) {\r\n                                        builder = lf + builder + attr[b].slice(0, attr[b].length - 1) + lf +\r\n                                                builder;\r\n                                    } else {\r\n                                        builder = lf + builder + attr[b].slice(0, attr[b].length - 1) + lf;\r\n                                    }\r\n                                    attrib[b] = builder;\r\n                                }\r\n                            }\r\n                        },\r\n                        linepreserve = function markuppretty__beautify_apply_linepreserve() {\r\n                            var str  = token[x]\r\n                                    .replace(/\\r\\n/g, "\\n")\r\n                                    .replace(/^(\\n)/, ""),\r\n                                item = str.split("\\n"),\r\n                                aa   = 0,\r\n                                bb   = item.length,\r\n                                out  = [],\r\n                                taby = new RegExp("^(" + ind + "+)");\r\n                            lines[x] = 1;\r\n                            for (aa = 0; aa < bb; aa = aa + 1) {\r\n                                item[aa] = item[aa]\r\n                                    .replace(/^(\\s+)/, "")\r\n                                    .replace(taby, "");\r\n                                if (item[aa] === "" && item[aa - 1] !== "" && aa < bb - 1) {\r\n                                    nl(0, out);\r\n                                } else if (item[aa] !== "") {\r\n                                    if (aa > 0) {\r\n                                        nl(level[x], out);\r\n                                    }\r\n                                    if (item[aa].indexOf(ind) === 0) {\r\n                                        do {\r\n                                            item[aa] = item[aa].slice(ind.length);\r\n                                        } while (item[aa].indexOf(ind) === 0);\r\n                                    }\r\n                                    out.push(item[aa].replace(/(\\s+)$/, ""));\r\n                                }\r\n                            }\r\n                            if (out[out.length - 1] === "") {\r\n                                out.pop();\r\n                            }\r\n                            if (types[x + 1] === "template_end" && out[out.length - 1].indexOf(ind) > 0 && (/^(\\s+)$/).test(out[out.length - 1]) === false) {\r\n                                out.pop();\r\n                            }\r\n                            token[x] = out.join("");\r\n                        },\r\n                        attArray     = function markuppretty__beautify_apply_attArray() {\r\n                            var list = Object.keys(attrs[x]),\r\n                                len  = list.length,\r\n                                b    = 0,\r\n                                attr = [];\r\n                            if (len < 1) {\r\n                                return [];\r\n                            }\r\n                            do {\r\n                                if (attrs[x][list[b]] === "") {\r\n                                    attr.push(list[b]);\r\n                                } else {\r\n                                    attr.push(list[b] + "=" + attrs[x][list[b]]);\r\n                                }\r\n                                b = b + 1;\r\n                            } while (b < len);\r\n                            return attr;\r\n                        };\r\n                    for (x = 0; x < y; x = x + 1) {\r\n                        attrib = attArray();\r\n                        if (options.jsx === true && attrib.length > 0) {\r\n                            jsxattribute();\r\n                        }\r\n                        if (jscom[x] === true) {\r\n                            attrcom();\r\n                        } else if (types[x] === "content" && x < y - 1) {\r\n                            if (presv[x] === true) {\r\n                                linepreserve();\r\n                            } else if (wrap > 0 && token[x].length > wrap && (options.mode === "beautify" || options.mode === "diff")) {\r\n                                wrapper();\r\n                            }\r\n                        } else if (types[x] !== "content" && options.unformatted === false && (options.mode === "beautify" || options.mode === "diff") && presv[x] === false && (attrib.length > 0 || (wrap > 0 && token[x].length > wrap)) && (types[x] === "content" || types[x] === "start" || types[x] === "singleton" || types[x] === "template_start" || types[x] === "template" || types[x] === "comment") && (types[x] !== "singleton" || token[x].charAt(0) !== "{")) {\r\n                            wrapper();\r\n                        } else if (options.unformatted === false && attrib.length > 0) {\r\n                            token[x] = token[x].replace(" ", " " + attrib.join(" "));\r\n                        } else if (types[x] === "singleton") {\r\n                            if (options.spaceclose === true) {\r\n                                token[x] = token[x].replace(/(\\u0020*\\/>)$/, " />");\r\n                            } else {\r\n                                token[x] = token[x].replace(/(\\u0020*\\/>)$/, "/>");\r\n                            }\r\n                        }\r\n                        if (token[x] === "</prettydiffli>" && options.correct === true) {\r\n                            token[x] = "</li>";\r\n                        }\r\n                        if (token[x] !== "</prettydiffli>" && jscom[x] === false) {\r\n                            if ((types[x] === "template" || types[x] === "template_start") && types[x - 1] === "content" && presv[x - 1] === true && options.mode === "beautify" && level[x] === -20) {\r\n                                build.push(" ");\r\n                            }\r\n                            if (level[x] > -9) {\r\n                                if (options.mode === "minify") {\r\n                                    build.push(" ");\r\n                                } else {\r\n                                    nl(level[x], build);\r\n                                }\r\n                            } else if (level[x] === -10) {\r\n                                build.push(" ");\r\n                            }\r\n                            build.push(token[x]);\r\n                        }\r\n                    }\r\n                    if (build[0] === lf || build[0] === " ") {\r\n                        build[0] = "";\r\n                    }\r\n                    if (options.newline === true) {\r\n                        if (options.crlf === true) {\r\n                            build.push("\\r\\n");\r\n                        } else {\r\n                            build.push("\\n");\r\n                        }\r\n                    }\r\n                    if (options.nodeasync === true) {\r\n                        return [build.join(""), globalerror];\r\n                    }\r\n                    return build.join("");\r\n                };\r\n\r\n            if (options.mode !== "minify") {\r\n                for (a = 0; a < c; a = a + 1) {\r\n                    if (twigStart.test(token[a]) === true && twigEnd.test(token[a]) === true && (a === 0 || (tagName(token[a - 1]) !== "script" && tagName(token[a - 1]) !== "style")) && (/\\D-+\\D/).test(token[a]) === false && (/^(\\{%\\s*((comment)|(else))\\s*)/).test(token[a]) === false) {\r\n                        script(true);\r\n                    }\r\n                    if (types[a] === "start") {\r\n                        level.push(indent);\r\n                        indent = indent + 1;\r\n                        xslline();\r\n                    } else if (types[a] === "template_start" || types[a] === "linepreserve") {\r\n                        if (types[a] === "linepreserve") {\r\n                            lprescount.push(tagName(token[a]));\r\n                        }\r\n                        level.push(indent);\r\n                        indent = indent + 1;\r\n                    } else if (types[a] === "template_else") {\r\n                        level.push(indent - 1);\r\n                    } else if (types[a] === "end") {\r\n                        end();\r\n                    } else if (types[a] === "template_end") {\r\n                        if (lprescount.length > 0 && tagName(token[a]) === "/" + lprescount[lprescount.length - 1]) {\r\n                            lprescount.pop();\r\n                        }\r\n                        end();\r\n                    } else if (lines[a] === 0 && (types[a] === "singleton" || types[a] === "content" || types[a] === "template")) {\r\n                        if (types[a] === "content" && options.textpreserve === true) {\r\n                            level.push(-20);\r\n                        } else {\r\n                            content();\r\n                        }\r\n                        xslline();\r\n                    } else if (types[a] === "script" || types[a] === "cfscript") {\r\n                        script(false);\r\n                    } else if (types[a] === "style") {\r\n                        style();\r\n                    } else if (types[a] === "comment" && options.comments === "noindent") {\r\n                        level.push(0);\r\n                    } else if (types[a] === "linepreserve") {\r\n                        level.push(indent);\r\n                    } else {\r\n                        level.push(indent);\r\n                        xslline();\r\n                    }\r\n                    if (types[a] !== "content" && types[a] !== "comment" && types[a - 1] === "content" && types[a - 2] !== "linepreserve" && lprescount.length > 0) {\r\n                        level[a] = -20;\r\n                    }\r\n                    if (lines[a] === 0 && (ltype === "content" || (ltype === "script" && token[a - 1].charAt(0) === "{" && options.jsx === true))) {\r\n                        level[a] = -20;\r\n                    }\r\n                    ltype = types[a];\r\n                    lline = lines[a];\r\n                }\r\n            }\r\n            level[0] = 0;\r\n            return apply();\r\n        }());\r\n\r\n        if (options.mode === "analysis") {\r\n            options.accessibility = true;\r\n            return (function markuppretty__beautify_apply_summary() {\r\n                var len           = token.length,\r\n                    sum           = [],\r\n                    data          = {\r\n                        violations: 0\r\n                    },\r\n                    numformat     = function markuppretty__beautify_apply_summary_numformat(x) {\r\n                        var y    = String(x).split(""),\r\n                            z    = 0,\r\n                            xlen = y.length,\r\n                            dif  = 0;\r\n                        if (xlen % 3 === 2) {\r\n                            dif = 2;\r\n                        } else if (xlen % 3 === 1) {\r\n                            dif = 1;\r\n                        }\r\n                        for (z = xlen - 1; z > 0; z = z - 1) {\r\n                            if ((z % 3) - dif === 0) {\r\n                                y[z] = "," + y[z];\r\n                            }\r\n                        }\r\n                        return y.join("");\r\n                    },\r\n                    analysis      = function markuppretty__beautify_apply_summary_analysis(arr) {\r\n                        var x       = arr.length,\r\n                            idtest  = (arr === ids),\r\n                            y       = 0,\r\n                            adata   = [],\r\n                            content = [];\r\n                        if (x > 0) {\r\n                            arr = safeSort(arr);\r\n                            for (y = 0; y < x; y = y + 1) {\r\n                                if (arr[y] === arr[y + 1]) {\r\n                                    if (idtest === true && (adata.length === 0 || adata[adata.length - 1][1] !== arr[y])) {\r\n                                        adata.push([\r\n                                            2, arr[y]\r\n                                        ]);\r\n                                    }\r\n                                    if (adata.length > 0) {\r\n                                        adata[adata.length - 1][0] = adata[adata.length - 1][0] + 1;\r\n                                    }\r\n                                } else if (idtest === false) {\r\n                                    adata.push([\r\n                                        1, arr[y]\r\n                                    ]);\r\n                                }\r\n                            }\r\n                            x = adata.length;\r\n                            if (idtest === true) {\r\n                                if (x === 0) {\r\n                                    return "";\r\n                                }\r\n                                content.push("<h4>Duplicate id attribute values</h4>");\r\n                            } else {\r\n                                content.push("<h4>HTTP requests:</h4>");\r\n                            }\r\n                            content.push("<ul>");\r\n                            for (y = 0; y < x; y = y + 1) {\r\n                                if (idtest === true && adata[y][0] > 1) {\r\n                                    data.violations = data.violations + (adata[y][0] - 1);\r\n                                }\r\n                                content.push("<li>");\r\n                                content.push(adata[y][0]);\r\n                                content.push("x - ");\r\n                                content.push(adata[y][1].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(\r\n                                    />/g,\r\n                                    "&gt;"\r\n                                ));\r\n                                content.push("</li>");\r\n                            }\r\n                            content.push("</ul>");\r\n                            return content.join("");\r\n                        }\r\n                        return "";\r\n                    },\r\n                    accessibility = (\r\n                        function markuppretty__beautify_apply_summary_accessibility() {\r\n                            var findings   = [],\r\n                                tagsbyname = function markuppretty__beautify_apply_summary_accessibility_tagsbyname() {\r\n                                    var b            = 0,\r\n                                        c            = 0,\r\n                                        x            = 0,\r\n                                        y            = 0,\r\n                                        z            = 0,\r\n                                        tagname      = "",\r\n                                        tabindex     = "",\r\n                                        alttest      = false,\r\n                                        id           = false,\r\n                                        fortest      = false,\r\n                                        hidden       = false,\r\n                                        html         = false,\r\n                                        headtest     = (/^(h\\d)$/),\r\n                                        obsoleteAttr = [\r\n                                            "alink",\r\n                                            "align",\r\n                                            "background",\r\n                                            "border",\r\n                                            "color",\r\n                                            "compact",\r\n                                            "face",\r\n                                            "height",\r\n                                            "language",\r\n                                            "link",\r\n                                            "nowrap",\r\n                                            "size",\r\n                                            "start",\r\n                                            "text",\r\n                                            "version",\r\n                                            "vlink",\r\n                                            "width"\r\n                                        ],\r\n                                        attr         = [],\r\n                                        formID       = [],\r\n                                        labelFor     = [],\r\n                                        nofor        = [],\r\n                                        namestack    = [];\r\n\r\n                                    // badnest - checks for improperly orderd tags [tagname, start index, end index]\r\n                                    data.badnest      = [];\r\n                                    // obsoleteTags - checks for obsolete or presentation only tag names of start\r\n                                    // and singleton tags token index\r\n                                    data.obsoleteTags = [];\r\n                                    // obsoleteAttr - checks for obsolete or presentation attribute names [token\r\n                                    // index, attr index]\r\n                                    data.obsoleteAttr = [];\r\n                                    // headings - stores heading tag data [token index, number from tag name, if\r\n                                    // violation]\r\n                                    data.headings     = [];\r\n                                    // emptyalt - if an img tag contains an alt attribute with no values token index\r\n                                    data.emptyalt     = [];\r\n                                    //noalt - if an img tag does not contain an alt attribute token index\r\n                                    data.noalt        = [];\r\n                                    //formNoId - if a form control is missing an id attribute token index\r\n                                    data.formNoId     = [];\r\n                                    // formNoLabel - if a form control is missing a binding to a label [token index,\r\n                                    // id attr index]\r\n                                    data.formNoLabel  = [];\r\n                                    // tabindex - identifies elements with a tabindex attribute [token index, if\r\n                                    // value is greater than 0]\r\n                                    data.tabindex     = [];\r\n                                    // htmllang - if there is an <html> tag does it contain a lang or xml:lang\r\n                                    // attribute? boolean\r\n                                    data.htmllang     = false;\r\n\r\n                                    c                 = token.length;\r\n                                    for (b = 0; b < c; b = b + 1) {\r\n                                        hidden  = false;\r\n                                        tagname = tagName(token[b]);\r\n                                        if ((types[b] === "start" || types[b] === "singleton") && (tagname === "font" || tagname === "center" || tagname === "basefont" || tagname === "b" || tagname === "i" || tagname === "u" || tagname === "small" || tagname === "big" || tagname === "blink" || tagname === "plaintext" || tagname === "spacer" || tagname === "strike" || tagname === "tt" || tagname === "xmp")) {\r\n                                            data\r\n                                                .obsoleteTags\r\n                                                .push(b);\r\n                                        } else {\r\n                                            if (types[b] === "start" && headtest.test(tagname) === true) {\r\n                                                z = Number(tagname.charAt(1));\r\n                                                if (data.headings.length > 0 && z - data.headings[data.headings.length - 1][1] > 1) {\r\n                                                    data.violations = data.violations + 1;\r\n                                                    data\r\n                                                        .headings\r\n                                                        .push([b, z, true]);\r\n                                                } else {\r\n                                                    data\r\n                                                        .headings\r\n                                                        .push([b, z, false]);\r\n                                                }\r\n                                            }\r\n                                            if (attrs[b].alt !== undefined && tagname === "img") {\r\n                                                alttest = true;\r\n                                                if (attrs[b].alt === "") {\r\n                                                    data\r\n                                                        .emptyalt\r\n                                                        .push(b);\r\n                                                }\r\n                                            }\r\n                                            if (attrs[b].for !== undefined && tagname === "label") {\r\n                                                labelFor.push(attrs[b].for);\r\n                                                fortest = true;\r\n                                            }\r\n                                            if (tagname === "select" || tagname === "input" || tagname === "textarea") {\r\n                                                if (typeof attrs[b].id === "string" || (tagname === "input" && typeof attrs[b].type === "string" && (attrs[b].type.toLowerCase() === "hidden" || attrs[b].type.toLowerCase() === "submit"))) {\r\n                                                    id = true;\r\n                                                    if (tagname === "input" && attrs[b].type === "hidden") {\r\n                                                        hidden = true;\r\n                                                    }\r\n                                                    if (typeof attrs[b].id === "string") {\r\n                                                        formID.push(b);\r\n                                                    }\r\n                                                } else {\r\n                                                    z = namestack.length;\r\n                                                    if (z > 0) {\r\n                                                        do {\r\n                                                            z = z - 1;\r\n                                                        } while (z > 0 && namestack[z][0] === "span");\r\n                                                        if (namestack[z][0] === "label") {\r\n                                                            hidden = true;\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                            } else if (tagname === "html") {\r\n                                                html = true;\r\n                                                if (typeof attrs[b].lang === "string" || typeof attrs[b]["xml:lang"] === "string") {\r\n                                                    data.htmllang = true;\r\n                                                }\r\n                                            }\r\n                                            if (data.obsoleteTags[data.obsoleteTags.length - 1] !== b) {\r\n                                                if (typeof attrs[b].name === "string" && tagname !== "meta" && tagname !== "iframe" && tagname !== "select" && tagname !== "input" && tagname !== "textarea") {\r\n                                                    data\r\n                                                        .obsoleteAttr\r\n                                                        .push([b, "name"]);\r\n                                                }\r\n                                                if (typeof attrs[b].type === "string" && tagname !== "script" && tagname !== "style" && tagname !== "input" && tagname !== "button" && tagname !== "link") {\r\n                                                    data\r\n                                                        .obsoleteAttr\r\n                                                        .push([b, "type"]);\r\n                                                }\r\n                                                if (typeof attrs[b].value === "string" && tagname !== "input" && tagname !== "option" && tagname !== "textarea" && tagname !== "button") {\r\n                                                    data\r\n                                                        .obsoleteAttr\r\n                                                        .push([b, "value"]);\r\n                                                }\r\n                                                z = obsoleteAttr.length;\r\n                                                for (y = 0; y < z; y = y + 1) {\r\n                                                    if (typeof attrs[b][obsoleteAttr[y]] === "string") {\r\n                                                        data\r\n                                                            .obsoleteAttr\r\n                                                            .push([\r\n                                                                b, obsoleteAttr[y]\r\n                                                            ]);\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            if (typeof attrs[b].tabindex === "string") {\r\n                                                tabindex = attrs[b]\r\n                                                    .tabindex\r\n                                                    .slice(1, attrs[b].tabindex.length - 1);\r\n                                                if (isNaN(tabindex) === true || Number(tabindex) > 0) {\r\n                                                    data\r\n                                                        .tabindex\r\n                                                        .push([b, true]);\r\n                                                    data.violations = data.violations + 1;\r\n                                                } else {\r\n                                                    data\r\n                                                        .tabindex\r\n                                                        .push([b, false]);\r\n                                                }\r\n                                            }\r\n                                            if (fortest === true) {\r\n                                                fortest = false;\r\n                                            } else if (tagname === "label") {\r\n                                                nofor.push(b);\r\n                                            }\r\n                                            if (id === true) {\r\n                                                id = false;\r\n                                            } else if (hidden === false && (tagname === "select" || tagname === "input" || tagname === "textarea")) {\r\n                                                data\r\n                                                    .formNoId\r\n                                                    .push(b);\r\n                                            }\r\n                                            if (alttest === true) {\r\n                                                alttest = false;\r\n                                            } else if (tagname === "img") {\r\n                                                data\r\n                                                    .noalt\r\n                                                    .push(b);\r\n                                            }\r\n                                        }\r\n                                        if (types[b] === "start" || types[b] === "template_start") {\r\n                                            namestack.push([tagname, b]);\r\n                                        } else if (types[b] === "end" || types[b] === "template_end") {\r\n                                            if (namestack.length > 0 && tagname !== "/" + namestack[namestack.length - 1][0]) {\r\n                                                namestack[namestack.length - 1].push(b);\r\n                                                data\r\n                                                    .badnest\r\n                                                    .push(namestack[namestack.length - 1]);\r\n                                            }\r\n                                            namestack.pop();\r\n                                        }\r\n                                    }\r\n                                    attr = [];\r\n                                    if (html === false) {\r\n                                        data.htmllang = true;\r\n                                    }\r\n                                    attr.push("<div id=\'a11y\'>");\r\n                                    //missing lang attribute\r\n                                    if (data.htmllang === false) {\r\n                                        data.violations = data.violations + 1;\r\n                                        attr.push(\r\n                                            "<div><h4>HTML tag is a <strong>missing</strong> lang or xml:lang attribute</h4>"\r\n                                        );\r\n                                        attr.push(\r\n                                            "<p>The lang attribute ensures the natural language is properly understood by a" +\r\n                                            "ssisting applications.</p></div>"\r\n                                        );\r\n                                    } else {\r\n                                        attr.push("<div><h4>HTML lang or xml:lang attribute is present</h4></div>");\r\n                                    }\r\n                                    //improperly nested tags\r\n                                    b               = data.badnest.length;\r\n                                    data.violations = data.violations + b;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        attr.push(b);\r\n                                        attr.push("</strong> improperly nested tag");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            "</h4> <p>Improperly nested tags produce unexpected behaviors.</p> <ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            attr.push(\r\n                                                token[data.badnest[x][2]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.badnest[x][2]]);\r\n                                            attr.push(" does not match start tag <code>");\r\n                                            attr.push(\r\n                                                token[data.badnest[x][1]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            attr.push("</code> from input line number ");\r\n                                            attr.push(linen[data.badnest[x][1]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push("<div><h4><strong>0</strong> improperly nested tags</h4>");\r\n                                        attr.push("<p>Improperly nested tags produce unexpected behaviors.</p></div>");\r\n                                    }\r\n                                    //obsolete tags\r\n                                    b               = data.obsoleteTags.length;\r\n                                    data.violations = data.violations + b;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        attr.push(b);\r\n                                        attr.push("</strong> obsolete HTML tag");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            "</h4> <p>Obsolete elements do not appropriately describe content.</p> <ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            attr.push(\r\n                                                token[data.obsoleteTags[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.obsoleteTags[x]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push("<div><h4><strong>0</strong> obsolete HTML tags</h4>");\r\n                                        attr.push("<p>Obsolete elements do not appropriately describe content.</p></div>");\r\n                                    }\r\n                                    //obsolete attributes\r\n                                    b = data.obsoleteAttr.length;\r\n                                    if (b > 0) {\r\n                                        z = 0;\r\n                                        attr.push("<div><h4><strong>");\r\n                                        y = attr.length;\r\n                                        attr.push("</strong> HTML tag");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            " containing obsolete or inappropriate attributes</h4> <p>Obsolete attributes d" +\r\n                                            "o not appropriately describe content.</p> <ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            tagname = token[data.obsoleteAttr[x][0]]\r\n                                                .replace(/&/g, "&amp;")\r\n                                                .replace(/</g, "&lt;")\r\n                                                .replace(/>/g, "&gt;")\r\n                                                .replace(\r\n                                                    attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x][1]],\r\n                                                    "<strong>" + attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x][1]] + "</stron" +\r\n                                                            "g>"\r\n                                                );\r\n                                            if (x < b - 1 && data.obsoleteAttr[x][0] === data.obsoleteAttr[x + 1][0]) {\r\n                                                do {\r\n                                                    tagname = tagname.replace(\r\n                                                        attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x + 1][1]],\r\n                                                        "<strong>" + attrs[data.obsoleteAttr[x][0]][data.obsoleteAttr[x + 1][1]] + "</s" +\r\n                                                                "trong>"\r\n                                                    );\r\n                                                    x       = x + 1;\r\n                                                } while (x < b - 1 && data.obsoleteAttr[x][0] === data.obsoleteAttr[x + 1][0]);\r\n                                            }\r\n                                            z = z + 1;\r\n                                            attr.push("<li><code>");\r\n                                            attr.push(tagname);\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.obsoleteAttr[x][0]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.splice(y, 0, z);\r\n                                        data.violations = data.violations + z;\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push(\r\n                                            "<div><h4><strong>0</strong> HTML tags containing obsolete or inappropriate attribut" +\r\n                                            "es</h4>"\r\n                                        );\r\n                                        attr.push("<p>Obsolete attributes do not appropriately describe content.</p></div>");\r\n                                    }\r\n                                    //form controls missing a required \'id\' attribute\r\n                                    b               = data.formNoId.length;\r\n                                    data.violations = data.violations + b;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        attr.push(b);\r\n                                        attr.push("</strong> form control element");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            " missing a required <em>id</em> attribute</h4> <p>The id attribute is required" +\r\n                                            " to bind a point of interaction to an HTML label.</p> <ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            attr.push(\r\n                                                token[data.formNoId[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.formNoId[x]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push(\r\n                                            "<div><h4><strong>0</strong> form control elements missing a required <em>id</em> at" +\r\n                                            "tribute</h4> <p>The id attribute is required to bind a point of interaction to" +\r\n                                            " an HTML label.</p></div>"\r\n                                        );\r\n                                    }\r\n                                    //form controls missing a binding to a label\r\n                                    b                = formID.length;\r\n                                    data.formNoLabel = [];\r\n                                    for (x = 0; x < b; x = x + 1) {\r\n                                        for (y = labelFor.length - 1; y > -1; y = y - 1) {\r\n                                            if (attrs[formID[x]].id === labelFor[y]) {\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        if (y < 0) {\r\n                                            data\r\n                                                .formNoLabel\r\n                                                .push(formID[x]);\r\n                                        }\r\n                                    }\r\n                                    b               = data.formNoLabel.length;\r\n                                    data.violations = data.violations + b;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        attr.push(b);\r\n                                        attr.push("</strong> form control element");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            " not bound to a label</h4> <p>The <em>id</em> of a form control must match the" +\r\n                                            " <em>for</em> of a label.</p><ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            attr.push(\r\n                                                token[data.formNoLabel[x][0]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.formNoLabel[x][0]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push(\r\n                                            "<div><h4><strong>0</strong> form control elements not bound to a label</h4> <p>The " +\r\n                                            "<em>id</em> of a form control must match the <em>for</em> of a label.</p></div>"\r\n                                        );\r\n                                    }\r\n                                    //elements with tabindex\r\n                                    b = data.tabindex.length;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        y = attr.length;\r\n                                        z = 0;\r\n                                        attr.push(0);\r\n                                        attr.push("</strong> <em>tabindex</em>");\r\n                                        attr.push(" violation");\r\n                                        attr.push(\r\n                                            "</h4> <p>The tabindex attribute should have a 0 or -1 value and should not be " +\r\n                                            "over used. Only tabindexes with a value greater than 0 are counted as violatio" +\r\n                                            "ns, but every element with a tabindex attribute is listed to quickly indicate " +\r\n                                            "if it used excessively.</p> <ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            if (data.tabindex[x][1] === true) {\r\n                                                attr.push("<strong>");\r\n                                                z = z + 1;\r\n                                            }\r\n                                            attr.push(\r\n                                                token[data.tabindex[x][0]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            if (data.tabindex[x][1] === true) {\r\n                                                attr.push("</strong>");\r\n                                            }\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.tabindex[x][0]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr[y] = z;\r\n                                        if (z !== 1) {\r\n                                            attr[y + 2] = attr[y + 2] + "s";\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push(\r\n                                            "<div><h4><strong>0</strong> elements with a <em>tabindex</em> attribute</h4> <p>The" +\r\n                                            " tabindex attribute should have a 0 or -1 value and should not be over used.</" +\r\n                                            "p></div>"\r\n                                        );\r\n                                    }\r\n                                    //headings\r\n                                    b = data.headings.length;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        attr.push(b);\r\n                                        attr.push("</strong> HTML heading tag");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            " and their order</h4> <p>Poorly ordered tags are described with a <strong>stro" +\r\n                                            "ng</strong> tag (color red).</p> <ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            if (data.headings[x][2] === true) {\r\n                                                attr.push("<strong>");\r\n                                            }\r\n                                            attr.push(\r\n                                                token[data.headings[x][0]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            if (data.headings[x][2] === true) {\r\n                                                attr.push("</strong>");\r\n                                            }\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.headings[x][0]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push("<div><h4><strong>0</strong> HTML heading elements</h4>");\r\n                                        attr.push(\r\n                                            "<p>When heading tags are present it is important they are properly ordered so " +\r\n                                            "that the content they describe can be navigated in the proper order.</p></div>"\r\n                                        );\r\n                                    }\r\n                                    //missing alt attributes on images\r\n                                    b               = data.noalt.length;\r\n                                    data.violations = data.violations + b;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        attr.push(b);\r\n                                        attr.push("</strong> image");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            " missing a required <em>alt</em> attribute</h4> <p>The alt attribute is requir" +\r\n                                            "ed even if it contains no value.</p> <ol>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            attr.push(\r\n                                                token[data.noalt[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.noalt[x]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push(\r\n                                            "<div><h4><strong>0</strong> images missing a required <em>alt</em> attribute</h4> <" +\r\n                                            "p>The alt attribute is required even if it contains no value.</p></div>"\r\n                                        );\r\n                                    }\r\n                                    //alt attributes with empty values\r\n                                    b               = data.emptyalt.length;\r\n                                    data.violations = data.violations + b;\r\n                                    if (b > 0) {\r\n                                        attr.push("<div><h4><strong>");\r\n                                        attr.push(b);\r\n                                        attr.push("</strong> image");\r\n                                        if (b > 1) {\r\n                                            attr.push("s");\r\n                                        }\r\n                                        attr.push(\r\n                                            " have an empty <em>alt</em> attribute value</h4> <p>Empty alt text is not nece" +\r\n                                            "ssarily a violation, such as the case of tracking pixels. If an image has embe" +\r\n                                            "dded text this content should be supplied in the alt attribute.</p>"\r\n                                        );\r\n                                        for (x = 0; x < b; x = x + 1) {\r\n                                            attr.push("<li><code>");\r\n                                            attr.push(\r\n                                                token[data.emptyalt[x]].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")\r\n                                            );\r\n                                            attr.push("</code> on input line number ");\r\n                                            attr.push(linen[data.emptyalt[x]]);\r\n                                            attr.push("</li>");\r\n                                        }\r\n                                        attr.push("</ol></div>");\r\n                                    } else {\r\n                                        attr.push(\r\n                                            "<div><h4><strong>0</strong> images have an empty <em>alt</em> attribute value</h4>"\r\n                                        );\r\n                                        attr.push(\r\n                                            "<p>Empty alt text is not necessarily a violation, such as the case of tracking" +\r\n                                            " pixels. If an image has embedded text this content should be supplied in the " +\r\n                                            "alt attribute.</p></div>"\r\n                                        );\r\n                                    }\r\n                                    attr.push("</div>");\r\n                                    return attr.join("");\r\n                                };\r\n                            if (options.accessibility === false) {\r\n                                return "";\r\n                            }\r\n                            findings.push(tagsbyname());\r\n                            return findings.join("");\r\n                        }()\r\n                    ),\r\n                    parseErrors   = (function markuppretty__beautify_apply_summary_parseErrors() {\r\n                        var x     = parseError.length,\r\n                            y     = 0,\r\n                            fails = [];\r\n                        data.violations = data.violations + x;\r\n                        if (parseError.length > 1) {\r\n                            globalerror = parseError[0].replace(options.functions.binaryCheck, "");\r\n                        }\r\n                        if (x === 0) {\r\n                            return "";\r\n                        }\r\n                        fails.push("<h4><strong>");\r\n                        fails.push(x);\r\n                        fails.push("</strong> errors interpreting markup</h4> <ol>");\r\n                        for (y = 0; y < x; y = y + 1) {\r\n                            fails.push("<li>");\r\n                            fails.push(\r\n                                parseError[y].replace(options.functions.binaryCheck, "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace("element: ", "element: <code>")\r\n                            );\r\n                            fails.push("</code></li>");\r\n                        }\r\n                        fails.push("</ol>");\r\n                        return fails.join("");\r\n                    }()),\r\n                    sizes         = (function markuppretty__beautify_apply_summary_sizes() {\r\n                        var table      = [],\r\n                            outlines   = output\r\n                                .split(lf)\r\n                                .length,\r\n                            outsize    = output.length,\r\n                            linechange = (outlines / line) * 100,\r\n                            charchange = (outsize / sourceSize) * 100;\r\n                        table.push("<h4>Data sizes</h4>");\r\n                        table.push(\r\n                            "<table class=\'analysis\' summary=\'Data sizes\'><caption>This table shows changes" +\r\n                            " in sizes of the data due to beautification.</caption>"\r\n                        );\r\n                        table.push(\r\n                            "<thead><tr><th>Data figure</th><th>Input</th><th>Output</th><th>Percent change" +\r\n                            "</th></tr></thead><tbody>"\r\n                        );\r\n                        table.push("<tr><th>Lines of code</th><td>");\r\n                        table.push(numformat(line));\r\n                        table.push("</td><td>");\r\n                        table.push(numformat(outlines));\r\n                        table.push("</td><td>");\r\n                        table.push(linechange.toFixed(2));\r\n                        table.push("%</td></tr>");\r\n                        table.push("<tr><th>Character size</th><td>");\r\n                        table.push(numformat(sourceSize));\r\n                        table.push("</td><td>");\r\n                        table.push(numformat(outsize));\r\n                        table.push("</td><td>");\r\n                        table.push(charchange.toFixed(2));\r\n                        table.push("%</td></tr>");\r\n                        table.push("</tbody></table>");\r\n                        return table.join("");\r\n                    }()),\r\n                    statistics    = (function markuppretty__beautify_apply_summary_statistics() {\r\n                        var stat       = [],\r\n                            totalItems = stats.cdata[0] + stats.comment[0] + stats.content[0] + stats.end[0] +\r\n                                    stats.ignore[0] + stats.script[0] + stats.sgml[0] + stats.singleton[0] +\r\n                                    stats.start[0] + stats.style[0] + stats.template[0] + stats.text[0] + stats.xml[0],\r\n                            totalSizes = stats.cdata[1] + stats.comment[1] + stats.content[1] + stats.end[1] +\r\n                                    stats.ignore[1] + stats.script[1] + stats.sgml[1] + stats.singleton[1] +\r\n                                    stats.start[1] + stats.style[1] + stats.template[1] + stats.text[1] + stats.xml[1],\r\n                            rowBuilder = function markuppretty__beautify_apply_summary_statistics_rowBuilder(\r\n                                type\r\n                            ) {\r\n                                var itema = (type === "Total*")\r\n                                        ? totalItems\r\n                                        : stats[type][0],\r\n                                    itemb = (type === "Total*")\r\n                                        ? totalSizes\r\n                                        : stats[type][1],\r\n                                    ratio = 0;\r\n                                stat.push("<tr><th>");\r\n                                stat.push(type);\r\n                                if (itema > 0 && (type === "script" || type === "style")) {\r\n                                    stat.push("**");\r\n                                }\r\n                                stat.push("</th><td");\r\n                                if ((globalerror.indexOf(" more start tag") || globalerror.indexOf(" more end tag")) && (type === "start" || type === "end")) {\r\n                                    stat.push(" class=\\"bad\\"");\r\n                                }\r\n                                stat.push(">");\r\n                                stat.push(itema);\r\n                                stat.push("</td><td>");\r\n                                ratio = ((itema / totalItems) * 100);\r\n                                stat.push(ratio.toFixed(2));\r\n                                stat.push("%</td><td>");\r\n                                stat.push(itemb);\r\n                                stat.push("</td><td");\r\n                                if (itema > 0 && (type === "script" || type === "style")) {\r\n                                    stat.push(" class=\'bad\'");\r\n                                }\r\n                                stat.push(">");\r\n                                ratio = ((itemb / totalSizes) * 100);\r\n                                stat.push(ratio.toFixed(2));\r\n                                stat.push("%</td></tr>");\r\n                            };\r\n                        stat.push("<h4>Statistics and analysis of parsed code</h4>");\r\n                        stat.push(\r\n                            "<table class=\'analysis\' summary=\'Statistics\'><caption>This table provides basi" +\r\n                            "c statistics about the parsed components of the given code sample after beauti" +\r\n                            "fication.</caption>"\r\n                        );\r\n                        stat.push(\r\n                            "<thead><tr><th>Item type</th><th>Number of instances</th><th>Percentage of tot" +\r\n                            "al items</th><th>Character size</th><th>Percentage of total size</th></tr></th" +\r\n                            "ead>"\r\n                        );\r\n                        stat.push("<tbody>");\r\n                        rowBuilder("Total*");\r\n                        rowBuilder("cdata");\r\n                        rowBuilder("comment");\r\n                        rowBuilder("content");\r\n                        rowBuilder("end");\r\n                        rowBuilder("ignore");\r\n                        rowBuilder("script");\r\n                        rowBuilder("sgml");\r\n                        rowBuilder("singleton");\r\n                        rowBuilder("start");\r\n                        rowBuilder("style");\r\n                        rowBuilder("template");\r\n                        rowBuilder("text");\r\n                        rowBuilder("xml");\r\n                        stat.push("<tr><th>space between tags***</th><td colspan=\'4\'>");\r\n                        stat.push(stats.space);\r\n                        stat.push("</td></tr>");\r\n                        stat.push("</tbody></table> ");\r\n                        stat.push(\r\n                            "<p>* Totals are accounted for parsed code/content tokens only and not extraneo" +\r\n                            "us space for beautification.</p> "\r\n                        );\r\n                        stat.push(\r\n                            "<p>** Script and Style code is measured with minimal white space.</p>"\r\n                        );\r\n                        stat.push(\r\n                            "<p>*** This is space that is not associated with text, tags, script, or css.</" +\r\n                            "p> "\r\n                        );\r\n                        return stat.join("");\r\n                    }()),\r\n                    zipf          = (function markuppretty__beautify_apply_summary_zipf() {\r\n                        var x          = 0,\r\n                            ratio      = 0,\r\n                            wordlen    = 0,\r\n                            wordcount  = 0,\r\n                            word       = "",\r\n                            wordlist   = [],\r\n                            wordtotal  = [],\r\n                            wordproper = [],\r\n                            zipfout    = [],\r\n                            identical  = true,\r\n                            sortchild  = function markuppretty__beautify_apply_summary_zipf_sortchild(y, z) {\r\n                                return z[0] - y[0];\r\n                            };\r\n                        for (x = x; x < len; x = x + 1) {\r\n                            if (types[x] === "content") {\r\n                                wordlist.push(token[x]);\r\n                            }\r\n                        }\r\n                        wordlist = safeSort(\r\n                            wordlist.join(" ").replace(options.functions.binaryCheck, "").toLowerCase().replace(/&nbsp;/gi, " ").replace(/(,|\\.|\\?|!|:|\\(|\\)|"|\\{|\\}|\\[|\\])/g, "").replace(/\\s+/g, " ").replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").split(" ")\r\n                        );\r\n                        wordlen  = wordlist.length;\r\n                        for (x = 0; x < wordlen; x = x + 1) {\r\n                            word = wordlist[x];\r\n                            if (word.length > 2 && word.length < 30 && (/&#?\\w+;/).test(word) === false && word !== "the" && word !== "and" && word !== "for" && word !== "are" && word !== "this" && word !== "from" && word !== "with" && word !== "that" && word !== "to") {\r\n                                if (wordproper.length === 0 || word !== wordproper[wordproper.length - 1][1]) {\r\n                                    wordproper.push([1, word]);\r\n                                } else {\r\n                                    wordproper[wordproper.length - 1][0] = wordproper[wordproper.length - 1][0] + 1;\r\n                                }\r\n                            }\r\n                            if (word !== wordlist[x - 1]) {\r\n                                wordtotal.push([1, word]);\r\n                            } else {\r\n                                wordtotal[wordtotal.length - 1][0] = wordtotal[wordtotal.length - 1][0] + 1;\r\n                            }\r\n                        }\r\n                        wordtotal  = wordtotal\r\n                            .sort(sortchild)\r\n                            .slice(0, 11);\r\n                        wordproper = wordproper\r\n                            .sort(sortchild)\r\n                            .slice(0, 11);\r\n                        wordlen    = (wordproper.length > 10)\r\n                            ? 11\r\n                            : wordproper.length;\r\n                        for (x = 0; x < wordlen; x = x + 1) {\r\n                            if (wordtotal[x][1] !== wordproper[x][1]) {\r\n                                identical = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        wordlen = (wordtotal.length > 10)\r\n                            ? 10\r\n                            : wordtotal.length;\r\n                        if (wordlen > 1) {\r\n                            wordcount = wordlist.length;\r\n                            zipfout.push("<h4>Zipf\'s Law analysis of content</h4>");\r\n                            zipfout.push(\r\n                                "<table class=\'analysis\' summary=\'Zipf&#39;s Law\'><caption>This table demonstra" +\r\n                                "tes <em>Zipf&#39;s Law</em> by listing the 10 most occuring words in the conte" +\r\n                                "nt and the number of times they occurred.</caption>"\r\n                            );\r\n                            zipfout.push(\r\n                                "<thead><tr><th>Word Rank</th><th>Most Occurring Word by Rank</th><th>Number of" +\r\n                                " Instances</th><th>Ratio Increased Over Next Most Frequence Occurance</th><th>" +\r\n                                "Percentage from "\r\n                            );\r\n                            zipfout.push(wordcount);\r\n                            zipfout.push(" total words</th></tr></thead><tbody>");\r\n                            if (identical === false) {\r\n                                zipfout.push("<tr><th colspan=\'5\'>Unfiltered Word Set</th></tr>");\r\n                            }\r\n                            for (x = 0; x < wordlen; x = x + 1) {\r\n                                ratio = (wordtotal[x + 1] !== undefined)\r\n                                    ? (wordtotal[x][0] / wordtotal[x + 1][0])\r\n                                    : 1;\r\n                                zipfout.push("<tr><td>");\r\n                                zipfout.push(x + 1);\r\n                                zipfout.push("</td><td>");\r\n                                zipfout.push(wordtotal[x][1]);\r\n                                zipfout.push("</td><td>");\r\n                                zipfout.push(wordtotal[x][0]);\r\n                                zipfout.push("</td><td>");\r\n                                zipfout.push(ratio.toFixed(2));\r\n                                zipfout.push("</td><td>");\r\n                                ratio = ((wordtotal[x][0] / wordcount) * 100);\r\n                                zipfout.push(ratio.toFixed(2));\r\n                                zipfout.push("%</td></tr>");\r\n                            }\r\n                            wordlen = (wordproper.length > 10)\r\n                                ? 10\r\n                                : wordproper.length;\r\n                            if (wordlen > 1 && identical === false) {\r\n                                zipfout.push("<tr><th colspan=\'5\'>Filtered Word Set</th></tr>");\r\n                                for (x = 0; x < wordlen; x = x + 1) {\r\n                                    ratio = (wordproper[x + 1] !== undefined)\r\n                                        ? (wordproper[x][0] / wordproper[x + 1][0])\r\n                                        : 1;\r\n                                    zipfout.push("<tr><td>");\r\n                                    zipfout.push(x + 1);\r\n                                    zipfout.push("</td><td>");\r\n                                    zipfout.push(wordproper[x][1]);\r\n                                    zipfout.push("</td><td>");\r\n                                    zipfout.push(wordproper[x][0]);\r\n                                    zipfout.push("</td><td>");\r\n                                    zipfout.push(ratio.toFixed(2));\r\n                                    zipfout.push("</td><td>");\r\n                                    ratio = ((wordproper[x][0] / wordcount) * 100);\r\n                                    zipfout.push(ratio.toFixed(2));\r\n                                    zipfout.push("%</td></tr>");\r\n                                }\r\n                            }\r\n                            zipfout.push("</tbody></table>");\r\n                        }\r\n                        return zipfout.join("");\r\n                    }());\r\n\r\n                sum.push(\r\n                    "<p><strong>Total number of HTTP requests (presuming HTML or XML Schema):</stro" +\r\n                    "ng> <em>"\r\n                );\r\n                sum.push(reqs.length);\r\n                sum.push("</em></p>");\r\n                sum.push("<div class=\'report\'>");\r\n                sum.push(analysis(ids));\r\n                sum.push(sizes);\r\n                sum.push(parseErrors);\r\n                if (options.accessibility === true) {\r\n                    sum.push(accessibility);\r\n                }\r\n                sum.push(statistics);\r\n                sum.push(analysis(reqs));\r\n                sum.push(zipf);\r\n                sum.push("</div>");\r\n                if (options.accessibility === true) {\r\n                    if (options.nodeasync === true) {\r\n                        return [\r\n                            sum\r\n                                .join("")\r\n                                .replace(\r\n                                    "<div class=\'report\'>",\r\n                                    "<p><strong>Total potential accessibility violations:</strong> <em>" + data.violations +\r\n                                            "</em></p> <div class=\'report\'>"\r\n                                ),\r\n                            globalerror\r\n                        ];\r\n                    }\r\n                    return sum\r\n                        .join("")\r\n                        .replace(\r\n                            "<div class=\'report\'>",\r\n                            "<p><strong>Total potential accessibility violations:</strong> <em>" + data.violations +\r\n                                    "</em></p> <div class=\'report\'>"\r\n                        );\r\n                }\r\n                if (options.nodeasync === true) {\r\n                    return [sum.join(""), globalerror];\r\n                }\r\n                return sum.join("");\r\n            }());\r\n        }\r\n        return output;\r\n    };\r\n    if ((typeof define === "object" || typeof define === "function") && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        //requirejs support\r\n        define(function markuppretty_requirejs() {\r\n            return function markuppretty_requirejs_wrapper(x) {\r\n                return markuppretty(x);\r\n            };\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports = markuppretty;\r\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n            (function glib_markuppretty() {\r\n                var localPath = (\r\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\r\n                )\r\n                    ? __dirname\r\n                    : ".";\r\n                if (global.prettydiff.csspretty === undefined) {\r\n                    global.prettydiff.csspretty = require(\r\n                        localPath + "/csspretty.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.jspretty === undefined) {\r\n                    global.prettydiff.jspretty = require(\r\n                        localPath + "/jspretty.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.safeSort === undefined) {\r\n                    global.prettydiff.safeSort = require(\r\n                        localPath + "/safeSort.js"\r\n                    );\r\n                }\r\n            }());\r\n        }\r\n    } else {\r\n        global.prettydiff.markuppretty = markuppretty;\r\n    }\r\n}());\r\n'},function(n,e){n.exports='/*prettydiff.com topcoms: true, insize: 4, inchar: " ", vertical: true */\r\n/*jshint laxbreak: true*/\r\n/*global __dirname, ace, console, define, global, module, options, performance, process, require */\r\n/*\r\n\r\n Execute in a NodeJS app:\r\n\r\n    var prettydiff = require("prettydiff"),\r\n        args       = {\r\n            source: "asdf",\r\n            diff  : "asdd",\r\n            lang  : "text"\r\n        },\r\n        output     = prettydiff(args);\r\n\r\n Execute on command line with NodeJS:\r\n\r\n    node api/node-local.js source:"c:\\mydirectory\\myfile.js" readmethod:"file" diff:"c:\\myotherfile.js"\r\n\r\n Execute from JavaScript:\r\n    var global = {},\r\n        args   = {\r\n            source: "asdf",\r\n            diff  : "asdd",\r\n            lang  : "text"\r\n        },\r\n        output = prettydiff(args);\r\n\r\n Manage with biddle\r\n     biddle install http://prettydiff.com/downloads/prettydiff/prettydiff_latest.zip\r\n     biddle global prettydiff\r\n     prettydiff source:"c:\\mydirectory\\myfile.js" readmethod:"file" diff:"c:\\myotherfile.js"\r\n\r\n Please see the license.txt file associated with the Pretty Diff\r\n application for license information.\r\n\r\n Special thanks to:\r\n\r\n * Harry Whitfield for the numerous test cases provided against\r\n JSPretty.  http://g6auc.me.uk/\r\n\r\n * Andreas Greuel for contributing samples to test diffview.js\r\n https://plus.google.com/105958105635636993368/posts\r\n\r\n */\r\n(function prettydiff_init() {\r\n    "use strict";\r\n    var prettydiff = function prettydiff_(api) {\r\n        var startTime = Date.now(),\r\n            core      = function core_(api) {\r\n                var spacetest    = (/^\\s+$/g),\r\n                    apioutput    = "",\r\n                    apidiffout   = "",\r\n                    metaerror    = "",\r\n                    finalFile    = global.prettydiff.finalFile,\r\n                    options      = global\r\n                        .prettydiff\r\n                        .options\r\n                        .functions\r\n                        .validate(api),\r\n                    jspretty     = function core__jspretty() {\r\n                        var jsout = global\r\n                            .prettydiff\r\n                            .jspretty(options);\r\n                        if (options.nodeasync === true) {\r\n                            metaerror = jsout[1];\r\n                            return jsout[0];\r\n                        }\r\n                        metaerror = global.prettydiff.meta.error;\r\n                        return jsout;\r\n                    },\r\n                    markuppretty = function core__markuppretty() {\r\n                        var markout = global\r\n                            .prettydiff\r\n                            .markuppretty(options);\r\n                        if (options.nodeasync === true) {\r\n                            metaerror = markout[1];\r\n                            if (options.mode === "beautify" && options.inchar !== "\\t") {\r\n                                markout[0] = markout[0].replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\r\n                            } else if (options.mode === "diff") {\r\n                                markout[0] = markout[0].replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\r\n                            }\r\n                            return markout[0];\r\n                        }\r\n                        metaerror = global.prettydiff.meta.error;\r\n                        if (options.mode === "beautify" && options.inchar !== "\\t") {\r\n                            markout = markout.replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\r\n                        } else if (options.mode === "diff") {\r\n                            markout = markout.replace(/\\r?\\n[\\t]*\\u0020\\/>/g, "");\r\n                        }\r\n                        return markout;\r\n                    },\r\n                    csspretty    = function core__markupcss() {\r\n                        var cssout = global\r\n                            .prettydiff\r\n                            .csspretty(options);\r\n                        if (options.nodeasync === true) {\r\n                            metaerror = cssout[1];\r\n                            return cssout[0];\r\n                        }\r\n                        metaerror = global.prettydiff.meta.error;\r\n                        return cssout;\r\n                    },\r\n                    proctime     = function core__proctime() {\r\n                        var minuteString = "",\r\n                            hourString   = "",\r\n                            minutes      = 0,\r\n                            hours        = 0,\r\n                            elapsed      = (Date.now() - startTime) / 1000,\r\n                            secondString = elapsed + "",\r\n                            plural       = function core__proctime_plural(x, y) {\r\n                                var a = x + y;\r\n                                if (x !== 1) {\r\n                                    a = a + "s";\r\n                                }\r\n                                if (y !== " second") {\r\n                                    a = a + " ";\r\n                                }\r\n                                return a;\r\n                            },\r\n                            minute       = function core__proctime_minute() {\r\n                                minutes      = parseInt((elapsed / 60), 10);\r\n                                minuteString = plural(minutes, " minute");\r\n                                minutes      = elapsed - (minutes * 60);\r\n                                secondString = (minutes === 1)\r\n                                    ? "1 second"\r\n                                    : minutes.toFixed(3) + " seconds";\r\n                            };\r\n                        if (elapsed >= 60 && elapsed < 3600) {\r\n                            minute();\r\n                        } else if (elapsed >= 3600) {\r\n                            hours      = parseInt((elapsed / 3600), 10);\r\n                            hourString = hours.toString();\r\n                            elapsed    = elapsed - (hours * 3600);\r\n                            hourString = plural(hours, " hour");\r\n                            minute();\r\n                        } else {\r\n                            secondString = plural(secondString, " second");\r\n                        }\r\n                        return hourString + minuteString + secondString;\r\n                    },\r\n                    output       = function core__output(finalProduct, difftotal, difflines) {\r\n                        var meta         = {\r\n                                difflines: 0,\r\n                                difftotal: 0,\r\n                                error    : "",\r\n                                insize   : 0,\r\n                                lang     : [\r\n                                    "", "", ""\r\n                                ],\r\n                                outsize  : 0,\r\n                                time     : ""\r\n                            };\r\n                        meta.lang   = options.autoval;\r\n                        meta.time   = proctime();\r\n                        meta.insize = (options.mode === "diff")\r\n                            ? options.source.length + options.diff.length\r\n                            : options.source.length;\r\n                        if (options.mode === "parse" && options.lang !== "text" && typeof finalProduct === "object" && (options.autoval[0] !== "" || options.lang !== "auto")) {\r\n                            if (options.parseFormat === "sequential" || options.parseFormat === "htmltable") {\r\n                                meta.outsize = finalProduct.data.length;\r\n                            } else {\r\n                                meta.outsize = finalProduct.data.token.length;\r\n                            }\r\n                        } else {\r\n                            meta.outsize = finalProduct.length;\r\n                        }\r\n                        if (options.autoval[0] === "text" && options.mode !== "diff") {\r\n                            if (options.autoval[2] === "unknown") {\r\n                                meta.error = "Language is set to auto, but could not be detected. File not parsed.";\r\n                            } else {\r\n                                meta.error = "Language is set to text, but plain text is only supported in diff mode. File n" +\r\n                                        "ot parsed.";\r\n                            }\r\n                        }\r\n                        if (difftotal !== undefined) {\r\n                            meta.difftotal = difftotal;\r\n                        }\r\n                        if (difflines !== undefined) {\r\n                            meta.difflines = difflines;\r\n                        }\r\n                        meta.error = metaerror;\r\n                        if (options.nodeasync === true) {\r\n                            return [finalProduct, meta];\r\n                        }\r\n                        global.prettydiff.meta = meta;\r\n                        return finalProduct;\r\n                    };\r\n                if (options.source === "" && (options.mode === "beautify" || options.mode === "minify" || options.mode === "analysis" || (options.mode === "diff" && options.diffcli === false) || (options.mode === "parse" && options.parseFormat === "htmltable"))) {\r\n                    metaerror = "options.source is empty!";\r\n                    console.log(metaerror);\r\n                    return output("", 0, 0);\r\n                }\r\n                if (options.mode === "diff" && options.diffcli === false) {\r\n                    if (options.diff === "") {\r\n                        metaerror = "options.mode is \'diff\' and options.diff is empty!";\r\n                        console.log(metaerror);\r\n                        return output("", 0, 0);\r\n                    }\r\n                    if (options.lang === "csv") {\r\n                        options.lang = "text";\r\n                    }\r\n                }\r\n                if (options.autoval[0] === "text" && options.mode !== "diff") {\r\n                    metaerror = "Language is either text or undetermined, but text is only allowed for the \'dif" +\r\n                            "f\' mode!";\r\n                    return output(options.source, 0, 0);\r\n                }\r\n                finalFile.order[7] = options.color;\r\n                if (options.mode === "diff") {\r\n                    options.vertical = false;\r\n                    options.jsscope  = "none";\r\n                    options.preserve = 0;\r\n                    if (options.diffcomments === false) {\r\n                        options.comments = "nocomment";\r\n                    }\r\n                    if (options.lang === "css") {\r\n                        apioutput      = csspretty();\r\n                        options.source = options.diff;\r\n                        apidiffout     = csspretty();\r\n                    } else if (options.lang === "csv") {\r\n                        apioutput  = global\r\n                            .prettydiff\r\n                            .csvpretty(options);\r\n                        apidiffout = global\r\n                            .prettydiff\r\n                            .csvpretty(options);\r\n                    } else if (options.lang === "markup") {\r\n                        apioutput      = markuppretty();\r\n                        options.source = options.diff;\r\n                        apidiffout     = markuppretty();\r\n                    } else if (options.lang === "text") {\r\n                        apioutput  = options.source;\r\n                        apidiffout = options.diff;\r\n                    } else {\r\n                        apioutput      = jspretty();\r\n                        options.source = options.diff;\r\n                        apidiffout     = jspretty();\r\n                    }\r\n                    if (options.quote === true) {\r\n                        apioutput  = apioutput.replace(/\'/g, "\\"");\r\n                        apidiffout = apidiffout.replace(/\'/g, "\\"");\r\n                    }\r\n                    if (options.semicolon === true) {\r\n                        apioutput  = apioutput\r\n                            .replace(/;\\r\\n/g, "\\r\\n")\r\n                            .replace(/;\\n/g, "\\n");\r\n                        apidiffout = apidiffout\r\n                            .replace(/;\\r\\n/g, "\\r\\n")\r\n                            .replace(/;\\n/g, "\\n");\r\n                    }\r\n                    if (options.sourcelabel === "" || spacetest.test(options.sourcelabel)) {\r\n                        options.sourcelabel = "Base Text";\r\n                    }\r\n                    if (options.difflabel === "" || spacetest.test(options.difflabel)) {\r\n                        options.difflabel = "New Text";\r\n                    }\r\n                    if (options.jsx === true) {\r\n                        options.autoval = ["jsx", "javascript", "React JSX"];\r\n                    }\r\n                    return (function core__diff() {\r\n                        var a = "";\r\n                        options.diff   = apidiffout;\r\n                        options.source = apioutput;\r\n                        if (options.diffcli === true) {\r\n                            a = global.prettydiff.diffview(options);\r\n                            return output(a[0], a[1], a[2]);\r\n                        }\r\n                        if (apioutput === "Error: This does not appear to be JavaScript." || apidiffout === "Error: This does not appear to be JavaScript.") {\r\n                            return output(\r\n                                "<p><strong>Error:</strong> Please try using the option labeled <em>Plain Text " +\r\n                                "(diff only)</em>. <span style=\'display:block\'>The input does not appear to be " +\r\n                                "markup, CSS, or JavaScript.</span></p>", 0, 0\r\n                            );\r\n                        }\r\n                        if (options.lang === "text") {\r\n                            options.inchar = "";\r\n                        }\r\n                        a = global\r\n                            .prettydiff\r\n                            .diffview(options);\r\n                        if (options.jsx === true) {\r\n                            options.autoval = ["jsx", "javascript", "React JSX"];\r\n                        }\r\n                        if (options.api === "") {\r\n                            finalFile.order[10] = a[0];\r\n                            finalFile.order[12] = finalFile.script.diff;\r\n                            return output(finalFile.order.join(""), a[1], a[2]);\r\n                        }\r\n                        return output(a[0], a[1], a[2]);\r\n                    }());\r\n                } else {\r\n                    if (options.mode === "analysis") {\r\n                        options.accessibility = true;\r\n                    }\r\n                    if (options.lang === "css") {\r\n                        apioutput = csspretty();\r\n                    } else if (options.lang === "csv") {\r\n                        apioutput = global\r\n                            .prettydiff\r\n                            .csvpretty(options);\r\n                    } else if (options.lang === "markup") {\r\n                        apioutput = markuppretty();\r\n                    } else if (options.lang === "text") {\r\n                        apioutput  = options.source;\r\n                        apidiffout = "";\r\n                    } else {\r\n                        apioutput = jspretty();\r\n                    }\r\n                    if (options.api === "") {\r\n                        if (options.mode === "analysis" || (options.mode === "parse" && options.parseFormat === "htmltable")) {\r\n                            finalFile.order[10] = apidiffout;\r\n                            apioutput           = finalFile\r\n                                .order\r\n                                .join("");\r\n                        } else if (options.mode === "beautify" && options.jsscope !== "none" && (options.lang === "javascript" || options.lang === "json")) {\r\n                            finalFile.order[10] = apidiffout;\r\n                            finalFile.order[12] = finalFile.script.beautify;\r\n                            apioutput           = finalFile\r\n                                .order\r\n                                .join("");\r\n                        }\r\n                    }\r\n                    if (options.jsx === true) {\r\n                        options.autoval = ["jsx", "javascript", "React JSX"];\r\n                    }\r\n                    return output(apioutput, 0, 0);\r\n                }\r\n            };\r\n        return core(api);\r\n    };\r\n\r\n    if (typeof global.prettydiff !== "object") {\r\n        global.prettydiff = {};\r\n    }\r\n    if (typeof global.prettydiff.meta !== "object") {\r\n        // schema for global.prettydiff.meta lang - array, language detection time -\r\n        // string, proctime (total execution time minus visual rendering) insize -\r\n        // number, input size outsize - number, output size difftotal - number,\r\n        // difference count difflines - number, difference lines\r\n        global.prettydiff.meta = {\r\n            difflines: 0,\r\n            difftotal: 0,\r\n            error    : "",\r\n            insize   : 0,\r\n            lang     : [\r\n                "", "", ""\r\n            ],\r\n            outsize  : 0,\r\n            time     : ""\r\n        };\r\n    }\r\n    if (typeof process === "object" && Array.isArray(process.argv) === true && process.argv[1].replace(/\\\\/g, "/").replace(".js", "").split("prettydiff/prettydiff")[1] === "") {\r\n        return console.log("This file \\u001b[31m\\u001b[1mdoes not execute from the command line\\u001b[0m\\u001b[39m.  Use \\u001b[32mapi/node-local.js\\u001b[39m instead.");\r\n    }\r\n    if (typeof define === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n        define(function prettydiff_requirejs() {\r\n            return function prettydiff_requirejs_wrapper(x) {\r\n                return prettydiff(x);\r\n            };\r\n        });\r\n    } else if (typeof module === "object" && typeof module.parent === "object") {\r\n        //commonjs and nodejs support\r\n        module.exports         = function commonjs_prettydiff(x) {\r\n            return prettydiff(x);\r\n        };\r\n        module.exports.edition = global.prettydiff.edition;\r\n        module.exports.meta    = global.prettydiff.meta;\r\n        if (typeof require === "function" && (typeof ace !== "object" || ace.prettydiffid === undefined)) {\r\n            (function glib_prettydiff() {\r\n                var localPath = (\r\n                    typeof process === "object" && typeof process.cwd === "function" && (process.cwd() === "/" || (/^([a-z]:\\\\)$/).test(process.cwd()) === true) && typeof __dirname === "string"\r\n                )\r\n                    ? __dirname\r\n                    : ".";\r\n                if (global.prettydiff.language === undefined) {\r\n                    global.prettydiff.language = require(\r\n                        localPath + "/lib/language.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.finalFile === undefined) {\r\n                    global.prettydiff.finalFile = require(\r\n                        localPath + "/lib/finalFile.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.csspretty === undefined) {\r\n                    global.prettydiff.csspretty = require(\r\n                        localPath + "/lib/csspretty.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.csvpretty === undefined) {\r\n                    global.prettydiff.csvpretty = require(\r\n                        localPath + "/lib/csvpretty.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.diffview === undefined) {\r\n                    global.prettydiff.diffview = require(\r\n                        localPath + "/lib/diffview.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.jspretty === undefined) {\r\n                    global.prettydiff.jspretty = require(\r\n                        localPath + "/lib/jspretty.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.options === undefined) {\r\n                    global.prettydiff.options = require(\r\n                        localPath + "/lib/options.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.safeSort === undefined) {\r\n                    global.prettydiff.safeSort = require(\r\n                        localPath + "/lib/safeSort.js"\r\n                    );\r\n                }\r\n                if (global.prettydiff.markuppretty === undefined) {\r\n                    global.prettydiff.markuppretty = require(\r\n                        localPath + "/lib/markuppretty.js"\r\n                    );\r\n                }\r\n            }());\r\n        }\r\n    } else {\r\n        global.prettydiff.prettydiff = prettydiff;\r\n    }\r\n    global.prettydiff.edition        = {\r\n        addon        : {\r\n            ace: 160307\r\n        },\r\n        api          : {\r\n            dom      : 170707, //dom.js\r\n            nodeLocal: 170707 //node-local.js\r\n        },\r\n        css          : 170707, //css files\r\n        csspretty    : 170707, //csspretty lib\r\n        csvpretty    : 170514, //csvpretty lib\r\n        diffview     : 170521, //diffview lib\r\n        documentation: 170707, //documentation.xhtml and various guide pages\r\n        finalFile    : 170514, //HTML report generator\r\n        jspretty     : 170707, //jspretty lib\r\n        language     : 170514, //language lib\r\n        latest       : 0,\r\n        lint         : 170707, //unit test and lint automation as test/lint.js\r\n        markuppretty : 170707, //markuppretty lib\r\n        options      : 170521, //options management\r\n        prettydiff   : 170707, //this file\r\n        safeSort     : 170514, //safeSort lib\r\n        version      : "2.2.8", //version number\r\n        webtool      : 170707\r\n    };\r\n    global.prettydiff.edition.latest = (function edition_latest() {\r\n        return Math.max(\r\n            global.prettydiff.edition.css,\r\n            global.prettydiff.edition.csspretty,\r\n            global.prettydiff.edition.csvpretty,\r\n            global.prettydiff.edition.diffview,\r\n            global.prettydiff.edition.documentation,\r\n            global.prettydiff.edition.finalFile,\r\n            global.prettydiff.edition.jspretty,\r\n            global.prettydiff.edition.language,\r\n            global.prettydiff.edition.markuppretty,\r\n            global.prettydiff.edition.options,\r\n            global.prettydiff.edition.prettydiff,\r\n            global.prettydiff.edition.webtool,\r\n            global.prettydiff.edition.api.dom,\r\n            global.prettydiff.edition.api.nodeLocal\r\n        );\r\n    }());\r\n}());\r\n'}]);